/**
 * PhysicsEngine.ts - Moteur physique principal de la simulation Kite
 *
 * R√¥le :
 *   - Orchestration de tou    // C      gravity,  // Gravit√© distribu√©e par surfacelcul des forces a√©rodynamiques et gravitationnelles distribu√©es calculs physiques du cerf-volant (vent, lignes, forces, contr√¥les)
 *   - Point d'entr√©e pour la boucle de simulation physique (appel√© √† chaque frame)
 *   - Centralise l'acc√®s aux sous-modules physiques
 *
 * D√©pendances principales :
 *   - WindSimulator.ts : Simulation du vent et turbulences
 *   - LineSystem.ts : Calcul des tensions et contraintes des lignes
 *   - AerodynamicsCalculator.ts : Calcul des forces a√©rodynamiques
 *   - KiteController.ts : Gestion de l'√©tat physique du cerf-volant
 *   - ControlBarManager.ts : Gestion de la barre de contr√¥le du pilote
 *   - SimulationConfig.ts : Param√®tres globaux de la simulation
 *   - Kite.ts : Mod√®le 3D et points anatomiques du cerf-volant
 *
 * Relation avec les fichiers adjacents :
 *   - Tous les fichiers du dossier 'physics' sont des sous-modules utilis√©s par PhysicsEngine
 *   - Les modules 'controllers' et 'objects' sont utilis√©s pour manipuler le kite et la barre
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, appel√© √† chaque frame pour mettre √† jour la physique
 *   - Sert d'API centrale pour acc√©der √† l'√©tat physique du kite
 *
 * Voir aussi :
 *   - src/simulation/physics/WindSimulator.ts
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/Kite";
import { KiteController } from "../controllers/KiteController";
import { ControlBarManager } from "../controllers/ControlBarManager";
import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

import { WindSimulator } from "./WindSimulator";
import { LineSystem } from "./LineSystem";
import { BridleSystem } from "./BridleSystem";
import { AerodynamicsCalculator } from "./AerodynamicsCalculator";

/**
 * Moteur physique principal
 *
 * Orchestre toutes les simulations physiques du cerf-volant
 */
export class PhysicsEngine {
  private windSimulator: WindSimulator;
  private lineSystem: LineSystem;
  private bridleSystem: BridleSystem;
  private kiteController: KiteController;
  private controlBarManager: ControlBarManager;
  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = 1000; // Log toutes les 1000ms (1 seconde)
  private startTime: number = Date.now(); // Temps de d√©marrage pour elapsed time
  private frameCount: number = 0; // Compteur de frames

  constructor(kite: Kite, controlBarPosition: THREE.Vector3) {
    this.windSimulator = new WindSimulator();
    this.lineSystem = new LineSystem();
    this.bridleSystem = new BridleSystem(kite.getBridleLengths());
    this.kiteController = new KiteController(kite);
    this.controlBarManager = new ControlBarManager(controlBarPosition);
  }

  /**
   * LE C≈íUR DE LA SIMULATION - Appel√©e 60 fois par seconde
   *
   * C'est ici que tout se passe ! Cette fonction orchestre toute la physique.
   *
   * VOICI CE QUI SE PASSE √Ä CHAQUE INSTANT :
   * 1. On regarde comment la barre est tourn√©e
   * 2. On calcule o√π sont les mains du pilote
   * 3. On calcule le vent que ressent le kite
   * 4. On calcule toutes les forces :
   *    - Le vent qui pousse
   *    - Les lignes qui tirent
   *    - La gravit√© qui attire vers le bas
   * 5. On fait bouger le kite selon ces forces
   *
   * C'est comme une boucle infinie qui simule la r√©alit√© !
   */
  update(
    deltaTime: number,
    targetBarRotation: number,
    isPaused: boolean = false
  ): void {
    // Si en pause, ne rien faire
    if (isPaused) return;

    // Limiter le pas de temps pour √©viter l'instabilit√© num√©rique
    deltaTime = Math.min(deltaTime, CONFIG.physics.deltaTimeMax);

    // Appliquer directement la rotation de la barre (pas de lissage, d√©j√† g√©r√© par InputHandler)
    this.controlBarManager.setRotation(targetBarRotation);

    // R√©cup√©rer l'√©tat actuel du syst√®me
    const kite = this.kiteController.getKite();
    const handles = this.controlBarManager.getHandlePositions(kite.position);

    // Vent apparent = vent r√©el - vitesse du kite (principe de relativit√©)
    const kiteState = this.kiteController.getState();

    // üîç DEBUG: V√©rifier la vitesse du kite pour comprendre le vent apparent faible - DISABLED for performance


    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );


    // ÔøΩ PHYSIQUE √âMERGENTE : Forces a√©ro + gravit√© distribu√©e calcul√©es par surface
    // - Chaque surface porte une fraction de la masse (fabric + frame + accessoires)
    // - Gravit√© appliqu√©e au centre g√©om√©trique de chaque surface
    // - Le couple gravitationnel √©merge naturellement de r √ó F_gravity
    // - Le couple total √©merge de la diff√©rence gauche/droite naturelle
    const {
      lift,
      drag,
      gravity,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e (plus r√©aliste physiquement)
      torque: totalTorque,  // Inclut d√©j√† couple a√©ro + couple gravitationnel !
    } = AerodynamicsCalculator.calculateForces(
      apparentWind, 
      kite.quaternion,
      kite.position,
      kiteState.velocity,
      kiteState.angularVelocity
    );

    this.kiteController.setAerodynamicSnapshot(lift, drag);

    // CALCUL DES TENSIONS (pour affichage/debug uniquement)
    // Les lignes ne TIRENT PAS le kite - elles le RETIENNENT √† distance max
    // La contrainte g√©om√©trique est appliqu√©e par ConstraintSolver dans KiteController
  this.lineSystem.calculateLineTensions(kite, handles, deltaTime);

    // CALCUL DES TENSIONS DES BRIDES (pour affichage/debug uniquement)
    // Les brides sont des contraintes INTERNES au kite
    // Les contraintes g√©om√©triques sont appliqu√©es par ConstraintSolver.enforceBridleConstraints()
    const bridleTensions = this.bridleSystem.calculateBridleTensions(kite);

    // Incr√©menter le compteur de frames
    this.frameCount++;

    // üìä LOG COMPLET toutes les secondes
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;
      this.logPhysicsState(kite, kiteState, apparentWind, lift, drag, gravity, totalTorque, bridleTensions, deltaTime, currentTime);
    }

    // Mettre √† jour la visualisation des brides selon leurs tensions
    kite.updateBridleVisualization(bridleTensions);

    // Somme vectorielle des forces (2√®me loi de Newton : F = ma)
    const totalForce = new THREE.Vector3()
      .add(lift)     // Portance a√©rodynamique (perpendiculaire au vent)
      .add(drag)     // Tra√Æn√©e a√©rodynamique (parall√®le au vent)
      .add(gravity); // Gravit√© distribu√©e (d√©j√† calcul√©e par surface)
      // PAS de forces de lignes - elles sont des contraintes g√©om√©triques

    // Couple total = moment a√©rodynamique + moment gravitationnel (√©mergent)
    // Les lignes n'appliquent PAS de couple - elles contraignent la position
    // L'orientation √©merge de l'√©quilibre des forces distribu√©es + contraintes

    // Int√©gration physique : F=ma et T=IŒ± pour calculer nouvelle position/orientation
    this.kiteController.update(totalForce, totalTorque, handles, deltaTime);
  }

  setBridleFactor(_factor: number): void {
    // Fonctionnalit√© d√©sactiv√©e dans V8 - physique √©mergente pure
  }

  /**
   * Ajuste une longueur de bride physique (en m√®tres)
   * @param bridleName - 'nez', 'inter' ou 'centre'
   * @param length - longueur en m√®tres
   */
  setBridleLength(bridleName: 'nez' | 'inter' | 'centre', length: number): void {
    this.kiteController.getKite().setBridleLengths({ [bridleName]: length });
  }

  setWindParams(params: Partial<WindParams>): void {
    this.windSimulator.setParams(params);
  }

  setLineLength(length: number): void {
    this.lineSystem.setLineLength(length);
    this.kiteController.setLineLength(length);
  }

  getKiteController(): KiteController {
    return this.kiteController;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getControlBarManager(): ControlBarManager {
    return this.controlBarManager;
  }

  /**
   * Retourne les longueurs actuelles des brides du kite
   */
  getBridleLengths() {
    return this.kiteController.getKite().getBridleLengths();
  }

  /**
   * D√©finit le taux de lissage des forces (en 1/s)
   */
  setForceSmoothing(rate: number): void {
    this.kiteController.setForceSmoothing(rate);
  }

  /**
   * Retourne le taux de lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController.getForceSmoothing();
  }

  /**
   * Affiche l'√©tat physique complet du kite (appel√© toutes les secondes)
   */
  private logPhysicsState(
    kite: Kite,
    kiteState: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    apparentWind: THREE.Vector3,
    lift: THREE.Vector3,
    drag: THREE.Vector3,
    gravity: THREE.Vector3,
    totalTorque: THREE.Vector3,
    bridleTensions: { leftNez: number; rightNez: number; leftInter: number; rightInter: number; leftCentre: number; rightCentre: number },
    deltaTime: number,
    currentTime: number
  ): void {
    // Calculs suppl√©mentaires pour le log
    const elapsedTime = (currentTime - this.startTime) / 1000; // en secondes
    const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
    const pitch = euler.x * (180 / Math.PI); // Convertir en degr√©s
    const roll = euler.z * (180 / Math.PI);
    const yaw = euler.y * (180 / Math.PI);

    // Tensions des lignes
    const lineTensions = this.lineSystem.getTensions();

    // Acc√©l√©ration (approximation : F/m)
    const totalForceCalc = new THREE.Vector3().add(lift).add(drag).add(gravity);
    const acceleration = totalForceCalc.clone().divideScalar(CONFIG.kite.mass);

    // Ratio portance/tra√Æn√©e
    const liftMag = lift.length();
    const dragMag = drag.length();
    const ldRatio = dragMag > 0.01 ? liftMag / dragMag : 0;

    console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log(`‚ïë üìä √âTAT COMPLET DU KITE - Frame #${this.frameCount.toString().padStart(6, '0')}                              ‚ïë`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ‚è±Ô∏è  Temps: ${elapsedTime.toFixed(3)}s | Œît: ${(deltaTime * 1000).toFixed(2)}ms | FPS: ${(1/deltaTime).toFixed(1)}    ‚ïë`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üìç POSITION & ORIENTATION                                                 ‚ïë`);
    console.log(`‚ïë    Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m`);
    console.log(`‚ïë    Distance pilote: ${kite.position.length().toFixed(2)} m`);
    console.log(`‚ïë    Angles: Pitch ${pitch.toFixed(1)}¬∞ | Roll ${roll.toFixed(1)}¬∞ | Yaw ${yaw.toFixed(1)}¬∞`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üöÄ CIN√âMATIQUE                                                            ‚ïë`);
    console.log(`‚ïë    Vitesse: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s`);
    console.log(`‚ïë    Acc√©l√©ration: (${acceleration.x.toFixed(2)}, ${acceleration.y.toFixed(2)}, ${acceleration.z.toFixed(2)}) m/s¬≤ | Mag: ${acceleration.length().toFixed(2)} m/s¬≤`);
    console.log(`‚ïë    Vit. angulaire: (${kiteState.angularVelocity.x.toFixed(2)}, ${kiteState.angularVelocity.y.toFixed(2)}, ${kiteState.angularVelocity.z.toFixed(2)}) rad/s | Mag: ${kiteState.angularVelocity.length().toFixed(2)} rad/s`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üí® A√âRODYNAMIQUE                                                          ‚ïë`);
    console.log(`‚ïë    Vent apparent: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s`);
    console.log(`‚ïë    Portance: (${lift.x.toFixed(2)}, ${lift.y.toFixed(2)}, ${lift.z.toFixed(2)}) N | Mag: ${liftMag.toFixed(2)} N`);
    console.log(`‚ïë    Tra√Æn√©e: (${drag.x.toFixed(2)}, ${drag.y.toFixed(2)}, ${drag.z.toFixed(2)}) N | Mag: ${dragMag.toFixed(2)} N`);
    console.log(`‚ïë    Ratio L/D: ${ldRatio.toFixed(2)}`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ‚öñÔ∏è  FORCES & COUPLES                                                       ‚ïë`);
    console.log(`‚ïë    Gravit√©: (${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}, ${gravity.z.toFixed(2)}) N | Mag: ${gravity.length().toFixed(2)} N`);
    console.log(`‚ïë    Force totale: (${totalForceCalc.x.toFixed(2)}, ${totalForceCalc.y.toFixed(2)}, ${totalForceCalc.z.toFixed(2)}) N | Mag: ${totalForceCalc.length().toFixed(2)} N`);
    console.log(`‚ïë    Couple total: (${totalTorque.x.toFixed(2)}, ${totalTorque.y.toFixed(2)}, ${totalTorque.z.toFixed(2)}) N‚ãÖm | Mag: ${totalTorque.length().toFixed(2)} N‚ãÖm`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ü™¢ TENSIONS                                                                ‚ïë`);
    console.log(`‚ïë    Ligne gauche: ${lineTensions.left.toFixed(2)} N | Ligne droite: ${lineTensions.right.toFixed(2)} N`);
    console.log(`‚ïë    Asym√©trie: ${(lineTensions.left - lineTensions.right).toFixed(2)} N (${((lineTensions.left - lineTensions.right) / Math.max(lineTensions.left, lineTensions.right) * 100).toFixed(1)}%)`);
    console.log(`‚ïë    Brides: NEZ L/R: ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)} N`);
    console.log(`‚ïë            INTER L/R: ${bridleTensions.leftInter.toFixed(1)}/${bridleTensions.rightInter.toFixed(1)} N`);
    console.log(`‚ïë            CENTRE L/R: ${bridleTensions.leftCentre.toFixed(1)}/${bridleTensions.rightCentre.toFixed(1)} N`);
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  }
}