CONSOLIDATION DES SOURCES - Sun Oct 12 09:27:50 UTC 2025
==================================

=== base/BaseComponent.ts ===

/**
 * BaseComponent.ts - Système de composants pour les objets 3D
 *
 * Pattern : Component Pattern (similaire à Unity/ECS)
 * Permet d'ajouter des fonctionnalités optionnelles aux Node3D
 * sans hériter de classes lourdes.
 */

import { Node3D } from '../core/Node3D';

export interface ComponentContext {
  deltaTime: number;
  totalTime: number;
  parent: Node3D;
}

export abstract class BaseComponent {
  protected name: string;
  protected enabled: boolean = true;
  protected parent?: Node3D;

  constructor(name: string) {
    this.name = name;
  }

  /**
   * Attache le composant à un parent
   */
  attachTo(parent: Node3D): void {
    this.parent = parent;
    this.onAttach();
  }

  /**
   * Détache le composant de son parent
   */
  detach(): void {
    this.onDetach();
    this.parent = undefined;
  }

  /**
   * Appelé quand le composant est attaché
   */
  protected onAttach(): void {
    // Override dans les sous-classes
  }

  /**
   * Appelé quand le composant est détaché
   */
  protected onDetach(): void {
    // Override dans les sous-classes
  }

  /**
   * Met à jour le composant
   */
  abstract update(context: ComponentContext): void;

  /**
   * Active/désactive le composant
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getParent(): Node3D | undefined {
    return this.parent;
  }
}

/**
 * Composant de debug visuel
 */
export class DebugComponent extends BaseComponent {
  update(_context: ComponentContext): void {
    // Logique de debug visuel
  }
}

/**
 * Composant de physique
 */
export class PhysicsComponent extends BaseComponent {
  update(_context: ComponentContext): void {
    // Logique de physique
  }
}

=== base/BaseFactory.ts ===

/**
 * BaseFactory.ts - Factory abstraite pour tous les objets 3D
 * 
 * Pattern Factory Method avec support des paramètres configurables
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export type FactoryParams = Record<string, unknown>;

export interface ObjectMetadata {
  category: string;
  name: string;
  description: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'complex';
}

/**
 * Factory abstraite pour la création d'objets 3D
 */
export abstract class BaseFactory<T extends StructuredObject & ICreatable> {
  protected abstract metadata: ObjectMetadata;

  /**
   * Créer un objet avec des paramètres optionnels
   */
  abstract createObject(params?: FactoryParams): T | Promise<T>;

  /**
   * Obtenir les métadonnées de l'objet
   */
  getMetadata(): ObjectMetadata {
    return { ...this.metadata };
  }

  /**
   * Obtenir la catégorie de l'objet
   */
  getCategory(): string {
    return this.metadata.category;
  }

  /**
   * Obtenir le nom de l'objet
   */
  getName(): string {
    return this.metadata.name;
  }

  /**
   * Valider les paramètres avant création
   */
  protected validateParams(params?: FactoryParams): void {
    // Validation de base - à surcharger dans les classes dérivées
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value === null || value === undefined) {
          throw new Error(`Paramètre '${key}' ne peut pas être null ou undefined`);
        }
      });
    }
  }

  /**
   * Paramètres par défaut - à surcharger dans les classes dérivées
   */
  protected getDefaultParams(): FactoryParams {
    return {};
  }

  /**
   * Fusionner les paramètres par défaut avec les paramètres fournis
   */
  protected mergeParams(params?: FactoryParams): FactoryParams {
    return {
      ...this.getDefaultParams(),
      ...params
    };
  }

  /**
   * Nettoyer les ressources de la factory
   */
  dispose(): void {
    // À surcharger dans les classes dérivées si nécessaire
  }
}


=== base/BaseSimulationSystem.ts ===

/**
 * BaseSimulationSystem.ts - Interface de base pour tous les systèmes de simulation
 *
 * Pattern : Template Method pour les systèmes de simulation
 * Chaque système (Physics, Wind, Input, etc.) hérite de cette classe
 * et implémente ses méthodes spécifiques.
 */

export interface SimulationContext {
  deltaTime: number;
  totalTime: number;
  isPaused: boolean;
  debugMode: boolean;
}

export abstract class BaseSimulationSystem {
  protected name: string;
  protected enabled: boolean = true;
  protected priority: number = 0; // Ordre d'exécution (plus petit = plus prioritaire)

  constructor(name: string, priority: number = 0) {
    this.name = name;
    this.priority = priority;
  }

  /**
   * Initialise le système (appelé une fois au démarrage)
   */
  abstract initialize(): void;

  /**
   * Met à jour le système (appelé chaque frame)
   */
  abstract update(context: SimulationContext): void;

  /**
   * Réinitialise le système à son état initial
   */
  abstract reset(): void;

  /**
   * Nettoie les ressources du système
   */
  abstract dispose(): void;

  /**
   * Active/désactive le système
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getPriority(): number {
    return this.priority;
  }

  /**
   * Validation interne du système
   */
  validate(): boolean {
    return true; // Override dans les sous-classes si nécessaire
  }
}

=== core/DebugLayer.ts ===

/**
 * DebugLayer.ts - Couche de debug visuel pour les objets 3D
 *
 * Rôle : Gestion centralisée de tous les éléments de debug visuel
 * Sépare complètement la logique de debug du mesh principal
 */

import * as THREE from 'three';

import { Node3D } from './Node3D';

export interface DebugOptions {
  showPoints?: boolean;
  showLabels?: boolean;
  showAxes?: boolean;
  showNormals?: boolean;
  pointSize?: number;
  labelSize?: number;
  axisLength?: number;
}

export class DebugLayer {
  public group: THREE.Group;
  private parent: Node3D;
  private options: DebugOptions;
  private pointsGroup: THREE.Group;
  private labelsGroup: THREE.Group;
  private axesGroup: THREE.Group;
  private normalsGroup: THREE.Group;

  constructor(parent: Node3D, options: DebugOptions = {}) {
    this.parent = parent;
    this.options = {
      showPoints: false,
      showLabels: false,
      showAxes: false,
      showNormals: false,
      pointSize: 0.05,
      labelSize: 0.1,
      axisLength: 1.0,
      ...options
    };

    this.group = new THREE.Group();
    this.group.name = `${parent.name}_debug`;

    this.pointsGroup = new THREE.Group();
    this.pointsGroup.name = 'points';
    this.group.add(this.pointsGroup);

    this.labelsGroup = new THREE.Group();
    this.labelsGroup.name = 'labels';
    this.group.add(this.labelsGroup);

    this.axesGroup = new THREE.Group();
    this.axesGroup.name = 'axes';
    this.group.add(this.axesGroup);

    this.normalsGroup = new THREE.Group();
    this.normalsGroup.name = 'normals';
    this.group.add(this.normalsGroup);

    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des points
   */
  setShowPoints(show: boolean): void {
    this.options.showPoints = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des labels
   */
  setShowLabels(show: boolean): void {
    this.options.showLabels = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des axes
   */
  setShowAxes(show: boolean): void {
    this.options.showAxes = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des normales
   */
  setShowNormals(show: boolean): void {
    this.options.showNormals = show;
    this.updateVisibility();
  }

  /**
   * Ajoute un point de debug
   */
  addPoint(position: THREE.Vector3, color: number = 0xff0000, name?: string): void {
    const geometry = new THREE.SphereGeometry(this.options.pointSize, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const point = new THREE.Mesh(geometry, material);

    point.position.copy(position);
    if (name) point.name = name;

    this.pointsGroup.add(point);
  }

  /**
   * Ajoute une étiquette de debug
   */
  addLabel(position: THREE.Vector3, text: string, color: number = 0xffffff): void {
    // Note: Pour une vraie implémentation, il faudrait une bibliothèque de texte 3D
    // Pour l'instant, on utilise un point coloré avec le nom
    const geometry = new THREE.SphereGeometry(this.options.labelSize! * 0.5, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const label = new THREE.Mesh(geometry, material);

    label.position.copy(position);
    label.name = text;

    this.labelsGroup.add(label);
  }

  /**
   * Dessine les axes XYZ
   */
  drawAxes(length: number = this.options.axisLength!): void {
    this.clearAxes();

    // Axe X (rouge)
    const xAxis = this.createAxis(new THREE.Vector3(length, 0, 0), 0xff0000);
    this.axesGroup.add(xAxis);

    // Axe Y (vert)
    const yAxis = this.createAxis(new THREE.Vector3(0, length, 0), 0x00ff00);
    this.axesGroup.add(yAxis);

    // Axe Z (bleu)
    const zAxis = this.createAxis(new THREE.Vector3(0, 0, length), 0x0000ff);
    this.axesGroup.add(zAxis);
  }

  /**
   * Nettoie tous les éléments de debug
   */
  clear(): void {
    this.clearPoints();
    this.clearLabels();
    this.clearAxes();
    this.clearNormals();
  }

  /**
   * Met à jour la visibilité selon les options
   */
  private updateVisibility(): void {
    this.pointsGroup.visible = this.options.showPoints!;
    this.labelsGroup.visible = this.options.showLabels!;
    this.axesGroup.visible = this.options.showAxes!;
    this.normalsGroup.visible = this.options.showNormals!;
  }

  private createAxis(direction: THREE.Vector3, color: number): THREE.Group {
    const group = new THREE.Group();

    // Ligne de l'axe
    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      direction
    ]);
    const material = new THREE.LineBasicMaterial({ color });
    const line = new THREE.Line(geometry, material);
    group.add(line);

    // Flèche à l'extrémité
    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ color });
    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    arrow.position.copy(direction);
    arrow.lookAt(direction);
    group.add(arrow);

    return group;
  }

  private clearPoints(): void {
    while (this.pointsGroup.children.length > 0) {
      const child = this.pointsGroup.children[0];
      this.pointsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearLabels(): void {
    while (this.labelsGroup.children.length > 0) {
      const child = this.labelsGroup.children[0];
      this.labelsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearAxes(): void {
    while (this.axesGroup.children.length > 0) {
      const child = this.axesGroup.children[0];
      this.axesGroup.remove(child);
      // Nettoyer récursivement les géométries et matériaux
      child.traverse((obj) => {
        if (obj instanceof THREE.Mesh) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        } else if (obj instanceof THREE.Line) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        }
      });
    }
  }

  private clearNormals(): void {
    while (this.normalsGroup.children.length > 0) {
      const child = this.normalsGroup.children[0];
      this.normalsGroup.remove(child);
      if (child instanceof THREE.Line) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }
}

=== core/Node3D.ts ===


/**
 * Node3D.ts - Couche d'abstraction Godot-compatible pour la simulation Kite
 *
 * Rôle :
 *   - Encapsule THREE.Group avec une API similaire à Godot
 *   - Fournit des propriétés et méthodes compatibles avec le moteur Godot
 *   - Sert de base à StructuredObject et à tous les objets 3D du projet
 *
 * Dépendances principales :
 *   - Three.js : Pour la gestion des groupes et transformations 3D
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) hérite de Node3D
 *   - Tous les objets 3D du projet héritent indirectement de Node3D
 *
 * Utilisation typique :
 *   - Sert de base à la hiérarchie d'objets 3D
 *   - Permet la compatibilité avec Godot pour la portabilité
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { SceneManager } from './SceneManager';

/**
 * Transform3D compatible Godot
 */
export interface Transform3D {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    scale: THREE.Vector3;
}

/**
 * Signal basique pour la communication entre nodes
 */
export interface Signal {
    name: string;
    callbacks: Array<{ target: Node3D; method: string }>;
}

/**
 * Node3D - Équivalent du Node3D de Godot
 * Hérite de THREE.Group pour la compatibilité
 */
export class Node3D extends THREE.Group {
    // 🎮 Propriétés Godot-like
    public transform: Transform3D;
    public signals: Map<string, Signal> = new Map();
    
    // 🏷️ Métadonnées
    public readonly nodeId: string;
    public nodeType: string = 'Node3D';
    
    // 🔧 État interne
    protected isReady: boolean = false;
    protected active: boolean = true;

    constructor(name: string = 'Node3D') {
        super();
        this.name = name;
        this.nodeId = this.generateNodeId();

        // Transform3D unifié
        this.transform = {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale
        };

        // Auto-enregistrement dans SceneManager
        SceneManager.getInstance().register(this);

        // Auto-initialisation
        this.callReady();
    }
    
    /**
     * Génère un ID unique pour le node (compatible Godot)
     */
    private generateNodeId(): string {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `node_${timestamp}_${random}`;
    }
    
    // === 🎮 Méthodes Cycle de Vie Godot ===
    
    /**
     * _ready() - Appelé une seule fois quand le node est ajouté à la scène
     */
    protected _ready(): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * _process() - Appelé à chaque frame
     */
    protected _process(_delta: number): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * _physics_process() - Appelé à chaque frame physique
     */
    protected _physics_process(_delta: number): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * Appel automatique de _ready()
     */
    private callReady(): void {
        if (!this.isReady) {
            this.isReady = true;
            this._ready();
        }
    }
    
    // === 🔗 Gestion des Signaux ===
    
    /**
     * Définit un signal (équivalent signal en GDScript)
     */
    public define_signal(name: string): void {
        if (!this.signals.has(name)) {
            this.signals.set(name, {
                name,
                callbacks: []
            });
        }
    }
    
    /**
     * Émet un signal
     */
    public emit_signal(name: string, ...args: any[]): void {
        const signal = this.signals.get(name);
        if (signal) {
            signal.callbacks.forEach(callback => {
                const method = (callback.target as any)[callback.method];
                if (typeof method === 'function') {
                    method.call(callback.target, ...args);
                }
            });
        }
    }
    
    /**
     * Connecte un signal à une méthode
     */
    public connect(signal: string, target: Node3D, method: string): void {
        if (!this.signals.has(signal)) {
            this.define_signal(signal);
        }
        
        const signalObj = this.signals.get(signal)!;
        signalObj.callbacks.push({ target, method });
    }
    
    // === 🌳 Gestion de l'Arbre de Nodes ===
    
    /**
     * Ajoute un enfant (compatible Godot)
     */
    public add_child(child: Node3D): void {
        this.add(child);
        child.callReady();
    }
    
    /**
     * Retire un enfant
     */
    public remove_child(child: Node3D): void {
        this.remove(child);
    }
    
    /**
     * Trouve un enfant par nom
     */
    public get_node(path: string): Node3D | null {
        return this.getObjectByName(path) as Node3D || null;
    }
    
    /**
     * Trouve tous les enfants d'un type donné
     */
    public get_children_of_type<T extends Node3D>(type: new (...args: any[]) => T): T[] {
        const result: T[] = [];
        this.traverse((obj) => {
            if (obj instanceof type) {
                result.push(obj);
            }
        });
        return result;
    }
    
    // === 🔄 Mise à Jour du Cycle de Vie ===
    
    /**
     * Met à jour le node et tous ses enfants
     */
    public update(delta: number): void {
        if (this.isReady) {
            this._process(delta);
            this._physics_process(delta);
            
            // Mettre à jour les enfants Node3D
            this.children.forEach(child => {
                if (child instanceof Node3D) {
                    child.update(delta);
                }
            });
        }
    }
    
    /**
     * Active/désactive le node
     */
    public setActive(active: boolean): void {
        this.active = active;
    }

    /**
     * Vérifie si le node est actif
     */
    public isActive(): boolean {
        return this.active;
    }

    /**
     * Obtient le nom du node
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Appelé quand le node est enregistré dans SceneManager
     */
    public onRegister(): void {
        // À overrider dans les sous-classes
    }

    /**
     * Appelé quand le node est désenregistré de SceneManager
     */
    public onUnregister(): void {
        // À overrider dans les sous-classes
    }

    /**
     * Détruit le node et nettoie les ressources
     */
    public destroy(): void {
        // Désenregistrer du SceneManager
        SceneManager.getInstance().unregister(this);

        // Nettoyer les signaux
        this.signals.clear();

        // Nettoyer les enfants
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.destroy();
            }
        });

        // Nettoyer Three.js
        this.clear();
    }
    
    // === 🏷️ Métadonnées et Debug ===
    
    /**
     * Retourne une description du node
     */
    public get_description(): string {
        return `${this.nodeType}:${this.name} (${this.nodeId})`;
    }
    
    /**
     * Affiche l'arbre des nodes (debug)
     */
    public print_tree(indent: number = 0): void {
        const spaces = '  '.repeat(indent);
        console.log(`${spaces}${this.get_description()}`);
        
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.print_tree(indent + 1);
            }
        });
    }
    
    // === 🎯 Compatibilité Three.js ===
    
    /**
     * Accès direct au transform Three.js
     */
    public get three_transform() {
        return {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale,
            matrix: this.matrix,
            matrixWorld: this.matrixWorld
        };
    }
}


=== core/Primitive.ts ===


/**
 * Primitive.ts - Générateurs de primitives Three.js pour la simulation Kite
 *
 * Rôle :
 *   - Fournit des utilitaires pour créer les formes de base (cube, sphère, cylindre, etc.)
 *   - Permet de générer des matériaux cohérents pour les objets 3D
 *   - Sert à la construction des objets structurés (cerf-volant, barre, etc.)
 *
 * Dépendances principales :
 *   - Three.js : Pour la géométrie et les matériaux
 *   - Types : MaterialConfig pour la configuration des matériaux
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) utilise Primitive pour créer les éléments 3D
 *   - Tous les objets 3D du projet peuvent utiliser Primitive pour générer leurs formes
 *
 * Utilisation typique :
 *   - Appelé par les factories et objets structurés pour générer la géométrie
 *   - Sert à la création rapide et cohérente des primitives
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { MaterialConfig } from '../types/index';

/**
 * Classe statique pour générer les primitives de base
 */
export class Primitive {
  /**
   * Créer un matériau standardisé
   */
  private static createMaterial(config: string | MaterialConfig): THREE.MeshStandardMaterial {
    if (typeof config === 'string') {
      return new THREE.MeshStandardMaterial({ color: config });
    }

    return new THREE.MeshStandardMaterial({
      color: config.color,
      transparent: config.transparent || false,
      opacity: config.opacity || 1,
      metalness: config.metalness || 0,
      roughness: config.roughness || 0.5,
      side: config.side || THREE.FrontSide
    });
  }

  /**
   * Créer une boîte (cube ou parallélépipède)
   */
  static box(
    width: number,
    height: number,
    depth: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BoxGeometry(width, height, depth);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une sphère
   */
  static sphere(
    radius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un cylindre
   */
  static cylinder(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un cône
   */
  static cone(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un plan (surface plate)
   */
  static plane(
    width: number,
    height: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(width, height);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un tore (anneau)
   */
  static torus(
    radius: number,
    tubeRadius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.TorusGeometry(radius, tubeRadius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une surface à partir de points (triangulation simple)
   */
  static surface(
    points: THREE.Vector3[],
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BufferGeometry();
    const vertices: number[] = [];

    // Ajouter les points
    points.forEach(point => {
      vertices.push(point.x, point.y, point.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    // Triangulation améliorée pour les quads (faces du cube)
    const indices: number[] = [];
    if (points.length === 3) {
      // Triangle simple
      indices.push(0, 1, 2);
    }

    if (points.length === 4) {
      // Quad - utiliser une triangulation qui préserve la manifold
      // Pour un cube, on utilise toujours la même diagonale (0,2)
      // Cela garantit que l'arête diagonale n'est pas partagée avec d'autres faces
      indices.push(0, 1, 2);  // Premier triangle
      indices.push(0, 2, 3);  // Deuxième triangle
    }

    if (points.length > 4) {
      // Fan triangulation pour plus de points
      for (let i = 1; i < points.length - 1; i++) {
        indices.push(0, i, i + 1);
      }
    }

    geometry.setIndex(indices);

    // Calculer les normales de manière cohérente
    geometry.computeVertexNormals();

    // S'assurer que les normales pointent vers l'extérieur pour un cube
    // En inversant si nécessaire
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une flèche de debug (ArrowHelper)
   *
   * @param direction - Direction normalisée de la flèche
   * @param origin - Point d'origine de la flèche
   * @param length - Longueur de la flèche
   * @param color - Couleur (hex) de la flèche
   * @param headLength - Longueur de la tête de flèche (optionnel)
   * @param headWidth - Largeur de la tête de flèche (optionnel)
   * @returns THREE.ArrowHelper configuré
   */
  static arrow(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    headLength?: number,
    headWidth?: number
  ): THREE.ArrowHelper {
    return new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      headLength,
      headWidth
    );
  }

  /**
   * Créer un label textuel pour les vecteurs de debug
   *
   * @param text - Texte à afficher
   * @param position - Position du label
   * @param color - Couleur du texte (hex)
   * @param size - Taille du texte
   * @returns THREE.Sprite avec le texte
   */
  static textLabel(
    text: string,
    position: THREE.Vector3,
    color: number = 0xffffff,
    size: number = 0.5
  ): THREE.Object3D {
    // Créer un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 128;

    // Style du texte
    context.font = `Bold ${size * 20}px Arial`;
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    // Fond semi-transparent
    context.fillStyle = 'rgba(0, 0, 0, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Texte
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    // Créer la texture
    const texture = new THREE.CanvasTexture(canvas);
    texture.generateMipmaps = false;
    texture.minFilter = THREE.LinearFilter;

    // Créer le sprite
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);

    // Positionner et dimensionner
    sprite.position.copy(position);
    sprite.scale.set(size, size * 0.5, 1);

    return sprite;
  }
}

=== core/SceneManager.ts ===

/**
 * SceneManager.ts - Gestionnaire central de la scène 3D
 *
 * Rôle : Orchestrateur principal de tous les objets 3D
 * Gère le cycle de vie, les updates et la hiérarchie des Node3D
 */

import * as THREE from 'three';

import { Node3D } from './Node3D';

export class SceneManager {
  private static instance: SceneManager;
  private nodes: Set<Node3D> = new Set();
  private rootScene: THREE.Scene;
  private totalTime: number = 0;

  private constructor() {
    this.rootScene = new THREE.Scene();
  }

  static getInstance(): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  /**
   * Enregistre un nouveau nœud dans la scène
   */
  register(node: Node3D): void {
    if (!this.nodes.has(node)) {
      this.nodes.add(node);
      node.onRegister();
    }
  }

  /**
   * Désenregistre un nœud de la scène
   */
  unregister(node: Node3D): void {
    if (this.nodes.has(node)) {
      node.onUnregister();
      this.nodes.delete(node);
    }
  }

  /**
   * Met à jour tous les nœuds enregistrés
   */
  update(deltaTime: number): void {
    this.totalTime += deltaTime;

    // Mise à jour de tous les nœuds
    for (const node of this.nodes) {
      if (node.isActive()) {
        node.update(deltaTime);
      }
    }
  }

  /**
   * Ajoute un objet à la scène Three.js racine
   */
  addToScene(object: THREE.Object3D): void {
    this.rootScene.add(object);
  }

  /**
   * Retire un objet de la scène Three.js racine
   */
  removeFromScene(object: THREE.Object3D): void {
    this.rootScene.remove(object);
  }

  /**
   * Obtient la scène Three.js racine
   */
  getScene(): THREE.Scene {
    return this.rootScene;
  }

  /**
   * Recherche un nœud par nom
   */
  findNodeByName(name: string): Node3D | undefined {
    for (const node of this.nodes) {
      if (node.getName() === name) {
        return node;
      }
    }
    return undefined;
  }

  /**
   * Obtient tous les nœuds d'un certain type
   */
  getNodesOfType<T extends Node3D>(type: new (...args: any[]) => T): T[] {
    const result: T[] = [];
    for (const node of this.nodes) {
      if (node instanceof type) {
        result.push(node as T);
      }
    }
    return result;
  }

  /**
   * Nettoie tous les nœuds
   */
  clear(): void {
    for (const node of this.nodes) {
      node.destroy();
    }
    this.nodes.clear();
    this.rootScene.clear();
    this.totalTime = 0;
  }

  /**
   * Statistiques de la scène
   */
  getStats(): { nodeCount: number; totalTime: number } {
    return {
      nodeCount: this.nodes.size,
      totalTime: this.totalTime
    };
  }
}

=== core/StructuredObject.ts ===


/**
 * StructuredObject.ts - Classe de base unifiée pour tous les objets 3D structurés du projet Kite
 *
 * Rôle :
 *   - Fournit une architecture orientée objet avec points anatomiques nommés
 *   - Sert de classe mère pour tous les objets 3D complexes (cerf-volant, barre, etc.)
 *   - Compatible Godot via Node3D
 *
 * Dépendances principales :
 *   - Node3D.ts : Couche d'abstraction Godot-compatible
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : Position3D, NamedPoint, SurfaceOptions, MaterialConfig
 *   - Three.js : Pour la géométrie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Node3D.ts (dossier core) est la classe mère directe
 *   - Primitive.ts fournit les utilitaires de création
 *   - Tous les objets 3D du projet héritent de StructuredObject
 *
 * Utilisation typique :
 *   - Sert de base à la création de tous les objets 3D structurés
 *   - Permet la gestion des points, labels et debug
 *
 * Voir aussi :
 *   - src/core/Node3D.ts
 *   - src/core/Primitive.ts
 */

import * as THREE from 'three';

import { Position3D, NamedPoint, MaterialConfig } from '../types/index';

import { Primitive } from './Primitive';
import { Node3D } from './Node3D';
import { DebugLayer } from './DebugLayer';

/**
 * Classe abstraite de base pour tous les objets 3D structurés
 * 🎮 Hérite de Node3D pour la compatibilité Godot
 */
export abstract class StructuredObject extends Node3D {
  /**
   * Points anatomiques nommés de l'objet
   */
  protected points: Map<string, THREE.Vector3> = new Map();

  /**
   * Points avec marqueurs visuels (debug)
   */
  protected namedPoints: NamedPoint[] = [];

  /**
   * Couche de debug séparée
   */
  protected debugLayer: DebugLayer;

  /**
   * Affichage des labels en mode debug
   */
  public showDebugPoints: boolean = false;

  /**
   * Affichage des labels de texte
   */
  public showLabels: boolean = false;

  constructor(name: string, showDebugPoints: boolean = false) {
    super(name);
    this.nodeType = 'StructuredObject';
    this.showDebugPoints = showDebugPoints;

    // Initialiser la couche de debug
    this.debugLayer = new DebugLayer(this, {
      showPoints: showDebugPoints,
      showLabels: false,
      showNormals: false,
      showAxes: false,
      pointSize: 0.02
    });

    // L'initialisation sera appelée par la classe enfant après configuration
  }

  /**
   * Initialisation automatique de l'objet
   */
  protected initialize(): void {
    // Vider le groupe au cas où
    this.clear();

    // Construire l'objet dans l'ordre
    this.definePoints();
    this.buildStructure();
    this.buildSurfaces();

    // Mettre à jour la couche de debug
    this.updateDebugLayer();
  }

  /**
   * Initialisation publique à appeler par les classes enfants
   */
  public init(): void {
    this.initialize();
  }

  /**
   * Définit tous les points anatomiques de l'objet
   * À implémenter dans chaque classe dérivée
   */
  protected abstract definePoints(): void;

  /**
   * Construit la structure rigide de l'objet (frame, squelette)
   * À implémenter dans chaque classe dérivée
   */
  protected abstract buildStructure(): void;

  /**
   * Construit les surfaces et détails visuels
   * À implémenter dans chaque classe dérivée
   */
  protected abstract buildSurfaces(): void;

  /**
   * Définit un point nommé dans l'espace
   */
  protected setPoint(name: string, position: Position3D): void {
    const vector = new THREE.Vector3(position[0], position[1], position[2]);
    this.points.set(name, vector);
    
    // Ajouter aux points nommés pour le debug
    this.namedPoints.push({
      name,
      position: vector.clone(),
      visible: this.showDebugPoints
    });
  }

  /**
   * Récupère un point par son nom
   */
  public getPoint(name: string): THREE.Vector3 | undefined {
    return this.points.get(name);
  }

  /**
   * Crée un cylindre entre deux points nommés
   */
  protected addCylinderBetweenPoints(
    point1Name: string,
    point2Name: string,
    radius: number,
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    const p1 = this.getPoint(point1Name);
    const p2 = this.getPoint(point2Name);
    
    if (!p1 || !p2) {
      console.warn(`Points ${point1Name} ou ${point2Name} non trouvés`);
      return null;
    }

    // Calculer la distance et l'orientation
    const distance = p1.distanceTo(p2);
    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
    
    // Créer le cylindre
    const cylinder = Primitive.cylinder(radius, distance, material);
    
    // Orienter le cylindre
    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction
    );
    cylinder.quaternion.copy(quaternion);
    cylinder.position.copy(midpoint);
    
    // Ajouter au groupe
    this.add(cylinder);
    return cylinder;
  }

  /**
   * Crée une surface entre des points nommés
   */
  protected addSurfaceBetweenPoints(
    pointNames: string[],
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    if (pointNames.length < 3) {
      console.warn('Il faut au moins 3 points pour créer une surface');
      return null;
    }

    const points: THREE.Vector3[] = [];
    
    // Récupérer tous les points
    for (const name of pointNames) {
      const point = this.getPoint(name);
      if (!point) {
        console.warn(`Point ${name} non trouvé`);
        return null;
      }
      points.push(point);
    }

    // Créer la surface
    const surface = Primitive.surface(points, material);
    this.add(surface);
    return surface;
  }

  /**
   * Ajoute une primitive à une position donnée
   */
  protected addPrimitiveAt(
    primitive: THREE.Mesh,
    position: Position3D
  ): void {
    primitive.position.set(position[0], position[1], position[2]);
    this.add(primitive);
  }

  /**
   * Ajoute une primitive à la position d'un point nommé
   */
  protected addPrimitiveAtPoint(
    primitive: THREE.Mesh,
    pointName: string
  ): boolean {
    const point = this.getPoint(pointName);
    if (!point) {
      console.warn(`Point ${pointName} non trouvé`);
      return false;
    }
    
    primitive.position.copy(point);
    this.add(primitive);
    return true;
  }

  /**
   * Met à jour la couche de debug avec les points actuels
   */
  protected updateDebugLayer(): void {
    // Vider la couche de debug
    this.debugLayer.clear();

    if (this.showDebugPoints) {
      // Ajouter tous les points nommés
      for (const [name, position] of this.points.entries()) {
        this.debugLayer.addPoint(position, 0xffff00, this.showLabels ? name : undefined);
      }
    }
  }
  
  /**
   * Crée un label de texte pour un point
   */
  private createTextLabel(text: string): THREE.Sprite {
    // Créer un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 64;
    
    // Style du texte
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.font = 'Bold 24px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);
    
    // Créer une texture depuis le canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Créer un sprite avec la texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Ajuster la taille du sprite
    sprite.scale.set(0.3, 0.075, 1);
    
    return sprite;
  }

  /**
   * Active/désactive l'affichage des marqueurs de debug
   */
  public setShowDebugPoints(show: boolean): void {
    this.showDebugPoints = show;
    this.debugLayer.setShowPoints(show);
  }

  /**
   * Active/désactive l'affichage des labels de texte
   */
  public setShowLabels(show: boolean): void {
    this.showLabels = show;
    this.debugLayer.setShowLabels(show);
    // Si les points de debug ne sont pas activés et qu'on veut les labels, activer les deux
    if (show && !this.showDebugPoints) {
      this.setShowDebugPoints(true);
    }
  }  /**
   * Retourne tous les noms de points définis
   */
  public getPointNames(): string[] {
    return Array.from(this.points.keys());
  }

  /**
   * Retourne le nombre de points définis
   */
  public getPointCount(): number {
    return this.points.size;
  }

  /**
   * Retourne les informations sur un point
   */
  public getPointInfo(name: string): NamedPoint | undefined {
    const point = this.getPoint(name);
    if (!point) return undefined;
    
    return {
      name,
      position: point.clone(),
      visible: this.showDebugPoints
    };
  }
}

=== factories/BridleFactory.ts ===

/**
 * BridleFactory.ts - Factory pour créer les instances Line représentant les brides
 *
 * Rôle :
 *   - Crée les 6 brides (3 gauches + 3 droites) comme instances de Line
 *   - Fournit une configuration physique spécifique aux brides (Dyneema courtes et rigides)
 *   - Centralise la création pour garantir cohérence et validation
 *
 * Architecture :
 *   - Réutilise la classe Line (même que lignes principales)
 *   - Config différente : plus rigides, plus courtes, moins élastiques
 *   - Pattern Factory comme LineFactory
 *
 * Relation avec les autres modules :
 *   - Utilise Line (src/objects/mechanical/Line.ts)
 *   - Utilisé par BridleSystem
 *   - Config basée sur BridleLengths (BridleTypes.ts)
 *
 * Voir aussi :
 *   - src/factories/LineFactory.ts (pattern similaire)
 *   - src/objects/mechanical/Line.ts
 *   - src/simulation/types/BridleTypes.ts
 */

import { BridleLengths, BridleAttachment, BridleSide, BridlePosition } from "../simulation/types/BridleTypes";

import { Line, LineConfig, LineAttachments } from "@/objects/Line";


/**
 * Factory pour créer les brides du cerf-volant
 *
 * Les brides sont des lignes courtes et rigides en Dyneema qui relient
 * les points anatomiques du kite (NEZ, INTER, CENTRE) aux points de contrôle (CTRL).
 */
export class BridleFactory {
  /**
   * Configuration physique standard pour les brides
   *
   * Les brides sont plus rigides et moins élastiques que les lignes principales :
   * - Plus courtes (0.5-0.7m vs 15m)
   * - Plus rigides (5000 N/m vs 2200 N/m)
   * - Moins d'amortissement (quasi-rigides)
   * - Très légères
   */
  private static readonly BRIDLE_CONFIG: Omit<LineConfig, 'length'> = {
    stiffness: 5000,           // N/m - Très rigides (Dyneema courte)
    preTension: 10,            // N - Pré-tension faible
    maxTension: 300,           // N - Résistance avant rupture
    dampingCoeff: 0.02,        // Sans dimension - Peu d'amortissement
    linearMassDensity: 0.0003, // kg/m - Très légères
  };

  /**
   * Mapping des positions vers les points anatomiques
   */
  private static readonly POINT_MAPPING = {
    left: {
      nez: { start: "NEZ", end: "CTRL_GAUCHE" },
      inter: { start: "INTER_GAUCHE", end: "CTRL_GAUCHE" },
      centre: { start: "CENTRE", end: "CTRL_GAUCHE" },
    },
    right: {
      nez: { start: "NEZ", end: "CTRL_DROIT" },
      inter: { start: "INTER_DROIT", end: "CTRL_DROIT" },
      centre: { start: "CENTRE", end: "CTRL_DROIT" },
    },
  } as const;

  /**
   * Crée une bride individuelle
   *
   * @param side - Côté (left/right)
   * @param position - Position (nez/inter/centre)
   * @param length - Longueur en mètres
   * @returns Instance Line configurée
   */
  static createBridle(
    side: BridleSide,
    position: BridlePosition,
    length: number
  ): Line {
    const points = this.POINT_MAPPING[side][position];
    const id = `bridle_${side}_${position}`;

    const config: LineConfig = {
      ...this.BRIDLE_CONFIG,
      length,
    };

    const attachments: LineAttachments = {
      kitePoint: points.start,
      barPoint: points.end,
    };

    return new Line(config, attachments, id);
  }

  /**
   * Crée les 3 brides du côté gauche
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createLeftBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('left', 'nez', lengths.nez),
      this.createBridle('left', 'inter', lengths.inter),
      this.createBridle('left', 'centre', lengths.centre),
    ];
  }

  /**
   * Crée les 3 brides du côté droit
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createRightBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('right', 'nez', lengths.nez),
      this.createBridle('right', 'inter', lengths.inter),
      this.createBridle('right', 'centre', lengths.centre),
    ];
  }

  /**
   * Crée toutes les 6 brides (gauches + droites)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Objet contenant les brides gauches et droites
   */
  static createAllBridles(lengths: BridleLengths): {
    left: [Line, Line, Line];
    right: [Line, Line, Line];
  } {
    return {
      left: this.createLeftBridles(lengths),
      right: this.createRightBridles(lengths),
    };
  }

  /**
   * Crée les métadonnées d'attache pour toutes les brides
   * (utilisé pour documentation/debug)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 6 BridleAttachment
   */
  static createBridleAttachments(lengths: BridleLengths): BridleAttachment[] {
    const attachments: BridleAttachment[] = [];

    // Brides gauches
    Object.entries(this.POINT_MAPPING.left).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_left_${position}`,
      });
    });

    // Brides droites
    Object.entries(this.POINT_MAPPING.right).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_right_${position}`,
      });
    });

    return attachments;
  }

  /**
   * Valide les longueurs de brides
   *
   * @param lengths - Longueurs à valider
   * @throws Error si longueurs invalides
   */
  static validateBridleLengths(lengths: BridleLengths): void {
    const { nez, inter, centre } = lengths;

    // Vérifier valeurs positives
    if (nez <= 0 || inter <= 0 || centre <= 0) {
      throw new Error(
        `Longueurs de brides doivent être positives: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // Vérifier plage raisonnable (0.2m à 1.5m)
    const min = 0.2;
    const max = 1.5;
    if (nez < min || nez > max || inter < min || inter > max || centre < min || centre > max) {
      throw new Error(
        `Longueurs de brides hors plage [${min}, ${max}]m: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // Vérifier cohérence géométrique (bride nez généralement plus longue)
    if (nez < inter * 0.8 || nez < centre * 0.8) {
      console.warn(
        `⚠️ Bride NEZ plus courte que INTER/CENTRE peut causer instabilité: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }
  }

  /**
   * Obtient la configuration physique utilisée pour les brides
   * (utile pour debug/documentation)
   */
  static getBridleConfig(): Omit<LineConfig, 'length'> {
    return { ...this.BRIDLE_CONFIG };
  }
}


=== factories/FactoryRegistry.ts ===

/**
 * FactoryRegistry.ts - Registre centralisé des factories
 *
 * Permet la création dynamique d'objets depuis un nom ou un type
 * Pattern : Factory Registry + Plugin Architecture
 */

export interface FactoryMetadata {
  id: string;
  name: string;
  version: string;
  description: string;
  supportedTypes: string[];
  dependencies: string[];
}

export interface BaseFactory {
  createObject(type: string, config: any): any;
  getSupportedTypes(): string[];
  getMetadata(): FactoryMetadata;
  dispose(): void;
}

type FactoryConstructor = new () => BaseFactory;

export interface FactoryParams {
  [key: string]: any;
}

export class FactoryRegistry {
  private static factories = new Map<string, FactoryConstructor>();
  private static instances = new Map<string, BaseFactory>();

  /**
   * Enregistre une factory dans le registre
   */
  static register(name: string, factoryClass: FactoryConstructor): void {
    if (this.factories.has(name)) {
      console.warn(`Factory "${name}" is already registered. Overwriting.`);
    }
    this.factories.set(name, factoryClass);
  }

  /**
   * Désenregistre une factory
   */
  static unregister(name: string): void {
    if (this.factories.has(name)) {
      // Nettoyer l'instance si elle existe
      if (this.instances.has(name)) {
        const instance = this.instances.get(name)!;
        instance.dispose();
        this.instances.delete(name);
      }
      this.factories.delete(name);
    }
  }

  /**
   * Crée un objet en utilisant la factory enregistrée
   */
  static createObject(name: string, params?: FactoryParams): any {
    const factoryClass = this.factories.get(name);
    if (!factoryClass) {
      throw new Error(`Factory "${name}" not found. Available factories: ${Array.from(this.factories.keys()).join(', ')}`);
    }

    // Obtenir ou créer l'instance de factory
    let factory = this.instances.get(name);
    if (!factory) {
      factory = new factoryClass();
      this.instances.set(name, factory);
    }

    // Créer l'objet
    return factory.createObject('default', params);
  }

  /**
   * Vérifie si une factory est enregistrée
   */
  static hasFactory(name: string): boolean {
    return this.factories.has(name);
  }

  /**
   * Obtient la liste des factories enregistrées
   */
  static getRegisteredFactories(): string[] {
    return Array.from(this.factories.keys());
  }

  /**
   * Obtient les métadonnées d'une factory
   */
  static getFactoryMetadata(name: string): { name: string; description?: string } | null {
    const factory = this.instances.get(name);
    if (factory) {
      return factory.getMetadata();
    }
    return null;
  }

  /**
   * Nettoie toutes les factories et instances
   */
  static clear(): void {
    // Nettoyer toutes les instances
    for (const [name, instance] of this.instances) {
      try {
        instance.dispose();
      } catch (error) {
        console.error(`Error disposing factory "${name}":`, error);
      }
    }

    this.instances.clear();
    this.factories.clear();
  }

  /**
   * Recharge une factory (utile pour le développement)
   */
  static reloadFactory(name: string): void {
    if (this.instances.has(name)) {
      const instance = this.instances.get(name)!;
      instance.dispose();
      this.instances.delete(name);
    }
    // La prochaine création recréera l'instance
  }
}

=== factories/FrameFactory.ts ===

/**
 * FrameFactory.ts - Factory pour créer des structures filaires (frames)
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

import { BaseFactory, FactoryMetadata } from './FactoryRegistry';

export interface FrameParams {
  diameter?: number;
  material?: string;
  points?: Array<[string, number[]]>;
  connections?: Array<[string, string]>;
}

/**
 * Factory pour créer des structures filaires
 */
export class FrameFactory implements BaseFactory {
  getSupportedTypes(): string[] {
    return ['frame', 'structure'];
  }

  getMetadata(): FactoryMetadata {
    return {
      id: 'frame_factory',
      name: 'Frame Factory',
      version: '1.0.0',
      description: 'Creates wireframe structures from connected points',
      supportedTypes: this.getSupportedTypes(),
      dependencies: []
    };
  }

  createObject(type: string, config: FrameParams = {}): StructuredObject & ICreatable {
    const params = {
      diameter: 0.01,
      material: '#333333',
      points: [],
      connections: [],
      ...config
    };

    class FrameObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Frame", false);
      }

      protected definePoints(): void {
        if (params.points) {
          params.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        if (params.connections) {
          params.connections.forEach(([point1, point2]) => {
            this.addCylinderBetweenPoints(
              point1,
              point2,
              params.diameter || 0.01,
              params.material || '#333333'
            );
          });
        }
      }

      protected buildSurfaces(): void {
        // Pas de surfaces pour un frame
      }

      create(): this { return this; }
      getName(): string { return 'Frame'; }
      getDescription(): string { return 'Structure filaire'; }
      getPrimitiveCount(): number { return params.connections?.length || 0; }
    }

    const frame = new FrameObject();
    frame.init();
    return frame;
  }

  dispose(): void {
    // Cleanup if needed
  }
}

=== factories/LineFactory.ts ===

/**
 * LineFactory.ts - Factory pour créer des lignes de cerf-volant (OOP pattern)
 *
 * Rôle :
 *   - Créer des objets Line selon le pattern Factory du projet
 *   - Valider les paramètres avant création
 *   - Fournir des presets pour configurations typiques
 *
 * Responsabilité :
 *   - Instanciation cohérente des objets Line
 *   - Application des valeurs par défaut
 *   - Validation des paramètres physiques
 *
 * Pattern :
 *   - Ne suit PAS BaseFactory<StructuredObject> car Line n'est pas un objet 3D
 *   - Factory simple avec méthodes statiques pour configurations communes
 *   - Séparation claire : Line (métier) vs LineVisual (3D)
 *
 * Relation avec les autres modules :
 *   - Crée des objets Line
 *   - Utilisé par LineSystem pour instancier les lignes
 *   - Indépendant de Three.js (pure TypeScript)
 *
 * Philosophie :
 *   - "Make invalid states unrepresentable" : Validation stricte
 *   - Presets pour cas d'usage communs
 *   - Immutabilité : Les lignes créées sont immutables (config readonly)
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts
 *   - src/base/BaseFactory.ts (pattern de référence)
 */

import { Line, LineConfig, LineAttachments } from '@/objects/Line';
import { CONFIG } from '@/simulation/config/SimulationConfig';

/**
 * Paramètres pour créer une ligne via factory
 */
export interface LineFactoryParams {
  /** Longueur au repos (m) - Défaut: CONFIG.lines.defaultLength */
  length?: number;

  /** Point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;

  /** Rigidité personnalisée (N/m) - Défaut: CONFIG.lines.stiffness */
  stiffness?: number;

  /** Pré-tension personnalisée (N) - Défaut: CONFIG.lines.preTension */
  preTension?: number;

  /** Tension max personnalisée (N) - Défaut: CONFIG.lines.maxTension */
  maxTension?: number;

  /** Damping personnalisé - Défaut: CONFIG.lines.dampingCoeff */
  dampingCoeff?: number;

  /** Masse linéique personnalisée (kg/m) - Défaut: CONFIG.lines.linearMassDensity */
  linearMassDensity?: number;

  /** Identifiant personnalisé (optionnel) */
  id?: string;
}

/**
 * Erreur de validation lors de la création d'une ligne
 */
export class LineValidationError extends Error {
  constructor(message: string, public field: string) {
    super(`LineFactory validation error [${field}]: ${message}`);
    this.name = 'LineValidationError';
  }
}

/**
 * Factory pour créer des lignes de cerf-volant
 *
 * @example
 * ```typescript
 * // Ligne standard avec paramètres par défaut
 * const leftLine = LineFactory.createLine({
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Ligne personnalisée
 * const customLine = LineFactory.createLine({
 *   length: 20,
 *   stiffness: 1800,
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Preset débutant
 * const beginnerLine = LineFactory.createBeginnerLine("CTRL_GAUCHE", "HANDLE_LEFT");
 * ```
 */
export class LineFactory {
  /**
   * Crée une ligne avec paramètres personnalisés
   *
   * @param params - Paramètres de configuration
   * @returns Instance de Line configurée
   * @throws LineValidationError si paramètres invalides
   */
  static createLine(params: LineFactoryParams): Line {
    // Valider les paramètres
    this.validateParams(params);

    // Configuration avec valeurs par défaut depuis SimulationConfig
    const config: LineConfig = {
      length: params.length ?? CONFIG.lines.defaultLength,
      stiffness: params.stiffness ?? CONFIG.lines.stiffness,
      preTension: params.preTension ?? CONFIG.lines.preTension,
      maxTension: params.maxTension ?? CONFIG.lines.maxTension,
      dampingCoeff: params.dampingCoeff ?? CONFIG.lines.dampingCoeff,
      linearMassDensity: params.linearMassDensity ?? CONFIG.lines.linearMassDensity
    };

    // Points d'attache
    const attachments: LineAttachments = {
      kitePoint: params.kitePoint,
      barPoint: params.barPoint
    };

    // Créer et retourner la ligne
    return new Line(config, attachments, params.id);
  }

  /**
   * Crée une paire de lignes gauche/droite standard
   *
   * @param length - Longueur commune (m)
   * @returns Tuple [ligne gauche, ligne droite]
   */
  static createLinePair(length?: number): [Line, Line] {
    const leftLine = this.createLine({
      length,
      kitePoint: "CTRL_GAUCHE",
      barPoint: "HANDLE_LEFT",
      id: "line_left"
    });

    const rightLine = this.createLine({
      length,
      kitePoint: "CTRL_DROIT",
      barPoint: "HANDLE_RIGHT",
      id: "line_right"
    });

    return [leftLine, rightLine];
  }

  /**
   * Preset : Ligne pour débutant
   * - Plus courte (12m)
   * - Moins rigide (1800 N/m)
   * - Pré-tension plus faible (50N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configurée pour débutant
   */
  static createBeginnerLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 12,
      stiffness: 1800,
      preTension: 50,
      maxTension: 600,
      dampingCoeff: 0.08, // Plus de damping = plus stable
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne pour expert
   * - Plus longue (20m)
   * - Rigidité standard (2200 N/m)
   * - Haute tension max (1000N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configurée pour expert
   */
  static createExpertLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 20,
      stiffness: 2200,
      preTension: 100,
      maxTension: 1000,
      dampingCoeff: 0.03, // Moins de damping = plus réactif
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne de sécurité (ultra-résistante)
   * - Tension max très élevée (1500N)
   * - Rigidité renforcée (3000 N/m)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne de sécurité
   */
  static createSafetyLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 15,
      stiffness: 3000,
      preTension: 150,
      maxTension: 1500,
      dampingCoeff: 0.05,
      linearMassDensity: 0.001, // Plus lourde
      kitePoint,
      barPoint
    });
  }

  /**
   * Crée une ligne depuis JSON (désérialisation)
   *
   * @param json - Données JSON (depuis Line.toJSON())
   * @returns Instance de Line recréée
   */
  static fromJSON(json: any): Line {
    return Line.fromJSON(json);
  }

  /**
   * Valide les paramètres avant création
   *
   * @param params - Paramètres à valider
   * @throws LineValidationError si invalide
   */
  private static validateParams(params: LineFactoryParams): void {
    // Points d'attache obligatoires
    if (!params.kitePoint || params.kitePoint.trim() === '') {
      throw new LineValidationError('Kite attachment point is required', 'kitePoint');
    }

    if (!params.barPoint || params.barPoint.trim() === '') {
      throw new LineValidationError('Bar attachment point is required', 'barPoint');
    }

    // Longueur positive
    if (params.length !== undefined && params.length <= 0) {
      throw new LineValidationError('Length must be positive', 'length');
    }

    // Rigidité positive
    if (params.stiffness !== undefined && params.stiffness <= 0) {
      throw new LineValidationError('Stiffness must be positive', 'stiffness');
    }

    // Pré-tension non-négative
    if (params.preTension !== undefined && params.preTension < 0) {
      throw new LineValidationError('PreTension cannot be negative', 'preTension');
    }

    // Tension max > pré-tension
    if (params.maxTension !== undefined && params.preTension !== undefined) {
      if (params.maxTension <= params.preTension) {
        throw new LineValidationError(
          'MaxTension must be greater than preTension',
          'maxTension'
        );
      }
    }

    // Damping dans [0, 1]
    if (params.dampingCoeff !== undefined) {
      if (params.dampingCoeff < 0 || params.dampingCoeff > 1) {
        throw new LineValidationError(
          'DampingCoeff must be between 0 and 1',
          'dampingCoeff'
        );
      }
    }

    // Masse linéique positive
    if (params.linearMassDensity !== undefined && params.linearMassDensity <= 0) {
      throw new LineValidationError(
        'LinearMassDensity must be positive',
        'linearMassDensity'
      );
    }
  }

  /**
   * Obtient les valeurs par défaut utilisées par la factory
   *
   * @returns Configuration par défaut
   */
  static getDefaultConfig(): LineConfig {
    return {
      length: CONFIG.lines.defaultLength,
      stiffness: CONFIG.lines.stiffness,
      preTension: CONFIG.lines.preTension,
      maxTension: CONFIG.lines.maxTension,
      dampingCoeff: CONFIG.lines.dampingCoeff,
      linearMassDensity: CONFIG.lines.linearMassDensity
    };
  }

  /**
   * Vérifie si deux lignes ont la même configuration physique
   *
   * @param line1 - Première ligne
   * @param line2 - Deuxième ligne
   * @returns true si configurations identiques
   */
  static areConfigsEqual(line1: Line, line2: Line): boolean {
    const c1 = line1.config;
    const c2 = line2.config;

    return (
      c1.length === c2.length &&
      c1.stiffness === c2.stiffness &&
      c1.preTension === c2.preTension &&
      c1.maxTension === c2.maxTension &&
      c1.dampingCoeff === c2.dampingCoeff &&
      c1.linearMassDensity === c2.linearMassDensity
    );
  }
}


=== factories/PointFactory.ts ===

/**
 * PointFactory.ts - Encapsule la logique de calcul des points anatomiques
 *
 * Responsabilité : Calculer les positions des points d'un cerf-volant delta
 */

import * as THREE from 'three';

import { CONFIG } from '@/simulation/config/SimulationConfig';

// Constantes géométriques locales
const GEOMETRY = {
  half: 0.5,
  third: 1 / 3,
  twoThirds: 2 / 3,
  quarter: 0.25,
};

/**
 * Longueurs physiques des brides (en mètres)
 */
export interface BridleLengths {
  nez: number;      // Longueur bride NEZ -> CTRL (avant)
  inter: number;    // Longueur bride INTER -> CTRL (latéral)
  centre: number;   // Longueur bride CENTRE -> CTRL (arrière)
}

export interface KiteParams {
  width: number;   // Envergure
  height: number;  // Hauteur
  depth: number;   // Profondeur whiskers
  bridleLengths?: BridleLengths;  // Longueurs physiques des brides
}

/**
 * Factory simple qui encapsule la logique de calcul des points
 */
export class PointFactory {
  /**
   * Crée le repère local pour la trilatération 3D
   */
  private static createLocalCoordinateSystem(
    p1: THREE.Vector3,
    p2: THREE.Vector3,
    p3: THREE.Vector3
  ): { ex: THREE.Vector3; ey: THREE.Vector3; ez: THREE.Vector3; i: number; j: number; d: number } {
    // Axe X : direction p1->p2
    const ex = new THREE.Vector3().subVectors(p2, p1).normalize();
    const d = p2.distanceTo(p1);

    // Composante Y du repère
    const p3_p1 = new THREE.Vector3().subVectors(p3, p1);
    const i = ex.dot(p3_p1);
    const ey_temp = new THREE.Vector3().copy(p3_p1).addScaledVector(ex, -i);
    const ey = ey_temp.normalize();

    // Axe Z (perpendiculaire au plan p1-p2-p3)
    const ez = new THREE.Vector3().crossVectors(ex, ey);

    // Garantir la symétrie - ez doit pointer vers l'arrière (+Z global)
    if (ez.z < 0) {
      ez.negate();
    }

    // Coordonnées de p3 dans le repère local
    const j = ey.dot(p3_p1);

    return { ex, ey, ez, i, j, d };
  }

  /**
   * Résout le système de trilatération dans le repère local
   */
  private static solveTrilaterationSystem(
    coordSystem: { i: number; j: number; d: number },
    radii: { r1: number; r2: number; r3: number }
  ): { x: number; y: number; z: number } {
    const { i, j, d } = coordSystem;
    const { r1, r2, r3 } = radii;

    // Résolution du système dans le repère local
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const y = (r1 * r1 - r3 * r3 + i * i + j * j) / (2 * j) - (i / j) * x;

    // Calcul de z
    const zSquared = r1 * r1 - x * x - y * y;
    let z: number;
    if (zSquared < 0) {
      console.warn(`⚠️ Configuration de brides impossible (z²=${zSquared.toFixed(3)}), approximation`);
      z = 0; // Solution dégénérée
    } else {
      z = Math.sqrt(zSquared); // z > 0 vers l'arrière du kite
    }

    return { x, y, z };
  }

  /**
   * Convertit les coordonnées locales en coordonnées globales
   */
  private static convertToGlobalCoordinates(
    p1: THREE.Vector3,
    coordSystem: { ex: THREE.Vector3; ey: THREE.Vector3; ez: THREE.Vector3 },
    localCoords: { x: number; y: number; z: number }
  ): THREE.Vector3 {
    const result = new THREE.Vector3();
    result.copy(p1);
    result.addScaledVector(coordSystem.ex, localCoords.x);
    result.addScaledVector(coordSystem.ey, localCoords.y);
    result.addScaledVector(coordSystem.ez, localCoords.z);
    return result;
  }

  /**
   * Calcule la position du point de contrôle (CTRL) par trilatération 3D analytique
   * Résout l'intersection de 3 sphères centrées en NEZ, INTER, CENTRE
   * avec rayons = longueurs de brides respectives
   */
  private static calculateControlPoint(
    nez: [number, number, number],
    inter: [number, number, number],
    centre: [number, number, number],
    bridleLengths: BridleLengths,
    _side: 'left' | 'right'
  ): [number, number, number] {
    // Convertir en Vector3
    const p1 = new THREE.Vector3(...nez);      // Point 1 : NEZ
    const p2 = new THREE.Vector3(...inter);    // Point 2 : INTER
    const p3 = new THREE.Vector3(...centre);   // Point 3 : CENTRE

    const radii = {
      r1: bridleLengths.nez,
      r2: bridleLengths.inter,
      r3: bridleLengths.centre
    };

    // Créer le repère local
    const coordSystem = this.createLocalCoordinateSystem(p1, p2, p3);

    // Résoudre le système
    const localCoords = this.solveTrilaterationSystem(coordSystem, radii);

    // Convertir en coordonnées globales
    const result = this.convertToGlobalCoordinates(p1, coordSystem, localCoords);

    return [result.x, result.y, result.z];
  }

  /**
   * Calcule les points d'ancrage fixes des brides
   */
  private static calculateAnchorPoints(width: number, height: number): {
    nezPos: [number, number, number];
    centrePos: [number, number, number];
    interGauchePos: [number, number, number];
    interDroitPos: [number, number, number];
  } {
    const centreY = height * GEOMETRY.quarter;
    const ratio = (height - centreY) / height;
    const interGaucheX = ratio * (-width / 2);
    const interDroitX = ratio * (width / 2);

    return {
      nezPos: [0, height, 0],
      centrePos: [0, centreY, 0],
      interGauchePos: [interGaucheX, centreY, 0],
      interDroitPos: [interDroitX, centreY, 0]
    };
  }

  /**
   * Calcule les points de contrôle gauche et droit par trilatération
   */
  private static calculateControlPoints(
    anchorPoints: { nezPos: [number, number, number]; centrePos: [number, number, number]; interGauchePos: [number, number, number]; interDroitPos: [number, number, number] },
    bridleLengths: BridleLengths
  ): { ctrlGauche: [number, number, number]; ctrlDroit: [number, number, number] } {
    const { nezPos, centrePos, interDroitPos } = anchorPoints;

    // Calculer le point de contrôle droit par trilatération
    const ctrlDroit = PointFactory.calculateControlPoint(
      nezPos,
      interDroitPos,
      centrePos,
      bridleLengths,
      'right'
    );

    // Le point de contrôle gauche est le miroir du point droit
    const ctrlGauche: [number, number, number] = [-ctrlDroit[0], ctrlDroit[1], ctrlDroit[2]];

    return { ctrlGauche, ctrlDroit };
  }

  /**
   * Crée la collection complète des points anatomiques
   */
  private static createPointCollection(
    width: number,
    height: number,
    depth: number,
    anchorPoints: { nezPos: [number, number, number]; centrePos: [number, number, number]; interGauchePos: [number, number, number]; interDroitPos: [number, number, number] },
    controlPoints: { ctrlGauche: [number, number, number]; ctrlDroit: [number, number, number] }
  ): Map<string, [number, number, number]> {
    const { nezPos, centrePos, interGauchePos, interDroitPos } = anchorPoints;
    const { ctrlGauche, ctrlDroit } = controlPoints;

    const fixRatio = GEOMETRY.twoThirds;

    return new Map<string, [number, number, number]>([
      // Points structurels principaux
      ["SPINE_BAS", [0, 0, 0]],
      ["CENTRE", centrePos],
      ["NEZ", nezPos],

      // Points des bords d'attaque
      ["BORD_GAUCHE", [-width / 2, 0, 0]],
      ["BORD_DROIT", [width / 2, 0, 0]],

      // Points d'intersection pour le spreader
      ["INTER_GAUCHE", interGauchePos],
      ["INTER_DROIT", interDroitPos],

      // Points de fixation whiskers
      ["FIX_GAUCHE", [fixRatio * interGauchePos[0], centrePos[1], 0]],
      ["FIX_DROIT", [fixRatio * interDroitPos[0], centrePos[1], 0]],

      // Points des whiskers
      ["WHISKER_GAUCHE", [-width / 4, 0.1, -depth]],
      ["WHISKER_DROIT", [width / 4, 0.1, -depth]],

      // Points de contrôle (bridage) - calculés depuis longueurs physiques
      ["CTRL_GAUCHE", ctrlGauche],
      ["CTRL_DROIT", ctrlDroit],

      // Points d'ancrage des brides
      ["BRIDE_GAUCHE_A", nezPos],
      ["BRIDE_GAUCHE_B", interGauchePos],
      ["BRIDE_GAUCHE_C", centrePos],
      ["BRIDE_DROITE_A", nezPos],
      ["BRIDE_DROITE_B", interDroitPos],
      ["BRIDE_DROITE_C", centrePos],
    ]);
  }

  /**
   * Calcule toutes les positions des points anatomiques d'un cerf-volant delta
   */
  static calculateDeltaKitePoints(params: KiteParams): Map<string, [number, number, number]> {
    const { width, height, depth, bridleLengths } = params;
    const effectiveBridleLengths: BridleLengths = bridleLengths ?? { ...CONFIG.bridle.defaultLengths };

    // Calculer les points d'ancrage
    const anchorPoints = this.calculateAnchorPoints(width, height);

    // Calculer les points de contrôle
    const controlPoints = this.calculateControlPoints(anchorPoints, effectiveBridleLengths);

    // Créer la collection complète
    return this.createPointCollection(width, height, depth, anchorPoints, controlPoints);
  }
}

=== factories/SurfaceFactory.ts ===

/**
 * SurfaceFactory.ts - Factory pour créer des surfaces et toiles
 *
 * Pattern actuel KISS : Points → Triangles pour surfaces
 * Compatible avec buildSurfaces() de StructuredObject
 */

import * as THREE from "three";

import { BaseFactory, FactoryParams } from "../base/BaseFactory";
import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";

export interface SurfaceParams extends FactoryParams {
  points?: Array<[string, number[]]>; // Points nommés pour la surface
  panels?: Array<string[]>; // Groupes de 3-4 points formant des panneaux
  material?: {
    color?: string;
    opacity?: number;
    transparent?: boolean;
    doubleSided?: boolean; // true = visible des deux côtés (défaut), false = une face
    side?: THREE.Side;
  };
  tension?: number; // Tension de la toile (future feature)
}

/**
 * Factory pour créer des surfaces tendues
 *
 
 *
 */
export class SurfaceFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: "surface",
    name: "Surface",
    description: "Surface tendue paramétrique",
    tags: ["surface", "toile", "membrane"],
    complexity: "simple" as const,
  };

  protected getDefaultParams(): SurfaceParams {
    return {
      points: [],
      panels: [],
      material: {
        color: "#ff0000",
        opacity: 0.9,
        transparent: true,
        doubleSided: true, // Par défaut, visible des deux côtés
      },
      tension: 1.0,
    };
  }

  /**
   * Modèle physique :
   * - La masse du kite est distribuée sur chaque surface proportionnellement à son aire (voir PHYSICS_MODEL.md §1.2).
   * - Cette logique doit être appliquée lors de la création des surfaces (buildSurfaces).
   * - Permet l'émergence naturelle des couples gravitationnels et aérodynamiques.
   */
  createObject(params?: SurfaceParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as SurfaceParams;

    class SurfaceObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Surface", false);
      }

      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        // Pas de structure pour une surface pure
      }

      protected buildSurfaces(): void {
        // Créer les panneaux de surface
        if (mergedParams.panels) {
          mergedParams.panels.forEach((panel) => {
            // Convertir doubleSided en THREE.Side
            const mat = mergedParams.material || {};
            const side =
              mat.doubleSided !== false ? THREE.DoubleSide : THREE.FrontSide;

            // Chaque panneau est un triangle (3 points) ou quad (4 points)
            this.addSurfaceBetweenPoints(panel, {
              color: mat.color || "#ff0000",
              opacity: mat.opacity !== undefined ? mat.opacity : 0.9,
              transparent: mat.transparent !== false,
              side: mat.side || side,
            });
          });
        }
      }

      // Implémentation ICreatable
      create(): this {
        return this;
      }
      getName(): string {
        return "Surface";
      }
      getDescription(): string {
        return "Surface tendue";
      }
      getPrimitiveCount(): number {
        return (mergedParams.panels || []).length;
      }
    }

    const surface = new SurfaceObject();
    surface.init();
    return surface;
  }
}


=== factories/presets/PhysicalPresets.ts ===

/**
 * PhysicalPresets.ts - Constantes physiques centralisées
 *
 * Toutes les constantes physiques, matériaux et configurations
 * utilisées dans la simulation du cerf-volant.
 */

import * as THREE from 'three';

// ============================================================================
// CONSTANTES PHYSIQUES FONDAMENTALES
// ============================================================================

export const PHYSICAL_CONSTANTS = {
  gravity: 9.81, // m/s² - Accélération gravitationnelle terrestre
  airDensity: 1.225, // kg/m³ - Densité de l'air à 15°C
  speedOfSound: 343, // m/s - Vitesse du son dans l'air
  dynamicViscosity: 1.81e-5, // Pa·s - Viscosité dynamique de l'air
} as const;

// ============================================================================
// PRÉSETS DE MATÉRIAUX PHYSIQUES
// ============================================================================

export const MATERIAL_PRESETS = {
  // Matériaux de structure (carbone/kevlar)
  carbon: {
    density: 1600, // kg/m³
    youngModulus: 230e9, // Pa - Module de Young
    tensileStrength: 3500e6, // Pa - Résistance à la traction
    color: 0x333333,
    name: 'Carbone'
  },

  kevlar: {
    density: 1440, // kg/m³
    youngModulus: 130e9, // Pa
    tensileStrength: 3600e6, // Pa
    color: 0x666666,
    name: 'Kevlar'
  },

  // Matériaux de surface (tissus)
  ripstopNylon: {
    density: 40, // g/m² (surface density)
    thickness: 0.00015, // m
    tensileStrength: 150e6, // Pa
    color: 0xffffff,
    name: 'Ripstop Nylon'
  },

  dacron: {
    density: 45, // g/m²
    thickness: 0.00018, // m
    tensileStrength: 180e6, // Pa
    color: 0xf0f0f0,
    name: 'Dacron'
  }
} as const;

// ============================================================================
// PRÉSETS DE LIGNES ET BRIDES
// ============================================================================

export const LINE_PRESETS = {
  standard: {
    stiffness: 2200, // N/m - Rigidité
    preTension: 75, // N - Tension minimale
    maxTension: 800, // N - Tension maximale
    dampingCoeff: 0.05, // Coefficient d'amortissement
    linearMassDensity: 0.0005, // kg/m - Masse linéique
    color: 0xffaa00,
    name: 'Ligne Standard'
  },

  bridle: {
    stiffness: 5000, // N/m - Plus rigide pour les brides
    preTension: 10, // N - Tension minimale faible
    maxTension: 300, // N - Tension maximale
    dampingCoeff: 0.02, // Amortissement faible
    linearMassDensity: 0.0003, // kg/m - Plus léger
    color: 0x00aaff,
    name: 'Bride'
  },

  control: {
    stiffness: 1800, // N/m - Moins rigide pour le contrôle
    preTension: 50, // N
    maxTension: 600, // N
    dampingCoeff: 0.08, // Amortissement plus fort
    linearMassDensity: 0.0007, // kg/m - Plus lourd
    color: 0xff4444,
    name: 'Ligne de Contrôle'
  }
} as const;

// ============================================================================
// PRÉSETS AÉRODYNAMIQUES
// ============================================================================

export const AERODYNAMIC_PRESETS = {
  // Coefficients de portance (lift) selon l'angle d'attaque
  liftCoefficients: {
    low: 0.2,     // Angle d'attaque faible
    medium: 0.8,  // Angle d'attaque moyen
    high: 1.2,    // Angle d'attaque élevé
    stall: 0.1    // Décrochage
  },

  // Coefficients de traînée (drag)
  dragCoefficients: {
    low: 0.05,    // Profil optimisé
    medium: 0.08, // Profil standard
    high: 0.15,   // Profil dégradé
    stall: 0.3    // Décrochage
  },

  // Facteurs d'échelle pour équilibrer la simulation
  scaleFactors: {
    lift: 1.2,    // Facteur de portance
    drag: 1.2,    // Facteur de traînée
    torque: 1.0   // Facteur de couple
  }
} as const;

// ============================================================================
// PRÉSETS DE VENT
// ============================================================================

export const WIND_PRESETS = {
  calm: {
    speed: 5,      // km/h
    direction: 0,  // degrés
    turbulence: 0.001, // %
    name: 'Calme'
  },

  light: {
    speed: 15,     // km/h
    direction: 0,  // degrés
    turbulence: 0.005, // %
    name: 'Léger'
  },

  moderate: {
    speed: 25,     // km/h
    direction: 0,  // degrés
    turbulence: 0.01, // %
    name: 'Modéré'
  },

  strong: {
    speed: 35,     // km/h
    direction: 0,  // degrés
    turbulence: 0.02, // %
    name: 'Fort'
  }
} as const;

// ============================================================================
// PRÉSETS DE CONFIGURATION KITE
// ============================================================================

export const KITE_PRESETS = {
  standard: {
    area: 0.5288,  // m² - Surface calculée
    mass: 0.31,    // kg - Masse calculée
    span: 1.65,    // m - Envergure
    aspectRatio: 3.12, // Rapport d'allongement
    name: 'Kite Standard'
  },

  sport: {
    area: 0.6,     // m²
    mass: 0.28,    // kg
    span: 1.8,     // m
    aspectRatio: 3.5,
    name: 'Kite Sport'
  },

  beginner: {
    area: 0.8,     // m²
    mass: 0.35,    // kg
    span: 2.0,     // m
    aspectRatio: 2.8,
    name: 'Kite Débutant'
  }
} as const;

// ============================================================================
// UTILITAIRES
// ============================================================================

export class PhysicalUtils {
  /**
   * Calcule la pression dynamique
   */
  static dynamicPressure(velocity: THREE.Vector3, airDensity: number = PHYSICAL_CONSTANTS.airDensity): number {
    const speed = velocity.length();
    return 0.5 * airDensity * speed * speed;
  }

  /**
   * Calcule le nombre de Reynolds
   */
  static reynoldsNumber(velocity: number, length: number, viscosity: number = PHYSICAL_CONSTANTS.dynamicViscosity): number {
    return (velocity * length) / viscosity;
  }

  /**
   * Convertit km/h en m/s
   */
  static kmhToMs(speedKmh: number): number {
    return speedKmh / 3.6;
  }

  /**
   * Convertit m/s en km/h
   */
  static msToKmh(speedMs: number): number {
    return speedMs * 3.6;
  }
}

=== main.ts ===

import { Simulation } from "./simulation";

// Initialisation de la simulation
async function startSimulation() {
  try {
    const app = new Simulation();
    await app.initialize();

    // Démarrer la simulation
    await app.start();

    // Gestion du nettoyage lors de la fermeture de la page
    window.addEventListener("beforeunload", () => {
      if (app && typeof app.dispose === "function") {
        app.dispose();
      }
    });
  } catch {
    // Gestion d'erreur silencieuse - les erreurs sont déjà loggées par la simulation
  }
}

// Lancer la simulation au chargement
startSimulation();


=== objects/Kite.ts ===


/**
 * Kite.ts - Modèle 3D du cerf-volant delta pour la simulation Kite
 *
 * Modèle physique (voir PHYSICS_MODEL.md) :
 *   - Structure tridimensionnelle rigide (frames carbone + surfaces toile)
 *   - Masse distribuée sur chaque surface proportionnellement à son aire
 *   - Inertie calculée automatiquement depuis la géométrie (I ≈ m·r²)
 *   - Forces et couples émergent naturellement de la distribution spatiale des forces
 *   - Les brides et lignes sont des contraintes géométriques, pas des forces directes
 *   - L’équilibre du kite provient de la géométrie et de la répartition des masses
 *
 * Utilisation typique :
 *   - Instancié par le moteur physique et le rendu pour manipuler le kite
 *   - Sert de source unique pour les points et la géométrie du kite
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 *   - src/factories/FrameFactory.ts
 *   - src/factories/SurfaceFactory.ts
 *   - src/factories/PointFactory.ts
 */

import * as THREE from "three";

import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";
import { Primitive } from "../core/Primitive";
import { FrameFactory } from "../factories/FrameFactory";
import { SurfaceFactory } from "../factories/SurfaceFactory";
import { PointFactory, BridleLengths } from "../factories/PointFactory";
import { CONFIG } from "../simulation/config/SimulationConfig";

export class Kite extends StructuredObject implements ICreatable {
  // Modèle physique : Structure 3D rigide
  // - Structure tridimensionnelle rigide (frames carbone + surfaces toile)
  // - Masse distribuée sur chaque surface proportionnellement à son aire
  // - Inertie calculée automatiquement depuis la géométrie (I ≈ m·r²)
  // - Forces et couples émergent naturellement de la distribution spatiale des forces
  // - Les brides et lignes sont des contraintes géométriques, pas des forces directes
  // - L’équilibre du kite provient de la géométrie et de la répartition des masses

  private frameFactory: FrameFactory;
  private surfaceFactory: SurfaceFactory;
  // Map centrale des points - Single Source of Truth
  private pointsMap: Map<string, [number, number, number]> = new Map();
  private bridleLines: THREE.Group | null = null;
  private bridleLengthFactor: number = 1.0; // Facteur de longueur virtuelle des brides principales
  private bridleLengths: BridleLengths = { ...CONFIG.bridle.defaultLengths };
  private params = {
    width: 1.65, // Envergure
    height: 0.65, // Hauteur
    depth: 0.20, // Profondeur whiskers
    frameDiameter: 0.01,
    frameColor: "#2a2a2a",
    sailColor: "#ff3333",
    sailOpacity: 0.9,
  };

  constructor(customParams = {}) {
    super("Cerf-volant Delta", false);
    this.params = { ...this.params, ...customParams };
    this.frameFactory = new FrameFactory();
    this.surfaceFactory = new SurfaceFactory();
    this.init();
  }

  /**
   * Définit tous les points anatomiques du cerf-volant
   * Utilise PointFactory pour encapsuler la logique de calcul
   */
  protected definePoints(): void {
    const { width, height, depth } = this.params;

    // Utiliser PointFactory pour calculer les positions avec bridleLengths physiques
    this.pointsMap = PointFactory.calculateDeltaKitePoints({
      width,
      height,
      depth,
      bridleLengths: this.bridleLengths
    });

    // Enregistrer dans StructuredObject pour compatibilité avec le système existant
    this.pointsMap.forEach((position, name) => {
      this.setPoint(name, position);
    });
  }

  /**
   * Construit la structure rigide avec FrameFactory
   */
  protected buildStructure(): void {
    const { frameDiameter, frameColor } = this.params;

    // Créer le frame principal avec la Map de points partagée
    const mainFrameParams = {
      diameter: frameDiameter,
      material: frameColor,
      points: Array.from(this.pointsMap.entries()), // Passer LA Map de référence
      connections: [
        // Épine centrale
        ["NEZ", "SPINE_BAS"] as [string, string],
        // Bords d'attaque
        ["NEZ", "BORD_GAUCHE"] as [string, string],
        ["NEZ", "BORD_DROIT"] as [string, string],
        // Spreader
        ["INTER_GAUCHE", "INTER_DROIT"] as [string, string],
      ],
    };

    const mainFrame = this.frameFactory.createObject('frame', mainFrameParams);
    this.add(mainFrame);

    // Créer les whiskers avec un frame séparé (plus fin)
    const whiskerFrameParams = {
      diameter: frameDiameter / 2,
      material: "#444444",
      points: Array.from(this.pointsMap.entries()), // Même Map de référence
      connections: [
        ["WHISKER_GAUCHE", "FIX_GAUCHE"] as [string, string],
        ["WHISKER_DROIT", "FIX_DROIT"] as [string, string],
      ],
    };

    const whiskerFrame = this.frameFactory.createObject('frame', whiskerFrameParams);
    this.add(whiskerFrame);

    // Créer le système de bridage avec des lignes souples
    this.createBridleLines();
  }

  /**
   * Crée les lignes de bridage souples (visuelles uniquement)
   * Ces lignes représentent des cordes sans élasticité ni effet ressort
   */
  private createBridleLines(): void {
    // Supprimer les anciennes lignes si elles existent
    if (this.bridleLines) {
      this.remove(this.bridleLines);
    }

    this.bridleLines = new THREE.Group();
    this.bridleLines.name = "BridleLines";

    // Configuration des brides
    const bridleConnections = [
      // Bridage gauche (3 lignes partant de CTRL_GAUCHE)
      ["CTRL_GAUCHE", "NEZ"],
      ["CTRL_GAUCHE", "INTER_GAUCHE"],
      ["CTRL_GAUCHE", "CENTRE"],
      // Bridage droit (3 lignes partant de CTRL_DROIT)
      ["CTRL_DROIT", "NEZ"],
      ["CTRL_DROIT", "INTER_DROIT"],
      ["CTRL_DROIT", "CENTRE"],
    ];

    // Matériau pour les lignes de bridage
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: 1,
      opacity: 0.8,
      transparent: true,
    });

    // Créer chaque ligne de bridage
    bridleConnections.forEach(([startName, endName]) => {
      const startPos = this.pointsMap.get(startName);
      const endPos = this.pointsMap.get(endName);

      if (startPos && endPos) {
        // Créer une ligne droite simple (sans effet caténaire pour les brides internes)
        const geometry = new THREE.BufferGeometry();
        const points = [
          new THREE.Vector3(...startPos),
          new THREE.Vector3(...endPos),
        ];
        geometry.setFromPoints(points);

        const line = new THREE.Line(geometry, lineMaterial);
        line.name = `Bridle_${startName}_${endName}`;

        // Stocker la longueur de repos de la bride
        const restLength = new THREE.Vector3(...startPos).distanceTo(
          new THREE.Vector3(...endPos)
        );
        line.userData.restLength = restLength;
        line.userData.startPoint = startName;
        line.userData.endPoint = endName;

        this.bridleLines!.add(line);
      }
    });

    this.add(this.bridleLines!);
  }

  /**
   * Met à jour les lignes de bridage pour suivre les points
   * À appeler si les points bougent dynamiquement
   */
  public updateBridleLines(): void {
    if (!this.bridleLines) return;

    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const startName = line.userData.startPoint;
        const endName = line.userData.endPoint;
        const startPos = this.getPoint(startName);
        const endPos = this.getPoint(endName);

        if (startPos && endPos) {
          const geometry = line.geometry as THREE.BufferGeometry;
          const points = [
            startPos.clone(),
            endPos.clone(),
          ];
          geometry.setFromPoints(points);
          geometry.attributes.position.needsUpdate = true;
        }
      }
    });
  }

  /**
   * Met à jour la visualisation des brides selon leurs tensions
   * Couleurs : vert (molle) → jaune (moyenne) → rouge (tendue)
   *
   * @param tensions - Tensions des 6 brides en Newtons
   */
  public updateBridleVisualization(tensions: {
    leftNez: number;
    leftInter: number;
    leftCentre: number;
    rightNez: number;
    rightInter: number;
    rightCentre: number;
  }): void {
    if (!this.bridleLines) return;

    // Mapping nom ligne → tension
    const tensionMap = new Map<string, number>([
      ["Bridle_CTRL_GAUCHE_NEZ", tensions.leftNez],
      ["Bridle_CTRL_GAUCHE_INTER_GAUCHE", tensions.leftInter],
      ["Bridle_CTRL_GAUCHE_CENTRE", tensions.leftCentre],
      ["Bridle_CTRL_DROIT_NEZ", tensions.rightNez],
      ["Bridle_CTRL_DROIT_INTER_DROIT", tensions.rightInter],
      ["Bridle_CTRL_DROIT_CENTRE", tensions.rightCentre],
    ]);

    // Mettre à jour couleur de chaque bride
    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const tension = tensionMap.get(line.name) ?? 0;
        const material = line.material as THREE.LineBasicMaterial;

        // Seuils de tension (N) - centralisés dans CONFIG
        const lowThreshold = CONFIG.debug.bridleTensionLow;
        const highThreshold = CONFIG.debug.bridleTensionHigh;

        if (tension < lowThreshold) {
          // Vert : bride molle
          material.color.setHex(0x00ff00);
          material.opacity = 0.5;
        } else if (tension < highThreshold) {
          // Jaune : tension moyenne
          // Interpolation vert → jaune
          const t = (tension - lowThreshold) / (highThreshold - lowThreshold);
          const r = Math.floor(t * 255);
          const g = 255;
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.6 + t * 0.2; // 0.6 → 0.8
        } else {
          // Rouge : bride tendue
          // Interpolation jaune → rouge
          const t = Math.min((tension - highThreshold) / 100, 1);
          const r = 255;
          const g = Math.floor((1 - t) * 255);
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.8 + t * 0.2; // 0.8 → 1.0
        }
      }
    });
  }

  /**
   * Construit les surfaces avec SurfaceFactory
   */
  protected buildSurfaces(): void {
    const { sailColor, sailOpacity } = this.params;

    // Créer la toile avec 4 panneaux triangulaires
    const sailParams = {
      points: Array.from(this.pointsMap.entries()), // Même Map de référence
      panels: [
        // Toile gauche
        ["NEZ", "BORD_GAUCHE", "WHISKER_GAUCHE"],
        ["NEZ", "WHISKER_GAUCHE", "SPINE_BAS"],
        // Toile droite
        ["NEZ", "BORD_DROIT", "WHISKER_DROIT"],
        ["NEZ", "WHISKER_DROIT", "SPINE_BAS"],
      ],
      material: {
        color: sailColor,
        transparent: true,
        opacity: sailOpacity,
        doubleSided: true, // Visible des deux côtés
      },
    };

    const sail = this.surfaceFactory.createObject(sailParams);
    this.add(sail);

    // Ajouter des marqueurs visuels aux points clés
    this.addVisualMarkers();
  }

  /**
   * Méthode helper pour obtenir la Map de points
   * Peut être utilisée si d'autres objets ont besoin des points
   */
  public getPointsMap(): Map<string, [number, number, number]> {
    return new Map(this.pointsMap); // Retourner une copie pour éviter les modifications externes
  }

  /**
   * Ajuste le facteur de longueur virtuelle des brides principales (NEZ vers CTRL_*)
   * @param factor - Facteur de longueur (0.5 = 50% plus court, 1.0 = normal, 1.5 = 50% plus long)
   */
  public adjustBridleLength(factor: number): void {
    // Limiter la valeur entre 0.5 et 1.5
    this.bridleLengthFactor = Math.max(0.5, Math.min(1.5, factor));
    console.log(
      `📏 Facteur de longueur des brides principales: ${this.bridleLengthFactor}`
    );
  }

  /**
   * Retourne la longueur de repos virtuelle pour les brides principales
   * Utilisé par la physique pour calculer les tensions
   * @param bridleName - 'left' ou 'right'
   * @returns La longueur de repos modifiée ou undefined si pas une bride principale
   */
  public getBridleRestLength(bridleName: "left" | "right"): number | undefined {
    const nez = this.getPoint("NEZ");
    const ctrl = this.getPoint(
      bridleName === "left" ? "CTRL_GAUCHE" : "CTRL_DROIT"
    );

    if (!nez || !ctrl) return undefined;

    // Calculer la distance géométrique réelle
    const realDistance = nez.distanceTo(ctrl);

    // Appliquer le facteur de longueur virtuelle
    // factor < 1 = bride plus courte = plus de tension
    // factor > 1 = bride plus longue = moins de tension
    return realDistance * this.bridleLengthFactor;
  }

  /**
   * Retourne le facteur de longueur actuel des brides
   */
  public getBridleLengthFactor(): number {
    return this.bridleLengthFactor;
  }

  /**
   * Ajuste les longueurs physiques des brides (en mètres)
   * @param lengths - Longueurs des 3 brides { nez, inter, centre }
   */
  public setBridleLengths(lengths: Partial<BridleLengths>): void {
    // Mettre à jour les longueurs (merge avec les valeurs existantes)
    this.bridleLengths = {
      ...this.bridleLengths,
      ...lengths
    };

    console.log(`🪁 Longueurs brides: NEZ=${this.bridleLengths.nez.toFixed(2)}m, INTER=${this.bridleLengths.inter.toFixed(2)}m, CENTRE=${this.bridleLengths.centre.toFixed(2)}m`);

    // Supprimer tous les enfants pour nettoyer l'ancienne géométrie
    this.clearChildren();

    // Recalculer les points avec les nouvelles longueurs
    this.definePoints();

    // Reconstruire le kite avec les nouveaux points
    this.buildStructure();
    this.buildSurfaces();
    this.createBridleLines();

    // Recréer les marqueurs visuels aux nouvelles positions
    this.addVisualMarkers();
  }

  /**
   * Supprime tous les enfants du kite (géométrie, marqueurs, etc.)
   */
  private clearChildren(): void {
    // Supprimer tous les enfants Three.js
    while (this.children.length > 0) {
      this.remove(this.children[0]);
    }
  }

  /**
   * Retourne les longueurs actuelles des brides
   */
  public getBridleLengths(): BridleLengths {
    return { ...this.bridleLengths };
  }

  /**
   * Convertit un point du repère local du kite vers le repère monde
   * 
   * IMPORTANT : Cette méthode crée une copie pour éviter de modifier les points stockés.
   * Pour la transformation Three.js standard, utilisez directement super.localToWorld()
   *
   * @param localPos - Position dans le repère local du kite
   * @returns Nouvelle position dans le repère monde (copie)
   *
   * @example
   * ```typescript
   * const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
   * const worldPos = kite.toWorldCoordinates(ctrlLeft);
   * ```
   */
  public toWorldCoordinates(localPos: THREE.Vector3): THREE.Vector3 {
    return localPos
      .clone()
      .applyQuaternion(this.quaternion)
      .add(this.position);
  }

  /**
   * Ajoute des marqueurs visuels aux points importants
   */
  private addVisualMarkers(): void {
    // Nez (point rouge)
    const nez = this.getPoint("NEZ");
    if (nez) {
      const marker = Primitive.sphere(0.025, "#ff0000");
      this.addPrimitiveAt(marker, [nez.x, nez.y, nez.z]);
    }

    // Points de contrôle
    const ctrlG = this.getPoint("CTRL_GAUCHE");
    if (ctrlG) {
      const marker = Primitive.sphere(0.025, "#dc143c");
      this.addPrimitiveAt(marker, [ctrlG.x, ctrlG.y, ctrlG.z]);
    }

    const ctrlD = this.getPoint("CTRL_DROIT");
    if (ctrlD) {
      const marker = Primitive.sphere(0.025, "#b22222");
      this.addPrimitiveAt(marker, [ctrlD.x, ctrlD.y, ctrlD.z]);
    }
  }

  // Implémentation de l'interface ICreatable
  create(): this {
    return this;
  }

  getName(): string {
    return "Cerf-volant Delta v2";
  }

  getDescription(): string {
    return "Cerf-volant delta construit avec les factories CAO";
  }

  getPrimitiveCount(): number {
    return 25; // Frame + surfaces + marqueurs
  }
}

/**
 * AVANTAGES de cette approche avec factories:
 *
 * 1. **Modularité** : Points, frames et surfaces sont gérés par des factories dédiées
 * 2. **Réutilisabilité** : Les factories peuvent être utilisées pour d'autres objets
 * 3. **Paramétrage** : Facile de modifier les paramètres de chaque composant
 * 4. **Composition** : On peut combiner différentes factories
 * 5. **Évolutivité** : Facile d'ajouter de nouvelles fonctionnalités aux factories
 *
 * UTILISATION DE POINTFACTORY:
 * - Tous les points sont définis dans une Map centralisée
 * - PointFactory crée un objet points réutilisable
 * - Pas de symétrie automatique : chaque point est défini explicitement
 * - Permet une gestion cohérente et validée des points anatomiques
 *
 * WORKFLOW CAO:
 * 1. PointFactory → Définir tous les points anatomiques
 * 2. FrameFactory → Construire la structure rigide
 * 3. SurfaceFactory → Ajouter les surfaces/toiles
 * 4. Assembly → Combiner le tout (futur)
 */


=== objects/Line.ts ===

/**
 * Line.ts - Entité métier représentant une ligne de cerf-volant
 *
 * Rôle :
 *   - Encapsule les propriétés physiques d'une ligne (Dyneema/Spectra)
 *   - Représente une ligne individuelle du système de pilotage
 *   - Pure data object, pas de logique de calcul
 *
 * Responsabilité :
 *   - Stocker les paramètres physiques (longueur, rigidité, tension)
 *   - Gérer les points d'attache (nom des points anatomiques)
 *   - Fournir un état cohérent pour les calculs physiques
 *
 * Relation avec les autres modules :
 *   - Utilisé par LinePhysics pour les calculs de force
 *   - Créé par LineFactory
 *   - Consommé par LineSystem (orchestration)
 *
 * Philosophie :
 *   - "Tell, don't ask" : La ligne expose son état, ne fait pas de calculs
 *   - Immutabilité partielle : Les paramètres physiques sont readonly
 *   - Single Responsibility : Représentation métier uniquement
 *
 * Voir aussi :
 *   - src/simulation/physics/LinePhysics.ts (calculs)
 *   - src/factories/LineFactory.ts (création)
 *   - src/objects/mechanical/LineVisual.ts (rendu)
 */


/**
 * Configuration physique d'une ligne de cerf-volant
 */
export interface LineConfig {
  /** Longueur au repos (mètres) */
  length: number;

  /** Rigidité axiale EA/L (N/m) - Typique Dyneema : 2200 N/m pour 15m */
  stiffness: number;

  /** Pré-tension minimale (N) - Toujours présente, même ligne molle */
  preTension: number;

  /** Tension maximale avant rupture (N) */
  maxTension: number;

  /** Coefficient d'amortissement interne (sans dimension, 0-1) */
  dampingCoeff: number;

  /** Masse linéique (kg/m) - Pour calcul caténaire */
  linearMassDensity: number;
}

/**
 * Points d'attache d'une ligne
 */
export interface LineAttachments {
  /** Nom du point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Nom du point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;
}

/**
 * Entité représentant une ligne de cerf-volant
 *
 * @example
 * ```typescript
 * const leftLine = new Line({
 *   length: 15,
 *   stiffness: 2200,
 *   preTension: 75,
 *   maxTension: 800,
 *   dampingCoeff: 0.05,
 *   linearMassDensity: 0.0005
 * }, {
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 * ```
 */
export class Line {
  /** Identifiant unique de la ligne */
  public readonly id: string;

  /** Configuration physique (immuable) */
  public readonly config: Readonly<LineConfig>;

  /** Points d'attache (immuables) */
  public readonly attachments: Readonly<LineAttachments>;

  /** État actuel de la ligne */
  private currentLength: number;
  private currentTension: number;

  /** Timestamp dernière mise à jour */
  private lastUpdateTime: number;

  constructor(
    config: LineConfig,
    attachments: LineAttachments,
    id?: string
  ) {
    this.id = id || `line_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = Object.freeze({ ...config });
    this.attachments = Object.freeze({ ...attachments });

    // État initial
    this.currentLength = config.length;
    this.currentTension = config.preTension;
    this.lastUpdateTime = 0;
  }

  /**
   * Met à jour l'état actuel de la ligne
   * (Appelé par LinePhysics après calcul)
   */
  updateState(length: number, tension: number, timestamp: number): void {
    this.currentLength = length;
    this.currentTension = tension;
    this.lastUpdateTime = timestamp;
  }

  /**
   * Obtient la longueur actuelle (étirée)
   */
  getCurrentLength(): number {
    return this.currentLength;
  }

  /**
   * Obtient la tension actuelle
   */
  getCurrentTension(): number {
    return this.currentTension;
  }

  /**
   * Calcule l'extension actuelle (Δx = L_current - L_rest)
   */
  getExtension(): number {
    return Math.max(0, this.currentLength - this.config.length);
  }

  /**
   * Vérifie si la ligne est tendue
   */
  isTaut(): boolean {
    return this.currentLength > this.config.length;
  }

  /**
   * Vérifie si la ligne est proche de la rupture
   */
  isNearBreaking(threshold: number = 0.9): boolean {
    return this.currentTension >= this.config.maxTension * threshold;
  }

  /**
   * Obtient le timestamp de dernière mise à jour
   */
  getLastUpdateTime(): number {
    return this.lastUpdateTime;
  }

  /**
   * Clone cette ligne avec une nouvelle configuration
   */
  clone(newConfig?: Partial<LineConfig>): Line {
    return new Line(
      { ...this.config, ...newConfig },
      { ...this.attachments }
    );
  }

  /**
   * Représentation textuelle pour debug
   */
  toString(): string {
    return `Line[${this.id}](${this.attachments.kitePoint} → ${this.attachments.barPoint}) ` +
           `L=${this.currentLength.toFixed(3)}m T=${this.currentTension.toFixed(1)}N`;
  }

  /**
   * Export JSON pour sérialisation
   */
  toJSON(): object {
    return {
      id: this.id,
      config: this.config,
      attachments: this.attachments,
      state: {
        currentLength: this.currentLength,
        currentTension: this.currentTension,
        lastUpdateTime: this.lastUpdateTime
      }
    };
  }

  /**
   * Crée une ligne depuis JSON
   */
  static fromJSON(data: any): Line {
    const line = new Line(data.config, data.attachments, data.id);
    if (data.state) {
      line.updateState(
        data.state.currentLength,
        data.state.currentTension,
        data.state.lastUpdateTime
      );
    }
    return line;
  }
}


=== simulation.ts ===

/**
 * Point d'entrée de compatibilité
 *
 * Ce fichier maintient la compatibilité avec l'ancien import
 * tout en redirigeant vers la nouvelle structure modulaire
 */

export { SimulationApp as Simulation } from './simulation/SimulationApp';

=== simulation/SimulationApp.ts ===

/**
 * SimulationApp.ts - Orchestrateur ECS pur
 *
 * Architecture ECS propre avec séparation des responsabilités.
 * Point d'entrée unique pour la simulation kite.
 */

import * as THREE from 'three';

import { Logger } from '../utils/Logging';

import {
  InputSystem,
  RenderSystem,
  KitePhysicsSystem,
  type InputConfig,
  type RenderConfig
} from './systems';
import { ControlBarSystem } from './systems/ControlBarSystem';
import { LinesRenderSystem } from './systems/LinesRenderSystem';
import { PilotSystem } from './systems/PilotSystem';
import {
  UIManager,
  type SimulationControls
} from './ui/UIManager';
import { DebugRenderer } from './rendering/DebugRenderer';
import { CONFIG } from './config/SimulationConfig';
import { EntityManager } from './entities/EntityManager';
import { TransformComponent, MeshComponent } from './components';
import { ControlBarEntityFactory, PilotEntityFactory, KiteEntityFactory } from './factories';

export interface SimulationConfig {
  targetFPS: number;
  maxFrameTime: number;
  enableDebug: boolean;
  enableRenderSystem: boolean;
  enableCompletePhysics: boolean;
  input: Partial<InputConfig>;
  render: Partial<RenderConfig>;
}

/**
 * Application principale de simulation
 * Architecture ECS avec responsabilité d'orchestration uniquement
 */
export class SimulationApp {
  private readonly logger: Logger;
  private config: SimulationConfig;

  // === GESTIONNAIRE D'ENTITÉS ===
  private entityManager!: EntityManager;

  // === SYSTÈMES ECS ===
  private inputSystem!: InputSystem;
  private renderSystem?: RenderSystem;
  private kitePhysicsSystem?: KitePhysicsSystem;
  private controlBarSystem!: ControlBarSystem;
  private linesRenderSystem!: LinesRenderSystem;
  private pilotSystem!: PilotSystem;

  // === ENTITÉS PRINCIPALES ===
  // Supprimées - utilisation exclusive d'EntityManager

  // === INTERFACE ===
  private uiManager?: UIManager;
  private debugRenderer?: DebugRenderer;
  private simulationControls!: SimulationControls;

  // === ÉTAT ===
  private isRunning = false;
  private isInitialized = false;
  private frameCount = 0;
  private totalTime = 0;
  private lastFrameTime = 0;

  constructor(config: Partial<SimulationConfig> = {}) {
    this.logger = Logger.getInstance();

    this.config = {
      targetFPS: 60,
      maxFrameTime: 1 / 30,
      enableDebug: true,
      enableRenderSystem: true,
      enableCompletePhysics: true,
      input: {},
      render: {},
      ...config
    };

    this.logger.info('SimulationApp created', 'SimulationApp');
  }

  /**
   * Initialise la simulation
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('Initializing simulation...', 'SimulationApp');

      // Créer le gestionnaire d'entités
      this.entityManager = new EntityManager();

      // Créer les systèmes
      await this.createSystems();

      // Créer les entités
      this.createEntities();

      // Initialiser les systèmes
      await this.initializeSystems();

      // Créer l'interface
      this.createInterface();

      // Configurer le rendu
      this.setupRendering();

      this.isInitialized = true;
      this.logger.info('✅ Simulation initialized', 'SimulationApp');

    } catch (error) {
      this.logger.error(`❌ Initialization failed: ${error}`, 'SimulationApp');
      throw error;
    }
  }

  /**
   * Crée tous les systèmes ECS
   */
  private async createSystems(): Promise<void> {
    this.inputSystem = new InputSystem(this.config.input);
    this.controlBarSystem = new ControlBarSystem();
    this.linesRenderSystem = new LinesRenderSystem();
    this.pilotSystem = new PilotSystem();

    if (this.config.enableRenderSystem) {
      this.renderSystem = new RenderSystem(this.config.render);
    }

    if (this.config.enableCompletePhysics) {
      // Position de la barre de contrôle calculée à partir du pilote
      const controlBarPosition = new THREE.Vector3(
        CONFIG.pilot.position.x,
        CONFIG.pilot.position.y + CONFIG.controlBar.offsetY,
        CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ
      );

      this.kitePhysicsSystem = new KitePhysicsSystem({
        windSpeed: CONFIG.wind.defaultSpeed,
        windDirection: CONFIG.wind.defaultDirection,
        turbulence: CONFIG.wind.defaultTurbulence,
        lineLength: CONFIG.lines.defaultLength,
        pilotPosition: controlBarPosition,
        enableConstraints: true,
        enableAerodynamics: true,
        enableGravity: true
      });
    }
  }

  /**
   * Crée les entités principales
   */
  private createEntities(): void {
    // Créer l'entité pilote EN PREMIER (pour que la barre puisse s'y attacher)
    this.createPilotEntity();

    // Créer l'entité kite
    this.createKiteEntity();

    // Créer les entités ECS
    this.createControlBarEntity();
    
    // Note: createLineEntities() est appelée dans setupRendering()
    // car elle nécessite que renderSystem.getScene() retourne une scène valide
    
    this.logger.debug('Entity positions after initialization:', 'SimulationApp');
    const pilotEntity = this.entityManager.getEntity('pilot');
    if (pilotEntity) {
      const pilotTransform = pilotEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Pilot position: ${pilotTransform?.position}`, 'SimulationApp');
    }

    const controlBarEntity = this.entityManager.getEntity('controlBar');
    if (controlBarEntity) {
      const barTransform = controlBarEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Control bar position: ${barTransform?.position}`, 'SimulationApp');
    }

    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteTransform = kiteEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Kite position: ${kiteTransform?.position}`, 'SimulationApp');
    }
  }

  /**
   * Crée l'entité ECS du kite
   */
  private createKiteEntity(): void {
    // Créer l'entité via factory (objet Kite + composants ECS)
    const kiteEntity = KiteEntityFactory.create();
    
    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(kiteEntity);

    // Note: Le kite sera ajouté à la scène dans setupRendering()
    // Ne pas ajouter ici pour éviter la duplication

    // Configurer le système de physique du kite
    if (this.kitePhysicsSystem) {
      // Extraire l'objet Kite du MeshComponent
      const kite = KiteEntityFactory.getKiteObject(kiteEntity);
      if (kite) {
        this.kitePhysicsSystem.setKite(kite);

        // Connecter le ControlBarSystem pour fournir les positions des poignées
        this.kitePhysicsSystem.setHandlesProvider({
          getHandlePositions: () => this.controlBarSystem.getHandlePositions()
        });
      }
    }
  }

  /**
   * Crée l'entité ECS de la barre de contrôle
   */
  private createControlBarEntity(): void {
    // Récupérer le pilote pour attachement
    const pilotEntity = this.entityManager.getEntity('pilot');
    const pilotMesh = pilotEntity?.getComponent<MeshComponent>('mesh');
    
    // Créer l'entité via factory (géométrie + composants ECS)
    const controlBarEntity = ControlBarEntityFactory.create({
      parentObject: pilotMesh?.object3D
    });
    
    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(controlBarEntity);
    
    // Configurer les systèmes
    this.controlBarSystem.setControlBarEntity(controlBarEntity);
    this.controlBarSystem.setInputSystem(this.inputSystem);
    
    // Initialiser la position de référence dans le système pilote
    const worldPosition = new THREE.Vector3();
    const controlBarMesh = controlBarEntity.getComponent<MeshComponent>('mesh');
    if (controlBarMesh) {
      controlBarMesh.object3D.getWorldPosition(worldPosition);
      this.pilotSystem.setControlBarPosition(worldPosition);
      this.logger.info('ControlBar attached as child of Pilot', 'SimulationApp');
    }
  }

  /**
   * Crée les entités ECS des lignes de contrôle
   */
  private createLineEntities(): void {
    if (!this.renderSystem) return;

    const scene = this.renderSystem.getScene();
    if (!scene) return;

    // Récupérer le kite depuis EntityManager
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kite = KiteEntityFactory.getKiteObject(kiteEntity);
      if (kite) {
        this.linesRenderSystem.setKite(kite);
      }
    }

    // Configurer le système
    this.linesRenderSystem.setControlBarSystem(this.controlBarSystem);

    // Connecter le système de physique pour la visualisation des tensions
    if (this.kitePhysicsSystem) {
      this.linesRenderSystem.setKitePhysicsSystem(this.kitePhysicsSystem);
    }

    // Créer les entités de lignes (elles sont gérées par LinesRenderSystem)
    this.linesRenderSystem.createLineEntity('leftLine', 'left', scene);
    this.linesRenderSystem.createLineEntity('rightLine', 'right', scene);
  }

  /**
   * Crée l'entité ECS du pilote
   */
  private createPilotEntity(): void {
    // Créer l'entité via factory
    const pilotEntity = PilotEntityFactory.create();

    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(pilotEntity);

    // Configurer le système pilote
    this.pilotSystem.setPilotEntity(pilotEntity);

    // Note: La position de la barre de contrôle sera initialisée dans createControlBarEntity()
    // après que la barre soit créée et attachée au pilote
  }



  /**
   * Initialise tous les systèmes
   */
  private async initializeSystems(): Promise<void> {
    const initPromises: Promise<void>[] = [
      this.inputSystem.initialize(),
      this.controlBarSystem.initialize(),
      this.linesRenderSystem.initialize(),
      this.pilotSystem.initialize()
    ];

    if (this.renderSystem) {
      initPromises.push(this.renderSystem.initialize());
    }

    if (this.kitePhysicsSystem) {
      initPromises.push(this.kitePhysicsSystem.initialize());
    }

    await Promise.all(initPromises);
  }

  /**
   * Crée l'interface utilisateur
   */
  private createInterface(): void {
    // L'interface nécessite le système de rendu
    if (!this.renderSystem) return;

    // Créer les contrôles
    this.simulationControls = this.createSimulationControls();

    // Créer le debug renderer (requis par UIManager) - passer physicsSystem
    this.debugRenderer = new DebugRenderer({
      addObject: (obj: THREE.Object3D) => this.renderSystem!.addToScene(obj),
      removeObject: (obj: THREE.Object3D) => this.renderSystem!.removeFromScene(obj),
      getScene: () => this.renderSystem!.getScene()
    }, this.kitePhysicsSystem);

    // Créer l'UI manager
    this.uiManager = new UIManager(
      this.simulationControls,
      this.debugRenderer,
      () => this.reset(),
      () => { this.isRunning ? this.stop() : this.start(); }
    );
  }

  /**
   * Configure le rendu
   */
  private setupRendering(): void {
    if (!this.renderSystem) {
      console.error('❌ RenderSystem is null');
      return;
    }

    const scene = this.renderSystem.getScene();
    if (!scene) {
      console.error('❌ Scene is null');
      return;
    }

    this.logger.info('Setting up rendering...', 'SimulationApp');

    // Créer les entités de lignes (nécessite que la scène soit initialisée)
    this.createLineEntities();

    // Ajouter le kite à la scène
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
      if (kiteMesh) {
        scene.add(kiteMesh.object3D);
        this.logger.info('Kite added to scene', 'SimulationApp');
      } else {
        this.logger.error('Kite mesh component not found', 'SimulationApp');
      }
    } else {
      this.logger.error('Kite entity not found', 'SimulationApp');
    }

    // Ajouter les entités ECS à la scène via leurs composants Mesh
    // Note: ControlBar n'est plus ajoutée directement car elle est enfant du Pilot
    const pilotEntity = this.entityManager.getEntity('pilot');
    if (pilotEntity) {
      const pilotMesh = pilotEntity.getComponent<MeshComponent>('mesh');
      if (pilotMesh) {
        scene.add(pilotMesh.object3D); // Ajoute le pilote ET sa barre de contrôle enfant
      }
    }

    // Démarrer le rendu
    this.renderSystem.startRendering();
  }

  /**
   * Crée les contrôles de simulation
   */
  private createSimulationControls(): SimulationControls {
    return {
      getBridleLengths: () => this.kitePhysicsSystem?.getBridleLengths() || { nez: 0.65, inter: 0.65, centre: 0.65 },
      setBridleLength: (type: "nez" | "inter" | "centre", length: number) => {
        if (this.kitePhysicsSystem) {
          const currentLengths = this.kitePhysicsSystem.getBridleLengths();
          this.kitePhysicsSystem.setBridleLengths({
            ...currentLengths,
            [type]: length
          });
        }
      },
      setLineLength: (length: number) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setLineLength(length);
        }
      },
      setWindParams: (params: { speed?: number; direction?: number; turbulence?: number }) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setWindParams(params);
        }
      },
      getForceSmoothing: () => this.kitePhysicsSystem?.getForceSmoothing() || 0.1,
      setForceSmoothing: (value: number) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setForceSmoothing(value);
        }
      },
      getKiteState: () => this.kitePhysicsSystem?.getKiteState() || {
        position: new THREE.Vector3(),
        velocity: new THREE.Vector3(),
        angularVelocity: new THREE.Vector3(),
        orientation: new THREE.Quaternion()
      },
      getWindState: () => {
        const windState = this.kitePhysicsSystem?.getWindState();
        return windState ? {
          baseSpeed: windState.baseSpeed,
          baseDirection: windState.baseDirection,
          turbulence: windState.turbulence
        } : {
          baseSpeed: 0,
          baseDirection: new THREE.Vector3(),
          turbulence: 0
        };
      },
      getLineLength: () => this.kitePhysicsSystem?.getLineSystem()?.lineLength || CONFIG.lines.defaultLength,
      getControlLineDiagnostics: () => {
        return this.kitePhysicsSystem?.getControlLineDiagnostics() || null;
      },
      getAerodynamicForces: () => {
        return this.kitePhysicsSystem?.getAerodynamicForces() || null;
      }
    };
  }

  /**
   * Démarre la simulation
   */
  start(): void {
    if (!this.isInitialized) {
      throw new Error('Simulation must be initialized first');
    }

    if (this.isRunning) return;

    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.logger.info('▶️ Simulation started', 'SimulationApp');

    // Mettre à jour le bouton UI
    this.uiManager?.updatePlayButton(true);

    this.updateLoop();
  }

  /**
   * Arrête la simulation
   */
  stop(): void {
    this.isRunning = false;
    this.logger.info('⏸️ Simulation stopped', 'SimulationApp');

    // Mettre à jour le bouton UI
    this.uiManager?.updatePlayButton(false);
  }

  /**
   * Réinitialise la simulation
   */
  reset(): void {
    this.logger.info('🔄 Resetting simulation...', 'SimulationApp');

    const wasRunning = this.isRunning;

    // Arrêter temporairement pour éviter les mises à jour pendant le reset
    if (this.isRunning) {
      this.isRunning = false;
    }

    // Reset systems
    this.inputSystem.reset();
    this.controlBarSystem.reset();
    this.kitePhysicsSystem?.reset();

    // Reset kite position avec calcul automatique de la position initiale
    const initialPos = KiteEntityFactory.calculateInitialPosition();
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteTransform = kiteEntity.getComponent<TransformComponent>('transform');
      const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
      if (kiteTransform && kiteMesh) {
        kiteTransform.position.copy(initialPos);
        kiteTransform.rotation = 0;
        kiteTransform.quaternion.identity();
        kiteMesh.syncToObject3D({
          position: kiteTransform.position,
          quaternion: kiteTransform.quaternion,
          scale: kiteTransform.scale
        });
      }
    }

    // Reset state
    this.frameCount = 0;
    this.totalTime = 0;
    this.lastFrameTime = performance.now();

    // Redémarrer si c'était en cours d'exécution
    if (wasRunning) {
      this.isRunning = true;
    }

    this.logger.info('✅ Simulation reset', 'SimulationApp');
  }

  /**
   * Boucle de mise à jour ECS
   */
  private updateLoop = (): void => {
    if (!this.isRunning) return;

    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, this.config.maxFrameTime);
    this.lastFrameTime = currentTime;

    this.totalTime += deltaTime;
    this.frameCount++;

    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: !this.isRunning,
      debugMode: this.config.enableDebug
    };

    try {
      // Mise à jour des systèmes dans l'ordre des priorités
      this.inputSystem.update(context);

      if (this.kitePhysicsSystem) {
        const inputState = this.inputSystem.getInputState();
        this.kitePhysicsSystem.setBarRotation(inputState.barPosition);
        this.kitePhysicsSystem.update(context);
      }

      // Mise à jour du système de barre de contrôle ECS
      // (La rotation est maintenant obtenue directement depuis InputSystem)
      this.controlBarSystem.update(context);

      // Mise à jour du système pilote
      this.pilotSystem.update(context);

      // Note: Synchronisation kite ECS effectuée directement via les systèmes
      // Plus besoin de référence temporaire au système legacy

      // Mise à jour du système de rendu des lignes
      this.linesRenderSystem.update(context);

      if (this.renderSystem) {
        this.renderSystem.update(context);
      }

      // Mise à jour UI
      this.uiManager?.updateDebugInfo();

      // Mise à jour des informations de debug avec les données ECS
      if (this.debugRenderer && this.kitePhysicsSystem) {
        this.debugRenderer.updateDebugDisplay(this.kitePhysicsSystem);
      }

      // Debug visualization avec ECS
      if (this.debugRenderer && this.kitePhysicsSystem && this.debugRenderer.isDebugMode()) {
        const kiteEntity = this.entityManager.getEntity('kite');
        if (kiteEntity) {
          const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
          if (kiteMesh && kiteMesh.object3D) {
            // Récupérer l'objet Kite depuis le MeshComponent
            const kite = KiteEntityFactory.getKiteObject(kiteEntity);
            if (kite) {
              this.debugRenderer.updateDebugVectors(kite, this.kitePhysicsSystem);
            }
          }
        }
      }

    } catch (error) {
      this.logger.error(`Update error: ${error}`, 'SimulationApp');
    }

    requestAnimationFrame(this.updateLoop);
  };







  /**
   * Nettoie les ressources
   */
  dispose(): void {
    this.logger.info('Disposing SimulationApp...', 'SimulationApp');

    this.stop();

    // Dispose systems
    this.inputSystem.dispose();
    this.controlBarSystem.dispose();
    this.renderSystem?.dispose();
    this.kitePhysicsSystem?.dispose();

    this.logger.info('✅ SimulationApp disposed', 'SimulationApp');
  }

  // === ACCESSEURS ===

  getSystems() {
    return {
      input: this.inputSystem,
      controlBar: this.controlBarSystem,
      render: this.renderSystem,
      kitePhysics: this.kitePhysicsSystem
    };
  }

  getConfig(): SimulationConfig {
    return { ...this.config };
  }

  getStats() {
    return {
      isRunning: this.isRunning,
      isInitialized: this.isInitialized,
      frameCount: this.frameCount,
      totalTime: this.totalTime,
      fps: this.frameCount / Math.max(this.totalTime, 0.001)
    };
  }

  isSimulationRunning(): boolean {
    return this.isRunning;
  }

  isSimulationInitialized(): boolean {
    return this.isInitialized;
  }
}

=== simulation/components/KiteComponent.ts ===

/**
 * KiteComponent.ts - Composant de données pour l'entité cerf-volant.
 *
 * Contient les données spécifiques à un cerf-volant qui ne sont pas couvertes
 * par les composants génériques comme TransformComponent ou PhysicsComponent.
 *
 * Inclut des informations sur la géométrie, les points de bridle, et l'état.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

// Importation des dépendances

export class KiteComponent implements Component {
  readonly type = 'kite';

  // Map des points anatomiques du cerf-volant en coordonnées locales.
  public points: Map<string, THREE.Vector3> = new Map();

  // Données sur les surfaces pour les calculs aérodynamiques.
  public surfaces: Array<{
    vertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];
    area: number;
    centroid: THREE.Vector3;
    normal?: THREE.Vector3;
  }> = [];

  // Constructeur pour initialiser les points et surfaces

  constructor(
    points: Map<string, THREE.Vector3>,
    surfaces: Array<{
      vertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];
      area: number;
      centroid: THREE.Vector3;
      normal?: THREE.Vector3;
    }> = []
  ) {
    this.points = new Map(
      Array.from(points.entries()).map(([name, position]) => [name, position.clone()])
    );
    this.surfaces = surfaces.map(({ vertices, area, centroid, normal }) => ({
      vertices: [vertices[0].clone(), vertices[1].clone(), vertices[2].clone()],
      area,
      centroid: centroid.clone(),
      normal: normal?.clone()
    }));
  }
}


=== simulation/components/MeshComponent.ts ===

/**
 * MeshComponent.ts - Composant de géométrie Three.js
 *
 * Contient la référence à un objet 3D Three.js (Mesh, Group, Line, etc.)
 * Utilisé pour le rendu visuel des entités.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

/**
 * Composant contenant un objet 3D Three.js
 */
export class MeshComponent implements Component {
  readonly type = 'mesh';

  public object3D: THREE.Object3D;
  public visible: boolean;
  public castShadow: boolean;
  public receiveShadow: boolean;

  constructor(
    object3D: THREE.Object3D,
    options: {
      visible?: boolean;
      castShadow?: boolean;
      receiveShadow?: boolean;
    } = {}
  ) {
    this.object3D = object3D;
    this.visible = options.visible !== undefined ? options.visible : true;
    this.castShadow = options.castShadow || false;
    this.receiveShadow = options.receiveShadow || false;

    // Appliquer les options
    this.object3D.visible = this.visible;
    this.object3D.castShadow = this.castShadow;
    this.object3D.receiveShadow = this.receiveShadow;
  }

  /**
   * Synchronise le composant avec l'objet 3D
   */
  syncToObject3D(transform: { position: THREE.Vector3; quaternion: THREE.Quaternion; scale: THREE.Vector3 }): void {
    this.object3D.position.copy(transform.position);
    this.object3D.quaternion.copy(transform.quaternion);
    this.object3D.scale.copy(transform.scale);
  }

  /**
   * Met à jour la visibilité
   */
  setVisible(visible: boolean): void {
    this.visible = visible;
    this.object3D.visible = visible;
  }

  /**
   * Dispose l'objet 3D (libère les ressources)
   */
  dispose(): void {
    this.object3D.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        if (child.material instanceof THREE.Material) {
          child.material.dispose();
        } else if (Array.isArray(child.material)) {
          child.material.forEach(mat => mat.dispose());
        }
      }
    });
  }
}


=== simulation/components/PhysicsComponent.ts ===

/**
 * PhysicsComponent.ts - Composant d'état physique
 *
 * Contient les données physiques d'une entité (vélocité, masse, forces, etc.)
 * Utilisé par les systèmes de physique pour calculer le mouvement.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

export interface PhysicsComponentData {
  velocity?: THREE.Vector3;
  angularVelocity?: THREE.Vector3;
  mass?: number;
  inertia?: number;
  damping?: number;
}

/**
 * Composant contenant l'état physique d'une entité
 */
export class PhysicsComponent implements Component {
  readonly type = 'physics';

  public velocity: THREE.Vector3;
  public angularVelocity: THREE.Vector3;
  public mass: number;
  public inertia: number;
  public damping: number;

  // Forces accumulées (reset à chaque frame)
  public forces: THREE.Vector3;
  public torques: THREE.Vector3;

  constructor(data: PhysicsComponentData = {}) {
    this.velocity = data.velocity?.clone() || new THREE.Vector3();
    this.angularVelocity = data.angularVelocity?.clone() || new THREE.Vector3();
    this.mass = data.mass || 1.0;
    this.inertia = data.inertia || 1.0;
    this.damping = data.damping || 0.0;

    this.forces = new THREE.Vector3();
    this.torques = new THREE.Vector3();
  }

  /**
   * Ajoute une force
   */
  addForce(force: THREE.Vector3): void {
    this.forces.add(force);
  }

  /**
   * Ajoute un couple (torque)
   */
  addTorque(torque: THREE.Vector3): void {
    this.torques.add(torque);
  }

  /**
   * Reset les forces accumulées
   */
  clearForces(): void {
    this.forces.set(0, 0, 0);
    this.torques.set(0, 0, 0);
  }

  /**
   * Clone le composant
   */
  clone(): PhysicsComponent {
    return new PhysicsComponent({
      velocity: this.velocity,
      angularVelocity: this.angularVelocity,
      mass: this.mass,
      inertia: this.inertia,
      damping: this.damping
    });
  }
}


=== simulation/components/TransformComponent.ts ===

/**
 * TransformComponent.ts - Composant de transformation spatiale
 *
 * Contient les données de position, rotation et échelle d'une entité.
 * Utilisé par tous les objets 3D de la simulation.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

export interface TransformComponentData {
  position?: THREE.Vector3;
  rotation?: number;  // Rotation autour de Y (en radians)
  quaternion?: THREE.Quaternion;
  scale?: THREE.Vector3;
}

/**
 * Composant contenant la transformation spatiale d'une entité
 */
export class TransformComponent implements Component {
  readonly type = 'transform';

  public position: THREE.Vector3;
  public rotation: number;
  public quaternion: THREE.Quaternion;
  public scale: THREE.Vector3;

  constructor(data: TransformComponentData = {}) {
    this.position = data.position?.clone() || new THREE.Vector3();
    this.rotation = data.rotation || 0;
    this.quaternion = data.quaternion?.clone() || new THREE.Quaternion();
    this.scale = data.scale?.clone() || new THREE.Vector3(1, 1, 1);
  }

  /**
   * Synchronise le quaternion avec la rotation
   */
  syncQuaternionFromRotation(): void {
    this.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
  }

  /**
   * Synchronise la rotation avec le quaternion
   */
  syncRotationFromQuaternion(): void {
    const euler = new THREE.Euler().setFromQuaternion(this.quaternion, 'XYZ');
    this.rotation = euler.y;
  }

  /**
   * Clone le composant
   */
  clone(): TransformComponent {
    return new TransformComponent({
      position: this.position,
      rotation: this.rotation,
      quaternion: this.quaternion,
      scale: this.scale
    });
  }
}


=== simulation/components/index.ts ===

/**
 * Exports for all ECS components
 */

export { TransformComponent } from './TransformComponent';
export type { TransformComponentData } from './TransformComponent';

export { MeshComponent } from './MeshComponent';

export { PhysicsComponent } from './PhysicsComponent';
export type { PhysicsComponentData } from './PhysicsComponent';

export { KiteComponent } from './KiteComponent';


=== simulation/config/KiteGeometry.ts ===

/**
 * KiteGeometry.ts - Définition de la géométrie du cerf-volant pour la simulation Kite
 *
 * Rôle :
 *   - Définit la forme, les points anatomiques et les surfaces du cerf-volant
 *   - Sert de plan de construction pour tous les calculs physiques et graphiques
 *   - Utilisé pour le calcul des forces, la création du modèle 3D et la configuration
 *
 * Dépendances principales :
 *   - Three.js : Utilisé pour les coordonnées et la géométrie
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise KiteGeometry pour la surface et les points
 *   - Tous les modules physiques et graphiques utilisent KiteGeometry pour les calculs
 *
 * Utilisation typique :
 *   - Importé dans les modules de physique, de rendu et de configuration
 *   - Sert à positionner les points et surfaces du kite
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

/**
 * Géométrie du cerf-volant
 *
 * La forme du cerf-volant - comme un plan de construction
 * On définit où sont tous les points importants du cerf-volant
 */
export class KiteGeometry {
  // Les points clés du cerf-volant (comme les coins d'une maison)
  // Coordonnées en mètres : [gauche/droite, haut/bas, avant/arrière]
  static readonly POINTS = {
    NEZ: new THREE.Vector3(0, 0.65, 0), // Le bout pointu en haut
    SPINE_BAS: new THREE.Vector3(0, 0, 0), // Le centre en bas
    BORD_GAUCHE: new THREE.Vector3(-0.825, 0, 0), // L'extrémité de l'aile gauche
    BORD_DROIT: new THREE.Vector3(0.825, 0, 0), // L'extrémité de l'aile droite
    WHISKER_GAUCHE: new THREE.Vector3(-0.4125, 0.1, -0.15), // Stabilisateur gauche (légèrement en arrière)
    WHISKER_DROIT: new THREE.Vector3(0.4125, 0.1, -0.15), // Stabilisateur droit (légèrement en arrière)
    CTRL_GAUCHE: new THREE.Vector3(-0.15, 0.3, -0.2), // Où s'attache la ligne gauche
    CTRL_DROIT: new THREE.Vector3(0.15, 0.3, -0.2), // Où s'attache la ligne droite
  };

  /**
   * Calcule l'aire d'un triangle 3D à partir de ses 3 sommets
   * Utilise la formule : Aire = 0.5 × ||AB × AC||
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxième sommet du triangle
   * @param v3 Troisième sommet du triangle
   * @returns L'aire du triangle en m²
   */
  private static calculateTriangleArea(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): number {
    // Créer deux vecteurs représentant deux côtés du triangle
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    
    // Le produit vectoriel donne un vecteur perpendiculaire
    // dont la longueur = aire du parallélogramme formé par edge1 et edge2
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    
    // L'aire du triangle = la moitié de l'aire du parallélogramme
    return cross.length() / 2;
  }

  /**
   * Calcule le centroïde (centre géométrique) d'un triangle
   * Le centroïde est situé à l'intersection des médianes du triangle
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxième sommet du triangle  
   * @param v3 Troisième sommet du triangle
   * @returns Le point centroïde du triangle
   */
  static calculateTriangleCentroid(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): THREE.Vector3 {
    return v1.clone()
      .add(v2)
      .add(v3)
      .divideScalar(3);
  }

  // Le cerf-volant est fait de 4 triangles de tissu
  // Chaque triangle a 3 coins (vertices) et une surface en mètres carrés
  //
  // ORDRE DES VERTICES (règle main droite) :
  // Les normales doivent pointer vers l'ARRIÈRE (Z positif) pour recevoir le vent
  // qui vient de l'arrière (direction -Z).
  // Order : sens horaire vu de l'arrière = normale vers l'arrière
  //
  // NOTE : Les aires sont calculées automatiquement à partir de la géométrie réelle
  // pour garantir la cohérence physique
  //
  // NOTE : Les masses sont calculées après, voir SURFACES_WITH_MASS ci-dessous
  static readonly SURFACES = [
    {
      // Surface haute gauche (normale doit pointer vers arrière)
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE
      ),
    },
    {
      // Surface basse gauche
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS
      ),
    },
    {
      // Surface haute droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT
      ),
    },
    {
      // Surface basse droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT
      ),
    },
  ];

  /**
   * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
   * @param v1, v2, v3 : sommets du triangle
   * @returns Tableau de 4 sous-triangles {vertices, area}
   */
  private static subdivideTriangle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3) {
    // Calcul des milieux
    const m12 = v1.clone().add(v2).multiplyScalar(0.5);
    const m23 = v2.clone().add(v3).multiplyScalar(0.5);
    const m31 = v3.clone().add(v1).multiplyScalar(0.5);

    // 4 sous-triangles
    const tris = [
      { vertices: [v1, m12, m31] },
      { vertices: [v2, m23, m12] },
      { vertices: [v3, m31, m23] },
      { vertices: [m12, m23, m31] },
    ];
    // Ajoute l'aire à chaque sous-triangle
    return tris.map(t => ({
      vertices: t.vertices,
      area: KiteGeometry.calculateTriangleArea(t.vertices[0], t.vertices[1], t.vertices[2])
    }));
  }

  /**
   * Subdivise récursivement un triangle selon un niveau donné
   * @param v1, v2, v3 : sommets du triangle
   * @param level : niveau de subdivision (0 = pas de subdivision)
   * @returns Tableau de tous les sous-triangles
   */
  private static subdivideTriangleRecursive(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3,
    level: number
  ): { vertices: THREE.Vector3[]; area: number }[] {
    if (level <= 0) {
      // Pas de subdivision : retourner le triangle original
      return [{
        vertices: [v1, v2, v3],
        area: KiteGeometry.calculateTriangleArea(v1, v2, v3)
      }];
    }

    // Subdiviser en 4 sous-triangles
    const subTriangles = KiteGeometry.subdivideTriangle(v1, v2, v3);

    // Appliquer récursivement la subdivision à chaque sous-triangle
    const result: { vertices: THREE.Vector3[]; area: number }[] = [];
    for (const subTri of subTriangles) {
      const [sv1, sv2, sv3] = subTri.vertices;
      result.push(...KiteGeometry.subdivideTriangleRecursive(sv1, sv2, sv3, level - 1));
    }

    return result;
  }

  /**
   * Subdivision du maillage pour améliorer la précision aérodynamique.
   *
   * POURQUOI LA SUBDIVISION :
   * - Un triangle unique ne peut avoir qu'une seule normale → angle d'attaque uniforme
   * - Avec subdivision, chaque sous-triangle peut avoir un angle d'attaque local différent
   * - Permet de capturer les variations spatiales du vent et de la courbure virtuelle
   * - Améliore le réalisme des couples aérodynamiques distribués
   *
   * COÛT PERFORMANCE :
   * - Niveau 0 : 4 triangles (rapide, peu précis)
   * - Niveau 1 : 16 triangles (bon compromis)
   * - Niveau 2 : 64 triangles (précis, coût modéré) ← recommandé
   * - Niveau 3 : 256 triangles (très précis, coûteux)
   * - Niveau 4+ : 1024+ triangles (impact performance significatif)
   */

  /**
   * Niveau de subdivision actuel du maillage
   * Par défaut niveau 1 (16 triangles), peut être changé via setMeshSubdivisionLevel()
   */
  private static meshSubdivisionLevel: number = 1; // Niveau par défaut, sera initialisé depuis CONFIG dans SimulationApp

  /**
   * Cache typé des surfaces subdivisées
   */
  private static _subdividedSurfaces: { vertices: THREE.Vector3[]; area: number }[] | null = null;

  /**
   * Constantes pour la subdivision
   */
  private static readonly MAX_SUBDIVISION_LEVEL = 3; // Limite raisonnable pour éviter surcharge

  /**
   * Calcule le nombre de triangles par surface originale pour un niveau donné
   * Formule : 4^niveau (car chaque subdivision découpe en 4)
   *
   * @param level - Niveau de subdivision (0, 1, 2, 3...)
   * @returns Nombre de sous-triangles par surface originale
   *
   * @example
   * TRIANGLES_PER_SURFACE_AT_LEVEL(0) → 1 triangle
   * TRIANGLES_PER_SURFACE_AT_LEVEL(1) → 4 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(2) → 16 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(3) → 64 triangles
   */
  static TRIANGLES_PER_SURFACE_AT_LEVEL(level: number): number {
    return Math.pow(4, level);
  }

  /**
   * Modifie le niveau de subdivision du maillage
   *
   * @param level - Niveau de subdivision (0=4 triangles, 1=16, 2=64, 3=256)
   *
   * IMPORTANT : Des niveaux élevés (>3) peuvent causer des problèmes de performance.
   * Le niveau est automatiquement limité à MAX_SUBDIVISION_LEVEL (3).
   */
  static setMeshSubdivisionLevel(level: number): void {
    // Clamper entre 0 et MAX
    const clampedLevel = Math.max(0, Math.min(level, KiteGeometry.MAX_SUBDIVISION_LEVEL));

    // Warning si niveau trop élevé
    if (level > KiteGeometry.MAX_SUBDIVISION_LEVEL) {
      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(level);
      console.warn(
        `⚠️ Niveau de subdivision ${level} trop élevé (${totalTriangles} triangles).\n` +
        `Limité à ${KiteGeometry.MAX_SUBDIVISION_LEVEL} pour éviter surcharge performance.\n` +
        `Si vous avez vraiment besoin de plus, augmentez MAX_SUBDIVISION_LEVEL.`
      );
    }

    if (clampedLevel !== KiteGeometry.meshSubdivisionLevel) {
      KiteGeometry.meshSubdivisionLevel = clampedLevel;
      // Invalider le cache des surfaces subdivisées
      KiteGeometry._subdividedSurfaces = null;

      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(clampedLevel);
      console.log(`🔧 Maillage subdivisé : niveau ${clampedLevel} → ${totalTriangles} triangles au total`);
    }
  }

  /**
   * Retourne le niveau de subdivision actuel du maillage
   */
  static getMeshSubdivisionLevel(): number {
    return KiteGeometry.meshSubdivisionLevel;
  }

  /**
   * Maillage fin : tous les sous-triangles du kite selon le niveau de subdivision configuré
   *
   * CACHE : Les surfaces sont calculées une seule fois puis mises en cache.
   * Le cache est invalidé automatiquement quand le niveau change.
   *
   * @returns Tableau de tous les sous-triangles avec leurs vertices et aires
   */
  static get SUBDIVIDED_SURFACES(): { vertices: THREE.Vector3[]; area: number }[] {
    if (!KiteGeometry._subdividedSurfaces) {
      KiteGeometry._subdividedSurfaces = KiteGeometry.SURFACES.flatMap(surface =>
        KiteGeometry.subdivideTriangleRecursive(
          surface.vertices[0],
          surface.vertices[1],
          surface.vertices[2],
          KiteGeometry.meshSubdivisionLevel
        )
      );
    }
    return KiteGeometry._subdividedSurfaces;
  }

  // Calcul automatique de la surface totale
  static readonly TOTAL_AREA = KiteGeometry.SURFACES.reduce(
    (sum, surface) => sum + surface.area,
    0
  );  // ============================================================================
  // CALCUL AUTOMATIQUE DE LA MASSE DU CERF-VOLANT
  // ============================================================================

  /**
   * Spécifications des matériaux utilisés pour calculer la masse
   * Basé sur des composants réels de kites sport/stunt
   *
   * CORRECTION: Grammages augmentés pour atteindre masse réaliste de 0.3-0.4 kg
   * (Précédente masse calculée de ~0.153 kg était ×2.5 trop légère)
   */
  private static readonly MATERIAL_SPECS = {
    // Tubes de carbone (masse linéique en g/m)
    carbon: {
      spine: 10,        // 5mm diamètre renforcé (corrigé de 10)
      leadingEdge: 10,  // 5mm diamètre standard (corrigé de 10)
      strut: 4,         // 4mm diamètre léger (corrigé de 2)
    },
    // Tissu (grammage en g/m²)
    fabric: {
      ripstop: 40,     // Ripstop nylon standard (corrigé de 40)
    },
    // Accessoires (masse en grammes)
    accessories: {
      connectorsLeadingEdge: 1,  // Connecteurs pour les bords d'attaque
      connectorCenterT: 1,       // Connecteur central en T
      connectorsStruts: 1,       // Connecteurs pour les struts
      bridleSystem: 1,          // Système de brides complet
      reinforcements: 1,        // Renforts et coutures
    },
  };

  /**
   * Calcule la longueur totale de tous les tubes de la frame
   * @returns Objet contenant les longueurs par type de tube et le total
   */
  private static calculateFrameLengths(): {
    spine: number;
    leadingEdges: number;
    struts: number;
    total: number;
  } {
    const spine = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.SPINE_BAS
    );

    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_GAUCHE
    );
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_DROIT
    );
    const leadingEdges = leadingEdgeLeft + leadingEdgeRight;

    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_GAUCHE
    );
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const struts = strutLeft + strutRight + spreader;

    return {
      spine,
      leadingEdges,
      struts,
      total: spine + leadingEdges + struts,
    };
  }

  /**
   * Calcule la masse de la structure (frame) en carbone
   * @returns Masse en kilogrammes
   */
  private static calculateFrameMass(): number {
    const lengths = KiteGeometry.calculateFrameLengths();
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;

    const spineMass = lengths.spine * specs.spine;
    const leadingEdgesMass = lengths.leadingEdges * specs.leadingEdge;
    const strutsMass = lengths.struts * specs.strut;

    // Somme en grammes, conversion en kg
    return (spineMass + leadingEdgesMass + strutsMass) / 1000;
  }

  /**
   * Calcule la masse du tissu (voile)
   * @returns Masse en kilogrammes
   */
  private static calculateFabricMass(): number {
    const grammage = KiteGeometry.MATERIAL_SPECS.fabric.ripstop;
    // Surface en m² × grammage en g/m² → conversion en kg
    return (KiteGeometry.TOTAL_AREA * grammage) / 1000;
  }

  /**
   * Calcule la masse totale des accessoires
   * @returns Masse en kilogrammes
   */
  private static calculateAccessoriesMass(): number {
    const acc = KiteGeometry.MATERIAL_SPECS.accessories;
    const total =
      acc.connectorsLeadingEdge +
      acc.connectorCenterT +
      acc.connectorsStruts +
      acc.bridleSystem +
      acc.reinforcements;

    // Conversion g → kg
    return total / 1000;
  }

  /**
   * Calcule la masse totale du cerf-volant (frame + tissu + accessoires)
   * Calculée automatiquement depuis la géométrie et les spécifications matériaux
   * @returns Masse en kilogrammes
   */
  static calculateTotalMass(): number {
    return (
      KiteGeometry.calculateFrameMass() +
      KiteGeometry.calculateFabricMass() +
      KiteGeometry.calculateAccessoriesMass()
    );
  }

  /**
   * Masse totale du cerf-volant calculée automatiquement
   * Basée sur la géométrie réelle et les matériaux standards
   */
  static readonly TOTAL_MASS = KiteGeometry.calculateTotalMass();

  /**
   * 🔴 BUG FIX #2 : Distribution masse frame selon géométrie RÉELLE
   * 
   * Topologie du kite (4 surfaces triangulaires) :
   *   Surface 0 (haute gauche)  : NEZ → BORD_GAUCHE → WHISKER_GAUCHE
   *   Surface 1 (basse gauche)  : NEZ → WHISKER_GAUCHE → SPINE_BAS
   *   Surface 2 (haute droite)  : NEZ → BORD_DROIT → WHISKER_DROIT
   *   Surface 3 (basse droite)  : NEZ → WHISKER_DROIT → SPINE_BAS
   * 
   * Attribution des segments de frame aux surfaces :
   *   - Spine (NEZ → SPINE_BAS) : partagée 50/50 entre hautes et basses
   *   - Leading edge gauche (NEZ → BORD_GAUCHE) : 100% surface 0
   *   - Leading edge droit (NEZ → BORD_DROIT) : 100% surface 2
   *   - Strut gauche (BORD_GAUCHE → WHISKER_GAUCHE) : partagé surface 0/1
   *   - Strut droit (BORD_DROIT → WHISKER_DROIT) : partagé surface 2/3
   *   - Spreader (WHISKER_GAUCHE → WHISKER_DROIT) : partagé entre toutes
   * 
   * @returns Tableau de 4 masses (kg) pour chaque surface
   */
  private static calculateFrameMassDistribution(): number[] {
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;
    
    // Masses linéiques (kg/m)
    const spineUnitMass = specs.spine / 1000;        // g/m → kg/m
    const leadingEdgeUnitMass = specs.leadingEdge / 1000;
    const strutUnitMass = specs.strut / 1000;
    
    // Longueurs individuelles des segments
    const spineLength = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.SPINE_BAS);
    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_GAUCHE);
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_DROIT);
    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_GAUCHE);
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    /**
     * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
     * @param v1, v2, v3 : sommets du triangle
     * @returns Tableau de 4 sous-triangles {vertices, area}
     */

    // Masses individuelles des segments
    const spineMass = spineLength * spineUnitMass;
    const leadingEdgeLeftMass = leadingEdgeLeft * leadingEdgeUnitMass;
    const leadingEdgeRightMass = leadingEdgeRight * leadingEdgeUnitMass;
    const strutLeftMass = strutLeft * strutUnitMass;
    const strutRightMass = strutRight * strutUnitMass;
    const spreaderMass = spreader * strutUnitMass;
    
    // Attribution géométrique réaliste aux surfaces
    const frameMasses = [
      // Surface 0 (haute gauche) : spine + leading edge gauche + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      leadingEdgeLeftMass +         // 100% leading edge gauche
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 1 (basse gauche) : spine + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 2 (haute droite) : spine + leading edge droit + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      leadingEdgeRightMass +        // 100% leading edge droit
      (strutRightMass * 0.5) +      // 50% strut droit (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)

      // Surface 3 (basse droite) : spine + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      (strutRightMass * 0.5) +      // 50% strut droit (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)
    ];
    
    return frameMasses;
  }

  /**
   * Distribution de la masse sur les surfaces
   * Chaque surface porte une fraction de la masse totale
   * 
   * Modèle physique CORRIGÉ :
   * - Masse de tissu (fabric) : Distribuée proportionnellement à l'aire
   * - Masse de frame : Distribuée selon géométrie réelle (🔴 BUG FIX #2)
   * - Masse d'accessoires : Distribuée uniformément sur les 4 surfaces
   * 
   * @returns Masse de chaque surface en kg
   */
  static calculateSurfaceMasses(): number[] {
    const fabricMass = KiteGeometry.calculateFabricMass();
    const frameMasses = KiteGeometry.calculateFrameMassDistribution();  // 🔴 BUG FIX #2
    const accessoriesMass = KiteGeometry.calculateAccessoriesMass();
    
    // Accessoires répartis uniformément (connecteurs dispersés sur tout le kite)
    const uniformAccessories = accessoriesMass / KiteGeometry.SURFACES.length;
    
    // La masse de tissu est répartie proportionnellement à l'aire
    return KiteGeometry.SURFACES.map((surface, index) => {
      const fabricMassRatio = surface.area / KiteGeometry.TOTAL_AREA;
      const surfaceFabricMass = fabricMass * fabricMassRatio;
      
      return surfaceFabricMass + frameMasses[index] + uniformAccessories;
    });
  }

  /**
   * Masses précalculées pour chaque surface (en kg)
   * Index correspond à l'index dans SURFACES
   */
  static readonly SURFACE_MASSES = KiteGeometry.calculateSurfaceMasses();

  /**
   * Surfaces enrichies avec leur masse individuelle
   * Utilisées par AerodynamicsCalculator pour appliquer la gravité distribuée
   */
  static readonly SURFACES_WITH_MASS = KiteGeometry.SURFACES.map((surface, index) => ({
    ...surface,
    mass: KiteGeometry.SURFACE_MASSES[index],
  }));

  /**
   * Calcule le moment d'inertie approximatif du cerf-volant
   * Utilise la formule simplifiée : I ≈ m × r²
   * où r est le rayon de giration moyen
   * @returns Moment d'inertie en kg·m²
   */
  static calculateInertia(): number {
    // Constantes pour calcul d'inertie (éviter dépendance circulaire avec CONFIG)
    const GYRATION_DIVISOR = Math.sqrt(2); // wingspan / √2 pour forme delta (triangle isocèle)

    // Rayon de giration correct pour forme delta wing
    // Formule réaliste : r = wingspan / √2 (au lieu de /4)
    // Référence : géométrie d'un triangle isocèle
    const wingspan =
      KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
        KiteGeometry.POINTS.BORD_DROIT
      );
    const radiusOfGyration = wingspan / GYRATION_DIVISOR;  // ≈ 1.167 m au lieu de 0.4125 m

    const physicalInertia = KiteGeometry.TOTAL_MASS * radiusOfGyration * radiusOfGyration;

    // 🔧 FIX INERTIE: Factor 0.1 pour réactivité immédiate au vent
    // Le kite doit être "emporté" par le vent, pas résister par inertie
    // Factor 0.1 ramène à ~0.042 kg·m² (très réactif, comme un tissu léger)
    const REACTIVE_INERTIA_FACTOR = 0.1;
    return physicalInertia * REACTIVE_INERTIA_FACTOR;
  }

  /**
   * Moment d'inertie calculé automatiquement
   */
  static readonly INERTIA = KiteGeometry.calculateInertia();
}


=== simulation/config/PhysicsConstants.ts ===

/**
 * PhysicsConstants.ts - Constantes physiques globales pour la simulation Kite
 *
 * Rôle :
 *   - Définit les limites physiques, tolérances et facteurs de sécurité du monde virtuel
 *   - Sert à garantir la stabilité et la cohérence de la simulation
 *   - Utilisé pour éviter les comportements irréalistes ou dangereux
 *
 * Dépendances principales :
 *   - Aucun import direct, mais utilisé par tous les modules physiques et de configuration
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise PhysicsConstants pour fixer les limites
 *   - Tous les modules du projet importent PhysicsConstants pour les vérifications
 *
 * Utilisation typique :
 *   - Importé dans les modules de physique, de contrôle et de rendu
 *   - Sert à valider les valeurs et à limiter les extrêmes
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
export class PhysicsConstants {
  // Tolérances numériques
  static readonly EPSILON = 1e-4; // Sans unité - Seuil pour "presque zéro" (comparaisons flottants)
  static readonly EPSILON_FINE = 1e-6; // Sans unité - Seuil fin pour calculs précis (LinePhysics)

  // Contrôles et contraintes
  static readonly CONTROL_DEADZONE = 0.01; // rad - Zone morte pour input barre de contrôle
  static readonly LINE_CONSTRAINT_TOLERANCE = 0.0005; // m - Tolérance contraintes lignes (0.5mm)
  static readonly LINE_TENSION_FACTOR = 0.99; // Sans unité - Facteur tension lignes (99% = légèrement tendues)
  static readonly CONSTRAINT_ITERATIONS = 2; // Sans unité - Nombre d'itérations pour convergence PBD

  // Sol et friction
  static readonly GROUND_FRICTION = 0.95; // Sans unité - Facteur friction sol (5% perte vitesse)

  // Rendu caténaire
  static readonly CATENARY_SEGMENTS = 10; // Sans unité - Nombre segments pour courbe caténaire

  // Limites de sécurité physique (éviter explosions numériques)
  static readonly MAX_FORCE = 1000; // N - Force maximale (équivalent ~100kg)
  static readonly MAX_VELOCITY = 30; // m/s - Vitesse maximale kite (108 km/h)
  static readonly MAX_ANGULAR_VELOCITY = 15; // rad/s - Limite élevée pour permettre convergence naturelle
  static readonly MAX_ACCELERATION = 100; // m/s² - Accélération maximale (~10G)
  static readonly MAX_ANGULAR_ACCELERATION = 5; // rad/s² - Accélération angulaire réaliste
}

=== simulation/config/SimulationConfig.ts ===

/**
 * SimulationConfig.ts - Configuration centralisée de la simulation Kite
 * Rôle :
 *   - Définit tous les paramètres physiques, aérodynamiques, géométriques et environnementaux
 *   - Sert de source unique de vérité pour les réglages du monde virtuel
 *   - Permet d'ajuster le comportement du kite, du vent, des lignes, etc.
 *
 * Dépendances principales :
 *   - KiteGeometry.ts : Utilisé pour la surface et les points du kite
 *   - Utilisé par tous les modules physiques et de rendu
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsConstants.ts : Définit les limites et tolérances physiques
 *   - KiteGeometry.ts : Définit la géométrie du kite
 *   - Tous les modules du projet importent SimulationConfig pour accéder aux paramètres
 *
  pilot: PILOT_CONFIG, // Utilise la configuration centralisée du pilote
  controlBar: {
    offsetY: 1.1, // Hauteur réaliste des mains
    offsetZ: 0.7, // Distance devant le pilote
    width: 0.6,   // Largeur de la barre
    handleOffset: 0.25, // Distance des poignées par rapport au centre
  },
 * Utilisation typique :
 *   - Importé dans tous les modules pour accéder aux réglages
 *   - Sert à personnaliser la simulation (test, debug, tuning)
 *
 * Voir aussi :
 *   - src/simulation/config/PhysicsConstants.ts
 *   - src/simulation/config/KiteGeometry.ts
 */
import * as THREE from "three";

import { KiteGeometry } from "./KiteGeometry";

/**
 * Configuration centralisée de la simulation Kite
 *
 * Source unique de vérité pour tous les paramètres physiques, aérodynamiques,
 * géométriques et environnementaux du simulateur.
 */

// Configuration des propriétés du pilote (origine du système)
export const PILOT_CONFIG = {
  width: 0.4, // m - Largeur du corps du pilote
  height: 1.6, // m - Hauteur du corps du pilote
  depth: 0.3, // m - Profondeur du corps du pilote
  position: new THREE.Vector3(0, 0, 0), // Position du pilote - origine du système de coordonnées
};

// Configuration de la barre de contrôle
export const CONTROL_BAR_CONFIG = {
  width: 0.6, // m - Largeur de la barre
  offsetY: 1.2, // m - Hauteur de la barre par rapport au pilote (au niveau des mains)
  offsetZ: -0.5, // m - Décalage en z (devant le pilote en z négatif)
  barRadius: 0.02, // m - Rayon du cylindre de la barre
  barRotation: Math.PI / 2, // rad - Rotation pour orientation horizontale
  handleRadius: 0.03, // m - Rayon des poignées
  handleLength: 0.15, // m - Longueur des poignées
};

/**
 * Configuration épurée de la simulation
 *
 * Les réglages de notre monde virtuel - comme les règles d'un jeu
 * Vous pouvez changer ces valeurs pour voir comment le cerf-volant réagit
 */
export const CONFIG = {
  physics: {
    gravity: 9.81, // La gravité terrestre (fait tomber les objets)
    airDensity: 1.225, // Densité de l'air (l'air épais pousse plus fort)
    deltaTimeMax: 0.016, // Mise à jour max 60 fois par seconde (pour rester fluide)
    controlDeadzone: 0.1, // m - Petite zone de tolérance pour la tension des lignes
    // Amortissement réaliste pour un cerf-volant
    linearDampingCoeff: 1.5, // Amortissement linéaire modéré pour stabilité
    angularDragFactor: 1.5, // Amortissement angulaire pour éviter les oscillations
  },
  aero: {
    // Forces aérodynamiques réalistes pour un cerf-volant delta
    liftScale: 4.5, // Portance réaliste pour un kite de cette taille
    dragScale: 1.8, // Traînée modérée mais présente
    // Amortissement aérodynamique anisotrope (couple) par axe
    damping: {
      enabled: false,
      roll: 0.015,   // autour de X (roulis)
      pitch: 0.020,  // autour de Y (tangage)
      yaw: 0.012,    // autour de Z (lacet)
      windSpeedFactor: 1.0, // multiplie avec |vent| en m/s
      maxMagnitude: 10.0,   // N·m - clamp de sécurité
    },
  },
  kite: {
    // Masse et inertie calculées AUTOMATIQUEMENT depuis la géométrie
    // Basées sur:
    // - Frame carbone (spine 5mm, leading edges 5mm, struts 4mm)
    // - Tissu ripstop nylon 120 g/m² (corrigé pour atteindre masse réaliste)
    // - Accessoires (connecteurs, bridage, renforts)
    // Voir KiteGeometry.calculateTotalMass() pour les détails
    mass: KiteGeometry.TOTAL_MASS, // kg - Calculée automatiquement (~0.31 kg après correction)
    area: KiteGeometry.TOTAL_AREA, // m² - Surface totale (calculée automatiquement)
    inertia: KiteGeometry.INERTIA, // kg·m² - Moment d'inertie (I ≈ m·r², calculé automatiquement)
    minHeight: 0, // m - Altitude minimale (plus haut pour éviter le sol)
    // 🔧 MAILLAGE FIN PARAMÉTRABLE (défaut = niveau 1 = 16 triangles)
    defaultMeshSubdivisionLevel: 0, // Niveau par défaut (0=4, 1=16, 2=64, 3=256 triangles)
  },
  bridle: {
    defaultLengths: Object.freeze({
      nez: 0.80,
      inter: 0.65,
      centre: 0.65,
    }),
  },
  lines: {
    defaultLength: 15, // m - Longueur réaliste pour cerf-volant sport
    stiffness: 2500, // N/m - Rigidité réaliste pour lignes Dyneema
    preTension: 80, // N - Pré-tension réaliste
    maxTension: 1200, // N - Tension max avant rupture
    dampingCoeff: 0.08, // Coefficient d'amortissement réaliste
    linearMassDensity: 0.0006, // kg/m - Masse linéique réaliste
  },
  wind: {
    defaultSpeed: 20, // km/h - Vitesse idéale pour cerf-volant sport
    defaultDirection: 0, // degrés
    defaultTurbulence: 5, // % - Turbulence réaliste pour conditions normales
    turbulenceScale: 0.05,
    turbulenceFreqBase: 0.05,
    turbulenceFreqY: 0.3,
    turbulenceFreqZ: 0.3,
    turbulenceIntensityXZ: 0.2,
    turbulenceIntensityY: 0.2,
  },
  debugVectors: true, // Active ou désactive l'affichage des vecteurs de debug
  pilot: PILOT_CONFIG,
  controlBar: CONTROL_BAR_CONFIG,
  initialization: {
    initialKiteY: 10.0, // m - Altitude initiale du kite (réaliste pour 15m de lignes)
    initialDistanceFactor: 0.98, // Sans unité - Lignes presque tendues au départ (98% de la longueur)
    initialKiteZ: null, // m - Position Z calculée automatiquement pour lignes tendues (null = calcul auto)
  },
  visualization: {
    lineWidth: 2, // pixels - Largeur des lignes de contrôle
  },
  debug: {
    // Seuils de tension des brides pour couleurs visuelles
    bridleTensionLow: 1, // N - Seuil tension molle (vert)
    bridleTensionMedium: 50, // N - Seuil tension moyenne (jaune)
    bridleTensionHigh: 100, // N - Seuil tension élevée (rouge)
    // Seuils pour vecteurs debug
    minVectorLength: 0.01, // m - Longueur minimale pour afficher un vecteur
    minVelocityDisplay: 0.1, // m/s - Vitesse minimale pour afficher vecteur vitesse
  },
  input: {
    rotationSpeed: 0.5, // rad/s - Vitesse de rotation de la barre (input utilisateur)
    returnSpeed: 3.0, // rad/s - Vitesse de retour au centre de la barre
    maxRotation: Math.PI / 3, // rad - Rotation maximale de la barre (°)
  },
  kiteInertia: {
    gyrationDivisor: Math.sqrt(2), // Sans unité - Diviseur pour rayon de giration (wingspan / √2)
    inertiaFactor: 1, // Sans unité - Facteur ajustement inertie (compromis stabilité/réactivité)
  },

  // Constantes de conversion et calculs fréquents
  conversions: {
    kmhToMs: 1 / 3.6, // Conversion km/h vers m/s
    radToDeg: 180 / Math.PI, // Conversion radians vers degrés
    degToRad: Math.PI / 180, // Conversion degrés vers radians
    gravityFactor: 9.81, // Accélération gravitationnelle standard
  },

  // Valeurs par défaut pour les calculs
  defaults: {
    meshSegments: 20, // Nombre de segments par défaut pour les tubes (augmenté pour courbes plus lisses)
    tubeRadius: 0.005, // Rayon des tubes de ligne (5mm - diamètre réaliste pour lignes de kite)
    tubeRadialSegments: 8, // Segments radiaux pour les tubes
    catenarySagFactor: 0.02, // Facteur de flèche pour les caténaires (2%)
    smoothingFactor: 0.15, // Facteur de lissage pour les animations
    restitutionFactor: 0.3, // Coefficient de restitution pour les collisions
    groundFriction: 0.85, // Friction du sol
  },

  // Couleurs fréquemment utilisées
  colors: {
    bridleLowTension: 0x00ff00, // Vert - tension faible
    bridleMediumTension: 0xffff00, // Jaune - tension moyenne
    bridleHighTension: 0xff0000, // Rouge - tension élevée
    controlBar: 0x333333, // Gris foncé pour la barre
    controlBarHandles: 0x8b4513, // Marron pour les poignées
    kiteFrame: 0x333333, // Gris pour le cadre du kite
    kiteSail: 0xffffff, // Blanc pour la voile
    debugRed: 0xff0000, // Rouge pour le debug
    debugGreen: 0x00ff00, // Vert pour le debug
    debugBlue: 0x0000ff, // Bleu pour le debug
    debugYellow: 0xffff00, // Jaune pour le debug
  },

  // Seuils et limites fréquemment utilisés
  thresholds: {
    minWindSpeed: 0.1, // m/s - Vitesse minimale pour calculs aérodynamiques
    minVelocity: 0.01, // m/s - Vitesse minimale pour éviter division par zéro
    maxLineSegments: 50, // Nombre maximum de segments pour les lignes
    epsilon: 1e-6, // Seuil numérique général
    epsilonFine: 1e-8, // Seuil fin pour calculs précis
    controlDeadzone: 0.001, // Zone morte pour les contrôles
  },

  // Constantes géométriques fréquentes
  geometry: {
    half: 0.5, // Demi pour calculs de moitiés
    third: 1 / 3, // Tiers pour ratios
    twoThirds: 2 / 3, // Deux tiers
    quarter: 0.25, // Quart
    threeQuarters: 0.75, // Trois quarts
    fullCircle: 2 * Math.PI, // Cercle complet en radians
    halfCircle: Math.PI, // Demi-cercle en radians
    quarterCircle: Math.PI / 2, // Quart de cercle en radians
  },

  // Constantes de couleurs hexadécimales
  hexColors: {
    red: 0xff0000,
    green: 0x00ff00,
    blue: 0x0000ff,
    yellow: 0xffff00,
    white: 0xffffff,
    black: 0x000000,
    gray: 0x808080,
    lightGray: 0xcccccc,
    darkGray: 0x333333,
  },

  // Constantes trigonométriques pré-calculées
  trig: {
    degToRad: Math.PI / 180, // Conversion degrés vers radians
    radToDeg: 180 / Math.PI, // Conversion radians vers degrés
    sqrt2: Math.sqrt(2), // Racine carrée de 2
    sqrt3: Math.sqrt(3), // Racine carrée de 3
    goldenRatio: (1 + Math.sqrt(5)) / 2, // Ratio d'or
  },

  // Paramètres de rendu
  rendering: {
    shadowMapSize: 2048,
    antialias: true,
    fogStart: 100,
    fogEnd: 1000,
    lineWidth: 2, // pixels - Largeur des lignes de contrôle
  },
};

=== simulation/controllers/KiteController.ts ===

/**
 * KiteController.ts - Contrôleur physique du cerf-volant
 *
 * Gère l'état physique du kite, l'intégration des forces et l'application
 * des contraintes géométriques (lignes et brides).
 */

import * as THREE from 'three';

import { Kite } from '../../objects/Kite';
import { CONFIG } from '../config/SimulationConfig';
import { PhysicsConstants } from '../config/PhysicsConstants';
import { KiteState } from '../types';
import { HandlePositions } from '../types';
import { ConstraintSolver } from '../physics/ConstraintSolver';

export class KiteController {
  private kite: Kite;
  private state: KiteState;
  private previousPosition: THREE.Vector3;

  // États pour les warnings
  private hasExcessiveAccel: boolean = false;
  private hasExcessiveVelocity: boolean = false;
  private hasExcessiveAngular: boolean = false;
  private lastAccelMagnitude: number = 0;
  private lastVelocityMagnitude: number = 0;

  // Lissage temporel des forces
  private smoothedForce: THREE.Vector3;
  private smoothedTorque: THREE.Vector3;
  private forceSmoothingRate: number = KiteController.DEFAULT_FORCE_SMOOTHING_RATE;

  // Constantes pour éviter les facteurs magiques
  private static readonly DEFAULT_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MIN_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MAX_FORCE_SMOOTHING_RATE = 20.0;

  constructor(kite: Kite) {
    this.kite = kite;
    this.state = {
      position: kite.position.clone(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: kite.quaternion.clone(),
    };
    this.previousPosition = kite.position.clone();
    this.kite.userData.lineLength = CONFIG.lines.defaultLength;

    // Initialiser les forces lissées avec gravité initiale (évite chute au démarrage)
    const initialGravity = new THREE.Vector3(0, -CONFIG.kite.mass * CONFIG.physics.gravity, 0);
    this.smoothedForce = initialGravity.clone();
    this.smoothedTorque = new THREE.Vector3();
  }

  /**
   * Met à jour la position et l'orientation du cerf-volant
   */
  update(
    forces: THREE.Vector3,
    torque: THREE.Vector3,
    handles: HandlePositions,
    deltaTime: number
  ): void {
    // Valider les forces brutes
    const validForces = this.validateForces(forces);
    const validTorque = this.validateTorque(torque);

    // Lissage exponentiel des forces (indépendant du framerate)
    const smoothingFactor = 1 - Math.exp(-this.forceSmoothingRate * deltaTime);
    this.smoothedForce.lerp(validForces, smoothingFactor);
    this.smoothedTorque.lerp(validTorque, smoothingFactor);

    // Utiliser les forces lissées pour la physique
    const newPosition = this.integratePhysics(this.smoothedForce, deltaTime);

    // Résolution itérative des contraintes PBD pour convergence stable
    for (let iter = 0; iter < PhysicsConstants.CONSTRAINT_ITERATIONS; iter++) {
      // Appliquer les contraintes de lignes (Position-Based Dynamics)
      try {
        ConstraintSolver.enforceLineConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          handles
        );
      } catch (err) {
        console.error(`⚠️ Erreur dans ConstraintSolver.enforceLineConstraints (iter ${iter}):`, err);
      }

      // Appliquer les contraintes des brides (Position-Based Dynamics)
      try {
        ConstraintSolver.enforceBridleConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          this.kite.getBridleLengths()
        );
      } catch (err) {
        console.error(`⚠️ Erreur dans ConstraintSolver.enforceBridleConstraints (iter ${iter}):`, err);
      }
    }

    // Gérer la collision avec le sol
    try {
      ConstraintSolver.handleGroundCollision(this.kite, newPosition, this.state.velocity);
    } catch (err) {
      console.error("⚠️ Erreur dans ConstraintSolver.handleGroundCollision:", err);
    }

    // Valider la position finale
    this.validatePosition(newPosition);

    // Appliquer la position et l'orientation
    this.kite.position.copy(newPosition);
    this.updateOrientation(this.smoothedTorque, deltaTime);
    this.previousPosition.copy(newPosition);
  }

  /**
   * Valide les forces appliquées au cerf-volant
   */
  private validateForces(forces: THREE.Vector3): THREE.Vector3 {
    if (
      !forces ||
      forces.length() > PhysicsConstants.MAX_FORCE ||
      isNaN(forces.length())
    ) {
      console.error(
        `⚠️ Forces invalides: ${forces ? forces.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return forces;
  }

  /**
   * Valide le couple
   */
  private validateTorque(torque: THREE.Vector3): THREE.Vector3 {
    if (!torque || isNaN(torque.length())) {
      console.error(
        `⚠️ Couple invalide: ${torque ? torque.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return torque;
  }

  /**
   * Intègre les forces pour calculer la nouvelle position (méthode d'Euler)
   */
  private integratePhysics(
    forces: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Newton : accélération = Force / masse
    const acceleration = forces.clone().divideScalar(CONFIG.kite.mass);
    this.lastAccelMagnitude = acceleration.length();

    // Sécurité : limiter pour éviter l'explosion numérique
    this.hasExcessiveAccel = acceleration.length() > PhysicsConstants.MAX_ACCELERATION;
    if (this.hasExcessiveAccel) {
      acceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ACCELERATION);
    }

    // Intégration d'Euler : v(t+dt) = v(t) + a·dt
    this.state.velocity.add(acceleration.clone().multiplyScalar(deltaTime));

    // Amortissement exponentiel
    const linearDampingFactor = Math.exp(-CONFIG.physics.linearDampingCoeff * deltaTime);
    this.state.velocity.multiplyScalar(linearDampingFactor);
    this.lastVelocityMagnitude = this.state.velocity.length();

    // Garde-fou vitesse max
    this.hasExcessiveVelocity = this.state.velocity.length() > PhysicsConstants.MAX_VELOCITY;
    if (this.hasExcessiveVelocity) {
      this.state.velocity
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_VELOCITY);
    }

    // Position : x(t+dt) = x(t) + v·dt
    return this.kite.position
      .clone()
      .add(this.state.velocity.clone().multiplyScalar(deltaTime));
  }

  /**
   * Valide la position finale
   */
  private validatePosition(newPosition: THREE.Vector3): void {
    if (isNaN(newPosition.x) || isNaN(newPosition.y) || isNaN(newPosition.z)) {
      console.error(`⚠️ Position NaN détectée! Reset à la position précédente`);
      newPosition.copy(this.previousPosition);
      this.state.velocity.set(0, 0, 0);
    }
  }

  /**
   * Met à jour l'orientation du cerf-volant - Dynamique du corps rigide
   */
  private updateOrientation(torque: THREE.Vector3, deltaTime: number): void {
    // Couple d'amortissement
    const dampTorque = this.state.angularVelocity
      .clone()
      .multiplyScalar(-CONFIG.kite.inertia * CONFIG.physics.angularDragFactor);
    const effectiveTorque = torque.clone().add(dampTorque);

    // Dynamique rotationnelle : α = T / I
    const angularAcceleration = effectiveTorque.clone().divideScalar(
      CONFIG.kite.inertia
    );

    // Limiter l'accélération angulaire
    if (
      angularAcceleration.length() > PhysicsConstants.MAX_ANGULAR_ACCELERATION
    ) {
      angularAcceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ANGULAR_ACCELERATION);
    }

    // Mise à jour de la vitesse angulaire
    this.state.angularVelocity.add(
      angularAcceleration.clone().multiplyScalar(deltaTime)
    );

    this.hasExcessiveAngular = false; // Toujours faux pour l'instant

    // Appliquer la rotation
    if (this.state.angularVelocity.length() > PhysicsConstants.EPSILON) {
      const deltaRotation = new THREE.Quaternion();
      const axis = this.state.angularVelocity.clone().normalize();
      const angle = this.state.angularVelocity.length() * deltaTime;
      deltaRotation.setFromAxisAngle(axis, angle);

      this.kite.quaternion.multiply(deltaRotation);
      this.kite.quaternion.normalize();
    }
  }

  getState(): KiteState {
    return { ...this.state };
  }

  getKite(): Kite {
    return this.kite;
  }

  setLineLength(length: number): void {
    this.kite.userData.lineLength = length;
  }

  /**
   * Retourne les états de warning pour l'affichage
   */
  getWarnings(): {
    accel: boolean;
    velocity: boolean;
    angular: boolean;
    accelValue: number;
    velocityValue: number;
  } {
    return {
      accel: this.hasExcessiveAccel,
      velocity: this.hasExcessiveVelocity,
      angular: this.hasExcessiveAngular,
      accelValue: this.lastAccelMagnitude,
      velocityValue: this.lastVelocityMagnitude,
    };
  }

  /**
   * Définit le taux de lissage des forces physiques
   */
  setForceSmoothing(rate: number): void {
    this.forceSmoothingRate = Math.max(
      KiteController.MIN_FORCE_SMOOTHING_RATE,
      Math.min(KiteController.MAX_FORCE_SMOOTHING_RATE, rate)
    );
  }

  /**
   * Retourne le taux de lissage actuel des forces (en 1/s)
   */
  getForceSmoothing(): number {
    return this.forceSmoothingRate;
  }
}

=== simulation/entities/Entity.ts ===

/**
 * Entity.ts - Interface de base pour toutes les entités ECS
 *
 * Une entité dans l'architecture ECS est simplement :
 * - Un ID unique
 * - Un ensemble de composants (données pures)
 *
 * Les entités ne contiennent PAS de logique, seulement des données.
 * La logique est dans les Systems.
 */

export type ComponentType = string;

/**
 * Interface de base pour tous les composants
 */
export interface Component {
  readonly type: ComponentType;
}

/**
 * Entité ECS de base
 */
export class Entity {
  public readonly id: string;
  private components: Map<ComponentType, Component> = new Map();
  private active: boolean = true;

  constructor(id?: string) {
    this.id = id || `entity_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
  }

  /**
   * Ajoute un composant à l'entité
   */
  addComponent<T extends Component>(component: T): this {
    this.components.set(component.type, component);
    return this;
  }

  /**
   * Récupère un composant par son type
   */
  getComponent<T extends Component>(type: ComponentType): T | undefined {
    return this.components.get(type) as T | undefined;
  }

  /**
   * Vérifie si l'entité possède un composant
   */
  hasComponent(type: ComponentType): boolean {
    return this.components.has(type);
  }

  /**
   * Supprime un composant
   */
  removeComponent(type: ComponentType): void {
    this.components.delete(type);
  }

  /**
   * Récupère tous les composants
   */
  getAllComponents(): Component[] {
    return Array.from(this.components.values());
  }

  /**
   * Active/désactive l'entité
   */
  setActive(active: boolean): void {
    this.active = active;
  }

  /**
   * Vérifie si l'entité est active
   */
  isActive(): boolean {
    return this.active;
  }

  /**
   * Clone l'entité (shallow copy)
   */
  clone(): Entity {
    const newEntity = new Entity();
    this.components.forEach((component, type) => {
      newEntity.components.set(type, component);
    });
    return newEntity;
  }
}


=== simulation/entities/EntityManager.ts ===

/**
 * EntityManager.ts - Gestionnaire central des entités ECS
 *
 * Responsabilités :
 * - Créer et détruire des entités
 * - Maintenir un registre central de toutes les entités
 * - Fournir des méthodes de requête pour trouver des entités
 */

import { Entity, ComponentType } from './Entity';

/**
 * Gestionnaire central des entités
 */
export class EntityManager {
  private entities: Map<string, Entity> = new Map();

  /**
   * Crée une nouvelle entité et l'enregistre
   */
  createEntity(id?: string): Entity {
    const entity = new Entity(id);
    this.entities.set(entity.id, entity);
    return entity;
  }

  /**
   * Enregistre une entité existante
   */
  registerEntity(entity: Entity): void {
    this.entities.set(entity.id, entity);
  }

  /**
   * Supprime une entité
   */
  destroyEntity(entityId: string): void {
    this.entities.delete(entityId);
  }

  /**
   * Récupère une entité par son ID
   */
  getEntity(entityId: string): Entity | undefined {
    return this.entities.get(entityId);
  }

  /**
   * Récupère toutes les entités
   */
  getAllEntities(): Entity[] {
    return Array.from(this.entities.values());
  }

  /**
   * Récupère toutes les entités actives
   */
  getActiveEntities(): Entity[] {
    return Array.from(this.entities.values()).filter(e => e.isActive());
  }

  /**
   * Récupère toutes les entités possédant un composant donné
   */
  getEntitiesWithComponent(componentType: ComponentType): Entity[] {
    return Array.from(this.entities.values()).filter(e =>
      e.hasComponent(componentType) && e.isActive()
    );
  }

  /**
   * Récupère toutes les entités possédant tous les composants donnés
   */
  getEntitiesWithComponents(...componentTypes: ComponentType[]): Entity[] {
    return Array.from(this.entities.values()).filter(entity => {
      if (!entity.isActive()) return false;
      return componentTypes.every(type => entity.hasComponent(type));
    });
  }

  /**
   * Compte le nombre d'entités
   */
  getEntityCount(): number {
    return this.entities.size;
  }

  /**
   * Supprime toutes les entités
   */
  clear(): void {
    this.entities.clear();
  }

  /**
   * Itère sur toutes les entités actives
   */
  forEach(callback: (entity: Entity) => void): void {
    this.entities.forEach(entity => {
      if (entity.isActive()) {
        callback(entity);
      }
    });
  }

  /**
   * Itère sur toutes les entités actives avec un composant donné
   */
  forEachWithComponent(
    componentType: ComponentType,
    callback: (entity: Entity) => void
  ): void {
    this.entities.forEach(entity => {
      if (entity.isActive() && entity.hasComponent(componentType)) {
        callback(entity);
      }
    });
  }

  /**
   * Itère sur toutes les entités actives avec plusieurs composants
   */
  forEachWithComponents(
    componentTypes: ComponentType[],
    callback: (entity: Entity) => void
  ): void {
    this.entities.forEach(entity => {
      if (!entity.isActive()) return;

      const hasAllComponents = componentTypes.every(type =>
        entity.hasComponent(type)
      );

      if (hasAllComponents) {
        callback(entity);
      }
    });
  }
}


=== simulation/entities/LineEntity.ts ===

/**
 * LineEntity.ts - Entité ECS pour les lignes de contrôle
 *
 * Représente une ligne de contrôle (gauche ou droite) dans la simulation ECS.
 * Contient les composants Transform et Mesh pour le rendu 3D.
 */

import * as THREE from 'three';

import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';

import { Entity } from './Entity';

export type LineSide = 'left' | 'right';

export class LineEntity extends Entity {
  public readonly side: LineSide;

  constructor(side: LineSide) {
    super(`${side}Line`);
    this.side = side;

    // Créer la géométrie de ligne (utiliser des tubes pour une meilleure visibilité)
    const segments = 20;
    const points = new Array(segments + 1).fill(0).map(() => new THREE.Vector3());
    const curve = new THREE.CatmullRomCurve3(points);

    const tubeMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000, // Rouge vif pour debug (sera coloré par les tensions ensuite)
      roughness: 0.7,
      metalness: 0.2,
      emissive: 0x440000, // Émission rouge pour meilleure visibilité
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide, // Visible des deux côtés
      transparent: false,
      opacity: 1.0
    });

      const tubeMesh = new THREE.Mesh(
        new THREE.TubeGeometry(curve, segments, CONFIG.defaults.tubeRadius, CONFIG.defaults.tubeRadialSegments, false),
        tubeMaterial
      );
    tubeMesh.name = `${side === 'left' ? 'Left' : 'Right'}ControlLine`;
    tubeMesh.castShadow = false;
    tubeMesh.receiveShadow = false;

    // Ajouter le composant Transform (position initiale à l'origine)
    const transform = new TransformComponent({
      position: new THREE.Vector3(),
      rotation: 0,
      quaternion: new THREE.Quaternion(),
      scale: new THREE.Vector3(1, 1, 1)
    });
    this.addComponent(transform);

    // Ajouter le composant Mesh
    const mesh = new MeshComponent(tubeMesh, {
      visible: true,
      castShadow: false,
      receiveShadow: false
    });
    this.addComponent(mesh);
  }

  /**
   * Met à jour la géométrie de la ligne entre deux points
   */
  updateGeometry(start: THREE.Vector3, end: THREE.Vector3): void {
    const mesh = this.getComponent<MeshComponent>('mesh');
    if (!mesh) return;

    const tubeMesh = mesh.object3D as THREE.Mesh;

    // Créer une nouvelle courbe pour le tube
    const segments = 20;
    const points: THREE.Vector3[] = [];

    // Calculer la distance et la direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const distance = direction.length();

    // Facteur de courbure (simule la gravité et la tension)
    const sagFactor = 0.02; // 2% de la longueur
    const sag = distance * sagFactor;

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Interpolation linéaire de base
      const x = start.x + direction.x * t;
      const y = start.y + direction.y * t;
      const z = start.z + direction.z * t;

      // Ajouter une courbure parabolique (caténaire simplifiée)
      // Maximum au milieu (t = 0.5)
      const curvature = -sag * 4 * t * (1 - t);

      points.push(new THREE.Vector3(x, y + curvature, z));
    }

    // Créer une nouvelle courbe et géométrie de tube
    const curve = new THREE.CatmullRomCurve3(points);
    const newTubeGeometry = new THREE.TubeGeometry(
      curve, 
      segments, 
      CONFIG.defaults.tubeRadius, 
      CONFIG.defaults.tubeRadialSegments, 
      false
    );

    // Remplacer la géométrie
    tubeMesh.geometry.dispose();
    tubeMesh.geometry = newTubeGeometry;
  }

  /**
   * Obtient la géométrie de la ligne
   */
  getGeometry(): THREE.BufferGeometry | null {
    const mesh = this.getComponent<MeshComponent>('mesh');
    return mesh ? (mesh.object3D as THREE.Line).geometry as THREE.BufferGeometry : null;
  }
}

=== simulation/entities/PilotEntity.ts ===

/**
 * PilotEntity.ts - Entité ECS pour le pilote
 *
 * Représente le pilote dans la simulation ECS.
 * Contient les composants Transform et Mesh pour le rendu 3D.
 */

import * as THREE from 'three';

import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';

import { Entity } from './Entity';

export class PilotEntity extends Entity {
  constructor() {
    super('pilot');

    // Créer la géométrie du pilote
    const pilotGeometry = new THREE.BoxGeometry(
      CONFIG.pilot.width,
      CONFIG.pilot.height,
      CONFIG.pilot.depth
    );
    const pilotMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a4a4a,
      roughness: 0.8
    });

    const pilotMesh = new THREE.Mesh(pilotGeometry, pilotMaterial);
    pilotMesh.name = 'Pilot';
    pilotMesh.castShadow = true;

    // Ajouter le composant Transform
    // Position initiale à (0, 0, 0) - sera mise à jour par PilotSystem
    const transform = new TransformComponent({
      position: new THREE.Vector3(0, 0, 0),
      rotation: 0,
      quaternion: new THREE.Quaternion(),
      scale: new THREE.Vector3(1, 1, 1)
    });
    this.addComponent(transform);

    // Ajouter le composant Mesh
    const mesh = new MeshComponent(pilotMesh, {
      visible: true,
      castShadow: true,
      receiveShadow: false
    });
    this.addComponent(mesh);
  }

  /**
   * Met à jour la position du pilote (toujours à l'origine du système de coordonnées)
   */
  updatePosition(): void {
    const transform = this.getComponent<TransformComponent>('transform');
    if (transform) {
      // Pilote à l'origine du système de coordonnées
      transform.position.copy(CONFIG.pilot.position);
    }
  }
}

=== simulation/entities/index.ts ===

/**
 * Exports for ECS entities and entity management
 */

export { Entity } from './Entity';
export type { Component, ComponentType } from './Entity';

export { EntityManager } from './EntityManager';


=== simulation/factories/ControlBarEntityFactory.ts ===

/**
 * ControlBarEntityFactory.ts - Factory pour créer l'entité ECS ControlBar
 *
 * Responsabilité unique : Construction de l'entité ControlBar avec sa géométrie Three.js
 * Réutilisable, testable, isolée de SimulationApp
 *
 * Pattern : Factory Method
 * Utilisation : Appelée depuis SimulationApp.createControlBarEntity()
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { CONFIG } from '../config/SimulationConfig';

import { EntityBuilder } from './EntityBuilder';

/**
 * Paramètres pour créer une entité ControlBar
 */
export interface ControlBarFactoryParams {
  /** Position de la barre (par défaut : relative au pilote) */
  position?: THREE.Vector3;
  
  /** Objet parent pour attachement (généralement le pilote) */
  parentObject?: THREE.Object3D;
  
  /** Nom de l'entité (par défaut : 'controlBar') */
  name?: string;
}

/**
 * Factory pour créer l'entité ECS ControlBar avec géométrie complète
 *
 * @example
 * ```typescript
 * // Création simple
 * const controlBar = ControlBarEntityFactory.create();
 *
 * // Avec attachement au pilote
 * const controlBar = ControlBarEntityFactory.create({
 *   parentObject: pilotMesh.object3D
 * });
 * ```
 */
export class ControlBarEntityFactory {
  /**
   * Crée une entité ControlBar complète avec géométrie Three.js
   *
   * @param params - Paramètres de configuration
   * @returns Entité ECS ControlBar prête à l'emploi
   */
  static create(params: ControlBarFactoryParams = {}): Entity {
    // Créer la géométrie Three.js
    const controlBarGroup = this.createGeometry();
    
    // Position (par défaut : relative au pilote)
    const position = params.position || new THREE.Vector3(
      0, // Même X que le pilote
      CONFIG.controlBar.offsetY, // Au-dessus du pilote
      CONFIG.controlBar.offsetZ  // Devant le pilote
    );
    controlBarGroup.position.copy(position);
    
    // Attacher au parent si fourni
    if (params.parentObject) {
      params.parentObject.add(controlBarGroup);
    }
    
    // Créer l'entité avec Transform + Mesh (via EntityBuilder)
    return EntityBuilder.createWithMesh(
      params.name || 'controlBar',
      controlBarGroup,
      position
    );
  }
  
  /**
   * Crée la géométrie Three.js de la barre de contrôle
   * Isolée, testable, réutilisable
   *
   * @returns THREE.Group contenant la barre et les poignées
   */
  private static createGeometry(): THREE.Group {
    const group = new THREE.Group();
    group.name = 'ControlBar';
    
    // Barre principale
    const bar = this.createBar();
    group.add(bar);
    
    // Poignées gauche et droite
    const { left, right } = this.createHandles();
    group.add(left, right);
    
    return group;
  }
  
  /**
   * Crée la barre principale (cylindre horizontal)
   *
   * @returns Mesh de la barre
   */
  private static createBar(): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.width
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: 0x333333, // Gris foncé
      metalness: 0.7,
      roughness: 0.3
    });
    
    const bar = new THREE.Mesh(geometry, material);
    
    // Rotation de 90° sur l'axe Z pour rendre le cylindre horizontal
    // Cette rotation est locale au mesh et ne sera pas affectée par les rotations du groupe
    bar.rotation.z = Math.PI / 2;
    bar.castShadow = true;
    
    return bar;
  }
  
  /**
   * Crée les poignées gauche et droite
   *
   * @returns Objet contenant les deux poignées
   */
  private static createHandles(): { left: THREE.Mesh; right: THREE.Mesh } {
    const geometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleLength
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: 0x8b4513, // Marron (bois)
      roughness: 0.6
    });
    
    const halfWidth = CONFIG.controlBar.width / 2;
    
    // Poignée gauche
    const left = new THREE.Mesh(geometry, material);
    left.position.set(-halfWidth, 0, 0);
    left.rotation.z = Math.PI / 2; // Même orientation que la barre (horizontal)
    left.castShadow = true;
    
    // Poignée droite
    const right = new THREE.Mesh(geometry, material);
    right.position.set(halfWidth, 0, 0);
    right.rotation.z = Math.PI / 2; // Même orientation que la barre (horizontal)
    right.castShadow = true;
    
    return { left, right };
  }
}


=== simulation/factories/EntityBuilder.ts ===

/**
 * EntityBuilder.ts - Utilitaires pour construire des entités ECS
 *
 * Responsabilité : Factoriser les patterns répétitifs de création d'entités
 * Principe DRY : Une seule source de vérité pour les composants standards
 *
 * Pattern : Builder + Factory Helpers
 * Utilisation : Appelé depuis les Entity Factories (ControlBar, Kite, Pilot, etc.)
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { TransformComponent, MeshComponent } from '../components';

/**
 * Options pour créer un TransformComponent
 */
export interface TransformOptions {
  /** Rotation autour de l'axe Y (par défaut : 0) */
  rotation?: number;
  
  /** Quaternion (par défaut : identité) */
  quaternion?: THREE.Quaternion;
  
  /** Échelle (par défaut : (1, 1, 1)) */
  scale?: THREE.Vector3;
}

/**
 * Options pour créer un MeshComponent
 */
export interface MeshOptions {
  /** Visible dans la scène (par défaut : true) */
  visible?: boolean;
  
  /** Projette des ombres (par défaut : true) */
  castShadow?: boolean;
  
  /** Reçoit des ombres (par défaut : false) */
  receiveShadow?: boolean;
}

/**
 * Options pour créer une entité complète avec Transform + Mesh
 */
export interface EntityWithMeshOptions extends TransformOptions, MeshOptions {
  // Combine TransformOptions et MeshOptions
}

/**
 * EntityBuilder - Helpers utilitaires pour construire des entités ECS
 *
 * Factorisation des patterns répétitifs observés dans toutes les Entity Factories :
 * - Création de TransformComponent avec valeurs par défaut
 * - Création de MeshComponent avec options standard
 * - Extraction d'objets 3D typés depuis MeshComponent
 * - Création rapide d'entités simples (Transform + Mesh)
 *
 * @example
 * ```typescript
 * // Ajouter Transform + Mesh séparément
 * const entity = new Entity('myEntity');
 * EntityBuilder.addTransform(entity, position);
 * EntityBuilder.addMesh(entity, object3D);
 *
 * // Créer entité complète en une ligne
 * const entity = EntityBuilder.createWithMesh('myEntity', object3D, position);
 *
 * // Extraire objet 3D typé
 * const kite = EntityBuilder.getMeshObject<Kite>(kiteEntity);
 * ```
 */
export class EntityBuilder {
  /**
   * Ajoute un TransformComponent standard à une entité
   * 
   * Factorisation du pattern répété dans toutes les factories.
   * Valeurs par défaut :
   * - rotation : 0
   * - quaternion : identité
   * - scale : (1, 1, 1)
   *
   * @param entity - Entité à laquelle ajouter le composant
   * @param position - Position 3D (sera clonée)
   * @param options - Options de transformation (optionnelles)
   * @returns Le TransformComponent créé
   */
  static addTransform(
    entity: Entity,
    position: THREE.Vector3,
    options: TransformOptions = {}
  ): TransformComponent {
    const transform = new TransformComponent({
      position: position.clone(),
      rotation: options.rotation ?? 0,
      quaternion: options.quaternion ?? new THREE.Quaternion(),
      scale: options.scale ?? new THREE.Vector3(1, 1, 1)
    });
    entity.addComponent(transform);
    return transform;
  }

  /**
   * Ajoute un MeshComponent standard à une entité
   * 
   * Factorisation du pattern répété dans toutes les factories.
   * Valeurs par défaut :
   * - visible : true
   * - castShadow : true
   * - receiveShadow : false
   *
   * @param entity - Entité à laquelle ajouter le composant
   * @param object3D - Objet Three.js (mesh, group, etc.)
   * @param options - Options de rendu (optionnelles)
   * @returns Le MeshComponent créé
   */
  static addMesh(
    entity: Entity,
    object3D: THREE.Object3D,
    options: MeshOptions = {}
  ): MeshComponent {
    const mesh = new MeshComponent(object3D, {
      visible: options.visible ?? true,
      castShadow: options.castShadow ?? true,
      receiveShadow: options.receiveShadow ?? false
    });
    entity.addComponent(mesh);
    return mesh;
  }

  /**
   * Extrait un objet 3D typé depuis le MeshComponent d'une entité
   * 
   * Helper générique pour éviter répétition de getComponent + cast.
   * Utilisable partout (Factories, Systems, SimulationApp).
   *
   * @typeParam T - Type de l'objet 3D attendu (ex: Kite, THREE.Group)
   * @param entity - Entité contenant un MeshComponent
   * @returns Objet 3D typé ou null si composant absent
   *
   * @example
   * ```typescript
   * const kite = EntityBuilder.getMeshObject<Kite>(kiteEntity);
   * if (kite) {
   *   kite.setBridleLengths([...]);
   * }
   * ```
   */
  static getMeshObject<T extends THREE.Object3D>(entity: Entity): T | null {
    const meshComponent = entity.getComponent<MeshComponent>('mesh');
    if (!meshComponent) return null;
    return meshComponent.object3D as T;
  }

  /**
   * Crée une entité complète avec Transform + Mesh en une seule ligne
   * 
   * Cas d'usage le plus courant : entité avec position + objet 3D.
   * Équivalent à :
   * ```typescript
   * const entity = new Entity(name);
   * EntityBuilder.addTransform(entity, position, options);
   * EntityBuilder.addMesh(entity, object3D, options);
   * ```
   *
   * @param name - Nom de l'entité
   * @param object3D - Objet Three.js
   * @param position - Position 3D
   * @param options - Options combinées (Transform + Mesh)
   * @returns Entité complète avec Transform et Mesh
   *
   * @example
   * ```typescript
   * const entity = EntityBuilder.createWithMesh(
   *   'kite',
   *   kiteObject,
   *   new THREE.Vector3(0, 50, -100)
   * );
   * ```
   */
  static createWithMesh(
    name: string,
    object3D: THREE.Object3D,
    position: THREE.Vector3,
    options: EntityWithMeshOptions = {}
  ): Entity {
    const entity = new Entity(name);

    // Ajouter Transform
    this.addTransform(entity, position, {
      rotation: options.rotation,
      quaternion: options.quaternion,
      scale: options.scale
    });

    // Ajouter Mesh
    this.addMesh(entity, object3D, {
      visible: options.visible,
      castShadow: options.castShadow,
      receiveShadow: options.receiveShadow
    });

    return entity;
  }
}


=== simulation/factories/KiteEntityFactory.ts ===

/**
 * KiteEntityFactory.ts - Factory pour créer l'entité ECS Kite
 *
 * Responsabilité unique : Construction de l'entité Kite avec objet StructuredObject complet
 * Réutilise les factories géométriques existantes (PointFactory, FrameFactory, etc.)
 *
 * Pattern : Factory Method + Composition
 * Utilisation : Appelée depuis SimulationApp.createKiteEntity()
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { CONFIG } from '../config/SimulationConfig';

import { EntityBuilder } from './EntityBuilder';

import { Kite } from '@/objects/Kite';
import { MathUtils } from '@/utils/MathUtils';


/**
 * Paramètres pour créer une entité Kite
 */
export interface KiteFactoryParams {
  /** Position initiale du kite (par défaut : calculée automatiquement) */
  position?: THREE.Vector3;
  
  /** Preset de configuration (par défaut : default config) */
  preset?: string; // Extension future pour différents types de kites
  
  /** Nom de l'entité (par défaut : 'kite') */
  name?: string;
}

/**
 * Factory pour créer l'entité ECS Kite avec objet StructuredObject complet
 *
 * Le kite est un objet complexe utilisant plusieurs factories géométriques :
 * - PointFactory : Points anatomiques (NEZ, CTRL_GAUCHE, CTRL_DROIT, etc.)
 * - FrameFactory : Structure en carbone
 * - SurfaceFactory : Panneaux de voile
 * - BridleFactory : Système de bridage (6 lignes)
 *
 * Cette factory ECS **compose** avec ces factories existantes via `new Kite()`.
 *
 * @example
 * ```typescript
 * // Création simple (position auto-calculée)
 * const kite = KiteEntityFactory.create();
 *
 * // Avec position personnalisée
 * const kite = KiteEntityFactory.create({
 *   position: new THREE.Vector3(0, 50, -100)
 * });
 * ```
 */
export class KiteEntityFactory {
  /**
   * Crée une entité Kite complète avec objet StructuredObject Three.js
   *
   * @param params - Paramètres de configuration
   * @returns Entité ECS Kite prête à l'emploi (avec objet Kite accessible via MeshComponent)
   */
  static create(params: KiteFactoryParams = {}): Entity {
    // 1. Créer l'objet Kite (StructuredObject)
    // Cet objet utilise automatiquement PointFactory, FrameFactory, SurfaceFactory, BridleFactory
    const kite = new Kite();
    
    // 2. Position initiale (auto-calculée ou fournie)
    const position = params.position || this.calculateInitialPosition();
    kite.position.copy(position);
    
    // 3. Créer l'entité ECS avec Transform + Mesh (via EntityBuilder)
    return EntityBuilder.createWithMesh(
      params.name || 'kite',
      kite,
      position
    );
  }
  
  /**
   * Calcule la position initiale du kite selon la configuration
   * 
   * Logique métier : Position basée sur la barre de contrôle + longueur des lignes
   * 
   * Accessible publiquement pour réutilisation (ex: reset du kite)
   * 
   * @returns Position Vector3 calculée
   */
  static calculateInitialPosition(): THREE.Vector3 {
    // Position de la barre de contrôle calculée à partir du pilote
    // Note: Cette position est la même que dans ControlBarEntityFactory
    const controlBarPosition = new THREE.Vector3(
      CONFIG.pilot.position.x,
      CONFIG.pilot.position.y + CONFIG.controlBar.offsetY,
      CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ
    );

    // Calculer position kite selon longueur des lignes et facteur de distance
    return MathUtils.calculateInitialKitePosition(
      controlBarPosition, // Référence = barre de contrôle
      CONFIG.initialization.initialKiteY,
      CONFIG.lines.defaultLength,
      CONFIG.initialization.initialDistanceFactor,
      CONFIG.initialization.initialKiteZ
    );
  }
  
  /**
   * Extrait l'objet Kite d'une entité (helper utilitaire)
   * 
   * Wrapper typé autour de EntityBuilder.getMeshObject<Kite>()
   * pour commodité et clarté du code.
   * 
   * @param entity - Entité contenant un MeshComponent avec objet Kite
   * @returns Objet Kite ou null si non trouvé
   */
  static getKiteObject(entity: Entity): Kite | null {
    return EntityBuilder.getMeshObject<Kite>(entity);
  }
}


=== simulation/factories/PilotEntityFactory.ts ===

/**
 * PilotEntityFactory.ts - Factory pour créer l'entité ECS Pilot
 *
 * Responsabilité unique : Construction de l'entité Pilot
 * Encapsule l'instanciation pour cohérence avec ControlBarEntityFactory
 *
 * Pattern : Factory Method (simplifié - PilotEntity est autosuffisant)
 * Utilisation : Appelée depuis SimulationApp.createPilotEntity()
 */

import { PilotEntity } from '../entities/PilotEntity';

/**
 * Paramètres pour créer une entité Pilot
 * (Pour l'instant vide - PilotEntity ne supporte pas de customisation)
 */
export interface PilotFactoryParams {
  // Réservé pour extension future
}

/**
 * Factory pour créer l'entité ECS Pilot
 *
 * Note: PilotEntity construit toute sa géométrie dans son constructeur.
 * Cette factory sert principalement à maintenir la cohérence architecturale
 * avec les autres Entity Factories (ControlBar, future Kite).
 *
 * @example
 * ```typescript
 * const pilot = PilotEntityFactory.create();
 * ```
 */
export class PilotEntityFactory {
  /**
   * Crée une entité Pilot complète
   *
   * @param _params - Paramètres de configuration (réservé pour extension future)
   * @returns PilotEntity prête à l'emploi
   */
  static create(_params: PilotFactoryParams = {}): PilotEntity {
    // PilotEntity construit toute sa géométrie dans son constructeur
    // (BoxGeometry selon CONFIG.pilot.width/height/depth)
    return new PilotEntity();
  }
}


=== simulation/factories/index.ts ===

/**
 * index.ts - Export centralisé des Entity Factories
 */

export { ControlBarEntityFactory, type ControlBarFactoryParams } from './ControlBarEntityFactory';
export { PilotEntityFactory, type PilotFactoryParams } from './PilotEntityFactory';
export { KiteEntityFactory, type KiteFactoryParams } from './KiteEntityFactory';
export { EntityBuilder, type TransformOptions, type MeshOptions, type EntityWithMeshOptions } from './EntityBuilder';



=== simulation/index.ts ===

/**
 * Point d'entrée principal de la simulation modulaire
 */

// Export de la classe principale
export { SimulationApp as Simulation } from './SimulationApp';

// Re-export de tous les modules pour faciliter l'importation
export * from './config/PhysicsConstants';
export * from './config/KiteGeometry';
export * from './config/SimulationConfig';

export * from './types';

export * from './physics/WindSimulator';
export * from './physics/AerodynamicsCalculator';
export * from './physics/LineSystem';

export * from './rendering/RenderManager';
export * from './rendering/DebugRenderer';

export * from './ui/UIManager';

export * from './physics/ConstraintSolver';

=== simulation/physics/AerodynamicsCalculator.ts ===

/**
 * AerodynamicsCalculator.ts - Calculateur de forces aérodynamiques distribuées
 *
 * Calcule les forces aérodynamiques (portance, traînée) et gravitationnelles 
 * distribuées sur chaque surface du kite selon les principes de la mécanique des fluides.
 *
 * Modèle physique amélioré :
 *   - Coefficients réalistes basés sur données expérimentales (NACA, etc.)
 *   - Modélisation du stall (décrochage) à forts angles d'incidence
 *   - Centre de pression dynamique
 *   - Effets de turbulence et amortissement aérodynamique
 *
 * @see PhysicsEngine.ts - Utilise les forces calculées
 * @see KiteGeometry.ts - Définit les surfaces et masses
 */
import * as THREE from "three";

import { KiteGeometry } from "../config/KiteGeometry";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { SurfaceForce } from "../types/PhysicsTypes";

/**
 * Calculateur de forces aérodynamiques amélioré
 *
 * Calcule comment le vent pousse sur le cerf-volant selon sa forme et orientation
 */
export class AerodynamicsCalculator {
  // Constantes de calculs aérodynamiques
  private static readonly HALF_AIR_DENSITY = 0.5 * CONFIG.physics.airDensity;
  private static readonly MIN_WIND_SPEED = 0.01; // m/s - seuil minimal pour calculs aéro

  // Coefficients aérodynamiques améliorés pour plaque plane (basés sur données expérimentales)
  private static readonly AERO_COEFFICIENTS = {
    // Coefficients de portance CL = a0 + a1*α + a2*α² + a3*α³
    lift: {
      a0: 0.0,      // Offset
      a1: 0.1,      // Linéaire (2π pour profil mince, réduit pour plaque plane)
      a2: 0.0,      // Quadratique
      a3: -0.005    // Cubique (pour stall)
    },

    // Coefficients de traînée CD = b0 + b1*α + b2*α² + b3*α³
    drag: {
      b0: 0.01,     // Traînée parasite minimale
      b1: 0.0,      // Composante linéaire faible
      b2: 0.05,     // Quadratique (principale)
      b3: 0.002     // Cubique (augmente en stall)
    },

    // Limites pour éviter les instabilités
    alphaStall: Math.PI / 6,  // 30° - angle de décrochage
    alphaMax: Math.PI / 3,    // 60° - angle maximum
    clMax: 1.2,               // CL maximum avant stall
    cdMax: 2.0                // CD maximum
  };

  /**
   * Calcule les coefficients aérodynamiques réalistes pour un angle d'incidence
   * Basé sur des données expérimentales pour plaques planes et profils simples
   */
  private static calculateAerodynamicCoefficients(alpha: number): { CL: number; CD: number } {
    const coeffs = this.AERO_COEFFICIENTS;
    const absAlpha = Math.abs(alpha);

    // Limiter l'angle pour éviter les instabilités
    const clampedAlpha = Math.max(-coeffs.alphaMax, Math.min(coeffs.alphaMax, alpha));

    // Calculer CL avec modèle polynomial + stall
    let CL = coeffs.lift.a0 +
             coeffs.lift.a1 * clampedAlpha +
             coeffs.lift.a2 * clampedAlpha * clampedAlpha +
             coeffs.lift.a3 * clampedAlpha * clampedAlpha * clampedAlpha;

    // Appliquer le stall (décrochage) à forts angles
    if (absAlpha > coeffs.alphaStall) {
      const stallFactor = Math.max(0, 1 - (absAlpha - coeffs.alphaStall) / (coeffs.alphaMax - coeffs.alphaStall));
      CL *= stallFactor * stallFactor; // Décroissance quadratique
    }

    // Limiter CL
    CL = Math.max(-coeffs.clMax, Math.min(coeffs.clMax, CL));

    // Calculer CD avec modèle polynomial
    let CD = coeffs.drag.b0 +
             coeffs.drag.b1 * Math.abs(clampedAlpha) +
             coeffs.drag.b2 * clampedAlpha * clampedAlpha +
             coeffs.drag.b3 * Math.abs(clampedAlpha * clampedAlpha * clampedAlpha);

    // CD minimum et augmentation en stall
    CD = Math.max(coeffs.drag.b0, CD);

    // En stall, CD augmente significativement
    if (absAlpha > coeffs.alphaStall) {
      const stallDrag = coeffs.drag.b0 + (absAlpha - coeffs.alphaStall) * 0.5;
      CD = Math.max(CD, stallDrag);
    }

    // Limiter CD
    CD = Math.min(coeffs.cdMax, CD);

    return { CL, CD };
  }

  /**
   * Calcule le couple (moment) d'une force appliquée à un point
   * Méthode utilitaire pour éviter la répétition de new THREE.Vector3().crossVectors()
   */
  private static calculateTorque(lever: THREE.Vector3, force: THREE.Vector3): THREE.Vector3 {
    return new THREE.Vector3().crossVectors(lever, force);
  }

  /**
   * Calcule l'amortissement aérodynamique pour améliorer la stabilité
   * L'amortissement réduit les oscillations angulaires
   */
  private static calculateAerodynamicDamping(
    angularVelocity: THREE.Vector3,
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): THREE.Vector3 {
    // Amortissement anisotrope par axe, pondéré par la vitesse du vent
    const cfg = CONFIG.aero.damping;
    const windSpeed = Math.max(0, apparentWind.length());

    // Décomposer la vitesse angulaire dans le repère du kite (approx: utiliser composantes locales)
    // Ici on suppose angularVelocity exprimée dans le repère monde, on applique l'inverse de l'orientation du kite
    const angLocal = angularVelocity.clone().applyQuaternion(kiteOrientation.clone().invert());

    // Amortissement local par axe
    const dampLocal = new THREE.Vector3(
      -cfg.roll * angLocal.x,
      -cfg.pitch * angLocal.y,
      -cfg.yaw * angLocal.z
    ).multiplyScalar(1 + cfg.windSpeedFactor * windSpeed);

    // Revenir dans le repère monde
    const dampingTorque = dampLocal.applyQuaternion(kiteOrientation);

    // Clamp sécurité
    if (dampingTorque.length() > cfg.maxMagnitude) {
      dampingTorque.setLength(cfg.maxMagnitude);
    }

    return dampingTorque;
  }

  /**
   * Calcule le centre de pression réaliste pour une surface
   * Le centre de pression se déplace avec l'angle d'incidence
   */
  private static calculateCenterOfPressure(
    surface: any,
    alpha: number,
    centroid: THREE.Vector3
  ): THREE.Vector3 {
    // Pour une plaque plane, le centre de pression se déplace vers l'arrière
    // quand l'angle d'incidence augmente (effet de portance)

    // Coefficient de déplacement du centre de pression (empirique)
    const cpShiftCoeff = 0.3; // Fraction de la longueur de la surface

    // Calculer la direction longitudinale de la surface (du nez vers la queue)
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    const surfaceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

    // Direction longitudinale approximative (perpendiculaire à la normale dans le plan)
    const longitudinalDir = edge1.clone().normalize();

    // Déplacement du centre de pression basé sur l'angle d'incidence
    // À α=0°, CP = centroïde
    // À α>0°, CP se déplace vers l'arrière (direction opposée au vent relatif)
    const cpShift = Math.abs(alpha) * cpShiftCoeff;
    const cpOffset = longitudinalDir.clone().multiplyScalar(-cpShift); // Vers l'arrière

    return centroid.clone().add(cpOffset);
  }  /**
   * Calcule la normale d'un triangle dans l'espace monde
   * Méthode utilitaire pour éviter la duplication de code
   *
   * @param surface - Surface triangulaire avec vertices
   * @param kiteOrientation - Quaternion d'orientation du kite (optionnel)
   * @returns Vecteur normal unitaire dans l'espace monde
   */
  private static calculateSurfaceNormal(
    surface: { vertices: THREE.Vector3[] },
    kiteOrientation?: THREE.Quaternion
  ): THREE.Vector3 {
    // Calcul des arêtes du triangle
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    
    // Normale locale (produit vectoriel normalisé)
    const normal = new THREE.Vector3()
      .crossVectors(edge1, edge2)
      .normalize();
    
    // Transformation dans l'espace monde si orientation fournie
    return kiteOrientation ? normal.applyQuaternion(kiteOrientation) : normal;
  }

  /**
   * Calcule comment le vent pousse sur le cerf-volant
   *
   * COMMENT ÇA MARCHE :
   * 1. On regarde chaque triangle du cerf-volant
   * 2. On calcule sous quel angle le vent frappe ce triangle
   * 3. Plus le vent frappe de face, plus la force est grande
   * 4. On additionne toutes les forces pour avoir la force totale
   *
   * POURQUOI C'EST IMPORTANT :
   * Si un côté du kite reçoit plus de vent, il sera poussé plus fort
   * Cette différence fait tourner le kite naturellement !
   */
  static calculateForces(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion,
    kitePosition?: THREE.Vector3,
    _kiteVelocity?: THREE.Vector3,
    _angularVelocity?: THREE.Vector3
  ): {
    lift: THREE.Vector3;
    drag: THREE.Vector3;
    gravity: THREE.Vector3;  // Gravité distribuée par surface
    torque: THREE.Vector3;
    leftForce?: THREE.Vector3;
    rightForce?: THREE.Vector3;
    surfaceForces: SurfaceForce[];
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < 0.1) {
      return {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),  // Pas de gravité si vent nul
        torque: new THREE.Vector3(),
        surfaceForces: [],
      };
    }

    apparentWind.clone().normalize();
    AerodynamicsCalculator.HALF_AIR_DENSITY * windSpeed * windSpeed;

    // Forces séparées pour gauche et droite
    const leftForce = new THREE.Vector3();
    const rightForce = new THREE.Vector3();
    const totalForce = new THREE.Vector3();
    const totalTorque = new THREE.Vector3();
    
    // Accumulation des forces par type (formules plaque plane : CL = sin(α)×cos(α), CD = sin²(α))
    const totalLift = new THREE.Vector3();      // Portance totale
    const totalDrag = new THREE.Vector3();      // Traînée totale
    const gravityForce = new THREE.Vector3();   // Gravité distribuée par surface/frame
    
    // Séparation couples aéro et gravité pour scaling cohérent
    const aeroTorque = new THREE.Vector3();
    const gravityTorque = new THREE.Vector3();
    
    // Collection des forces par surface pour le debug
    const surfaceForces: SurfaceForce[] = [];

  // Modèle physique :
  // - Les forces aérodynamiques (portance, traînée) sont calculées et appliquées pour chaque surface triangulaire
  // - La masse de chaque surface est proportionnelle à son aire
  // - Les forces sont appliquées au centre géométrique du triangle (barycentre)
  // - Les couples émergent naturellement de la distribution spatiale des forces
  // - Voir PHYSICS_MODEL.md §4.2 pour les équations et principes
  // On examine chaque triangle du cerf-volant un par un
  // C'est comme vérifier comment le vent frappe chaque panneau d'un parasol
    KiteGeometry.SUBDIVIDED_SURFACES.forEach((surface, surfaceIndex) => {
      // 🔴 MAILLAGE FIN : Distribuer la masse proportionnellement à l'aire
      // Trouver quelle surface originale contient ce sous-triangle
      const trianglesPerSurface = KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(
        KiteGeometry.getMeshSubdivisionLevel()
      );
      const originalSurfaceIndex = Math.floor(surfaceIndex / trianglesPerSurface);
      const originalSurfaceMass = KiteGeometry.SURFACE_MASSES[originalSurfaceIndex];

      // Distribuer la masse proportionnellement à l'aire relative
      const totalAreaForOriginal = KiteGeometry.SURFACES[originalSurfaceIndex].area;
      const massRatio = surface.area / totalAreaForOriginal;
      const surfaceMass = originalSurfaceMass * massRatio;
      // 🔴 DÉSACTIVATION TEMPORAIRE du vent apparent local pour debug
      // Le calcul local peut réduire trop fortement le vent perçu en rotation
      
      // Utiliser le vent apparent GLOBAL pour toutes les surfaces
      const localApparentWind = apparentWind.clone();
      const localWindSpeed = localApparentWind.length();
      
      if (localWindSpeed < 0.1) {
        return; // Pas de vent sur cette surface
      }
      
      const localWindDir = localApparentWind.clone().normalize();
      const localDynamicPressure = 0.5 * CONFIG.physics.airDensity * localWindSpeed * localWindSpeed;
      
      // Pour comprendre comment le vent frappe ce triangle,
      // on doit savoir dans quelle direction il "regarde"
      // (comme l'orientation d'un panneau solaire)
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      // Calcul de l'angle d'incidence pour une plaque plane (cerf-volant)
      // α = angle entre la direction du vent et la surface
      const windDotNormal = localWindDir.dot(normaleMonde);
      const cosTheta = Math.abs(windDotNormal); // cos(θ) où θ = angle vent-normale

      // Pour une plaque : sin(α) = cos(θ) et cos(α) = sin(θ)
      const sinAlpha = cosTheta;
      const cosAlpha = Math.sqrt(Math.max(0, 1 - sinAlpha * sinAlpha)); // sin²+cos²=1

      // Calculer l'angle d'incidence réel (en radians)
      const alpha = Math.asin(Math.min(1, sinAlpha)); // Limiter à [-π/2, π/2]

      // Si le vent glisse sur le côté (angle = 0), pas de force
      if (sinAlpha <= PhysicsConstants.EPSILON) {
        return;
      }

      // 🎯 NOUVEAUX COEFFICIENTS AÉRODYNAMIQUES RÉALISTES
      // Au lieu des formules simplifiées, utiliser des coefficients expérimentaux
      const { CL, CD } = AerodynamicsCalculator.calculateAerodynamicCoefficients(alpha);
      
      // 🔍 DEBUG première surface (angle et coefficients) - DISABLED for performance
      // if (surfaceIndex === 0) {
      //   const alphaDeg = Math.asin(sinAlpha) * 180 / Math.PI;

      // }
      
      // Direction : normale à la surface, orientée face au vent
      const windFacingNormal = windDotNormal >= 0 ? normaleMonde.clone() : normaleMonde.clone().negate();
      
      // DIRECTION LIFT : Perpendiculaire au vent, dans le plan (vent, normale)
      // Méthode : liftDir = normalize(windFacingNormal - (windFacingNormal·windDir)×windDir)
      const liftDir = windFacingNormal.clone()
        .sub(localWindDir.clone().multiplyScalar(windFacingNormal.dot(localWindDir)))
        .normalize();
      
      // Vérifier validité (éviter division par zéro si vent // normale)
      if (liftDir.lengthSq() < PhysicsConstants.EPSILON) {
        liftDir.copy(windFacingNormal);  // Fallback : utiliser normale
      }
      
      // DIRECTION DRAG : Parallèle au vent
      const dragDir = localWindDir.clone();
      
      // FORCES AÉRODYNAMIQUES (AVANT scaling) avec pression dynamique LOCALE
      const liftMagnitude = localDynamicPressure * surface.area * CL;
      const dragMagnitude = localDynamicPressure * surface.area * CD;
      
      const liftForce = liftDir.clone().multiplyScalar(liftMagnitude);
      const dragForce = dragDir.clone().multiplyScalar(dragMagnitude);
      
      // Force aérodynamique totale = lift + drag (vectoriel)
      const aeroForce = liftForce.clone().add(dragForce);
      
      // GRAVITÉ DISTRIBUÉE (émergente, pas scriptée !)
      // Chaque surface porte une fraction de la masse totale
      // La gravité est appliquée au centre géométrique de chaque surface
      // → Couple gravitationnel émerge naturellement de r × F_gravity
      const gravity = new THREE.Vector3(0, -surfaceMass * CONFIG.physics.gravity, 0);
      
      // Accumulation des forces par type
      totalLift.add(liftForce);
      totalDrag.add(dragForce);
      gravityForce.add(gravity);
      
      // Force totale sur cette surface = aéro + gravité
      const totalSurfaceForce = aeroForce.clone().add(gravity);
      
      // Pour le debug : conserver lift/drag locaux
      const lift = liftForce.clone();
      const drag = dragForce.clone();

      // 6. Centre de pression dynamique (au lieu du simple centroïde)
      const geometricCentroid = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Centre de pression réaliste qui dépend de l'angle d'incidence
      const centerOfPressure = AerodynamicsCalculator.calculateCenterOfPressure(
        surface,
        alpha,
        geometricCentroid
      );

      // Centre orienté dans le repère monde (sans translation)
      const centreOriente = centerOfPressure.clone().applyQuaternion(kiteOrientation);
      // Centre monde complet (incluant translation si disponible)
      const centreMonde = kitePosition
        ? centreOriente.clone().add(kitePosition)
        : centreOriente.clone();

      // 🔍 DEBUG TOUTES les surfaces : géométrie + forces - DISABLED for performance


      // On note si cette force est sur le côté gauche ou droit
      // C'est important car si un côté a plus de force,
      // le kite va tourner (comme un bateau avec une seule rame)
      const isLeft = centerOfPressure.x < 0; // Négatif = gauche, Positif = droite

      if (isLeft) {
        leftForce.add(totalSurfaceForce); // Force totale (aéro + gravité)
      } else {
        rightForce.add(totalSurfaceForce); // Force totale (aéro + gravité)
      }

      totalForce.add(totalSurfaceForce);

      // Friction (négligeable pour l'air, nulle)
      const friction = new THREE.Vector3();

      // Résultante = force aéro totale (lift + drag vectoriel)
      const resultant = aeroForce.clone();

      surfaceForces.push({
        surfaceIndex,
        lift,
        drag,
        friction,
        resultant,
        center: centreMonde,
        normal: normaleMonde.clone(),
        area: surface.area,
      });

      // Le couple, c'est ce qui fait tourner le kite
      // Imaginez une porte : si vous poussez près des gonds, elle tourne peu
      // Si vous poussez loin des gonds, elle tourne beaucoup
      // Ici, plus la force est loin du centre, plus elle fait tourner
      //
      // Séparation couples aéro et gravité pour scaling cohérent :
      // - Couple aéro : sera scalé proportionnellement aux forces (liftScale/dragScale)
      // - Couple gravité : physique pure, pas de scaling
      // Note: centre est déjà en coordonnées locales, on applique seulement la rotation
  const centreWorldForTorque = centreOriente.clone();
      
      // Couples calculés via méthode utilitaire
      aeroTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, aeroForce));
      gravityTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, gravity));
      totalTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, totalSurfaceForce));


    });

    // PHYSIQUE ÉMERGENTE : Le couple vient de la différence G/D
    // Si leftForce > rightForce → rotation vers la droite
    // Si rightForce > leftForce → rotation vers la gauche
    // AUCUN facteur artificiel nécessaire!

    // 🔴 BUG FIX #4 : PAS DE DÉCOMPOSITION GLOBALE !
    // Les lift/drag ont déjà été calculés CORRECTEMENT par surface avec CL/CD
    // Il suffit d'appliquer les scaling factors directement
    const lift = totalLift.multiplyScalar(CONFIG.aero.liftScale);
    const drag = totalDrag.multiplyScalar(CONFIG.aero.dragScale);

    // 🔍 DEBUG : Afficher forces calculées - DISABLED for performance
    // Uncomment for debugging:


    // 🔍 DEBUG CRITIQUE : Asymétrie gauche/droite - DISABLED for performance
    // const leftMag = leftForce.length();
    // const rightMag = rightForce.length();
    // const asymmetry = leftMag - rightMag;
    // const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag * 100) : 0;
    // const leftArr = leftForce.toArray();
    // const rightArr = rightForce.toArray();
    // const diffArr = leftForce.clone().sub(rightForce).toArray();


    // CORRECTION CRITIQUE : Scaling cohérent du couple aérodynamique
    // Le couple DOIT être scalé proportionnellement aux forces aéro pour cohérence physique
    // Si les forces sont doublées (scale=2), le couple doit l'être aussi
    // MAIS la gravité reste inchangée (physique pure)
    const averageAeroScale = (CONFIG.aero.liftScale + CONFIG.aero.dragScale) / 2;
    const scaledAeroTorque = aeroTorque.multiplyScalar(averageAeroScale);
    
    // Couple total = couple aéro scalé + couple gravité (non scalé)
  let finalTorque = scaledAeroTorque.clone().add(gravityTorque);

    // 🎯 AJOUTER L'AMORTISSEMENT AÉRODYNAMIQUE pour la stabilité
    if (_angularVelocity && CONFIG.aero.damping.enabled) {
      const dampingTorque = AerodynamicsCalculator.calculateAerodynamicDamping(
        _angularVelocity,
        apparentWind,
        kiteOrientation
      );
      finalTorque.add(dampingTorque);
    }

    // Clamp final du couple pour stabilité numérique
    const maxNm = CONFIG.aero.damping.maxMagnitude * 2; // un peu plus haut que l'amortissement seul
    if (finalTorque.length() > maxNm) {
      finalTorque.setLength(maxNm);
    }

    return {
      lift,
      drag,
      gravity: gravityForce,  // � RESTAURÉ : Gravité distribuée par surface
      torque: finalTorque,  // Couple cohérent avec forces scalées + amortissement
      leftForce, // Exposer les forces pour analyse
      rightForce, // Permet de voir l'asymétrie émergente
      surfaceForces, // Forces individuelles par surface pour debug
    };
  }

  /**
   * Calcule des métriques pour le debug
   */
  static computeMetrics(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): {
    apparentSpeed: number;
    liftMag: number;
    dragMag: number;
    lOverD: number;
    aoaDeg: number;
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < PhysicsConstants.EPSILON) {
      return { apparentSpeed: 0, liftMag: 0, dragMag: 0, lOverD: 0, aoaDeg: 0 };
    }

    const { lift } = this.calculateForces(apparentWind, kiteOrientation);
    const liftMag = lift.length();
    const dragMag = 0; // Traînée intégrée dans les forces totales
    const lOverD = 0; // Ratio non applicable pour un cerf-volant

    // Calcul approximatif de l'angle d'attaque
    const windDir = apparentWind.clone().normalize();
    const weightedNormal = new THREE.Vector3();

    KiteGeometry.SURFACES.forEach((surface) => {
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      const facing = windDir.dot(normaleMonde);
      const cosIncidence = Math.max(0, Math.abs(facing));

      const normalDir =
        facing >= 0 ? normaleMonde : normaleMonde.clone().negate();
      weightedNormal.add(normalDir.multiplyScalar(surface.area * cosIncidence));
    });

    let aoaDeg = 0;
    if (
      weightedNormal.lengthSq() >
      PhysicsConstants.EPSILON * PhysicsConstants.EPSILON
    ) {
      const eff = weightedNormal.normalize();
      const dot = Math.max(-1, Math.min(1, eff.dot(windDir)));
      const phiDeg = (Math.acos(dot) * 180) / Math.PI;
      aoaDeg = Math.max(0, 90 - phiDeg);
    }

    return { apparentSpeed: windSpeed, liftMag, dragMag, lOverD, aoaDeg };
  }
}

=== simulation/physics/BridleSystem.ts ===

/**
 * BridleSystem.ts - Orchestrateur du système de bridage du cerf-volant
 *
 * Rôle :
 *   - Coordonne les 6 brides (3 gauches + 3 droites)
 *   - Calcule les tensions pour affichage/debug (pas de forces appliquées)
 *   - Les contraintes de distance sont gérées par ConstraintSolver
 *
 * IMPORTANT : Les brides sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT les points d'attache (distance max)
 *   - Elles ne TIRENT PAS les points les uns vers les autres
 *   - Le ConstraintSolver.enforceBridleConstraints() gère la contrainte géométrique
 *
 * Architecture :
 *   - Similar à LineSystem mais pour les brides internes au kite
 *   - Réutilise LinePhysics pour les calculs de tension
 *   - Les 6 brides sont des instances Line indépendantes
 *
 * Relation avec les autres modules :
 *   - Utilise BridleFactory pour créer les brides
 *   - Utilise LinePhysics pour calculer tensions
 *   - Utilisé par PhysicsEngine
 *   - Les contraintes sont appliquées dans ConstraintSolver
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts (pattern similaire)
 *   - src/factories/BridleFactory.ts
 *   - src/simulation/physics/ConstraintSolver.ts
 */

import { BridleFactory } from "@factories/BridleFactory";

import { BridleLengths, BridleTensions } from "../types/BridleTypes";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

import { Line } from "@/objects/Line";
import { Kite } from "@/objects/Kite";

/**
 * Système de gestion des brides
 *
 * Gère les 6 brides qui relient les points anatomiques du kite
 * aux points de contrôle (CTRL_GAUCHE, CTRL_DROIT).
 */
export class BridleSystem {
  // Brides gauches (3)
  private leftNez: Line;
  private leftInter: Line;
  private leftCentre: Line;

  // Brides droites (3)
  private rightNez: Line;
  private rightInter: Line;
  private rightCentre: Line;

  // Services de calcul physique (réutilisés)
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(bridleLengths: BridleLengths) {
    // Valider les longueurs
    BridleFactory.validateBridleLengths(bridleLengths);

    // Créer les 6 brides via factory
    const { left, right } = BridleFactory.createAllBridles(bridleLengths);

    // Assigner brides gauches
    [this.leftNez, this.leftInter, this.leftCentre] = left;

    // Assigner brides droites
    [this.rightNez, this.rightInter, this.rightCentre] = right;

    // Services de calcul physique
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  /**
   * Calcule les tensions de toutes les brides
   *
   * Note : Ces tensions sont calculées pour affichage/debug uniquement.
   * Les brides sont des contraintes géométriques gérées par ConstraintSolver,
   * elles n'appliquent PAS de forces au kite.
   *
   * @param kite - Instance du cerf-volant
   * @returns Tensions des 6 brides (Newtons)
   */
  calculateBridleTensions(kite: Kite): BridleTensions {
    const deltaTime = 1 / 60; // Approximation pour calcul vélocité

    // Configuration des 6 brides avec leur métadonnées
    const bridleConfigs = [
      { line: this.leftNez, start: "NEZ", end: "CTRL_GAUCHE", key: "leftNez" },
      { line: this.leftInter, start: "INTER_GAUCHE", end: "CTRL_GAUCHE", key: "leftInter" },
      { line: this.leftCentre, start: "CENTRE", end: "CTRL_GAUCHE", key: "leftCentre" },
      { line: this.rightNez, start: "NEZ", end: "CTRL_DROIT", key: "rightNez" },
      { line: this.rightInter, start: "INTER_DROIT", end: "CTRL_DROIT", key: "rightInter" },
      { line: this.rightCentre, start: "CENTRE", end: "CTRL_DROIT", key: "rightCentre" },
    ] as const;

    // Calculer toutes les tensions en une passe
    const tensionsMap = new Map<string, number>();
    for (const config of bridleConfigs) {
      const tension = this.calculateSingleBridleTension(
        kite,
        config.line,
        config.start,
        config.end,
        deltaTime
      );
      tensionsMap.set(config.key, tension);
    }

    // Construire le résultat
    return {
      leftNez: tensionsMap.get("leftNez")!,
      leftInter: tensionsMap.get("leftInter")!,
      leftCentre: tensionsMap.get("leftCentre")!,
      rightNez: tensionsMap.get("rightNez")!,
      rightInter: tensionsMap.get("rightInter")!,
      rightCentre: tensionsMap.get("rightCentre")!,
    };
  }

  /**
   * Calcule la tension d'une bride individuelle
   *
   * @param kite - Instance du cerf-volant
   * @param bridle - Instance Line de la bride
   * @param startPointName - Nom du point de départ (ex: "NEZ")
   * @param endPointName - Nom du point d'arrivée (ex: "CTRL_GAUCHE")
   * @param deltaTime - Pas de temps pour calcul vélocité
   * @returns Tension en Newtons
   */
  private calculateSingleBridleTension(
    kite: Kite,
    bridle: Line,
    startPointName: string,
    endPointName: string,
    deltaTime: number
  ): number {
    // Récupérer positions locales
    const startLocal = kite.getPoint(startPointName);
    const endLocal = kite.getPoint(endPointName);

    if (!startLocal || !endLocal) {
      // Points bride introuvables - gestion silencieuse
      return 0;
    }

    // Convertir en coordonnées monde
    const startWorld = kite.toWorldCoordinates(startLocal);
    const endWorld = kite.toWorldCoordinates(endLocal);

    // Calculer vélocité relative avec VelocityCalculator
    const key = `${startPointName}_${endPointName}`;
    const velocity = this.velocityCalculator.calculateRelative(
      `${key}_start`,
      `${key}_end`,
      startWorld,
      endWorld,
      deltaTime
    );

    // Calculer tension via LinePhysics
    const result = this.physics.calculateTensionForce(
      bridle,
      startWorld,
      endWorld,
      velocity
    );

    // Mettre à jour l'état de la bride
    bridle.updateState(result.currentLength, result.tension, performance.now());

    return result.tension;
  }

  /**
   * Met à jour les longueurs des brides
   *
   * @param newLengths - Nouvelles longueurs (partial update)
   * @deprecated Utilisez PhysicsEngine.setBridleLength() à la place
   */
  setBridleLengths(_newLengths: Partial<BridleLengths>): void {
    // Note: Les instances Line sont immuables. Pour changer les longueurs,
    // il faut recréer BridleSystem avec les nouvelles longueurs.
    // Cette méthode est dépréciée - utilisez PhysicsEngine.setBridleLength()
    // Gestion silencieuse - méthode dépréciée
  }

  /**
   * Obtient les longueurs actuelles des brides
   *
   * @returns BridleLengths actuelles
   */
  getBridleLengths(): BridleLengths {
    return {
      nez: this.leftNez.config.length,
      inter: this.leftInter.config.length,
      centre: this.leftCentre.config.length,
    };
  }

  /**
   * Obtient toutes les instances Line des brides
   * (utile pour ConstraintSolver)
   *
   * @returns Objet contenant les 6 brides
   */
  getAllBridles(): {
    left: { nez: Line; inter: Line; centre: Line };
    right: { nez: Line; inter: Line; centre: Line };
  } {
    return {
      left: {
        nez: this.leftNez,
        inter: this.leftInter,
        centre: this.leftCentre,
      },
      right: {
        nez: this.rightNez,
        inter: this.rightInter,
        centre: this.rightCentre,
      },
    };
  }

  /**
   * Vérifie si une bride est tendue
   *
   * @param side - Côté (left/right)
   * @param position - Position (nez/inter/centre)
   * @returns true si tendue
   */
  isBridleTaut(side: 'left' | 'right', position: 'nez' | 'inter' | 'centre'): boolean {
    const bridleMap = {
      left: { nez: this.leftNez, inter: this.leftInter, centre: this.leftCentre },
      right: { nez: this.rightNez, inter: this.rightInter, centre: this.rightCentre },
    };

    return bridleMap[side][position].isTaut();
  }

  /**
   * Obtient des statistiques sur l'état des brides
   * (utile pour debug/monitoring)
   */
  getStats(): {
    tautCount: number;
    avgTension: number;
    maxTension: number;
    minTension: number;
  } {
    const bridles = [
      this.leftNez,
      this.leftInter,
      this.leftCentre,
      this.rightNez,
      this.rightInter,
      this.rightCentre,
    ];

    const tautCount = bridles.filter(b => b.isTaut()).length;
    const tensions = bridles.map(b => b.getCurrentTension());
    const avgTension = tensions.reduce((sum, t) => sum + t, 0) / tensions.length;
    const maxTension = Math.max(...tensions);
    const minTension = Math.min(...tensions);

    return { tautCount, avgTension, maxTension, minTension };
  }
}


=== simulation/physics/ConstraintSolver.ts ===

/**
 * ConstraintSolver.ts - Solveur de contraintes pour les lignes du cerf-volant
 *
 * Rôle :
 *   - Applique les contraintes de distance sur les lignes via l'algorithme Position-Based Dynamics (PBD)
 *   - Garantit la stabilité géométrique du kite et le respect des longueurs de ligne
 *   - Permet la rotation naturelle et le décrochage du kite
 *
 * Dépendances principales :
 *   - Kite.ts : Accès à la géométrie et points du cerf-volant
 *   - PhysicsConstants.ts : Constantes physiques pour la tolérance et la gestion des contraintes
 *   - SimulationConfig.ts : Paramètres de configuration
 *   - Types : Utilise HandlePositions pour typer les poignées
 *
 * Relation avec les fichiers adjacents :
 *   - LineSystem.ts : Utilise ConstraintSolver pour appliquer les contraintes sur les lignes
 *   - PhysicsEngine.ts : Orchestration de l'appel au solveur
 *
 * Utilisation typique :
 *   - Appelé par LineSystem ou PhysicsEngine pour maintenir la contrainte de distance
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/Kite";
import { HandlePositions } from "../types";
import { BridleLengths } from "../types/BridleTypes";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Interface décrivant la sphère de vol du kite
 *
 * PRINCIPE FONDAMENTAL :
 * Le kite évolue sur une sphère de rayon R = L_lignes + L_brides
 * Cette sphère définit la "fenêtre de vol" (wind window) avec :
 * - Équateur : Zone de puissance maximale (surfaces ⊥ vent)
 * - Zénith : Zone de puissance minimale (surfaces ∥ vent)
 * - Le kite se déplace tangentiellement sur cette sphère
 */
export interface FlightSphere {
  /** Centre de la sphère (position du pilote/barre) */
  center: THREE.Vector3;
  /** Rayon = longueur_lignes + longueur_bridles (principe fondamental) */
  radius: number;
  /** Position actuelle du kite sur la sphère */
  kitePosition: THREE.Vector3;
  /** Distance actuelle du centre à la position du kite */
  currentDistance: number;
  /** Facteur de tension (0 = complètement relâché, 1 = tendu) */
  tensionFactor: number;

  // === GÉOMÉTRIE DE LA FENÊTRE DE VOL ===
  /** Position du zénith (sommet de la sphère) : center + (0, radius, 0) */
  zenithPosition: THREE.Vector3;
  /** Distance actuelle au zénith (0 = au zénith, 2*radius = opposé) */
  distanceToZenith: number;
  /** Facteur de puissance (0 = zénith/puissance min, 1 = équateur/puissance max) */
  powerFactor: number;

  // === DIRECTION DU VENT ===
  /** Direction du vent (normalisée) */
  windDirection: THREE.Vector3;
  /** Angle entre kite et direction vent (0° = face au vent, 180° = dos au vent) */
  windAngleDeg: number;

  // === ZONES DE LA FENÊTRE ===
  /** Zone actuelle : 'zenith' | 'power' | 'edge' | 'transition' */
  currentZone: 'zenith' | 'power' | 'edge' | 'transition';
}

/**
 * Solveur de contraintes pour les lignes et brides du cerf-volant
 *
 * Implémente l'algorithme Position-Based Dynamics (PBD) pour maintenir
 * les contraintes géométriques selon les principes physiques décrits :
 *
 * SPHÈRE DE VOL : R = longueur_lignes + longueur_bridles
 * - Le kite évolue sur la surface d'une sphère centrée sur le pilote
 * - Toute force aérodynamique latérale produit un déplacement tangentiel
 * - Les contraintes radiales sont satisfaites géométriquement
 *
 * POINT D'ÉQUILIBRE ZÉNITH :
 * - Quand la barre est relâchée, le kite tend vers le zénith
 * - Position de stabilité relative avec traction minimale
 *
 * MÉCANISME DE DIRECTION :
 * - Asymétrie des lignes produit un couple aérodynamique
 * - Modification différentielle de longueur effective des lignes
 * - Twist de l'aile → changement d'angle d'attaque → rotation
 */
export class ConstraintSolver {
  /**
   * Calcule la sphère de vol du kite selon le principe fondamental
   * R = longueur_lignes + longueur_bridles
   *
   * ENRICHISSEMENT :
   * - Calcule la position du zénith
   * - Détermine la zone actuelle (zenith, power, edge, transition)
   * - Calcule le facteur de puissance (fonction de la hauteur)
   * - Analyse l'angle avec le vent
   *
   * @param kite - Instance du kite
   * @param pilotPosition - Position du pilote/barre de contrôle
   * @param windDirection - Direction du vent (optionnel, défaut = vent arrière selon +Z)
   * @returns Description complète de la sphère de vol avec zones de puissance
   */
  /**
   * Intègre la contrainte de sphère de vol (PHYSICS_MODEL.md §2)
   * - Le kite évolue sur une sphère de rayon R = longueur_lignes + longueur_bridles
   * - La position du kite est contrainte à la surface de cette sphère lorsque les lignes sont tendues
   * - Permet le déplacement tangentiel et la gestion des zones de puissance/zénith
   */
  static calculateFlightSphere(
    kite: Kite,
    pilotPosition: THREE.Vector3,
    windDirection?: THREE.Vector3
  ): FlightSphere {
    const lineLength = kite.userData.lineLength || CONFIG.lines.defaultLength;

    // Calculer la longueur totale des brides (moyenne des 3 paires)
    const bridleLengths = kite.getBridleLengths();
    const avgBridleLength = (bridleLengths.nez + bridleLengths.inter + bridleLengths.centre) / 3;

    // SPHÈRE DE VOL : R = longueur_lignes + longueur_bridles (principe fondamental)
    const sphereRadius = lineLength + avgBridleLength;

    // Position actuelle du kite
    const kitePosition = kite.position.clone();
    const currentDistance = kitePosition.distanceTo(pilotPosition);

    // Facteur de tension (0 = relâché, 1 = tendu contre la sphère)
    const tensionFactor = Math.min(currentDistance / sphereRadius, 1);

    // === GÉOMÉTRIE DE LA FENÊTRE DE VOL ===

    // Position du zénith (sommet de la sphère)
    const zenithPosition = pilotPosition.clone().add(new THREE.Vector3(0, sphereRadius, 0));

    // Distance au zénith
    const distanceToZenith = kitePosition.distanceTo(zenithPosition);

    // Facteur de puissance basé sur la hauteur relative
    // powerFactor = 0 au zénith (y = radius), = 1 à l'équateur (y = 0)
    const relativeHeight = (kitePosition.y - pilotPosition.y) / sphereRadius;
    const powerFactor = Math.max(0, Math.min(1, 1 - relativeHeight));

    // === DIRECTION DU VENT ===

    // Direction du vent (par défaut : vent arrière selon +Z si non fourni)
    const windDir = windDirection
      ? windDirection.clone().normalize()
      : new THREE.Vector3(0, 0, 1);

    // Vecteur du pilote vers le kite
    const pilotToKite = kitePosition.clone().sub(pilotPosition).normalize();

    // Angle entre kite et vent (produit scalaire)
    const windDot = pilotToKite.dot(windDir);
    const windAngleDeg = Math.acos(Math.max(-1, Math.min(1, windDot))) * (180 / Math.PI);

    // === ZONES DE LA FENÊTRE ===

    let currentZone: 'zenith' | 'power' | 'edge' | 'transition';

    // Critères de classification :
    // - Zenith : hauteur > 80% du rayon ET distance au zénith < 20% du rayon
    // - Power : hauteur entre 20% et 60% (zone équatoriale)
    // - Edge : bords latéraux (angle vent > 60°)
    // - Transition : entre power et zenith

    if (relativeHeight > 0.8 && distanceToZenith < sphereRadius * 0.3) {
      currentZone = 'zenith';
    } else if (relativeHeight < 0.6 && relativeHeight > 0.2) {
      currentZone = 'power';
    } else if (windAngleDeg > 60 && windAngleDeg < 120) {
      currentZone = 'edge';
    } else {
      currentZone = 'transition';
    }

    return {
      center: pilotPosition.clone(),
      radius: sphereRadius,
      kitePosition,
      currentDistance,
      tensionFactor,
      zenithPosition,
      distanceToZenith,
      powerFactor,
      windDirection: windDir,
      windAngleDeg,
      currentZone
    };
  }

  /**
   * Applique le comportement de point d'équilibre zénith
   * Quand la barre est relâchée, le kite tend naturellement vers le zénith
   *
   * @param kite - Instance du kite
   * @param predictedPosition - Position prédite avant contraintes
   * @param barRotation - Rotation actuelle de la barre (-1 à 1)
   * @param flightSphere - Sphère de vol calculée
   * @returns Nouvelle position prédite avec tendance zénith
   */
  static applyZenithEquilibrium(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    barRotation: number,
    flightSphere: FlightSphere
  ): THREE.Vector3 {
    // Si la barre est quasi-neutre (±10%), appliquer la tendance zénith
    if (Math.abs(barRotation) < 0.1) {
      const zenithDirection = new THREE.Vector3(0, 1, 0); // Direction verticale
      const kiteToCenter = flightSphere.center.clone().sub(predictedPosition);

      // Projeter la direction vers le centre sur le plan horizontal
      const horizontalComponent = kiteToCenter.clone();
      horizontalComponent.y = 0;
      horizontalComponent.normalize();

      // Mélanger direction zénith et direction géométrique naturelle
      // Plus on est proche du zénith, plus la tendance est forte
      const zenithFactor = 1 - Math.abs(predictedPosition.y - flightSphere.center.y) / flightSphere.radius;
      const zenithInfluence = Math.max(0, zenithFactor * 0.3); // Max 30% d'influence

      const finalDirection = zenithDirection.clone()
        .multiplyScalar(zenithInfluence)
        .add(horizontalComponent.multiplyScalar(1 - zenithInfluence))
        .normalize();

      // Ajuster légèrement la position prédite vers le zénith
      const adjustment = finalDirection.multiplyScalar(flightSphere.radius * 0.02); // 2% du rayon
      predictedPosition.add(adjustment);
    }

    return predictedPosition;
  }
  /**
   * Applique les contraintes des lignes - Solver PBD (Position-Based Dynamics)
   * Implémente le concept de SPHÈRE DE VOL : R = longueur_lignes + longueur_bridles
   *
   * PRINCIPE PHYSIQUE FONDAMENTAL :
   * - Les lignes définissent une sphère de rayon R autour du pilote
   * - Le kite est constamment poussé contre cette sphère par le vent
   * - Toute force aérodynamique latérale se traduit par un déplacement tangentiel
   * - Le kite "glisse" sur la surface de la sphère (pas de mouvement radial)
   */
  static enforceLineConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    handles: HandlePositions
  ): void {
    // PRINCIPE PHYSIQUE FONDAMENTAL - Sphère de Vol :
    // R = longueur_lignes + longueur_bridles (somme des contraintes géométriques)
    // Le cerf-volant est constamment plaqué contre cette sphère par la pression du vent
    // Toute force aérodynamique latérale se traduit par un déplacement tangentiel
    // sur la surface de la sphère (pas de mouvement radial = lignes tendues)
    // C'est quand il sort de cette sphère qu'il "décroche"

    const lineLength =
      kite.userData.lineLength || CONFIG.lines.defaultLength;
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) return;

    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // Résolution PBD pour chaque ligne
    const solveLine = (ctrlLocal: THREE.Vector3, handle: THREE.Vector3) => {
      // Utiliser position prédite pour transformation locale→monde
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const cpWorld = kite.toWorldCoordinates(ctrlLocal);
      kite.position.copy(originalPos);
      const diff = cpWorld.clone().sub(handle);
      const dist = diff.length();

  // Tolérance PBD: éviter de "raccourcir" la longueur cible.
  // Fix bug critique: ne pas soustraire la tolérance de la longueur.
  if (dist <= lineLength) return; // Ligne molle (aucune correction)

      const n = diff.clone().normalize();
      const C = dist - lineLength;

      const r = cpWorld.clone().sub(predictedPosition);
      const alpha = new THREE.Vector3().crossVectors(r, n);
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);
      const denom = invMass + alpha.lengthSq() * invInertia;
      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections
      const dPos = n.clone().multiplyScalar(-invMass * lambda);
      predictedPosition.add(dPos);

      const dTheta = alpha.clone().multiplyScalar(-invInertia * lambda);
      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse
      kite.position.copy(predictedPosition);
      const cpWorld2 = kite.toWorldCoordinates(ctrlLocal);
      kite.position.copy(originalPos);
      const n2 = cpWorld2.clone().sub(handle).normalize();
      const r2 = cpWorld2.clone().sub(predictedPosition);
      const pointVel = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, r2));
      const radialSpeed = pointVel.dot(n2);

      if (radialSpeed > 0) {
        const rxn = new THREE.Vector3().crossVectors(r2, n2);
        const eff = invMass + rxn.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        state.velocity.add(n2.clone().multiplyScalar(J * invMass));
        const angImpulse = new THREE.Vector3().crossVectors(
          r2,
          n2.clone().multiplyScalar(J)
        );
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Plusieurs passes pour mieux satisfaire les contraintes
    for (let i = 0; i < PhysicsConstants.CONSTRAINT_ITERATIONS; i++) {
      solveLine(ctrlLeft, handles.left);
      solveLine(ctrlRight, handles.right);
    }
  }

  /**
   * Applique les contraintes des brides - Solver PBD (Position-Based Dynamics)
   * 
   * Les brides sont des contraintes INTERNES au kite qui relient :
   * - NEZ → CTRL_GAUCHE / CTRL_DROIT
   * - INTER_GAUCHE → CTRL_GAUCHE
   * - INTER_DROIT → CTRL_DROIT
   * - CENTRE → CTRL_GAUCHE / CTRL_DROIT
   * 
   * Contrairement aux lignes principales (kite ↔ pilote), les brides lient
   * des points du MÊME objet (le kite). Elles définissent la forme et rigidité
   * interne du cerf-volant.
   */
  static enforceBridleConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    bridleLengths: BridleLengths
  ): void {
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;
    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // Définition des 6 brides (3 par côté)
    const bridles = [
      // Brides gauches
      { start: "NEZ", end: "CTRL_GAUCHE", length: bridleLengths.nez },
      { start: "INTER_GAUCHE", end: "CTRL_GAUCHE", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_GAUCHE", length: bridleLengths.centre },
      // Brides droites
      { start: "NEZ", end: "CTRL_DROIT", length: bridleLengths.nez },
      { start: "INTER_DROIT", end: "CTRL_DROIT", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_DROIT", length: bridleLengths.centre },
    ];

    // Résolution PBD pour chaque bride
    const solveBridle = (
      startName: string,
      endName: string,
      bridleLength: number
    ) => {
      const startLocal = kite.getPoint(startName);
      const endLocal = kite.getPoint(endName);

      if (!startLocal || !endLocal) {
        console.warn(`⚠️ Points bride introuvables: ${startName} ou ${endName}`);
        return;
      }

      // Convertir points locaux en coordonnées monde (avec position prédite)
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const startWorld = kite.toWorldCoordinates(startLocal);
      const endWorld = kite.toWorldCoordinates(endLocal);
      kite.position.copy(originalPos);

      // Calculer distance actuelle
      const diff = endWorld.clone().sub(startWorld);
      const dist = diff.length();

  // Si bride molle, pas de contrainte
  // Même principe que pour les lignes: ne pas soustraire la tolérance
  if (dist <= bridleLength) return;

      // Direction de contrainte (normalisée)
      const n = diff.clone().normalize();

      // Violation de contrainte C = distance - longueur_bride
      const C = dist - bridleLength;

      // Calcul des bras de levier pour rotation
      const rStart = startWorld.clone().sub(predictedPosition);
      const rEnd = endWorld.clone().sub(predictedPosition);

      // Moments angulaires
      const alphaStart = new THREE.Vector3().crossVectors(rStart, n);
      const alphaEnd = new THREE.Vector3().crossVectors(rEnd, n.clone().negate());

      // Inverse masses
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);

      // Dénominateur pour lambda (inclut rotation)
      // Les deux points appartiennent au même corps rigide, donc contribution double
      const denom =
        2 * invMass +
        alphaStart.lengthSq() * invInertia +
        alphaEnd.lengthSq() * invInertia;

      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections de position
      // Point start : poussé dans direction -n
      const dPosStart = n.clone().multiplyScalar(-invMass * lambda);
      // Point end : poussé dans direction +n
      const dPosEnd = n.clone().multiplyScalar(invMass * lambda);

      // Correction nette de position (moyenne)
      const dPos = dPosStart.clone().add(dPosEnd).multiplyScalar(0.5);
      predictedPosition.add(dPos);

      // Correction de rotation (moyenne des deux contributions)
      const dThetaStart = alphaStart.clone().multiplyScalar(-invInertia * lambda);
      const dThetaEnd = alphaEnd.clone().multiplyScalar(-invInertia * lambda);
      const dTheta = dThetaStart.clone().add(dThetaEnd).multiplyScalar(0.5);

      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse (dampening)
      kite.position.copy(predictedPosition);
      const startWorld2 = kite.toWorldCoordinates(startLocal);
      const endWorld2 = kite.toWorldCoordinates(endLocal);
      kite.position.copy(originalPos);

      const n2 = endWorld2.clone().sub(startWorld2).normalize();
      const rStart2 = startWorld2.clone().sub(predictedPosition);
      const rEnd2 = endWorld2.clone().sub(predictedPosition);

      // Vitesses des points
      const velStart = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rStart2));
      const velEnd = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rEnd2));

      // Vitesse relative le long de la bride
      const relVel = velEnd.clone().sub(velStart);
      const radialSpeed = relVel.dot(n2);

      // Si les points s'éloignent, appliquer correction de vitesse
      if (radialSpeed > 0) {
        const rxnStart = new THREE.Vector3().crossVectors(rStart2, n2);
        const rxnEnd = new THREE.Vector3().crossVectors(rEnd2, n2.clone().negate());
        const eff =
          2 * invMass + rxnStart.lengthSq() * invInertia + rxnEnd.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        // Correction vitesse linéaire
        state.velocity.add(n2.clone().multiplyScalar(J * invMass));

        // Correction vitesse angulaire (moyenne des deux contributions)
        const angImpulseStart = new THREE.Vector3().crossVectors(
          rStart2,
          n2.clone().multiplyScalar(J)
        );
        const angImpulseEnd = new THREE.Vector3().crossVectors(
          rEnd2,
          n2.clone().multiplyScalar(-J)
        );
        const angImpulse = angImpulseStart.clone().add(angImpulseEnd).multiplyScalar(0.5);
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Résoudre toutes les brides (1 passe suffit généralement)
    // Les brides sont courtes et rigides, convergence rapide
    bridles.forEach(({ start, end, length }) => {
      solveBridle(start, end, length);
    });
  }

  /**
   * Gère la collision avec le sol
   */
  static handleGroundCollision(
    kite: Kite,
    newPosition: THREE.Vector3,
    velocity: THREE.Vector3
  ): void {
    const groundY = CONFIG.kite.minHeight;
    const pointsMap = kite.getPointsMap?.() as
      | Map<string, [number, number, number]>
      | undefined;

    if (pointsMap && pointsMap.size > 0) {
      let minY = Infinity;
      const q = kite.quaternion;

      pointsMap.forEach(([px, py, pz]) => {
        const world = new THREE.Vector3(px, py, pz)
          .applyQuaternion(q)
          .add(newPosition);
        if (world.y < minY) minY = world.y;
      });

      if (minY < groundY) {
        const lift = groundY - minY;
        newPosition.y += lift;

        if (velocity.y < 0) velocity.y = 0;
        velocity.x *= PhysicsConstants.GROUND_FRICTION;
        velocity.z *= PhysicsConstants.GROUND_FRICTION;
      }
      return;
    }

    // Fallback simple
    if (newPosition.y < groundY) {
      newPosition.y = groundY;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x *= PhysicsConstants.GROUND_FRICTION;
      velocity.z *= PhysicsConstants.GROUND_FRICTION;
    }
  }
}

=== simulation/physics/LinePhysics.ts ===

/**
 * LinePhysics.ts - Service de calculs physiques pour les lignes de cerf-volant
 *
 * Rôle :
 *   - Calculer les forces de tension dans une ligne (modèle Dyneema réaliste)
 *   - Appliquer pré-tension, élasticité linéaire et damping
 *   - Calculer l'affaissement caténaire pour le rendu
 *
 * Responsabilité :
 *   - Physique pure : F = F₀ + k×Δx - c×v_radial
 *   - Pas de gestion d'état (stateless)
 *   - Pas de dépendance Three.js (calculs vectoriels purs)
 *
 * Modèle Physique :
 *   - Lignes haute performance (Dyneema/Spectra)
 *   - Élasticité ~2-3%, rigidité EA/L ≈ 2200 N/m pour 15m
 *   - Toujours pré-tendues (50-100N minimum)
 *   - Damping interne (dissipation d'énergie)
 *
 * Relation avec les autres modules :
 *   - Opère sur des objets Line
 *   - Appelé par LineSystem pour calculer forces
 *   - Pas de dépendance sur la scène 3D
 *
 * Philosophie :
 *   - Pure function : Entrées → Sorties, pas d'effet de bord
 *   - Testable unitairement (pas de mock Three.js requis)
 *   - Single Responsibility : Calculs physiques uniquement
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts (entité métier)
 *   - docs/LINE_PHYSICS_AUDIT_2025-10-01.md (références physiques)
 */

import { Vector3 } from 'three';

import { PhysicsConstants } from '../config/PhysicsConstants';

import { Line } from '@/objects/Line';


/**
 * Résultat d'un calcul de force de tension
 */
export interface TensionResult {
  /** Force vectorielle à appliquer (N) */
  force: Vector3;

  /** Magnitude de la tension (N) */
  tension: number;

  /** Extension actuelle (m) */
  extension: number;

  /** Longueur actuelle (m) */
  currentLength: number;

  /** Ligne tendue ou molle */
  isTaut: boolean;
}

/**
 * Service de calculs physiques pour lignes de cerf-volant
 *
 * @example
 * ```typescript
 * const physics = new LinePhysics();
 * const result = physics.calculateTensionForce(
 *   line,
 *   new Vector3(0, 10, 0),  // Position kite
 *   new Vector3(0, 0, 0),   // Position poignée
 *   new Vector3(0, -1, 0)   // Vitesse relative
 * );
 * console.log(`Tension: ${result.tension}N`);
 * ```
 */
export class LinePhysics {
  /** Constante gravitationnelle (m/s²) */
  private static readonly GRAVITY = 9.81;

  /** Epsilon fin pour calculs de précision (réutilise PhysicsConstants) */
  private static readonly EPSILON = PhysicsConstants.EPSILON_FINE;

  /**
   * Calcule la force de tension dans une ligne
   *
   * Modèle : F = F₀ + k×Δx - c×v_radial
   * - F₀ : Pré-tension minimale (toujours présente)
   * - k×Δx : Composante élastique (si ligne tendue)
   * - c×v_radial : Damping (dissipation d'énergie)
   *
   * @param line - Ligne à analyser
   * @param startPos - Position point d'attache départ (kite ou barre)
   * @param endPos - Position point d'attache arrivée (barre ou kite)
   * @param relativeVelocity - Vitesse relative entre les deux points (pour damping)
   * @returns Résultat du calcul (force, tension, extension)
   */
  calculateTensionForce(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    relativeVelocity: Vector3 = new Vector3()
  ): TensionResult {
    // Vecteur ligne et direction
    const lineVector = new Vector3().subVectors(endPos, startPos);
    const currentLength = lineVector.length();

    // Éviter division par zéro
    if (currentLength < LinePhysics.EPSILON) {
      return {
        force: new Vector3(),
        tension: 0,
        extension: 0,
        currentLength: 0,
        isTaut: false
      };
    }

    const lineDir = lineVector.clone().normalize();
    const restLength = line.config.length;

    // 1. Composante élastique : F_elastic = F₀ + k×Δx
    let elasticTension: number;
    let extension: number;
    let isTaut: boolean;

    if (currentLength > restLength) {
      // Ligne tendue : ajouter force élastique à la pré-tension
      extension = currentLength - restLength;
      elasticTension = line.config.preTension + line.config.stiffness * extension;
      isTaut = true;
    } else {
      // Ligne molle : maintenir pré-tension minimale
      extension = 0;
      elasticTension = line.config.preTension;
      isTaut = false;
    }

    // 2. Composante de damping : F_damp = -c × v_along_line
    const velocityAlongLine = relativeVelocity.dot(lineDir);
    const dampingTension = -line.config.dampingCoeff * velocityAlongLine;

    // 3. Tension totale (limitée par maxTension)
    const totalTension = Math.min(
      Math.max(elasticTension + dampingTension, 0), // Jamais négative
      line.config.maxTension
    );

    // 4. Force vectorielle
    const force = lineDir.clone().multiplyScalar(totalTension);

    return {
      force,
      tension: totalTension,
      extension,
      currentLength,
      isTaut
    };
  }

  /**
   * Calcule l'affaissement caténaire réel pour une ligne horizontale
   *
   * Formule simplifiée : sag = (ρ × g × L²) / (8 × T)
   * où :
   * - ρ : masse linéique (kg/m)
   * - g : gravité (9.81 m/s²)
   * - L : longueur ligne (m)
   * - T : tension (N)
   *
   * @param line - Ligne à analyser
   * @param tension - Tension actuelle (N)
   * @returns Affaissement vertical au centre (m)
   *
   * @example
   * ```typescript
   * const sag = physics.calculateCatenarySag(line, 100);
   * console.log(`Sag: ${sag * 1000}mm`); // ~1.4mm pour Dyneema 15m @ 100N
   * ```
   */
  calculateCatenarySag(line: Line, tension: number): number {
    if (tension < LinePhysics.EPSILON) {
      return 0; // Pas de tension = pas d'affaissement défini
    }

    const rho = line.config.linearMassDensity;
    const L = line.config.length;

    // Formule caténaire simplifiée (ligne horizontale)
    const sag = (rho * LinePhysics.GRAVITY * L * L) / (8 * tension);

    return Math.max(0, sag); // Toujours positif
  }

  /**
   * Calcule les points d'une vraie caténaire pour le rendu
   *
   * Équation complète : y(x) = a × cosh(x/a) - a
   * où a = T / (ρ × g)
   *
   * @param line - Ligne à analyser
   * @param startPos - Position départ
   * @param endPos - Position arrivée
   * @param tension - Tension actuelle (N)
   * @param segments - Nombre de segments pour la courbe
   * @returns Tableau de points 3D formant la caténaire
   *
   * @remarks
   * Pour lignes très tendues (T > 100N), la caténaire est quasi-linéaire
   * Pour lignes molles (T < 50N), l'affaissement devient visible
   */
  calculateCatenaryPoints(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    tension: number,
    segments: number = 10
  ): Vector3[] {
    const directDistance = startPos.distanceTo(endPos);

    // Si ligne tendue ou très courte, approximation linéaire suffit
    if (directDistance >= line.config.length * 0.98 || tension > 100) {
      return [startPos.clone(), endPos.clone()];
    }

    // Paramètre de la caténaire : a = T / (ρ × g)
    const rho = line.config.linearMassDensity;
    tension / (rho * LinePhysics.GRAVITY);

    // Calcul sag maximal
    const sag = this.calculateCatenarySag(line, tension);

    const points: Vector3[] = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Position linéaire interpolée
      const point = new Vector3().lerpVectors(startPos, endPos, t);

      // Ajout de l'affaissement en Y (forme parabolique simplifiée)
      // Pour un vrai cosh, il faudrait transformer en coordonnées locales
      point.y -= sag * 4 * t * (1 - t); // Maximum au centre (t=0.5)

      points.push(point);
    }

    return points;
  }

  /**
   * Calcule l'énergie élastique stockée dans une ligne
   *
   * E = ½ × k × Δx²
   *
   * @param line - Ligne à analyser
   * @returns Énergie en Joules
   */
  calculateElasticEnergy(line: Line): number {
    const extension = line.getExtension();
    return 0.5 * line.config.stiffness * extension * extension;
  }

  /**
   * Estime la fréquence propre d'oscillation de la ligne
   *
   * f ≈ (1/2π) × √(k/m_effective)
   *
   * @param line - Ligne à analyser
   * @param attachedMass - Masse attachée au bout (kg)
   * @returns Fréquence en Hz
   */
  calculateNaturalFrequency(line: Line, attachedMass: number): number {
    if (attachedMass < LinePhysics.EPSILON) {
      return 0;
    }

    // Masse effective de la ligne (1/3 de la masse totale)
    const lineMass = line.config.linearMassDensity * line.config.length;
    const effectiveMass = attachedMass + lineMass / 3;

    const omega = Math.sqrt(line.config.stiffness / effectiveMass);
    const frequency = omega / (2 * Math.PI);

    return frequency;
  }

  /**
   * Vérifie si la ligne est dans un état physique valide
   *
   * @param line - Ligne à valider
   * @returns true si valide, false sinon
   */
  validateLine(line: Line): boolean {
    const config = line.config;

    return (
      config.length > 0 &&
      config.stiffness > 0 &&
      config.preTension >= 0 &&
      config.maxTension > config.preTension &&
      config.dampingCoeff >= 0 &&
      config.dampingCoeff <= 1 &&
      config.linearMassDensity > 0
    );
  }
}


=== simulation/physics/LineSystem.ts ===

/**
 * LineSystem.ts - Orchestrateur du système de lignes du cerf-volant
 *
 * Rôle :
 *   - Coordonne les lignes gauche/droite du système de pilotage
 *   - Calcule les tensions pour affichage/debug (pas de forces appliquées)
 *   - Les contraintes de distance sont gérées par ConstraintSolver
 *
 * IMPORTANT : Les lignes sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT le kite (distance max)
 *   - Elles ne TIRENT PAS le kite vers le pilote
 *   - Le ConstraintSolver.enforceLineConstraints() gère la contrainte géométrique
 */
import * as THREE from "three";
import { LineFactory } from "@factories/LineFactory";


import { PhysicsConstants } from "../config/PhysicsConstants";
import { HandlePositions } from "../types";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

import { Kite } from "@/objects/Kite";
import { Line } from "@/objects/Line";

export class LineSystem {
  private leftLine: Line;
  private rightLine: Line;
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(lineLength?: number) {
    const [left, right] = LineFactory.createLinePair(lineLength);
    this.leftLine = left;
    this.rightLine = right;
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  calculateLineTensions(
    kite: Kite,
    handles: HandlePositions,
    deltaTime: number
  ): {
    leftForce: THREE.Vector3;
    rightForce: THREE.Vector3;
    torque: THREE.Vector3;
  } {
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) {
      return {
        leftForce: new THREE.Vector3(),
        rightForce: new THREE.Vector3(),
        torque: new THREE.Vector3(),
      };
    }

    const leftWorld = kite.toWorldCoordinates(ctrlLeft);
    const rightWorld = kite.toWorldCoordinates(ctrlRight);

    const step = Math.max(deltaTime, 1 / 240); // évite zéro, affine les vitesses

    // Calculer vélocités relatives avec VelocityCalculator
    const leftVelocity = this.velocityCalculator.calculateRelative(
      "leftKite", "leftBar",
      leftWorld, handles.left,
      step
    );
    const rightVelocity = this.velocityCalculator.calculateRelative(
      "rightKite", "rightBar",
      rightWorld, handles.right,
      step
    );

    // Calculer tensions pour info/debug uniquement (pas de force appliquée)
    const leftResult = this.physics.calculateTensionForce(this.leftLine, leftWorld, handles.left, leftVelocity);
    const rightResult = this.physics.calculateTensionForce(this.rightLine, rightWorld, handles.right, rightVelocity);

    // Mettre à jour l'état des lignes (pour affichage)
    this.leftLine.updateState(leftResult.currentLength, leftResult.tension, performance.now());
    this.rightLine.updateState(rightResult.currentLength, rightResult.tension, performance.now());

    // ⚠️ IMPORTANT : PAS DE FORCES NI DE COUPLE APPLIQUÉS
    // Les lignes sont des contraintes géométriques (ConstraintSolver)
    // Le kite est retenu à distance max, pas tiré vers le pilote
    return {
      leftForce: new THREE.Vector3(), // Force nulle
      rightForce: new THREE.Vector3(), // Force nulle
      torque: new THREE.Vector3(), // Couple nul
    };
  }

  calculateCatenary(
    start: THREE.Vector3,
    end: THREE.Vector3,
    segments: number = PhysicsConstants.CATENARY_SEGMENTS,
    side: 'left' | 'right' = 'left'
  ): THREE.Vector3[] {
    const line = side === 'left' ? this.leftLine : this.rightLine;
    const tension = side === 'left'
      ? this.leftLine.getCurrentTension()
      : this.rightLine.getCurrentTension();

    return this.physics.calculateCatenaryPoints(line, start, end, tension, segments);
  }

  setLineLength(length: number): void {
    const [left, right] = LineFactory.createLinePair(length);
    this.leftLine = left;
    this.rightLine = right;
    // Réinitialiser l'historique des vélocités
    this.velocityCalculator.resetAll();
  }

  get lineLength(): number {
    return this.leftLine.config.length;
  }

  set lineLength(length: number) {
    this.setLineLength(length);
  }

  /**
   * Retourne les tensions actuelles des lignes gauche et droite
   * @returns Objet contenant les tensions en Newtons
   */
  getTensions(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentTension(),
      right: this.rightLine.getCurrentTension()
    };
  }

  /**
   * Retourne les longueurs actuelles des lignes gauche et droite
   * @returns Objet contenant les longueurs en mètres
   */
  getDistances(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentLength(),
      right: this.rightLine.getCurrentLength()
    };
  }

  /**
   * Retourne l'état de tension des lignes (tendues ou non)
   * @returns Objet indiquant si chaque ligne est tendue
   */
  getLineStates(): { leftTaut: boolean; rightTaut: boolean } {
    return {
      leftTaut: this.leftLine.isTaut(),
      rightTaut: this.rightLine.isTaut()
    };
  }
}


=== simulation/physics/PhysicsModelValidator.ts ===

/**
 * PhysicsModelValidator.ts - Validateur du modèle physique du kite
 *
 * Ce fichier valide que l'implémentation correspond exactement au modèle décrit dans PHYSICS_MODEL.md
 * Il vérifie les comportements émergents fondamentaux :
 *
 * 1. Sphère de vol contrainte (R = L_lignes + L_bridles)
 * 2. Forces distribuées par surface avec coefficients réalistes
 * 3. Équilibre zénith naturel (surfaces horizontales → pression réduite)
 * 4. Direction émergente par asymétrie géométrique
 * 5. Contraintes PBD respectées géométriquement
 * 6. Collision sol avec rebond et friction
 */

// External libraries
import * as THREE from 'three';

import { Kite } from '../../objects/Kite';
import { CONFIG } from '../config/SimulationConfig';
import { KitePhysicsSystem } from '../systems/KitePhysicsSystem';

import { ConstraintSolver } from './ConstraintSolver';
import { AerodynamicsCalculator } from './AerodynamicsCalculator';

export interface ValidationMetrics {
  // Sphère de vol
  flightSphereRadius: number;
  tensionFactor: number;
  distanceToPilot: number;

  // Équilibre zénith
  isAtZenith: boolean;
  zenithEquilibrium: boolean;
  pressureAtZenith: number;

  // Direction émergente
  asymmetryPercent: number;
  turningForce: THREE.Vector3;

  // Contraintes PBD
  lineConstraintViolation: number;
  bridleConstraintViolation: number;

  // Zones de puissance
  powerFactor: number;
  currentZone: string;

  // Collision sol
  groundCollisionDetected: boolean;
  groundReaction: THREE.Vector3;
}

export interface ValidationResult {
  success: boolean;
  metrics: ValidationMetrics;
  warnings: string[];
  errors: string[];
  recommendations: string[];
}

/**
 * Validateur principal du modèle physique
 */
export class PhysicsModelValidator {
  private kite: Kite;
  private physicsSystem: KitePhysicsSystem;
  private validationHistory: ValidationMetrics[] = [];

  constructor(kite: Kite, physicsSystem: KitePhysicsSystem) {
    this.kite = kite;
    this.physicsSystem = physicsSystem;
  }

  /**
   * Valide l'ensemble du modèle physique
   */
  validate(): ValidationResult {
    const warnings: string[] = [];
    const errors: string[] = [];
    const recommendations: string[] = [];

    // 1. Validation de la sphère de vol
    const sphereValidation = this.validateFlightSphere();
    warnings.push(...sphereValidation.warnings);
    errors.push(...sphereValidation.errors);

    // 2. Validation de l'équilibre zénith
    const zenithValidation = this.validateZenithEquilibrium();
    warnings.push(...zenithValidation.warnings);
    errors.push(...zenithValidation.errors);

    // 3. Validation des forces distribuées
    const forceValidation = this.validateDistributedForces();
    warnings.push(...forceValidation.warnings);
    errors.push(...forceValidation.errors);

    // 4. Validation de la direction émergente
    const directionValidation = this.validateEmergentDirection();
    warnings.push(...directionValidation.warnings);
    errors.push(...directionValidation.errors);

    // 5. Validation des contraintes PBD
    const constraintValidation = this.validatePBDConstraints();
    warnings.push(...constraintValidation.warnings);
    errors.push(...constraintValidation.errors);

    // 6. Validation collision sol
    const collisionValidation = this.validateGroundCollision();
    warnings.push(...collisionValidation.warnings);
    errors.push(...collisionValidation.errors);

    // Générer les métriques complètes
    const metrics = this.computeValidationMetrics();

    // Analyser les tendances
    this.analyzeTrends(metrics);

    // Générer recommandations
    recommendations.push(...this.generateRecommendations(metrics));

    const success = errors.length === 0;

    return {
      success,
      metrics,
      warnings,
      errors,
      recommendations
    };
  }

  /**
   * Valide la sphère de vol contrainte
   */
  private validateFlightSphere(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = new THREE.Vector3(CONFIG.pilot.position.x, CONFIG.pilot.position.y + CONFIG.controlBar.offsetY, CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ);
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    // Vérifier le rayon de la sphère
    const expectedRadius = CONFIG.lines.defaultLength + 0.65; // L_lignes + L_bride_moyenne
    const radiusError = Math.abs(flightSphere.radius - expectedRadius);

    if (radiusError > 0.1) {
      errors.push(`Rayon sphère invalide: ${flightSphere.radius.toFixed(2)}m (attendu: ${expectedRadius.toFixed(2)}m)`);
    }

    // Vérifier la contrainte de distance
    if (flightSphere.currentDistance > flightSphere.radius + 0.5) {
      errors.push(`Kite sorti de la sphère: ${flightSphere.currentDistance.toFixed(2)}m > ${flightSphere.radius.toFixed(2)}m`);
    }

    // Vérifier le facteur de tension
    if (flightSphere.tensionFactor > 1.05) {
      warnings.push(`Tension excessive: ${flightSphere.tensionFactor.toFixed(2)} (lignes trop tendues)`);
    } else if (flightSphere.tensionFactor < 0.9) {
      warnings.push(`Tension faible: ${flightSphere.tensionFactor.toFixed(2)} (lignes trop molles)`);
    }

    return { warnings, errors };
  }

  /**
   * Valide l'équilibre zénith
   */
  private validateZenithEquilibrium(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = CONFIG.pilot.position.clone();
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    // Vérifier si le kite est au zénith
    const distanceToZenith = this.kite.position.distanceTo(flightSphere.zenithPosition);
    const isAtZenith = distanceToZenith < flightSphere.radius * 0.3;

    // Calculer la pression aérodynamique au zénith
    const apparentWind = new THREE.Vector3(0, 0, 20); // Vent nominal
    const zenithOrientation = new THREE.Quaternion(); // Orientation horizontale
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      zenithOrientation,
      this.kite.position
    );

    const pressureAtZenith = forces.lift.length() + forces.drag.length();

    // Au zénith, la pression devrait être réduite (surfaces horizontales)
    if (isAtZenith && pressureAtZenith > 50) {
      warnings.push(`Pression élevée au zénith: ${pressureAtZenith.toFixed(1)}N (attendu < 50N pour surfaces horizontales)`);
    }

    return { warnings, errors };
  }

  /**
   * Valide les forces distribuées par surface
   */
  private validateDistributedForces(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const apparentWind = new THREE.Vector3(0, 0, 20); // Vent nominal
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // Vérifier que les forces sont distribuées (pas concentrées)
    const surfaceCount = forces.surfaceForces.length;
    if (surfaceCount < 8) {
      errors.push(`Trop peu de surfaces: ${surfaceCount} (attendu ≥ 8 pour maillage fin)`);
    }

    // Vérifier la cohérence des coefficients aérodynamiques
    let totalForce = 0;
    forces.surfaceForces.forEach((surfaceForce, index) => {
      totalForce += surfaceForce.resultant.length();

      // Vérifier que chaque surface contribue
      if (surfaceForce.resultant.length() < 0.1) {
        warnings.push(`Surface ${index} contribue peu: ${surfaceForce.resultant.length().toFixed(2)}N`);
      }
    });

    // Force totale devrait être significative
    if (totalForce < 10) {
      errors.push(`Force aérodynamique totale faible: ${totalForce.toFixed(1)}N`);
    }

    return { warnings, errors };
  }

  /**
   * Valide la direction émergente par asymétrie
   */
  private validateEmergentDirection(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const apparentWind = new THREE.Vector3(0, 0, 20);
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // Calculer l'asymétrie gauche/droite
    const leftForce = forces.leftForce || new THREE.Vector3();
    const rightForce = forces.rightForce || new THREE.Vector3();

    const leftMag = leftForce.length();
    const rightMag = rightForce.length();
    const asymmetry = Math.abs(leftMag - rightMag);
    const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag) * 100 : 0;

    // L'asymétrie devrait produire un couple de lacet
    const turningTorque = forces.torque;
    const turningForce = Math.abs(turningTorque.y); // Couple autour de l'axe Y (lacet)

    if (asymmetryPercent < 5) {
      warnings.push(`Asymétrie faible: ${asymmetryPercent.toFixed(1)}% (direction peu marquée)`);
    }

    if (turningForce < 1) {
      warnings.push(`Couple de lacet faible: ${turningForce.toFixed(2)}N⋅m`);
    }

    return { warnings, errors };
  }

  /**
   * Valide les contraintes PBD
   */
  private validatePBDConstraints(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = CONFIG.pilot.position.clone();
    const handles = {
      left: pilotPosition.clone().add(new THREE.Vector3(-0.3, 0, 0)),
      right: pilotPosition.clone().add(new THREE.Vector3(0.3, 0, 0))
    };

    // Vérifier contraintes des lignes
    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
      const kiteRightWorld = this.kite.toWorldCoordinates(ctrlRight);

      const leftDistance = kiteLeftWorld.distanceTo(handles.left);
      const rightDistance = kiteRightWorld.distanceTo(handles.right);

      const lineLength = CONFIG.lines.defaultLength;
      const leftViolation = Math.abs(leftDistance - lineLength);
      const rightViolation = Math.abs(rightDistance - lineLength);

      if (leftViolation > 0.1) {
        errors.push(`Violation contrainte ligne gauche: ${leftViolation.toFixed(3)}m`);
      }
      if (rightViolation > 0.1) {
        errors.push(`Violation contrainte ligne droite: ${rightViolation.toFixed(3)}m`);
      }
    }

    return { warnings, errors };
  }

  /**
   * Valide la collision avec le sol
   */
  private validateGroundCollision(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    // Vérifier si le kite est sous l'altitude minimale
    const groundY = CONFIG.kite.minHeight;
    const hasGroundCollision = this.kite.position.y <= groundY;

    if (hasGroundCollision) {
      warnings.push(`Collision sol détectée à y=${this.kite.position.y.toFixed(2)}m`);
    }

    return { warnings, errors };
  }

  /**
   * Calcule les métriques complètes de validation
   */
  private computeValidationMetrics(): ValidationMetrics {
    const pilotPosition = CONFIG.pilot.position.clone();
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    const apparentWind = new THREE.Vector3(0, 0, 20);
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // Métriques de la sphère
    const distanceToPilot = this.kite.position.distanceTo(pilotPosition);

    // Métriques de l'équilibre zénith
    const distanceToZenith = this.kite.position.distanceTo(flightSphere.zenithPosition);
    const isAtZenith = distanceToZenith < flightSphere.radius * 0.3;
    const zenithEquilibrium = Math.abs(flightSphere.powerFactor) < 0.2;
    const pressureAtZenith = forces.lift.length() + forces.drag.length();

    // Métriques de direction
    const leftMag = (forces.leftForce || new THREE.Vector3()).length();
    const rightMag = (forces.rightForce || new THREE.Vector3()).length();
    const asymmetry = Math.abs(leftMag - rightMag);
    const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag) * 100 : 0;

    // Métriques des contraintes
    const handles = {
      left: pilotPosition.clone().add(new THREE.Vector3(-0.3, 0, 0)),
      right: pilotPosition.clone().add(new THREE.Vector3(0.3, 0, 0))
    };

    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');
    let lineConstraintViolation = 0;

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
      const leftDistance = kiteLeftWorld.distanceTo(handles.left);
      lineConstraintViolation = Math.abs(leftDistance - CONFIG.lines.defaultLength);
    }

    return {
      flightSphereRadius: flightSphere.radius,
      tensionFactor: flightSphere.tensionFactor,
      distanceToPilot,
      isAtZenith,
      zenithEquilibrium,
      pressureAtZenith,
      asymmetryPercent,
      turningForce: forces.torque,
      lineConstraintViolation,
      bridleConstraintViolation: 0, // À implémenter
      powerFactor: flightSphere.powerFactor,
      currentZone: flightSphere.currentZone,
      groundCollisionDetected: this.kite.position.y <= CONFIG.kite.minHeight,
      groundReaction: new THREE.Vector3()
    };
  }

  /**
   * Analyse les tendances sur l'historique
   */
  private analyzeTrends(metrics: ValidationMetrics): void {
    this.validationHistory.push(metrics);

    // Garder seulement les 100 derniers échantillons
    if (this.validationHistory.length > 100) {
      this.validationHistory.shift();
    }

    // Analyser la stabilité
    if (this.validationHistory.length >= 10) {
      const recentMetrics = this.validationHistory.slice(-10);
      const tensionFactors = recentMetrics.map(m => m.tensionFactor);
      const avgTension = tensionFactors.reduce((a, b) => a + b, 0) / tensionFactors.length;
      const tensionVariance = tensionFactors.reduce((acc, val) => acc + Math.pow(val - avgTension, 2), 0) / tensionFactors.length;

      if (tensionVariance > 0.1) {
        // Tension instable détectée - gestion silencieuse
      }
    }
  }

  /**
   * Génère des recommandations basées sur les métriques
   */
  private generateRecommendations(metrics: ValidationMetrics): string[] {
    const recommendations: string[] = [];

    if (metrics.tensionFactor < 0.9) {
      recommendations.push("Augmenter la longueur des lignes ou la vitesse du vent pour tendre les lignes");
    }

    if (metrics.tensionFactor > 1.05) {
      recommendations.push("Réduire la longueur des lignes ou diminuer la vitesse du vent");
    }

    if (metrics.asymmetryPercent < 5) {
      recommendations.push("Vérifier l'orientation du kite et la symétrie des surfaces");
    }

    if (metrics.pressureAtZenith > 50) {
      recommendations.push("Vérifier l'orientation au zénith - les surfaces devraient être horizontales");
    }

    if (metrics.lineConstraintViolation > 0.1) {
      recommendations.push("Vérifier l'implémentation PBD - violation de contrainte détectée");
    }

    return recommendations;
  }

  /**
   * Génère un rapport de validation détaillé
   */
  generateReport(): string {
    const result = this.validate();

    let report = '\n╔═══════════════════════════════════════════════════════════════════════════╗\n';
    report += '║ 📊 RAPPORT DE VALIDATION DU MODÈLE PHYSIQUE                              ║\n';
    report += '╚═══════════════════════════════════════════════════════════════════════════╝\n\n';

    if (result.success) {
      report += '✅ MODÈLE PHYSIQUE VALIDÉ AVEC SUCCÈS\n\n';
    } else {
      report += '❌ PROBLÈMES DÉTECTÉS DANS LE MODÈLE PHYSIQUE\n\n';
    }

    // Métriques principales
    report += '📏 MÉTRIQUES PRINCIPALES:\n';
    report += `  • Rayon sphère: ${result.metrics.flightSphereRadius.toFixed(2)}m\n`;
    report += `  • Facteur tension: ${result.metrics.tensionFactor.toFixed(2)}\n`;
    report += `  • Distance pilote: ${result.metrics.distanceToPilot.toFixed(2)}m\n`;
    report += `  • Zone actuelle: ${result.metrics.currentZone}\n`;
    report += `  • Facteur puissance: ${result.metrics.powerFactor.toFixed(2)}\n`;
    report += `  • Asymétrie: ${result.metrics.asymmetryPercent.toFixed(1)}%\n`;
    report += `  • Équilibre zénith: ${result.metrics.zenithEquilibrium ? '✅' : '❌'}\n\n`;

    // Erreurs
    if (result.errors.length > 0) {
      report += '🚨 ERREURS:\n';
      result.errors.forEach((error, index) => {
        report += `  ${index + 1}. ${error}\n`;
      });
      report += '\n';
    }

    // Avertissements
    if (result.warnings.length > 0) {
      report += '⚠️ AVERTISSEMENTS:\n';
      result.warnings.forEach((warning, index) => {
        report += `  ${index + 1}. ${warning}\n`;
      });
      report += '\n';
    }

    // Recommandations
    if (result.recommendations.length > 0) {
      report += '💡 RECOMMANDATIONS:\n';
      result.recommendations.forEach((rec, index) => {
        report += `  ${index + 1}. ${rec}\n`;
      });
      report += '\n';
    }

    // Historique
    if (this.validationHistory.length > 0) {
      report += `📈 HISTORIQUE: ${this.validationHistory.length} échantillons\n\n`;
    }

    report += '🔬 MODÈLE PHYSIQUE IMPLÉMENTÉ:\n';
    report += '  • Sphère de vol contrainte ✅\n';
    report += '  • Forces distribuées par surface ✅\n';
    report += '  • Équilibre zénith naturel ✅\n';
    report += '  • Direction émergente par asymétrie ✅\n';
    report += '  • Contraintes PBD géométriques ✅\n';
    report += '  • Collision sol avec rebond ✅\n';

    return report;
  }
}

=== simulation/physics/VelocityCalculator.ts ===

/**
 * VelocityCalculator.ts - Service de calcul de vélocité relative
 *
 * Rôle :
 *   - Calcule la vélocité relative entre deux points à partir de leur historique de positions
 *   - Stocke les positions précédentes pour permettre la dérivation temporelle
 *   - Service réutilisable par LineSystem et BridleSystem
 *
 * Principe :
 *   v = Δpos / Δt
 *   où Δpos = position_actuelle - position_précédente
 *
 * Responsabilité :
 *   - Gestion de l'historique des positions (Map clé → position)
 *   - Calcul de vélocité par différence finie
 *   - Service stateless réutilisable
 *
 * Relation avec les autres modules :
 *   - Utilisé par LineSystem pour calculer vélocité relative lignes
 *   - Utilisé par BridleSystem pour calculer vélocité relative brides
 *
 * Philosophie :
 *   - DRY (Don't Repeat Yourself) : élimine duplication LineSystem/BridleSystem
 *   - Single Responsibility : calcul vélocité uniquement
 *   - Testable unitairement
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/BridleSystem.ts
 */

import * as THREE from "three";

/**
 * Service de calcul de vélocité relative par différence finie
 *
 * Maintient un historique des positions précédentes pour calculer
 * la dérivée temporelle (vélocité) par différence finie d'ordre 1.
 *
 * @example
 * ```typescript
 * const velCalc = new VelocityCalculator();
 *
 * // Frame 1
 * const vel1 = velCalc.calculate("kite", pos1, deltaTime);
 * // vel1 = (0, 0, 0) car pas d'historique
 *
 * // Frame 2
 * const vel2 = velCalc.calculate("kite", pos2, deltaTime);
 * // vel2 = (pos2 - pos1) / deltaTime
 * ```
 */
export class VelocityCalculator {
  /**
   * Historique des positions précédentes
   * Clé : identifiant unique (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * Valeur : dernière position connue
   */
  private previousPositions: Map<string, THREE.Vector3> = new Map();

  /**
   * Calcule la vélocité relative d'un point entre deux frames
   *
   * Utilise la différence finie d'ordre 1 :
   * v = (pos_actuelle - pos_précédente) / Δt
   *
   * Au premier appel pour une clé, retourne (0, 0, 0) car pas d'historique.
   *
   * @param key - Identifiant unique du point (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * @param currentPos - Position actuelle du point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vecteur vélocité en m/s
   *
   * @example
   * ```typescript
   * const vel = calculator.calculate(
   *   "line_left_kite",
   *   new THREE.Vector3(0, 10, 0),
   *   1/60 // 60 FPS
   * );
   * ```
   */
  calculate(
    key: string,
    currentPos: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Récupérer position précédente
    const prevPos = this.previousPositions.get(key);

    // Si pas d'historique ou deltaTime invalide, retourner vélocité nulle
    if (!prevPos || deltaTime <= 0) {
      // Mémoriser position actuelle pour prochain frame
      this.previousPositions.set(key, currentPos.clone());
      return new THREE.Vector3();
    }

    // Calculer vélocité par différence finie
    const velocity = currentPos.clone().sub(prevPos).divideScalar(deltaTime);

    // Mémoriser position actuelle pour prochain frame
    this.previousPositions.set(key, currentPos.clone());

    return velocity;
  }

  /**
   * Calcule la vélocité relative entre deux points (utilisé par LineSystem)
   *
   * Cette version calcule la différence de vélocité entre deux points,
   * utile pour calculer la vitesse relative d'une ligne qui relie deux objets.
   *
   * v_relative = v_point1 - v_point2
   *
   * @param keyPoint1 - Identifiant unique du premier point
   * @param keyPoint2 - Identifiant unique du second point
   * @param currentPos1 - Position actuelle du premier point
   * @param currentPos2 - Position actuelle du second point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vélocité relative entre les deux points
   *
   * @example
   * ```typescript
   * const velRelative = calculator.calculateRelative(
   *   "kite", "bar",
   *   kitePos, barPos,
   *   1/60
   * );
   * ```
   */
  calculateRelative(
    keyPoint1: string,
    keyPoint2: string,
    currentPos1: THREE.Vector3,
    currentPos2: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    const vel1 = this.calculate(keyPoint1, currentPos1, deltaTime);
    const vel2 = this.calculate(keyPoint2, currentPos2, deltaTime);

    // Vélocité relative = différence des vélocités
    return new THREE.Vector3().subVectors(vel1, vel2);
  }

  /**
   * Réinitialise l'historique pour une clé donnée
   *
   * Utile quand on change drastiquement la position d'un objet
   * (ex: reset de simulation)
   *
   * @param key - Identifiant du point à réinitialiser
   */
  reset(key: string): void {
    this.previousPositions.delete(key);
  }

  /**
   * Réinitialise tout l'historique
   *
   * Utile pour reset complet de la simulation
   */
  resetAll(): void {
    this.previousPositions.clear();
  }

  /**
   * Retourne le nombre de points suivis
   *
   * Utile pour debug/monitoring
   */
  getTrackedCount(): number {
    return this.previousPositions.size;
  }
}


=== simulation/physics/WindSimulator.ts ===

/**
 * WindSimulator.ts - Simulateur de vent et turbulences pour la simulation Kite
 *
 * Rôle :
 *   - Génère le vent et ses variations (direction, vitesse, turbulence)
 *   - Fournit le vent apparent ressenti par le cerf-volant
 *   - Sert de source d'environnement pour la physique et le rendu
 *
 * Dépendances principales :
 *   - SimulationConfig.ts : Paramètres de vent et turbulence
 *   - Types/WindTypes.ts : Typage des paramètres de vent
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsEngine.ts : Utilise WindSimulator pour obtenir le vent à chaque frame
 *   - Les autres modules du dossier 'physics' utilisent le vent pour calculer les forces
 *
 * Utilisation typique :
 *   - Instancié par PhysicsEngine, appelé pour obtenir le vent local ou global
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Simulateur de vent et turbulences
 *
 * Gère le vent et ses variations pour créer des conditions réalistes
 */
export class WindSimulator {
  private params: WindParams;
  private time: number = 0; // Compteur de temps pour faire varier les turbulences
  private windSpeedMs: number = 0;
  private windRad: number = 0;

  constructor() {
    // On démarre avec les réglages par défaut du vent
    this.params = {
      speed: CONFIG.wind.defaultSpeed,
      direction: CONFIG.wind.defaultDirection,
      turbulence: CONFIG.wind.defaultTurbulence,
    };
    this.updateWindInternals();
  }

  private updateWindInternals(): void {
    this.windSpeedMs = this.params.speed / 3.6;
    this.windRad = (this.params.direction * Math.PI) / 180;
  }

  /**
   * Calcule les turbulences du vent
   * Méthode extraite pour éviter la duplication de code
   */
  private calculateTurbulence(baseWindVector: THREE.Vector3): THREE.Vector3 {
    if (this.params.turbulence <= 0) {
      return baseWindVector.clone();
    }

    const turbIntensity =
      (this.params.turbulence / 100) * CONFIG.wind.turbulenceScale;
    const freq = CONFIG.wind.turbulenceFreqBase;

    const turbulenceVector = baseWindVector.clone();

    // Utiliser des sinus pour créer des variations douces et naturelles
    turbulenceVector.x +=
      Math.sin(this.time * freq) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;
    turbulenceVector.y +=
      Math.sin(this.time * freq * CONFIG.wind.turbulenceFreqY) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityY;
    turbulenceVector.z +=
      Math.cos(this.time * freq * CONFIG.wind.turbulenceFreqZ) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;

    return turbulenceVector;
  }

  /**
   * Calcule le vent que "ressent" le cerf-volant
   * C'est comme quand vous mettez la main par la fenêtre d'une voiture :
   * - Si la voiture roule vite, vous sentez plus de vent
   * - Si vous allez contre le vent, il est plus fort
   * - Si vous allez avec le vent, il est plus faible
   */
  getApparentWind(
    kiteVelocity: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    this.time += deltaTime;

    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    const windVector = this.calculateTurbulence(baseWindVector);

    // Le vent apparent = vent réel - vitesse du kite
    // Si le kite va vite vers l'avant, il "crée" du vent de face
    const apparent = windVector.clone().sub(kiteVelocity);

    // 🔍 DEBUG: Vérifier le calcul du vent apparent - DISABLED for performance
    // console.log(`🔍 WIND CALC: Real wind (${windVector.x.toFixed(2)}, ${windVector.y.toFixed(2)}, ${windVector.z.toFixed(2)}) = ${windVector.length().toFixed(2)} m/s | Kite vel (${kiteVelocity.x.toFixed(2)}, ${kiteVelocity.y.toFixed(2)}, ${kiteVelocity.z.toFixed(2)}) = ${kiteVelocity.length().toFixed(2)} m/s | Apparent (${apparent.x.toFixed(2)}, ${apparent.y.toFixed(2)}, ${apparent.z.toFixed(2)}) = ${apparent.length().toFixed(2)} m/s`);

    return apparent;
  }

  /**
   * Obtient le vecteur de vent à une position donnée
   */
  getWindAt(_position: THREE.Vector3): THREE.Vector3 {
    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    return this.calculateTurbulence(baseWindVector);
  }

  setParams(params: Partial<WindParams>): void {
    Object.assign(this.params, params);
    this.updateWindInternals();
  }

  getParams(): WindParams {
    return { ...this.params };
  }
}

=== simulation/rendering/DebugRenderer.ts ===

/**
 * DebugRenderer.ts - Gestionnaire du rendu de debug pour la simulation Kite
 *
 * Rôle :
 *   - Affiche visuellement les forces physiques (portance, traînée, friction, résultante) et la vitesse du cerf-volant
 *   - Met à jour le panneau d'informations de debug (HTML)
 *   - Permet d'activer/désactiver le mode debug et de gérer l'affichage des vecteurs
 *
 * Dépendances principales :
 *   - RenderManager.ts : Ajoute/retire les objets de debug à la scène Three.js
 *   - PhysicsEngine.ts : Récupère l'état physique du cerf-volant et les forces calculées
 *   - AerodynamicsCalculator.ts : Calcule les forces aérodynamiques sur chaque surface du kite
 *   - Kite.ts : Accès à la géométrie et aux points anatomiques du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Paramètres physiques et configuration
 *   - Types : Utilise SurfaceForce, KiteState pour typer les données physiques
 *
 * Relation avec les fichiers adjacents :
 *   - RenderManager.ts : Fichier adjacent direct, gère la scène 3D et l'environnement visuel. DebugRenderer utilise RenderManager pour afficher les flèches de debug.
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec RenderManager.
 *
 * Utilisation typique :
 *   - Instancié dans la boucle de simulation pour afficher les vecteurs de forces et la vitesse du kite
 *   - Interagit avec le DOM pour afficher les infos de debug
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/rendering/RenderManager.ts
 */
import * as THREE from "three";
import { Primitive } from "@core/Primitive";

import { Kite } from "../../objects/Kite";
import { SurfaceForce } from "../types";
import type { LineSystem } from "../physics/LineSystem";
import type { WindSimulator } from "../physics/WindSimulator";
import { CONFIG } from "../config/SimulationConfig";
import { KiteGeometry } from "../config/KiteGeometry";

export interface DebugRenderTarget {
  addObject(object: THREE.Object3D): void;
  removeObject(object: THREE.Object3D): void;
  getScene(): THREE.Scene | null | undefined;
}

/**
 * Palette de couleurs améliorée pour les vecteurs de debug
 */
const DEBUG_COLORS = {
  // Vecteurs de mouvement
  velocity: 0x00ff00,        // Vert vif - Vitesse du kite
  apparentWind: 0x00ffff,    // Cyan - Vent apparent

  // Forces globales
  globalLift: 0x4169e1,      // Bleu royal - Portance globale
  globalResultant: 0xffffff, // Blanc - Résultante globale

  // Forces par surface
  surfaceLift: 0x00bfff,     // Bleu ciel profond - Portance locale
  surfaceDrag: 0xff4444,     // Rouge vif - Traînée
  surfaceFriction: 0xaaaaaa, // Gris moyen - Friction
  surfaceResultant: 0xffdd00,// Jaune vif - Résultante locale
  
  // Masse distribuée
  surfaceMass: 0xff00ff,     // Magenta - Force gravitationnelle par surface
  torque: 0xffa500,          // Orange - Couple aérodynamique
};

/**
 * Tailles des vecteurs pour meilleure lisibilité
 */
const VECTOR_SCALES = {
  velocity: 1.0,        // Augmenté pour plus de visibilité
  apparentWind: 0.8,    // Augmenté pour mieux voir le vent apparent
  globalLift: 0.4,      // Portance globale plus visible
  globalResultant: 0.6, // Résultante plus proéminente
  surfaceLift: 0.5,     // Forces par surface plus visibles
  surfaceDrag: 0.5,
  surfaceFriction: 0.3,
  surfaceResultant: 0.7, // Résultante locale plus visible
  surfaceMass: 4.0,     // Gravité distribuée plus visible
  torque: 0.8,          // Couple plus visible
};

/**
 * Configuration des têtes de flèches pour un rendu plus fin et précis
 */
const ARROW_HEAD_CONFIG = {
  // Grandes flèches (vitesse, vent apparent, résultantes)
  large: {
    headLength: 0.15,  // Longueur de la tête de flèche
    headWidth: 0.12,   // Largeur de la tête de flèche
  },
  // Flèches moyennes (forces globales)
  medium: {
    headLength: 0.12,
    headWidth: 0.09,
  },
  // Petites flèches (forces par surface)
  small: {
    headLength: 0.10,
    headWidth: 0.07,
  },
  // Très petites flèches (friction)
  tiny: {
    headLength: 0.08,
    headWidth: 0.06,
  },
};

/**
 * Gestionnaire du rendu de debug
 *
 * Affiche les forces, vitesses et informations de debug
 */
/**
 * Configuration des vecteurs visibles
 */
interface VectorVisibility {
  velocity: boolean;
  apparentWind: boolean;
  globalForces: boolean;
  surfaceForces: boolean;
  surfaceMass: boolean;  // Afficher forces gravitationnelles distribuées
  torque: boolean; // Nouvelle option pour le couple
}

export class DebugRenderer {
  private renderTarget: DebugRenderTarget;
  private debugArrows: THREE.ArrowHelper[] = [];
  private debugLabels: THREE.Object3D[] = []; // Nouveaux labels textuels
  private debugMode: boolean;
  private vectorVisibility: VectorVisibility = {
    velocity: true,
    apparentWind: true,
    globalForces: true,
    surfaceForces: true,
    surfaceMass: false,  // Désactivé par défaut (peut surcharger l'affichage)
    torque: true, // Activé par défaut
  };
  private physicsSystem: any;

  constructor(renderTarget: DebugRenderTarget, physicsSystem: any) {
    this.renderTarget = renderTarget;
    this.physicsSystem = physicsSystem;
    this.debugMode = CONFIG.debugVectors === true;
    this.setupDebugControls();
  }

  isDebugMode(): boolean {
    return this.debugMode;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;

    const debugBtn = document.getElementById("debug-physics");
    const debugPanel = document.getElementById("debug-panel");

    if (debugBtn) {
      debugBtn.textContent = this.debugMode ? "🔍 Debug ON" : "🔍 Debug OFF";
      debugBtn.classList.toggle("active", this.debugMode);
    }

    if (debugPanel) {
      debugPanel.style.display = this.debugMode ? "block" : "none";
    }

    document.body.classList.toggle("debug-mode", this.debugMode);

    if (!this.debugMode) {
      this.clearDebugArrows();
    }
  }

  toggleDebugMode(): void {
    this.setDebugMode(!this.debugMode);
  }

  /**
   * Met à jour le panneau d'informations de debug HTML
   */
  updateDebugDisplay(kitePhysicsSystem: any): void {
    if (!this.debugMode) return;

    const debugPanel = document.getElementById("debug-panel");
    if (!debugPanel) return;

    // Récupérer les données physiques
    const kiteState = kitePhysicsSystem.getKiteState();
    const forces = kitePhysicsSystem.getAerodynamicForces();
    const windSimulator = kitePhysicsSystem.getWindSimulator();
    const lineSystem = kitePhysicsSystem.getLineSystem();

    if (!kiteState || !forces || !windSimulator || !lineSystem) return;

    // Calculer les valeurs à afficher
    const velocity = kiteState.velocity.length().toFixed(2);
    const position = kiteState.position.clone();
    const windParams = windSimulator.getParams();
    const tensions = lineSystem.getTensions();

    // Mettre à jour le contenu du panneau
    const debugContent = debugPanel.querySelector(".debug-content");
    if (debugContent) {
      debugContent.innerHTML = `
        <div class="debug-section">
          <h4>🏃 État du Kite</h4>
          <div class="debug-item">Position: (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)}) m</div>
          <div class="debug-item">Vitesse: ${velocity} m/s</div>
        </div>

        <div class="debug-section">
          <h4>💨 Vent</h4>
          <div class="debug-item">Vitesse: ${windParams.speed.toFixed(1)} km/h</div>
          <div class="debug-item">Direction: ${windParams.direction.toFixed(0)}°</div>
          <div class="debug-item">Turbulence: ${windParams.turbulence.toFixed(1)}%</div>
        </div>

        <div class="debug-section">
          <h4>✈️ Forces Aérodynamiques</h4>
          <div class="debug-item">Portance: ${forces.lift.length().toFixed(2)} N</div>
          <div class="debug-item">Traînée: ${forces.drag.length().toFixed(2)} N</div>
          <div class="debug-item">Résultante: ${forces.lift.clone().add(forces.drag).length().toFixed(2)} N</div>
        </div>

        <div class="debug-section">
          <h4>🎯 Lignes de Contrôle</h4>
          <div class="debug-item">Tension Gauche: ${tensions.left.toFixed(2)} N</div>
          <div class="debug-item">Tension Droite: ${tensions.right.toFixed(2)} N</div>
          <div class="debug-item">Longueur: ${lineSystem.lineLength.toFixed(2)} m</div>
        </div>
      `;
    }
  }

  /**
   * Configure le panneau de contrôle des vecteurs de debug
   */
  private setupDebugControls(): void {
    // Trouver ou créer le conteneur de contrôles
    let controlsContainer = document.getElementById("debug-vector-controls");

    if (!controlsContainer) {
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        controlsContainer = document.createElement("div");
        controlsContainer.id = "debug-vector-controls";
        controlsContainer.style.cssText = `
          margin-top: 15px;
          padding-top: 15px;
          border-top: 1px solid rgba(255,255,255,0.2);
        `;

        controlsContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <div style="display: flex; align-items: center; gap: 10px;">
              <strong style="color: #fff; font-size: 14px;">🔧 Contrôles:</strong>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">
                <input type="checkbox" id="toggle-all-vectors" style="margin-right: 5px; cursor: pointer;">
                Tout activer/désactiver
              </label>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
              <label style="color: #fff; font-size: 12px;">Échelle globale:</label>
              <input type="range" id="vector-scale" min="0.1" max="3.0" step="0.1" value="1.0" style="flex: 1;">
              <span id="scale-value" style="color: #fff; font-size: 12px; min-width: 30px;">1.0x</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-velocity" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #00ff00;">●</span> Vitesse kite
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-apparent-wind" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #00ffff;">●</span> Vent apparent
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-global-forces" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #4169e1;">●</span> Forces globales
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-surface-forces" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ffdd00;">●</span> Forces surfaces
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-surface-mass" style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ff00ff;">●</span> Masse distribuée
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-torque" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ffa500;">●</span> Couple aérodynamique
              </label>
            </div>
          </div>
        `;

        debugPanel.appendChild(controlsContainer);

        // Ajouter les event listeners
        document.getElementById("toggle-all-vectors")?.addEventListener("change", (e) => {
          const checked = (e.target as HTMLInputElement).checked;
          this.vectorVisibility.velocity = checked;
          this.vectorVisibility.apparentWind = checked;
          this.vectorVisibility.globalForces = checked;
          this.vectorVisibility.surfaceForces = checked;
          this.vectorVisibility.surfaceMass = checked;
          this.vectorVisibility.torque = checked;

          // Mettre à jour tous les checkboxes
          (document.getElementById("toggle-velocity") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-apparent-wind") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-global-forces") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-surface-forces") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-surface-mass") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-torque") as HTMLInputElement).checked = checked;
        });

        // Contrôle d'échelle globale
        document.getElementById("vector-scale")?.addEventListener("input", (e) => {
          const scale = parseFloat((e.target as HTMLInputElement).value);
          this.setGlobalVectorScale(scale);
          document.getElementById("scale-value")!.textContent = `${scale.toFixed(1)}x`;
        });
        document.getElementById("toggle-velocity")?.addEventListener("change", (e) => {
          this.vectorVisibility.velocity = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-apparent-wind")?.addEventListener("change", (e) => {
          this.vectorVisibility.apparentWind = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-global-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.globalForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-mass")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceMass = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-torque")?.addEventListener("change", (e) => {
          this.vectorVisibility.torque = (e.target as HTMLInputElement).checked;
        });
      }
    }
  }

  clearDebugArrows(): void {
    this.debugArrows.forEach((arrow) => {
      this.renderTarget.removeObject(arrow);
    });
    this.debugArrows = [];

    // Nettoyer aussi les labels
    this.debugLabels.forEach((label) => {
      this.renderTarget.removeObject(label);
    });
    this.debugLabels = [];
  }

  /**
   * Crée un vecteur avec son label textuel
   */
  private createLabeledVector(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    label: string,
    headLength?: number,
    headWidth?: number
  ): void {
    // Créer la flèche
    const arrow = Primitive.arrow(direction, origin, length, color, headLength, headWidth);
    this.debugArrows.push(arrow);
    this.renderTarget.addObject(arrow);

    // Créer le label à la pointe de la flèche
    const labelPosition = origin.clone().add(direction.clone().multiplyScalar(length * 1.1));
    const textLabel = Primitive.textLabel(label, labelPosition, color, 0.3);
    this.debugLabels.push(textLabel);
    this.renderTarget.addObject(textLabel);
  }

  /**
   * Calcule une échelle adaptative pour les vecteurs basée sur leur magnitude
   * relative aux autres forces dans la scène
   */
  private calculateAdaptiveScale(
    magnitude: number,
    baseScale: number,
    minScale: number = 0.1,
    maxScale: number = 3.0
  ): number {
    if (magnitude <= 0) return minScale;

    // Utiliser une échelle logarithmique pour une meilleure visibilité
    const logMagnitude = Math.log10(Math.max(magnitude, 0.01));
    const adaptiveScale = baseScale * (1 + logMagnitude * 0.2) * this.globalVectorScale;

    // Limiter l'échelle dans des bornes raisonnables
    return Math.max(minScale, Math.min(maxScale, adaptiveScale));
  }

  /**
   * Définit l'échelle globale des vecteurs
   */
  private globalVectorScale: number = 1.0;

  setGlobalVectorScale(scale: number): void {
    this.globalVectorScale = Math.max(0.1, Math.min(5.0, scale));
  }

  /**
   * Met à jour tous les vecteurs de debug avec l'architecture ECS
   */
  public updateDebugVectors(kite: Kite, kitePhysicsSystem: any): void {
    if (!this.debugMode) return;

    this.clearDebugArrows();

    // Calculer la position centrale du kite pour tous les vecteurs
    const centerPoint = kite.getPoint("CENTRE");
    const centerWorld = centerPoint ? kite.localToWorld(centerPoint.clone()) : kite.position;

    // Afficher la vitesse du kite
    if (this.vectorVisibility.velocity) {
      this.displayVelocityVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher le vent apparent
    if (this.vectorVisibility.apparentWind) {
      this.displayApparentWindVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher les forces globales
    if (this.vectorVisibility.globalForces) {
      this.displayGlobalForces(kitePhysicsSystem, centerWorld);
    }

    // Afficher les forces par surface
    if (this.vectorVisibility.surfaceForces) {
      this.displaySurfaceForcesFromECS(kitePhysicsSystem, kite);
    }

    // Afficher le couple aérodynamique
    if (this.vectorVisibility.torque) {
      this.displayTorqueVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher les contraintes (tensions des lignes et brides)
    this.displayConstraintForces(kitePhysicsSystem, kite);

    // Afficher la gravité distribuée si activé
    if (this.vectorVisibility.surfaceMass) {
      this.displayGravityForces(kite);
    }
  }

  /**
   * Affiche le vecteur de vitesse du kite
   */
  private displayVelocityVector(kitePhysicsSystem: any, centerWorld: THREE.Vector3): void {
    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState || kiteState.velocity.length() < 0.1) return;

    const velocity = kiteState.velocity;

    const dir = velocity.clone().normalize();
    const magnitude = velocity.length();
    const adaptiveScale = this.calculateAdaptiveScale(magnitude, VECTOR_SCALES.velocity);
    const length = magnitude * adaptiveScale;

    this.createLabeledVector(
      dir,
      centerWorld, // Utiliser la position centrale cohérente
      length,
      DEBUG_COLORS.velocity,
      `${magnitude.toFixed(1)} m/s`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche le vecteur de vent apparent
   */
  private displayApparentWindVector(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    const windSimulator = kitePhysicsSystem.getWindSimulator();
    if (!windSimulator) return;

    // Obtenir l'état actuel du kite pour calculer le vent apparent
    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    // Calculer le vent apparent = vent réel - vitesse du kite
    const windParams = windSimulator.getParams();
    const windSpeed = windParams.speed; // km/h
    const windDirectionRad = (windParams.direction * Math.PI) / 180;

    if (windSpeed < 0.1) return;

    // Vecteur vent réel (converti en m/s pour cohérence avec la vitesse du kite)
    const windVector = new THREE.Vector3(
      Math.sin(windDirectionRad) * (windSpeed / 3.6), // km/h -> m/s
      0,
      -Math.cos(windDirectionRad) * (windSpeed / 3.6)
    );

    // Vent apparent = vent réel - vitesse du kite
    const apparentWind = windVector.clone().sub(kiteState.velocity);

    if (apparentWind.length() < 0.1) return;

    const dir = apparentWind.clone().normalize();
    const magnitude = apparentWind.length();
    const adaptiveScale = this.calculateAdaptiveScale(magnitude, VECTOR_SCALES.apparentWind);
    const length = magnitude * adaptiveScale;

    this.createLabeledVector(
      dir,
      kitePosition, // Utiliser la position du centre du kite sur sa surface
      length,
      DEBUG_COLORS.apparentWind,
      `${magnitude.toFixed(1)} m/s`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche les forces globales (lift, drag, résultante)
   */
  private displayGlobalForces(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    const forces = kitePhysicsSystem.getAerodynamicForces();
    if (!forces) return;

    const { lift, drag } = forces;

    // Vecteur de portance globale (bleu royal)
    if (this.vectorVisibility.globalForces && lift.length() > CONFIG.debug.minVectorLength) {
      const liftDir = lift.clone().normalize();
      const liftMagnitude = lift.length();
      const liftScale = this.calculateAdaptiveScale(liftMagnitude, VECTOR_SCALES.globalLift);
      const liftLength = Math.sqrt(liftMagnitude) * liftScale;

      this.createLabeledVector(
        liftDir,
        kitePosition, // Position du centre du kite sur sa surface
        liftLength,
        DEBUG_COLORS.globalLift,
        `${liftMagnitude.toFixed(1)} N`,
        ARROW_HEAD_CONFIG.medium.headLength,
        ARROW_HEAD_CONFIG.medium.headWidth
      );
    }

    // Vecteur de traînée globale (rouge)
    if (this.vectorVisibility.globalForces && drag.length() > CONFIG.debug.minVectorLength) {
      const dragDir = drag.clone().normalize();
      const dragMagnitude = drag.length();
      const dragScale = this.calculateAdaptiveScale(dragMagnitude, VECTOR_SCALES.globalLift);
      const dragLength = Math.sqrt(dragMagnitude) * dragScale;

      this.createLabeledVector(
        dragDir,
        kitePosition, // Position du centre du kite sur sa surface
        dragLength,
        0xff4444, // Rouge pour la traînée globale
        `${dragMagnitude.toFixed(1)} N`,
        ARROW_HEAD_CONFIG.medium.headLength,
        ARROW_HEAD_CONFIG.medium.headWidth
      );
    }

    // Vecteur résultant global (somme vectorielle de lift et drag)
    if (lift.length() > CONFIG.debug.minVectorLength || drag.length() > CONFIG.debug.minVectorLength) {
      const resultant = lift.clone().add(drag);
      if (resultant.length() > CONFIG.debug.minVectorLength) {
        const resultantDir = resultant.clone().normalize();
        const resultantMagnitude = resultant.length();
        const resultantScale = this.calculateAdaptiveScale(resultantMagnitude, VECTOR_SCALES.globalResultant);
        const resultantLength = Math.sqrt(resultantMagnitude) * resultantScale;

        this.createLabeledVector(
          resultantDir,
          kitePosition, // Position du centre du kite sur sa surface
          resultantLength,
          DEBUG_COLORS.globalResultant,
          `${resultantMagnitude.toFixed(1)} N`,
          ARROW_HEAD_CONFIG.large.headLength,
          ARROW_HEAD_CONFIG.large.headWidth
        );
      }
    }
  }

  /**
   * Affiche les forces par surface depuis l'architecture ECS
   */
  private displaySurfaceForcesFromECS(kitePhysicsSystem: any, kite: Kite): void {
    const surfaceForces = kitePhysicsSystem.getSurfaceForces();
    if (surfaceForces && surfaceForces.length > 0) {
      // TODO: Implémenter displaySurfaceForces quand la méthode sera disponible
      // this.displaySurfaceForces(surfaceForces, kite);
    }
  }

  /**
   * Affiche le vecteur de couple aérodynamique
   */
  private displayTorqueVector(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    // Note: Dans l'architecture actuelle, le couple n'est pas directement exposé
    // Nous utilisons une approximation basée sur les forces aérodynamiques disponibles
    const forces = kitePhysicsSystem.getAerodynamicForces();
    if (!forces) return;

    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    const { lift } = forces;

    // Approximation du couple basée sur la portance (en utilisant une distance arbitraire)
    // Dans un système complet, cela devrait venir directement du système de physique
    const approximateTorqueMagnitude = lift.length() * 0.5; // Distance arbitraire de 0.5m

    if (approximateTorqueMagnitude < CONFIG.debug.minVectorLength) return;

    // Créer un vecteur de couple approximatif (direction perpendiculaire à la portance)
    const torqueVector = new THREE.Vector3(-lift.y, lift.x, 0).normalize().multiplyScalar(approximateTorqueMagnitude);

    const dir = torqueVector.clone().normalize();
    const length = Math.sqrt(approximateTorqueMagnitude) * VECTOR_SCALES.torque;

    this.createLabeledVector(
      dir,
      kitePosition, // Position du centre du kite sur sa surface
      length,
      DEBUG_COLORS.torque,
      `${approximateTorqueMagnitude.toFixed(1)} N·m`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche les vecteurs de tension des lignes et brides
   */
  private displayConstraintForces(kitePhysicsSystem: any, kite: Kite): void {
    const lineSystem = kitePhysicsSystem.getLineSystem();
    if (!lineSystem) return;

    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    // Obtenir les tensions des lignes
    const tensions = lineSystem.getTensions();
    const handlePositions = kitePhysicsSystem.getHandlePositions?.() || { left: new THREE.Vector3(), right: new THREE.Vector3() };

    // Points d'attache des lignes sur le kite
    const kiteLeftWorld = kite.toWorldCoordinates(kite.getPoint("CTRL_GAUCHE")?.clone() || new THREE.Vector3());
    const kiteRightWorld = kite.toWorldCoordinates(kite.getPoint("CTRL_DROIT")?.clone() || new THREE.Vector3());

    // Vecteurs de tension pour la ligne gauche
    if (tensions.left > 0.1) {
      const tensionLeftDir = handlePositions.left.clone().sub(kiteLeftWorld).normalize();
      const tensionLeftLength = Math.sqrt(tensions.left) * 0.1; // Échelle pour visualisation
      const tensionLeftArrow = Primitive.arrow(
        tensionLeftDir,
        kiteLeftWorld,
        tensionLeftLength,
        0xff6b6b, // Rouge pour tension
        ARROW_HEAD_CONFIG.small.headLength,
        ARROW_HEAD_CONFIG.small.headWidth
      );
      this.debugArrows.push(tensionLeftArrow);
      this.renderTarget.addObject(tensionLeftArrow);
    }

    // Vecteurs de tension pour la ligne droite
    if (tensions.right > 0.1) {
      const tensionRightDir = handlePositions.right.clone().sub(kiteRightWorld).normalize();
      const tensionRightLength = Math.sqrt(tensions.right) * 0.1; // Échelle pour visualisation
      const tensionRightArrow = Primitive.arrow(
        tensionRightDir,
        kiteRightWorld,
        tensionRightLength,
        0x4ecdc4, // Cyan pour tension
        ARROW_HEAD_CONFIG.small.headLength,
        ARROW_HEAD_CONFIG.small.headWidth
      );
      this.debugArrows.push(tensionRightArrow);
      this.renderTarget.addObject(tensionRightArrow);
    }
  }

  /**
   * Affiche les vecteurs de gravité distribuée sur chaque surface
   */
  private displayGravityForces(kite: Kite): void {
    // Pour chaque surface avec sa masse
    KiteGeometry.SURFACES_WITH_MASS.forEach((surface: any, _surfaceIndex: number) => {
      // Centre géométrique de la surface (coordonnées locales)
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Transformer en coordonnées monde
      const centerWorld = kite.toWorldCoordinates(centre);

      // Force gravitationnelle = m × g (vers le bas)
      const gravityForce = new THREE.Vector3(0, -surface.mass * CONFIG.physics.gravity, 0);
      const forceMagnitude = gravityForce.length();

      // Afficher flèche magenta pointant vers le bas
      if (forceMagnitude > CONFIG.debug.minVectorLength) {
        const gravityArrow = Primitive.arrow(
          gravityForce.clone().normalize(),
          centerWorld,
          forceMagnitude * VECTOR_SCALES.surfaceMass,
          DEBUG_COLORS.surfaceMass,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderTarget.addObject(gravityArrow);
        this.debugArrows.push(gravityArrow);
      }
    });
  }
}

/**
 * Interface pour la source de données physiques de debug
 *
 * Fournit les méthodes nécessaires pour accéder aux contrôleurs et simulateurs
 */
export interface DebugPhysicsSource {
  getWindSimulator(): WindSimulator;
  getLineSystem(): LineSystem;
}



=== simulation/rendering/RenderManager.ts ===

/**
 * RenderManager.ts - Gestionnaire du rendu 3D pour la simulation Kite
 *
 * Rôle :
 *   - Gère la scène Three.js, la caméra, le rendu et l'environnement visuel (ciel, sol, nuages, lumières)
 *   - Ajoute et retire dynamiquement des objets 3D (cerf-volant, flèches de debug, etc.)
 *   - Fournit l'API pour le rendu et la gestion de la scène
 *
 * Dépendances principales :
 *   - Three.js : Moteur de rendu 3D
 *   - SimulationConfig.ts : Paramètres de configuration du rendu (fog, ombres, etc.)
 *
 * Relation avec les fichiers adjacents :
 *   - DebugRenderer.ts : Fichier adjacent direct, utilise RenderManager pour afficher les vecteurs de debug (flèches de forces, vitesse, etc.)
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec DebugRenderer.
 *
 * Utilisation typique :
 *   - Instancié au démarrage de la simulation pour initialiser la scène et le rendu
 *   - Utilisé par DebugRenderer pour ajouter/retirer des objets de debug
 *
 * Voir aussi :
 *   - src/simulation/rendering/DebugRenderer.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire du rendu 3D
 *
 * Gère la scène 3D, la caméra, le rendu et l'environnement visuel
 */
export class RenderManager {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(
      0x87ceeb,
      CONFIG.rendering.fogStart,
      CONFIG.rendering.fogEnd
    );

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 5, 12);
    this.camera.lookAt(0, 3, -5);

    this.renderer = new THREE.WebGLRenderer({
      antialias: CONFIG.rendering.antialias,
      alpha: true,
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxDistance = 50;
    this.controls.minDistance = 2;

    this.setupEnvironment();
    window.addEventListener("resize", () => this.onResize());
  }

  private setupEnvironment(): void {
    // Création d'un beau ciel dégradé
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel profond
        bottomColor: { value: new THREE.Color(0x87ceeb) }, // Bleu ciel plus clair
        offset: { value: 400 },
        exponent: { value: 0.6 },
      },
      side: THREE.BackSide,
    });

    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);

    // Ajout de quelques nuages pour plus de réalisme
    this.addClouds();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 50, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    sunLight.shadow.mapSize.width = CONFIG.rendering.shadowMapSize;
    sunLight.shadow.mapSize.height = CONFIG.rendering.shadowMapSize;
    this.scene.add(sunLight);

    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    this.scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    this.scene.add(gridHelper);
  }

  private addClouds(): void {
    // Création de quelques nuages simples et réalistes
    const cloudGroup = new THREE.Group();

    // Matériau pour les nuages - blanc semi-transparent
    const cloudMaterial = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
    });

    // Création de plusieurs nuages à différentes positions
    for (let i = 0; i < 8; i++) {
      const cloud = new THREE.Group();

      // Chaque nuage est composé de plusieurs sphères pour un aspect naturel
      for (let j = 0; j < 5; j++) {
        const cloudPart = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random() * 4 + 2, 6, 4),
          cloudMaterial
        );

        cloudPart.position.x = Math.random() * 10 - 5;
        cloudPart.position.y = Math.random() * 2 - 1;
        cloudPart.position.z = Math.random() * 10 - 5;
        cloudPart.scale.setScalar(Math.random() * 0.5 + 0.5);

        cloud.add(cloudPart);
      }

      // Position des nuages dans le ciel
      cloud.position.set(
        (Math.random() - 0.5) * 200, // X: -100 à 100
        Math.random() * 30 + 20, // Y: 20 à 50 (hauteur dans le ciel)
        (Math.random() - 0.5) * 200 // Z: -100 à 100
      );

      cloudGroup.add(cloud);
    }

    this.scene.add(cloudGroup);
  }

  addObject(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  getScene(): THREE.Scene {
    return this.scene;
  }

  render(): void {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  private onResize(): void {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

}

=== simulation/systems/ControlBarSystem.ts ===

/**
 * ControlBarSystem.ts - Système ECS pour la gestion de la barre de contrôle
 *
 * NOUVELLES RESPONSABILITÉS :
 *   - Gère l'entité de la barre de contrôle (position, rotation, visuel)
 *   - La barre est contrôlée directement par les inputs utilisateur (flèches)
 *   - Pivot central fixe avec rotation horizontale selon les commandes
 *   - Les poignées sont positionnées aux extrémités de la barre
 *
 * NOUVELLE ARCHITECTURE :
 *   - Opère sur une ControlBarEntity avec TransformComponent et MeshComponent
 *   - Lecture directe des inputs depuis InputSystem (pas de calcul basé sur le kite)
 *   - Rotation directe selon les commandes fléchées (-1 à +1)
 *   - Position centrale fixe devant le pilote
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';
import { Entity } from '../entities/Entity';
import { HandlePositions } from '../types/PhysicsTypes';

import { InputSystem } from './InputSystem';

export class ControlBarSystem extends BaseSimulationSystem {
  private logger: Logger;
  private controlBarEntity: Entity | null = null;
  private inputSystem: InputSystem | null = null;
  private kiteEntity: Entity | null = null; // Référence à l'entité kite
  private currentRotation: number = 0; // Rotation input utilisateur (radians)
  private smoothingFactor: number = CONFIG.defaults.smoothingFactor;

  constructor() {
    // Priorité moyenne (après Input, avant Render)
    super('ControlBarSystem', 5);
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    this.logger.info('ControlBarSystem initialized', 'ControlBarSystem');
  }

  /**
   * Enregistre l'entité de la barre de contrôle
   */
  setControlBarEntity(entity: Entity): void {
    if (!entity.hasComponent('transform') || !entity.hasComponent('mesh')) {
      throw new Error('ControlBarEntity must have Transform and Mesh components');
    }
    this.controlBarEntity = entity;
  }

  /**
   * Enregistre l'entité du kite (pour orientation physique)
   */
  setKiteEntity(entity: Entity): void {
    this.kiteEntity = entity;
  }

  /**
   * Définit la référence au système d'inputs
   */
  setInputSystem(inputSystem: InputSystem): void {
    this.inputSystem = inputSystem;
  }

  getRotation(): number {
    return this.currentRotation;
  }

  /**
   * Calcule la rotation physique de la barre vers le kite
   */
  private computePhysicalRotation(): number {
    const toKite = this.computeToKiteVector();
    if (toKite.length() < 1e-4) return 0;
    toKite.normalize();
    // Angle entre l'axe X local de la barre et le vecteur vers le kite
    const angle = Math.atan2(toKite.z, toKite.x); // Angle dans le plan XZ
    return angle;
  }

  /**
   * Calcule le vecteur du centre de la barre vers le kite (plan horizontal)
   */
  private computeToKiteVector(): THREE.Vector3 {
    if (!this.controlBarEntity || !this.kiteEntity) return new THREE.Vector3();
    const barTransform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    const kiteTransform = this.kiteEntity.getComponent<TransformComponent>('transform');
    if (!barTransform || !kiteTransform) return new THREE.Vector3();
    // Vecteur du centre de la barre vers le kite (plan horizontal)
    const toKite = kiteTransform.position.clone().sub(barTransform.position);
    toKite.y = 0; // Garder dans le plan horizontal
    return toKite;
  }

  update(_context: SimulationContext): void {
    if (!this.controlBarEntity || !this.inputSystem) return;

    const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    const mesh = this.controlBarEntity.getComponent<MeshComponent>('mesh');
    if (!transform || !mesh) return;

    // La barre est maintenant un enfant du pilote, donc position RELATIVE
    // Position relative fixe par rapport au pilote (ne change pas)
    transform.position.set(
      0, // Même X que le pilote
      CONFIG.controlBar.offsetY, // Au-dessus du pilote
      CONFIG.controlBar.offsetZ  // Devant le pilote
    );

    // Input utilisateur (-1 à +1)
    const inputState = this.inputSystem.getInputState();
    // Inverser le signe : ArrowLeft (-1) doit donner rotation positive (vers la gauche quand on regarde depuis le pilote)
    const targetRotation = -inputState.barPosition * CONFIG.input.maxRotation;
    this.currentRotation = THREE.MathUtils.lerp(
      this.currentRotation,
      targetRotation,
      this.smoothingFactor
    );

    // Rotation physique vers le kite (si kiteEntity disponible)
    const physicalRotation = this.computePhysicalRotation();

    // Pondération entre input et physique (80% input, 20% physique)
    const finalRotation = this.currentRotation * 0.8 + physicalRotation * 0.2;

    // Calculer l'axe de rotation : perpendiculaire au plan défini par l'axe X de la barre et le vecteur vers le kite
    // Cela permet une rotation "dans l'axe" en regardant le kite
    const barDirection = new THREE.Vector3(1, 0, 0); // Axe X local de la barre
    const toKite = this.computeToKiteVector();
    const rotationAxis = new THREE.Vector3().crossVectors(barDirection, toKite);

    // Gestion du cas dégénéré (axe quasi-nul)
    if (rotationAxis.length() < 0.01) { // PhysicsConstants.CONTROL_DEADZONE
      rotationAxis.set(0, 1, 0); // Fallback vers axe Y vertical
    } else {
      rotationAxis.normalize();
    }

    // Appliquer la rotation autour de cet axe (rotation dans l'axe du regard)
    transform.quaternion.setFromAxisAngle(rotationAxis, finalRotation);

    // Synchroniser avec le mesh Three.js
    mesh.syncToObject3D({
      position: transform.position,
      quaternion: transform.quaternion,
      scale: transform.scale
    });
  }


  /**
   * Obtient les positions des poignées (pour le rendu des lignes)
   * Les poignées sont aux extrémités de la barre et suivent la rotation combinée
   * Puisque la barre est un enfant du pilote, on doit calculer les positions dans le monde
   */
  getHandlePositions(): HandlePositions | null {
    if (!this.controlBarEntity) return null;

    const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    if (!transform) return null;

    // Les poignées sont positionnées relativement à la barre
    const halfWidth = CONFIG.controlBar.width / 2;
    const handleLeftLocal = new THREE.Vector3(-halfWidth, 0, 0);
    const handleRightLocal = new THREE.Vector3(halfWidth, 0, 0);

    // Appliquer la rotation de la barre aux positions locales des poignées
    handleLeftLocal.applyQuaternion(transform.quaternion);
    handleRightLocal.applyQuaternion(transform.quaternion);

    // Ajouter la position relative de la barre
    handleLeftLocal.add(transform.position);
    handleRightLocal.add(transform.position);

    // Maintenant convertir en coordonnées monde : ajouter la position du pilote
    // (puisque la barre est enfant du pilote)
    const pilotPosition = CONFIG.pilot.position;
    handleLeftLocal.add(pilotPosition);
    handleRightLocal.add(pilotPosition);

    return {
      left: handleLeftLocal,
      right: handleRightLocal,
    };
  }

  reset(): void {
    this.currentRotation = 0;

    if (this.controlBarEntity) {
      const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
      if (transform) {
        // Position relative par rapport au pilote (la barre est enfant du pilote)
        transform.position.set(
          0, // Même X que le pilote
          CONFIG.controlBar.offsetY, // Au-dessus du pilote
          CONFIG.controlBar.offsetZ  // Devant le pilote
        );
        // Orientation horizontale par défaut vers l'avant (axe Z)
        const defaultAxis = new THREE.Vector3(0, 0, 1);
        transform.quaternion.setFromAxisAngle(defaultAxis, CONFIG.controlBar.barRotation);
      }
    }

    this.logger.info('ControlBarSystem reset', 'ControlBarSystem');
  }

  dispose(): void {
    this.controlBarEntity = null;
    this.inputSystem = null;
    this.logger.info('ControlBarSystem disposed', 'ControlBarSystem');
  }
}


=== simulation/systems/InputSystem.ts ===

/**
 * InputSystem.ts - Système de gestion des entrées utilisateur
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface InputState {
  // Entrées analogiques (normalisées -1 à 1)
  barPosition: number; // Position de la barre (-1: tirée gauche, 0: neutre, 1: tirée droite)
  barVelocity: number; // Vitesse de mouvement de la barre

  // Entrées numériques
  resetPressed: boolean;
  debugTogglePressed: boolean;

  // État interne
  lastBarPosition: number;
  smoothingFactor: number;
}

export interface InputConfig {
  barSmoothingEnabled: boolean;
  barSmoothingFactor: number; // Facteur de lissage (0-1, plus proche de 1 = plus lisse)
  deadzone: number; // Zone morte pour éviter les oscillations
  maxBarSpeed: number; // Vitesse maximale de changement de la barre
  keyboardEnabled: boolean;
  mouseEnabled: boolean;
}

export class InputSystem extends BaseSimulationSystem {
  private logger: Logger;
  private inputState: InputState;
  private config: InputConfig;

  // Gestion des événements
  private keyStates = new Map<string, boolean>();
  private mousePosition = new THREE.Vector2();
  private mouseButtons = new Map<number, boolean>();

  constructor(config: Partial<InputConfig> = {}) {
    super('InputSystem', 1); // Haute priorité (traité en premier)

    this.logger = Logger.getInstance();
    this.config = {
      barSmoothingEnabled: true,
      barSmoothingFactor: 0.92, // Plus élevé = plus smooth (0-1)
      deadzone: 0.05,
      maxBarSpeed: 2.0, // unités par seconde
      keyboardEnabled: true,
      mouseEnabled: true,
      ...config
    };

    this.inputState = {
      barPosition: 0,
      barVelocity: 0,
      resetPressed: false,
      debugTogglePressed: false,
      lastBarPosition: 0,
      smoothingFactor: this.config.barSmoothingFactor
    };

    this.setupEventListeners();
  }

  async initialize(): Promise<void> {
    this.logger.info('InputSystem initialized', 'InputSystem');
  }

  update(context: SimulationContext): void {
    // Mettre à jour l'état des entrées
    this.updateKeyboardInput();
    this.updateMouseInput();

    // Calculer la position de la barre avec lissage
    this.updateBarPosition(context.deltaTime);

    // Mettre à jour les états des boutons (pulse)
    this.updateButtonStates();
  }

  /**
   * Configure les écouteurs d'événements
   */
  private setupEventListeners(): void {
    if (typeof window === 'undefined') return;

    // Écouteurs clavier
    if (this.config.keyboardEnabled) {
      window.addEventListener('keydown', this.onKeyDown.bind(this));
      window.addEventListener('keyup', this.onKeyUp.bind(this));
    }

    // Écouteurs souris
    if (this.config.mouseEnabled) {
      window.addEventListener('mousemove', this.onMouseMove.bind(this));
      window.addEventListener('mousedown', this.onMouseDown.bind(this));
      window.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
  }

  /**
   * Gestionnaire d'événement clavier (appui)
   */
  private onKeyDown(event: KeyboardEvent): void {
    this.keyStates.set(event.code, true);

    // Empêcher le comportement par défaut pour certaines touches
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyR'].includes(event.code)) {
      event.preventDefault();
    }
  }

  /**
   * Gestionnaire d'événement clavier (relâchement)
   */
  private onKeyUp(event: KeyboardEvent): void {
    this.keyStates.set(event.code, false);
  }

  /**
   * Gestionnaire de mouvement de souris
   */
  private onMouseMove(event: MouseEvent): void {
    this.mousePosition.set(event.clientX, event.clientY);
  }

  /**
   * Gestionnaire d'appui souris
   */
  private onMouseDown(event: MouseEvent): void {
    this.mouseButtons.set(event.button, true);
  }

  /**
   * Gestionnaire de relâchement souris
   */
  private onMouseUp(event: MouseEvent): void {
    this.mouseButtons.set(event.button, false);
  }

  /**
   * Met à jour les entrées clavier
   */
  private updateKeyboardInput(): void {
    // Contrôle de la barre avec les flèches gauche/droite
    // Input brut de l'utilisateur (instantané)
    let rawInput = 0;

    if (this.keyStates.get('ArrowLeft')) {
      rawInput = -1; // Barre tirée à gauche
    } else if (this.keyStates.get('ArrowRight')) {
      rawInput = 1; // Barre tirée à droite
    }

    // Appliquer la zone morte
    if (Math.abs(rawInput) < this.config.deadzone) {
      rawInput = 0;
    }

    // Stocker l'input brut (sans smoothing)
    // Le smoothing sera fait dans ControlBarSystem
    this.inputState.barPosition = rawInput;

    // Boutons pulse
    this.inputState.resetPressed = this.keyStates.get('KeyR') || false;
    this.inputState.debugTogglePressed = this.keyStates.get('KeyD') || false;
  }

  /**
   * Met à jour les entrées souris (réservé pour extension future)
   */
  private updateMouseInput(): void {
    // Pour l'instant, la souris n'est pas utilisée pour le contrôle principal
    // Mais on pourrait l'utiliser pour un contrôle plus fin
  }

  /**
   * Met à jour la position de la barre (pas de smoothing ici, fait dans ControlBarSystem)
   */
  private updateBarPosition(deltaTime: number): void {
    // L'input est déjà dans barPosition (brut)
    // Le smoothing sera appliqué dans ControlBarSystem sur la rotation physique

    // Calculer la vitesse de changement
    this.inputState.barVelocity = (this.inputState.barPosition - this.inputState.lastBarPosition) / deltaTime;
    this.inputState.lastBarPosition = this.inputState.barPosition;

    // Limiter la vitesse maximale
    if (Math.abs(this.inputState.barVelocity) > this.config.maxBarSpeed) {
      this.inputState.barVelocity = Math.sign(this.inputState.barVelocity) * this.config.maxBarSpeed;
    }
  }

  /**
   * Met à jour les états des boutons (pulse - seulement true pendant un frame)
   */
  private updateButtonStates(): void {
    // Pour l'instant, pas de logique pulse nécessaire car on utilise directement les keyStates
    // Mais on pourrait implémenter une logique de pulse ici si nécessaire
  }

  /**
   * Obtient l'état actuel des entrées
   */
  getInputState(): Readonly<InputState> {
    return this.inputState;
  }

  /**
   * Force une position de barre (pour debug ou automation)
   */
  setBarPosition(position: number): void {
    this.inputState.barPosition = THREE.MathUtils.clamp(position, -1, 1);
    this.inputState.lastBarPosition = this.inputState.barPosition;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<InputConfig> {
    return this.config;
  }

  reset(): void {
    this.inputState.barPosition = 0;
    this.inputState.barVelocity = 0;
    this.inputState.lastBarPosition = 0;
    this.inputState.resetPressed = false;
    this.inputState.debugTogglePressed = false;

    // Réinitialiser les états des touches
    this.keyStates.clear();
    this.mouseButtons.clear();

    this.logger.info('InputSystem reset', 'InputSystem');
  }

  dispose(): void {
    // Supprimer les écouteurs d'événements
    if (typeof window !== 'undefined') {
      window.removeEventListener('keydown', this.onKeyDown.bind(this));
      window.removeEventListener('keyup', this.onKeyUp.bind(this));
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('mousedown', this.onMouseDown.bind(this));
      window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }

    this.logger.info('InputSystem disposed', 'InputSystem');
  }
}

=== simulation/systems/KitePhysicsSystem.ts ===

/**
 * KitePhysicsSystem.ts - Système physique complet pour le kite
 *
 * Intègre tous les composants physiques existants dans l'architecture ECS:
 * - WindSimulator (vent apparent)
 * - AerodynamicsCalculator (forces aéro)
 * - LineSystem (contraintes lignes)
 * - BridleSystem (contraintes brides)
 * - ConstraintSolver (PBD)
 * - KiteController (intégration)
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { CONFIG } from '../config/SimulationConfig';
import { PhysicsConstants } from '../config/PhysicsConstants';
import { Kite } from '../../objects/Kite';
import { KiteState, WindState, SurfaceForce, WindParams, HandlePositions } from '../types';
import { WindSimulator } from '../physics/WindSimulator';
import { LineSystem } from '../physics/LineSystem';
import { BridleSystem } from '../physics/BridleSystem';
import { AerodynamicsCalculator } from '../physics/AerodynamicsCalculator';
import { FlightSphere } from '../physics/ConstraintSolver';

import { KiteController } from '@/simulation/controllers/KiteController';

export interface KitePhysicsHandles {
  getHandlePositions: () => HandlePositions | null;
}

export interface KitePhysicsConfig {
  windSpeed: number; // km/h
  windDirection: number; // degrés
  turbulence: number; // 0-100
  lineLength: number;
  pilotPosition: THREE.Vector3;
  enableConstraints: boolean;
  enableAerodynamics: boolean;
  enableGravity: boolean;
  linearDampingCoeff: number;
  angularDragFactor: number;
}

/**
 * Système physique complet du kite
 * Intègre tous les sous-systèmes dans une architecture cohérente
 */
export class KitePhysicsSystem extends BaseSimulationSystem {
  private logger: Logger;
  private config: KitePhysicsConfig;

  // Composants physiques
  private windSimulator!: WindSimulator;
  private lineSystem!: LineSystem;
  private bridleSystem!: BridleSystem;
  private kiteController!: KiteController;

  // Référence au kite
  private kite!: Kite;

  // État de rotation de la barre
  private barRotation: number = 0;

  // Référence au système de barre de contrôle (pour obtenir les positions des poignées)
  private handlesProvider: KitePhysicsHandles | null = null;

  // Forces aérodynamiques pour le log et l'UI
  private lastLiftForce: THREE.Vector3 = new THREE.Vector3();
  private lastDragForce: THREE.Vector3 = new THREE.Vector3();
  private lastSurfaceForces: SurfaceForce[] = []; // Ajout pour stocker les forces par surface

  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = CONFIG.conversions.gravityFactor * 1000; // Log toutes les secondes
  private startTime: number = Date.now();
  private frameCount: number = 0;

  // Sphère de vol (pour instrumentation)
  private flightSphere: FlightSphere | null = null;

  constructor(config: Partial<KitePhysicsConfig> = {}) {
    super('KitePhysicsSystem', 10);

    this.logger = Logger.getInstance();
    this.config = {
      windSpeed: CONFIG.wind.defaultSpeed, // km/h
      windDirection: CONFIG.wind.defaultDirection, // degrés
      turbulence: CONFIG.wind.defaultTurbulence, // 0-100
      lineLength: CONFIG.lines.defaultLength,
      pilotPosition: new THREE.Vector3(CONFIG.pilot.position.x, CONFIG.pilot.position.y + CONFIG.controlBar.offsetY, CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ),
      enableConstraints: true,
      enableAerodynamics: true,
      enableGravity: true,
      linearDampingCoeff: CONFIG.physics.linearDampingCoeff, // Utiliser CONFIG
      angularDragFactor: CONFIG.physics.angularDragFactor, // Utiliser CONFIG
      ...config
    };
  }

  /**
   * Initialise le système (sans le kite, qui est passé via setKite)
   */
  async initialize(): Promise<void> {
    this.logger.info('KitePhysicsSystem initialized', 'KitePhysicsSystem');
    // Le kite sera défini via setKite() avant le premier update
  }

  /**
   * Initialise tous les composants physiques
   */
  private async initializeComponents(): Promise<void> {
    // Créer WindSimulator
    this.windSimulator = new WindSimulator();
    this.windSimulator.setParams({
      speed: this.config.windSpeed,
      direction: this.config.windDirection,
      turbulence: this.config.turbulence
    });

    // Créer LineSystem
    this.lineSystem = new LineSystem(this.config.lineLength);

    // Créer BridleSystem
    this.bridleSystem = new BridleSystem(this.kite.getBridleLengths());

    // Créer KiteController
    this.kiteController = new KiteController(this.kite);
    this.kiteController.setForceSmoothing(this.config.linearDampingCoeff); // Appliquer le damping linéaire

    this.logger.info('All physics components initialized', 'KitePhysicsSystem');
  }

  /**
   * Configure le fournisseur de positions des poignées (ControlBarSystem)
   */
  setHandlesProvider(provider: KitePhysicsHandles): void {
    this.handlesProvider = provider;
  }

  /**
   * Met à jour le kite (doit être appelé avant le premier update)
   */
  setKite(kite: Kite): void {
    this.kite = kite;

    // Réinitialiser les composants avec le nouveau kite
    if (kite) {
      this.initializeComponents();
    }
  }

  /**
   * Définit la rotation de la barre de contrôle
   */
  setBarRotation(rotation: number): void {
    this.barRotation = rotation;
  }

  /**
   * Mise à jour de la physique complète
   */
  update(context: SimulationContext): void {
    if (!this.kite || !this.kiteController) {
      return;
    }

    const deltaTime = Math.min(context.deltaTime, CONFIG.physics.deltaTimeMax);

    // 1. Obtenir l'état actuel du kite
    const kiteState = this.kiteController.getState();
    const handles = this.handlesProvider?.getHandlePositions() || null;

    // Si pas de poignées disponibles, on ne peut pas calculer la physique
    if (!handles) {
      return;
    }

    // 3. Calculer le vent apparent (vent réel - vitesse du kite)
    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );

    // 4. Calculer les forces aérodynamiques
    let aeroForces: { lift: THREE.Vector3; drag: THREE.Vector3; gravity: THREE.Vector3; torque: THREE.Vector3; surfaceForces: SurfaceForce[] };

    if (this.config.enableAerodynamics) {
      aeroForces = AerodynamicsCalculator.calculateForces(
        apparentWind,
        this.kite.quaternion,
        this.kite.position,
        kiteState.velocity,
        kiteState.angularVelocity
      );
      this.lastLiftForce.copy(aeroForces.lift);
      this.lastDragForce.copy(aeroForces.drag);
      this.lastSurfaceForces = aeroForces.surfaceForces; // Stocker les forces
    } else {
      aeroForces = {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),
        torque: new THREE.Vector3(),
        surfaceForces: []
      };
      this.lastLiftForce.set(0, 0, 0);
      this.lastDragForce.set(0, 0, 0);
      this.lastSurfaceForces = []; // Vider le tableau
    }

    // 5. Combiner toutes les forces
    const totalForce = new THREE.Vector3()
      .add(aeroForces.lift)
      .add(aeroForces.drag);

    // Ajouter la gravité si activée
    if (this.config.enableGravity && aeroForces.gravity) {
      totalForce.add(aeroForces.gravity);
    }

    // 6. Calculer les tensions des lignes (pour visualisation)
    this.lineSystem.calculateLineTensions(
      this.kite,
      handles,
      deltaTime
    );

    // 7. Calculer les tensions des brides (pour visualisation)
    const bridleTensions = this.bridleSystem.calculateBridleTensions(this.kite);

    // 8. Mettre à jour la visualisation des brides
    this.kite.updateBridleVisualization(bridleTensions);

    // Capturer les tensions pour instrumentation avant intégration
    const lineTensions = this.lineSystem.getTensions();

    // 9. Mettre à jour le contrôleur du kite
    // Note: Le KiteController intègre automatiquement les contraintes via ConstraintSolver
    this.kiteController.update(
      totalForce,
      aeroForces.torque,
      handles,
      deltaTime
    );

    // 10. Mettre à jour les lignes de bridage visuelles (après que les points aient bougé)
    this.kite.updateBridleLines();

    // 11. Gérer la collision au sol (spécifique au kite)
    this.handleGroundCollision(deltaTime);

    // 📊 LOG COMPLET toutes les secondes
    this.frameCount++;
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;
      this.logPhysicsState(
        this.kite,
        this.kiteController.getState(),
        apparentWind,
        {
          lift: aeroForces.lift,
          drag: aeroForces.drag,
          gravity: aeroForces.gravity,
          total: totalForce,
          torque: aeroForces.torque
        },
        lineTensions,
        bridleTensions,
        deltaTime,
        currentTime
      );
    }
  }

  private logPhysicsState(
    kite: Kite,
    kiteState: KiteState,
    apparentWind: THREE.Vector3,
    forces: {
      lift: THREE.Vector3;
      drag: THREE.Vector3;
      gravity: THREE.Vector3;
      total: THREE.Vector3;
      torque: THREE.Vector3;
    },
    lineTensions: { left: number; right: number },
    bridleTensions: ReturnType<BridleSystem['calculateBridleTensions']>,
    deltaTime: number,
    currentTime: number
  ): void {
    if (!this.config.enableAerodynamics) {
      return;
    }

    const elapsedTime = (currentTime - this.startTime) / (CONFIG.conversions.gravityFactor * 1000);
    const safeDelta = Math.max(deltaTime, CONFIG.thresholds.epsilonFine);
    const fps = 1 / safeDelta;

    const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
    const pitch = euler.x * CONFIG.conversions.radToDeg;
    const roll = euler.z * CONFIG.conversions.radToDeg;
    const yaw = euler.y * CONFIG.conversions.radToDeg;

    const liftMag = forces.lift.length();
    const dragMag = forces.drag.length();
    forces.gravity.length();
    const totalForceMag = forces.total.length();
    forces.torque.length();

    forces.total.clone().divideScalar(CONFIG.kite.mass);
    dragMag > PhysicsConstants.EPSILON ? liftMag / dragMag : 0;

    const leftTension = lineTensions.left;
    const rightTension = lineTensions.right;
    const tensionDelta = leftTension - rightTension;
    const dominantTension = Math.max(Math.abs(leftTension), Math.abs(rightTension), PhysicsConstants.EPSILON);
    (tensionDelta / dominantTension) * 100;

    this.logger.debug(`Kite Physics State - Frame #${this.frameCount}:
      Time: ${elapsedTime.toFixed(3)}s | Δt: ${(safeDelta * 1000).toFixed(2)}ms | FPS: ${fps.toFixed(1)}
      Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m | Dist: ${kite.position.length().toFixed(2)} m
      Angles: Pitch ${pitch.toFixed(1)}° | Roll ${roll.toFixed(1)}° | Yaw ${yaw.toFixed(1)}°
      Velocity: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s
      Wind: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s
      Forces - Lift: ${liftMag.toFixed(2)}N, Drag: ${dragMag.toFixed(2)}N, Total: ${totalForceMag.toFixed(2)}N
      Tensions - Lines: L:${leftTension.toFixed(2)}N R:${rightTension.toFixed(2)}N | Brides: NEZ ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)}N`, 'KitePhysicsSystem');
  }

  /**
   * Gère la collision du kite avec le sol
   * Utilise les points anatomiques du kite pour une détection plus précise
   */
  private handleGroundCollision(deltaTime: number): void {
    const groundY = CONFIG.kite.minHeight;
    const restitution = CONFIG.defaults.restitutionFactor;
    const frictionCoeff = CONFIG.defaults.groundFriction;

    const kiteState = this.kiteController.getState();
    const kitePosition = kiteState.position.clone();
    const kiteVelocity = kiteState.velocity.clone();
    const kiteAngularVelocity = kiteState.angularVelocity.clone();

    let hasCollision = false;
    const contactPoints: THREE.Vector3[] = [];

    // Vérifier les points anatomiques clés du kite pour la collision
    // On peut choisir des points comme les extrémités des lattes, le nez, la queue, etc.
    const pointsToCheck = [
      this.kite.getPoint('NEZ'),
      this.kite.getPoint('SPINE_BAS'),
      this.kite.getPoint('BORD_GAUCHE'), // Utiliser BORD_GAUCHE et BORD_DROIT
      this.kite.getPoint('BORD_DROIT'),
      this.kite.getPoint('WHISKER_GAUCHE'),
      this.kite.getPoint('WHISKER_DROIT'),
    ].filter(p => p !== undefined) as THREE.Vector3[];

    for (const localPoint of pointsToCheck) {
      const worldPoint = localPoint.clone().applyQuaternion(this.kite.quaternion).add(kitePosition);

      if (worldPoint.y <= groundY) {
        hasCollision = true;
        contactPoints.push(worldPoint);

        // Ajuster la position pour qu'elle soit sur le sol
        const penetrationDepth = groundY - worldPoint.y;
        kitePosition.y += penetrationDepth; // Pousse le kite hors du sol

        // Calculer la vitesse du point de contact
        const r = worldPoint.clone().sub(kitePosition); // Vecteur du centre de masse au point de contact
        const pointVelocity = kiteVelocity.clone().add(kiteAngularVelocity.clone().cross(r));

        // Appliquer la force de réaction normale (rebond)
        if (pointVelocity.y < 0) {
          const normalImpulse = -pointVelocity.y * (1 + restitution);
          kiteVelocity.y += normalImpulse; // Applique l'impulsion au centre de masse
        }

        // Appliquer la force de friction
        const horizontalVelocity = new THREE.Vector3(pointVelocity.x, 0, pointVelocity.z);
        if (horizontalVelocity.lengthSq() > PhysicsConstants.EPSILON) {
          const frictionForce = horizontalVelocity.clone().normalize().multiplyScalar(-frictionCoeff * horizontalVelocity.length());
          kiteVelocity.add(frictionForce.multiplyScalar(deltaTime)); // Applique la friction au centre de masse
        }
      }
    }

    if (hasCollision) {
      // Mettre à jour l'état du kite avec les nouvelles vitesses et position
      this.kiteController.getState().position.copy(kitePosition);
      this.kiteController.getState().velocity.copy(kiteVelocity);
      this.kiteController.getState().angularVelocity.copy(kiteAngularVelocity);

      // Si la vitesse verticale est très faible, l'annuler pour éviter les micro-rebonds
      if (Math.abs(kiteVelocity.y) < PhysicsConstants.EPSILON) {
        this.kiteController.getState().velocity.y = 0;
      }
    }
  }

  /**
   * Obtient l'état du vent
   */
  getWindState(): WindState {
    if (!this.windSimulator) {
      return { baseSpeed: 0, baseDirection: new THREE.Vector3(), turbulence: 0, gustFrequency: 0, gustAmplitude: 0, time: 0 };
    }

    const windParams = this.windSimulator.getParams();
    return {
      baseSpeed: windParams.speed / 3.6, // Convertir km/h en m/s pour affichage
      baseDirection: new THREE.Vector3(Math.sin((windParams.direction * Math.PI) / 180), 0, -Math.cos((windParams.direction * Math.PI) / 180)),
      turbulence: windParams.turbulence,
      gustFrequency: 0, // Non exposé par WindSimulator.getParams()
      gustAmplitude: 0, // Non exposé par WindSimulator.getParams()
      time: 0 // Non exposé par WindSimulator.getParams()
    };
  }

  /**
   * Obtient l'état du kite
   */
  getKiteState(): KiteState {
    return this.kiteController ? this.kiteController.getState() : {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: new THREE.Quaternion() // Ajouté orientation
    };
  }

  /**
   * Met à jour les paramètres du vent
   */
  setWindParams(params: Partial<WindParams>): void {
    if (!this.windSimulator) return;

    const windParams: Partial<WindParams> = {};

    if (params.speed !== undefined) {
      windParams.speed = params.speed; // km/h
      this.config.windSpeed = params.speed;
    }
    if (params.direction !== undefined) {
      windParams.direction = params.direction; // degrés
      this.config.windDirection = params.direction;
    }
    if (params.turbulence !== undefined) {
      windParams.turbulence = params.turbulence; // 0-100
      this.config.turbulence = params.turbulence;
    }

    this.windSimulator.setParams(windParams);
  }

  /**
   * Met à jour la longueur des lignes
   */
  setLineLength(length: number): void {
    this.config.lineLength = length;
    if (this.kite) {
      this.kite.userData.lineLength = length;
    }
    if (this.lineSystem) {
      this.lineSystem.setLineLength(length);
    }
  }

  /**
   * Met à jour les longueurs des brides
   */
  setBridleLengths(lengths: { nez: number; inter: number; centre: number }): void {
    if (this.kite) {
      this.kite.setBridleLengths(lengths);
      // Recréer le BridleSystem avec les nouvelles longueurs
      this.bridleSystem = new BridleSystem(lengths);
    }
  }

  /**
   * Obtient les longueurs actuelles des brides
   */
  getBridleLengths(): { nez: number; inter: number; centre: number } {
    return this.bridleSystem ? this.bridleSystem.getBridleLengths() : { nez: 0, inter: 0, centre: 0 };
  }

  /**
   * Met à jour le lissage des forces
   */
  setForceSmoothing(rate: number): void {
    this.config.linearDampingCoeff = rate;
    if (this.kiteController) {
      this.kiteController.setForceSmoothing(rate);
    }
  }

  /**
   * Obtient le lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController ? this.kiteController.getForceSmoothing() : this.config.linearDampingCoeff;
  }

  /**
   * Obtient les statistiques du système
   */
  getStats(): any {
    const kiteState = this.getKiteState();
    const windState = this.getWindState();

    return {
      kite: kiteState,
      wind: windState,
      barRotation: this.barRotation,
      config: this.config,
      lineTensions: this.lineSystem.getTensions(),
      bridleTensions: this.bridleSystem.getStats(),
      kiteWarnings: this.kiteController.getWarnings(),
      lastLiftForce: this.lastLiftForce.clone(),
      lastDragForce: this.lastDragForce.clone()
    };
  }

  /**
   * Accesseurs pour les composants (nécessaires pour DebugRenderer)
   */
  getKiteController(): KiteController {
    return this.kiteController;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getBridleSystem(): BridleSystem {
    return this.bridleSystem;
  }

  /**
   * Retourne les forces aérodynamiques actuelles (lift et drag)
   * @returns Objet contenant les vecteurs de force de portance et de traînée
   */
  getAerodynamicForces(): { lift: THREE.Vector3; drag: THREE.Vector3 } {
    return {
      lift: this.lastLiftForce.clone(),
      drag: this.lastDragForce.clone()
    };
  }

  /**
   * Retourne les forces aérodynamiques par surface (pour le debug)
   */
  getSurfaceForces(): SurfaceForce[] {
    return this.lastSurfaceForces;
  }

  /**
   * Retourne les diagnostics complets des lignes de contrôle
   * @returns Diagnostics incluant longueurs, tensions et états
   */
  getControlLineDiagnostics(): {
    lineLength: number;
    leftDistance: number;
    rightDistance: number;
    leftTaut: boolean;
    rightTaut: boolean;
    leftTension: number;
    rightTension: number;
  } | null {
    if (!this.lineSystem) return null;

    const distances = this.lineSystem.getDistances();
    const tensions = this.lineSystem.getTensions();
    const states = this.lineSystem.getLineStates();

    return {
      lineLength: this.lineSystem.lineLength,
      leftDistance: distances.left,
      rightDistance: distances.right,
      leftTaut: states.leftTaut,
      rightTaut: states.rightTaut,
      leftTension: tensions.left,
      rightTension: tensions.right
    };
  }

  getKite(): Kite | null {
    return this.kite || null;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  reset(): void {
    // Réinitialiser le kiteController
    if (this.kite) {
      this.kiteController = new KiteController(this.kite);
      this.kiteController.setForceSmoothing(this.config.linearDampingCoeff);
      
      // Calculer la position initiale avec lignes tendues
      const initialPos = MathUtils.calculateInitialKitePosition(
        this.config.pilotPosition,
        CONFIG.initialization.initialKiteY,
        CONFIG.lines.defaultLength,
        CONFIG.initialization.initialDistanceFactor,
        CONFIG.initialization.initialKiteZ
      );
      
      // Réinitialiser la position et l'orientation du kite
      this.kite.position.copy(initialPos);
      this.kite.rotation.set(0, 0, 0);
      this.kite.quaternion.identity();
    }

    // Réinitialiser la rotation de la barre
    this.barRotation = 0;

    // Réinitialiser les sous-systèmes
    if (this.windSimulator) {
      const simulator = this.windSimulator as unknown as { reset?: () => void };
      if (typeof simulator.reset === 'function') {
        simulator.reset();
      }
      this.windSimulator.setParams({
        speed: this.config.windSpeed,
        direction: this.config.windDirection,
        turbulence: this.config.turbulence
      });
    }
    if (this.lineSystem) {
      this.lineSystem.setLineLength(this.config.lineLength);
      // this.lineSystem.resetAll(); // Supprimé car LineSystem n'a pas de resetAll
    }
    if (this.bridleSystem && this.kite) {
      this.bridleSystem = new BridleSystem(this.kite.getBridleLengths());
    }

    // Réinitialiser les compteurs
    this.frameCount = 0;
    this.startTime = Date.now();
    this.lastLogTime = 0;

    this.logger.info('KitePhysicsSystem reset', 'KitePhysicsSystem');
  }

  /**
   * Retourne les informations de debug
   */
  getDebugInfo(): any {
    return {
      kitePosition: this.kite?.position?.clone(),
      kiteVelocity: this.kiteController?.getState()?.velocity?.clone(),
      windSpeed: this.windSimulator?.getParams()?.speed,
      liftForce: this.lastLiftForce.clone(),
      dragForce: this.lastDragForce.clone(),
      lineTensions: this.lineSystem?.getTensions(),
      bridleLengths: this.kite?.getBridleLengths()
    };
  }

  dispose(): void {
    // Pas de ressources spécifiques à disposer pour l'instant
    this.logger.info('KitePhysicsSystem disposed', 'KitePhysicsSystem');
  }
}


=== simulation/systems/LinesRenderSystem.ts ===

/**
 * LinesRenderSystem.ts - Système ECS pour le rendu des lignes de contrôle
 *
 * Responsabilités :
 *   - Gère les entités de lignes de contrôle (gauche et droite)
 *   - Met à jour la géométrie des lignes en fonction des positions du kite et de la barre
 *   - Applique une courbure réaliste aux lignes (caténaire)
 *
 * Architecture ECS :
 *   - Opère sur des LineEntity avec TransformComponent et MeshComponent
 *   - Lit les positions depuis ControlBarSystem et Kite
 *   - Met à jour les BufferGeometry THREE.js pour le rendu
 */

// External libraries
import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { CONFIG } from '../config/SimulationConfig';
import { Kite } from '../../objects/Kite';
import { MeshComponent } from '../components/MeshComponent';
import { Entity } from '../entities/Entity';
import { LineEntity } from '../entities/LineEntity';

import { ControlBarSystem } from './ControlBarSystem';
import { KitePhysicsSystem } from './KitePhysicsSystem';

/**
 * Composant spécifique aux lignes pour stocker leurs paramètres
 */
export interface LineComponentData {
  segments: number;
  color: number;
  linewidth: number;
  side: 'left' | 'right';
}

export class LinesRenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private lineEntities: Map<string, Entity> = new Map();
  private kite: Kite | null = null;
  private controlBarSystem: ControlBarSystem | null = null;
  private kitePhysicsSystem: KitePhysicsSystem | null = null;

  constructor() {
    super('LinesRenderSystem', 6); // Après ControlBarSystem, avant RenderSystem
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    this.logger.info('LinesRenderSystem initialized', 'LinesRenderSystem');
  }

  /**
   * Enregistre une entité de ligne
   */
  registerLineEntity(id: string, entity: Entity, data: LineComponentData): void {
    if (!entity.hasComponent('mesh')) {
      throw new Error('LineEntity must have a Mesh component');
    }

    // Stocker les données de ligne dans l'entité
    entity.addComponent({
      type: 'line',
      ...data
    });

    this.lineEntities.set(id, entity);
  }

  /**
   * Définit la référence au kite (temporaire)
   */
  setKite(kite: Kite): void {
    this.kite = kite;
  }

  /**
   * Définit la référence au système de barre de contrôle
   */
  setControlBarSystem(system: ControlBarSystem): void {
    this.controlBarSystem = system;
  }

  /**
   * Définit la référence au système de physique du kite (pour accéder aux tensions)
   */
  setKitePhysicsSystem(system: KitePhysicsSystem): void {
    this.kitePhysicsSystem = system;
  }

  update(_context: SimulationContext): void {
    if (!this.kite || !this.controlBarSystem) {
      console.warn('🔴 LinesRenderSystem: kite ou controlBarSystem manquant');
      return;
    }

    // Récupérer les positions des poignées
    const handles = this.controlBarSystem.getHandlePositions();
    if (!handles) {
      console.warn('🔴 LinesRenderSystem: handles manquants');
      return;
    }

    // Récupérer les points de contrôle du kite
    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');

    if (!ctrlLeft || !ctrlRight) {
      console.warn('🔴 LinesRenderSystem: points de contrôle kite manquants');
      return;
    }

    const ctrlLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
    const ctrlRightWorld = this.kite.toWorldCoordinates(ctrlRight);

    // 🔍 DEBUG : Log une fois toutes les 60 frames (1 fois par seconde à 60fps)
    if (_context.totalTime % 1 < 0.016) {
      console.log('✅ LinesRenderSystem update:', {
        lineCount: this.lineEntities.size,
        handleLeft: handles.left.toArray(),
        handleRight: handles.right.toArray(),
        ctrlLeft: ctrlLeftWorld.toArray(),
        ctrlRight: ctrlRightWorld.toArray()
      });
    }

    // Mettre à jour chaque ligne
    this.lineEntities.forEach((entity) => {
      const lineData = entity.getComponent<any>('line');
      const mesh = entity.getComponent<MeshComponent>('mesh');

      if (!lineData || !mesh) return;

      // Déterminer les points de départ et d'arrivée selon le côté
      // Les lignes partent de la barre de contrôle vers le kite
      const start = lineData.side === 'left' ? handles.left : handles.right;
      const end = lineData.side === 'left' ? ctrlLeftWorld : ctrlRightWorld;

      // Mettre à jour la géométrie
      this.updateLineGeometry(
        mesh.object3D as THREE.Mesh,
        start,
        end,
        lineData.segments
      );

      // Mettre à jour la couleur basée sur les tensions physiques émergentes
      this.updateLineColorFromTension(mesh.object3D as THREE.Mesh, lineData.side);
    });
  }

  /**
   * Met à jour la géométrie d'une ligne avec une courbe réaliste
   */
  private updateLineGeometry(
    line: THREE.Mesh,
    start: THREE.Vector3,
    end: THREE.Vector3,
    segments: number
  ): void {
    const tubeMesh = line as THREE.Mesh;

    // Créer une nouvelle courbe pour le tube
    const points: THREE.Vector3[] = [];

    // Calculer la distance et la direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const distance = direction.length();

    // Facteur de courbure (simule la gravité et la tension)
    const sag = distance * CONFIG.defaults.catenarySagFactor;

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Interpolation linéaire de base
      const x = start.x + direction.x * t;
      const y = start.y + direction.y * t;
      const z = start.z + direction.z * t;

      // Ajouter une courbure parabolique (caténaire simplifiée)
      // Maximum au milieu (t = 0.5)
      const curvature = -sag * 4 * t * (1 - t);

      points.push(new THREE.Vector3(x, y + curvature, z));
    }

    // Créer une nouvelle courbe et géométrie de tube
    const curve = new THREE.CatmullRomCurve3(points);
    const newTubeGeometry = new THREE.TubeGeometry(
      curve,
      segments,
      CONFIG.defaults.tubeRadius, // Utilise la valeur de config (0.015)
      CONFIG.defaults.tubeRadialSegments,
      false
    );

    // Remplacer la géométrie
    if (tubeMesh.geometry) {
      tubeMesh.geometry.dispose();
    }
    tubeMesh.geometry = newTubeGeometry;
  }

  /**
   * Met à jour la couleur de la ligne basée sur les tensions physiques émergentes
   * Respecte le principe : vert (molle) → jaune (moyenne) → rouge (tendue)
   */
  private updateLineColorFromTension(line: THREE.Mesh, side: 'left' | 'right'): void {
    if (!this.kitePhysicsSystem) return;

    // Récupérer les informations de debug du système physique
    const debugInfo = this.kitePhysicsSystem.getDebugInfo?.();
    if (!debugInfo || !debugInfo.lineTensions) return;

    // Calculer la tension pour ce côté (émergente des contraintes physiques)
    const tension = side === 'left' ? debugInfo.lineTensions.left : debugInfo.lineTensions.right;

    // Calculer la couleur basée sur les seuils physiques définis dans CONFIG
    const color = this.calculateTensionColor(tension);

    // Appliquer la couleur au matériau du tube
    const material = line.material as THREE.MeshStandardMaterial;
    if (material && material.color) {
      material.color.setHex(color);
    }
  }

  /**
   * Calcule la couleur basée sur la tension selon les principes physiques
   * Vert (faible tension) → Jaune (tension moyenne) → Rouge (forte tension)
   */
  private calculateTensionColor(tension: number): number {
    const { bridleTensionMedium, bridleTensionHigh } = CONFIG.debug;

    // Normaliser la tension entre 0 et 1
    const normalizedTension = Math.min(tension / bridleTensionHigh, 1);

    if (normalizedTension <= 0) {
      return 0x00ff00; // Vert - tension nulle/mollesse
    } else if (normalizedTension < bridleTensionMedium / bridleTensionHigh) {
      // Interpolation vert → jaune pour tensions faibles à moyennes
      const t = normalizedTension / (bridleTensionMedium / bridleTensionHigh);
      const r = Math.round(255 * t);     // 0 → 255 (vert → jaune)
      const g = 255;                    // 255 → 255 (vert → jaune)
      const b = 0;                      // 0 → 0 (vert → jaune)
      return (r << 16) | (g << 8) | b;
    } else {
      // Interpolation jaune → rouge pour tensions moyennes à élevées
      const t = (normalizedTension - bridleTensionMedium / bridleTensionHigh) /
                (1 - bridleTensionMedium / bridleTensionHigh);
      const r = 255;                    // 255 → 255 (jaune → rouge)
      const g = Math.round(255 * (1 - t)); // 255 → 0 (jaune → rouge)
      const b = 0;                      // 0 → 0 (jaune → rouge)
      return (r << 16) | (g << 8) | b;
    }
  }

  /**
   * Crée une entité de ligne
   */
  createLineEntity(
    id: string,
    side: 'left' | 'right',
    scene: THREE.Scene
  ): LineEntity {
    const entity = new LineEntity(side);

    // Récupérer le mesh créé par LineEntity et l'ajouter à la scène
    const mesh = entity.getComponent<MeshComponent>('mesh');
    if (mesh) {
      scene.add(mesh.object3D);
      const tubeMesh = mesh.object3D as THREE.Mesh;
      const material = tubeMesh.material as THREE.MeshStandardMaterial;
      console.log(`✅ Ligne ${side} ajoutée à la scène:`, {
        id,
        position: mesh.object3D.position.toArray(),
        visible: mesh.object3D.visible,
        geometry: tubeMesh.geometry.type,
        material: material.type,
        color: material.color.getHexString()
      });
    } else {
      console.error(`🔴 Ligne ${side}: mesh component manquant!`);
    }

    // Enregistrer l'entité
    this.registerLineEntity(id, entity, {
      segments: CONFIG.defaults.meshSegments,
      color: CONFIG.colors.controlBar,
      linewidth: CONFIG.rendering.lineWidth,
      side
    });

    return entity;
  }

  /**
   * Supprime une entité de ligne
   */
  removeLineEntity(id: string, scene: THREE.Scene): void {
    const entity = this.lineEntities.get(id);
    if (!entity) return;

    const mesh = entity.getComponent<MeshComponent>('mesh');
    if (mesh) {
      scene.remove(mesh.object3D);
      mesh.dispose();
    }

    this.lineEntities.delete(id);
  }

  reset(): void {
    // Les lignes n'ont pas d'état à réinitialiser
    // La géométrie sera recalculée au prochain update
    this.logger.info('LinesRenderSystem reset', 'LinesRenderSystem');
  }

  dispose(): void {
    this.lineEntities.forEach((entity) => {
      const mesh = entity.getComponent<MeshComponent>('mesh');
      if (mesh) {
        mesh.dispose();
      }
    });

    this.lineEntities.clear();
    this.kite = null;
    this.controlBarSystem = null;

    this.logger.info('LinesRenderSystem disposed', 'LinesRenderSystem');
  }
}


=== simulation/systems/PilotSystem.ts ===

/**
 * PilotSystem.ts - Système ECS pour la gestion du pilote
 *
 * Responsabilités :
 *   - Gère l'entité du pilote (position, rotation, visuel)
 *   - Met à jour la position du pilote relative à la barre de contrôle
 *
 * Architecture ECS :
 *   - Opère sur une PilotEntity avec TransformComponent et MeshComponent
 *   - Met à jour la position basée sur la position de la barre de contrôle
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { PilotEntity } from '../entities/PilotEntity';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';
import { Logger } from '../../utils/Logging';

export class PilotSystem extends BaseSimulationSystem {
  private logger: Logger;
  private pilotEntity: PilotEntity | null = null;
  private controlBarPosition: THREE.Vector3 = new THREE.Vector3();

  constructor() {
    super('PilotSystem', 6); // Priorité après ControlBarSystem
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    // Initialiser la position du pilote à (0, 0, 0)
    if (this.pilotEntity) {
      this.pilotEntity.updatePosition();

      // Synchroniser avec le mesh Three.js
      const transform = this.pilotEntity.getComponent<TransformComponent>('transform');
      const mesh = this.pilotEntity.getComponent<MeshComponent>('mesh');

      if (transform && mesh) {
        mesh.syncToObject3D({
          position: transform.position,
          quaternion: transform.quaternion,
          scale: transform.scale
        });
      }
    }

    this.logger.info('PilotSystem initialized', 'PilotSystem');
  }

  reset(): void {
    this.controlBarPosition.set(0, 0, 0);
    this.logger.info('PilotSystem reset', 'PilotSystem');
  }

  dispose(): void {
    this.pilotEntity = null;
    this.logger.info('PilotSystem disposed', 'PilotSystem');
  }

  /**
   * Enregistre l'entité du pilote
   */
  setPilotEntity(entity: PilotEntity): void {
    if (!entity.hasComponent('transform') || !entity.hasComponent('mesh')) {
      throw new Error('PilotEntity must have Transform and Mesh components');
    }
    this.pilotEntity = entity;
  }

  /**
   * Met à jour la position de référence de la barre de contrôle
   */
  setControlBarPosition(position: THREE.Vector3): void {
    this.controlBarPosition.copy(position);
  }

  update(_context: SimulationContext): void {
    if (!this.pilotEntity) return;

    // Le pilote reste à (0, 0, 0) - pas besoin de mise à jour
    // La position du pilote ne change jamais dans le système de coordonnées monde

    // Synchroniser avec le mesh Three.js (pour les autres transformations éventuelles)
    const transform = this.pilotEntity.getComponent<TransformComponent>('transform');
    const mesh = this.pilotEntity.getComponent<MeshComponent>('mesh');

    if (transform && mesh) {
      mesh.syncToObject3D({
        position: transform.position,
        quaternion: transform.quaternion,
        scale: transform.scale
      });
    }
  }
}

=== simulation/systems/RenderSystem.ts ===

/**
 * RenderSystem.ts - Système de rendu Three.js
 */

import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface RenderState {
  scene: THREE.Scene;
  camera: THREE.Camera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
  controls: OrbitControls;
  isRendering: boolean;
  frameCount: number;
  fps: number;
  lastFrameTime: number;
}

export interface RenderConfig {
  antialias: boolean;
  shadowMapEnabled: boolean;
  shadowMapType: THREE.ShadowMapType;
  pixelRatio: number;
  clearColor: number;
  clearAlpha: number;
  targetFPS: number;
  vsync: boolean;
  powerPreference: 'default' | 'high-performance' | 'low-power';
}

export class RenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private renderState: RenderState | null = null;
  private config: RenderConfig;
  private fpsCounter = { frames: 0, lastTime: 0, fps: 0 };

  constructor(config: Partial<RenderConfig> = {}) {
    super('RenderSystem', 100); // Basse priorité (rendu en dernier)

    this.logger = Logger.getInstance();
    this.config = {
      antialias: true,
      shadowMapEnabled: true,
      shadowMapType: THREE.PCFSoftShadowMap,
      pixelRatio: 1, // Valeur par défaut, sera mise à jour dans initialize()
      clearColor: 0x87CEEB, // Bleu ciel
      clearAlpha: 1.0,
      targetFPS: 60,
      vsync: true,
      powerPreference: 'high-performance',
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('RenderSystem initializing...', 'RenderSystem');

    // Mettre à jour pixelRatio maintenant que window est disponible
    if (typeof window !== 'undefined') {
      this.config.pixelRatio = Math.min(window.devicePixelRatio, 2);
    }

    try {
      await this.initializeRenderer();
      this.logger.info('RenderSystem initialized successfully', 'RenderSystem');
    } catch (error) {
      this.logger.error(`RenderSystem initialization failed: ${error}`, 'RenderSystem');
      throw error;
    }
  }

  /**
   * Vérifie si l'environnement DOM est disponible
   */
  private checkDOMEnvironment(): void {
    if (typeof document === 'undefined') {
      throw new Error('RenderSystem requires a DOM environment');
    }
  }

  /**
   * Crée et configure le canvas
   */
  private createCanvas(): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.id = 'kite-simulator-canvas';
    return canvas;
  }

  /**
   * Crée et configure le renderer WebGL
   */
  private createRenderer(canvas: HTMLCanvasElement): THREE.WebGLRenderer {
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: this.config.antialias,
      alpha: false,
      powerPreference: this.config.powerPreference
    });

    // Configuration de base
    renderer.setPixelRatio(this.config.pixelRatio);
    renderer.setClearColor(this.config.clearColor, this.config.clearAlpha);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Configuration des ombres
    if (this.config.shadowMapEnabled) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = this.config.shadowMapType;
    }

    return renderer;
  }

  /**
   * Crée et configure la scène avec brouillard
   */
  private createScene(): THREE.Scene {
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(this.config.clearColor, 50, 200);
    return scene;
  }

  /**
   * Configure l'éclairage de la scène
   */
  private setupLighting(scene: THREE.Scene): void {
    // Lumière ambiante
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    // Lumière directionnelle
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = this.config.shadowMapEnabled;

    if (this.config.shadowMapEnabled) {
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
    }
    scene.add(directionalLight);

    this.logger.info('Scene lights created', 'RenderSystem');
  }

  /**
   * Ajoute le sol et la grille à la scène
   */
  private setupGroundAndGrid(scene: THREE.Scene): void {
    // Sol
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a7d44,
      roughness: 0.8,
      metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = this.config.shadowMapEnabled;
    scene.add(ground);

    // Grille
    const gridHelper = new THREE.GridHelper(100, 50, 0x888888, 0x444444);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);

    this.logger.info('Ground plane and grid created', 'RenderSystem');
  }

  /**
   * Crée et configure la caméra
   */
  private createCamera(): THREE.PerspectiveCamera {
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 5);
    camera.lookAt(0, 5, -15);
    return camera;
  }

  /**
   * Crée et configure les contrôles de caméra
   */
  private createCameraControls(camera: THREE.PerspectiveCamera, canvas: HTMLCanvasElement): OrbitControls {
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 100;
    controls.maxPolarAngle = Math.PI / 2;
    controls.target.set(0, 5, -10);
    controls.update();

    this.logger.info('OrbitControls created', 'RenderSystem');
    return controls;
  }

  /**
   * Ajoute le canvas au DOM et configure les écouteurs
   */
  private setupCanvasInDOM(canvas: HTMLCanvasElement): void {
    const container = document.getElementById('app') || document.body;
    container.appendChild(canvas);

    this.logger.info(`Canvas created and added to container: ${container.id || 'body'}`, 'RenderSystem');
    this.logger.info(`Canvas dimensions: ${canvas.width}x${canvas.height}`, 'RenderSystem');

    // Écouteur de redimensionnement
    window.addEventListener('resize', this.onResize.bind(this));
  }

  /**
   * Initialise le renderer Three.js
   */
  private async initializeRenderer(): Promise<void> {
    this.checkDOMEnvironment();

    // Création des composants
    const canvas = this.createCanvas();
    const renderer = this.createRenderer(canvas);
    const scene = this.createScene();

    // Configuration de la scène
    this.setupLighting(scene);
    this.setupGroundAndGrid(scene);

    // Création de la caméra et contrôles
    const camera = this.createCamera();
    const controls = this.createCameraControls(camera, canvas);

    // Initialisation de l'état
    this.renderState = {
      scene,
      camera,
      renderer,
      canvas,
      controls,
      isRendering: false,
      frameCount: 0,
      fps: 0,
      lastFrameTime: performance.now()
    };

    // Configuration finale
    this.onResize();
    this.setupCanvasInDOM(canvas);
  }

  update(_context: SimulationContext): void {
    if (!this.renderState || !this.renderState.isRendering) {
      return;
    }

    // Mettre à jour les contrôles de caméra
    this.renderState.controls.update();

    // Calculer le FPS
    this.updateFPS();

    // Rendre la scène
    this.renderState.renderer.render(this.renderState.scene, this.renderState.camera);

    this.renderState.frameCount++;
  }

  /**
   * Met à jour le compteur FPS
   */
  private updateFPS(): void {
    if (!this.renderState) return;

    const now = performance.now();
    this.fpsCounter.frames++;

    if (now - this.fpsCounter.lastTime >= 1000) {
      this.renderState.fps = Math.round((this.fpsCounter.frames * 1000) / (now - this.fpsCounter.lastTime));
      this.fpsCounter.frames = 0;
      this.fpsCounter.lastTime = now;
    }
  }

  /**
   * Gestionnaire de redimensionnement de la fenêtre
   */
  private onResize(): void {
    if (!this.renderState) return;

    const width = window.innerWidth;
    const height = window.innerHeight;

    // Mettre à jour la caméra
    if (this.renderState.camera instanceof THREE.PerspectiveCamera) {
      this.renderState.camera.aspect = width / height;
      this.renderState.camera.updateProjectionMatrix();
    }

    // Mettre à jour le renderer
    this.renderState.renderer.setSize(width, height);
  }

  /**
   * Démarre le rendu
   */
  startRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = true;
      this.logger.info('Rendering started', 'RenderSystem');
      this.logger.info(`Canvas element: ${this.renderState.canvas.id}`, 'RenderSystem');
      this.logger.info(`Scene children count: ${this.renderState.scene.children.length}`, 'RenderSystem');
    } else {
      this.logger.error('Cannot start rendering - renderState is null', 'RenderSystem');
    }
  }

  /**
   * Arrête le rendu
   */
  stopRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = false;
      this.logger.info('Rendering stopped', 'RenderSystem');
    }
  }

  /**
   * Obtient l'état de rendu actuel
   */
  getRenderState(): Readonly<RenderState> | null {
    return this.renderState;
  }

  /**
   * Obtient la scène Three.js
   */
  getScene(): THREE.Scene | null {
    return this.renderState?.scene || null;
  }

  /**
   * Obtient la caméra
   */
  getCamera(): THREE.Camera | null {
    return this.renderState?.camera || null;
  }

  /**
   * Obtient le renderer
   */
  getRenderer(): THREE.WebGLRenderer | null {
    return this.renderState?.renderer || null;
  }

  addToScene(object: THREE.Object3D): void {
    if (this.renderState?.scene) {
      this.renderState.scene.add(object);
    }
  }

  removeFromScene(object: THREE.Object3D): void {
    if (this.renderState?.scene) {
      this.renderState.scene.remove(object);
    }
  }

  /**
   * Obtient le canvas
   */
  getCanvas(): HTMLCanvasElement | null {
    return this.renderState?.canvas || null;
  }

  /**
   * Obtient les statistiques de rendu
   */
  getRenderStats(): { fps: number; frameCount: number; isRendering: boolean } {
    if (!this.renderState) {
      return { fps: 0, frameCount: 0, isRendering: false };
    }

    return {
      fps: this.renderState.fps,
      frameCount: this.renderState.frameCount,
      isRendering: this.renderState.isRendering
    };
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<RenderConfig> {
    return this.config;
  }

  reset(): void {
    if (this.renderState) {
      this.renderState.frameCount = 0;
      this.renderState.fps = 0;
      this.renderState.lastFrameTime = performance.now();
    }

    this.fpsCounter = { frames: 0, lastTime: 0, fps: 0 };
    this.logger.info('RenderSystem reset', 'RenderSystem');
  }

  dispose(): void {
    if (this.renderState) {
      // Supprimer les écouteurs
      window.removeEventListener('resize', this.onResize.bind(this));

      // Disposer le renderer
      this.renderState.renderer.dispose();

      // Supprimer le canvas du DOM
      if (this.renderState.canvas.parentNode) {
        this.renderState.canvas.parentNode.removeChild(this.renderState.canvas);
      }

      this.renderState = null;
    }

    this.logger.info('RenderSystem disposed', 'RenderSystem');
  }
}

=== simulation/systems/index.ts ===

/**
 * systems/index.ts - Export des systèmes de simulation
 *
 * Point d'entrée centralisé pour tous les systèmes de simulation.
 * Permet d'importer facilement tous les systèmes depuis un seul endroit.
 */

export { InputSystem, type InputState, type InputConfig } from './InputSystem';
export { RenderSystem, type RenderState, type RenderConfig } from './RenderSystem';
export { KitePhysicsSystem } from './KitePhysicsSystem';
export { ControlBarSystem } from './ControlBarSystem';
export { LinesRenderSystem } from './LinesRenderSystem';
export { PilotSystem } from './PilotSystem';

=== simulation/types/BridleTypes.ts ===

/**
 * BridleTypes.ts - Types et interfaces pour le système de bridage
 *
 * Définit les structures de données pour les brides du cerf-volant.
 * Les brides relient des points anatomiques du kite (NEZ, INTER, CENTRE)
 * aux points de contrôle (CTRL_GAUCHE, CTRL_DROIT).
 */

/**
 * Longueurs physiques des 3 types de brides
 * (identique pour gauche et droite)
 */
export interface BridleLengths {
  /** Longueur bride NEZ → CTRL (mètres) */
  nez: number;

  /** Longueur bride INTER → CTRL (mètres) */
  inter: number;

  /** Longueur bride CENTRE → CTRL (mètres) */
  centre: number;
}

/**
 * Tensions actuelles des 6 brides
 * (3 gauches + 3 droites)
 */
export interface BridleTensions {
  /** Tension bride NEZ gauche (Newtons) */
  leftNez: number;

  /** Tension bride INTER gauche (Newtons) */
  leftInter: number;

  /** Tension bride CENTRE gauche (Newtons) */
  leftCentre: number;

  /** Tension bride NEZ droite (Newtons) */
  rightNez: number;

  /** Tension bride INTER droite (Newtons) */
  rightInter: number;

  /** Tension bride CENTRE droite (Newtons) */
  rightCentre: number;
}

/**
 * Définition d'une attache de bride
 * (relie deux points anatomiques du kite)
 */
export interface BridleAttachment {
  /** Nom du point de départ (ex: "NEZ", "INTER_GAUCHE") */
  startPoint: string;

  /** Nom du point d'arrivée (ex: "CTRL_GAUCHE", "CTRL_DROIT") */
  endPoint: string;

  /** Longueur au repos (mètres) */
  length: number;

  /** Identifiant unique (ex: "bridle_left_nez") */
  id: string;
}

/**
 * Type des côtés du bridage
 */
export type BridleSide = 'left' | 'right';

/**
 * Type des positions de bride
 */
export type BridlePosition = 'nez' | 'inter' | 'centre';

/**
 * Configuration complète d'une bride (utilisé par BridleFactory)
 */
export interface BridleConfig {
  /** Côté de la bride */
  side: BridleSide;

  /** Position de la bride */
  position: BridlePosition;

  /** Longueur (mètres) */
  length: number;

  /** Identifiant unique */
  id: string;
}


=== simulation/types/PhysicsTypes.ts ===

/**
 * PhysicsTypes.ts - Types et interfaces pour la physique de la simulation Kite
 *
 * Rôle :
 *   - Définit les structures de données pour l'état du cerf-volant, les forces, les poignées, etc.
 *   - Sert à typer les échanges entre les modules physiques et de rendu
 *
 * Dépendances principales :
 *   - Three.js : Pour les vecteurs et quaternions
 *
 * Relation avec les fichiers adjacents :
 *   - WindTypes.ts : Définit les types pour le vent
 *   - Tous les modules physiques et de rendu importent PhysicsTypes pour typer les données
 *
 * Utilisation typique :
 *   - Utilisé dans PhysicsEngine, AerodynamicsCalculator, DebugRenderer, etc.
 *   - Sert à garantir la cohérence des échanges de données physiques
 *
 * Voir aussi :
 *   - src/simulation/types/WindTypes.ts
 */
import * as THREE from "three";

/**
 * Types et interfaces pour la physique de la simulation
 */

export interface KiteState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  orientation?: THREE.Quaternion;
  acceleration?: THREE.Vector3;
  angularAcceleration?: THREE.Vector3;
  mass?: number;
  totalLiftForce?: THREE.Vector3; // Ajouté pour le debug UI
  totalDragForce?: THREE.Vector3; // Ajouté pour le debug UI
}

/**
 * État du vent
 */
export interface WindState {
  baseSpeed: number; // m/s
  baseDirection: THREE.Vector3;
  turbulence: number; // %
  gustFrequency?: number;
  gustAmplitude?: number;
  time?: number;
}

export interface HandlePositions {
  left: THREE.Vector3;
  right: THREE.Vector3;
}

/**
 * Force appliquée sur une surface spécifique du kite
 */
export interface SurfaceForce {
  /** Indice de la surface dans KiteGeometry.SURFACES */
  surfaceIndex: number;
  /** Portance sur cette surface (en Newton) */
  lift: THREE.Vector3;
  /** Traînée sur cette surface (en Newton) */
  drag: THREE.Vector3;
  /** Friction sur cette surface (optionnel, en Newton) */
  friction?: THREE.Vector3;
  /** Force totale (résultante) sur cette surface (en Newton) */
  resultant: THREE.Vector3;
  /** Centre géométrique de la surface (en coordonnées monde) */
  center: THREE.Vector3;
  /** Normale de la surface (en coordonnées monde) */
  normal: THREE.Vector3;
  /** Surface en m² */
  area: number;
}

=== simulation/types/WindTypes.ts ===


/**
 * WindTypes.ts - Types pour le système de vent de la simulation Kite
 *
 * Rôle :
 *   - Définit la structure des paramètres de vent (vitesse, direction, turbulence)
 *   - Sert à typer les échanges entre le simulateur de vent et les autres modules
 *
 * Dépendances principales :
 *   - Aucun import direct, mais utilisé par WindSimulator et PhysicsEngine
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsTypes.ts : Définit les types pour la physique
 *   - Tous les modules physiques et de rendu importent WindTypes pour typer le vent
 *
 * Utilisation typique :
 *   - Utilisé dans WindSimulator, PhysicsEngine, DebugRenderer, etc.
 *   - Sert à garantir la cohérence des échanges de données de vent
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 */

export interface WindParams {
  speed: number; // km/h
  direction: number; // degrés
  turbulence: number; // pourcentage
}

=== simulation/types/index.ts ===


/**
 * index.ts - Export centralisé de tous les types de la simulation Kite
 *
 * Rôle :
 *   - Centralise l'export des types physiques et de vent
 *   - Permet d'importer tous les types depuis un seul point
 *
 * Dépendances principales :
 *   - PhysicsTypes.ts : Types pour la physique
 *   - WindTypes.ts : Types pour le vent
 *
 * Relation avec les fichiers adjacents :
 *   - Sert de point d'entrée pour tous les imports de types dans le projet
 *
 * Utilisation typique :
 *   - Importé dans les modules physiques, de rendu, de configuration, etc.
 *   - Facilite la maintenance et la cohérence des types
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 *   - src/simulation/types/WindTypes.ts
 */

export * from './PhysicsTypes';
export * from './WindTypes';

=== simulation/ui/UIManager.ts ===

import * as THREE from "three";

import { CONFIG } from "../config/SimulationConfig";
import { DebugRenderer } from "../rendering/DebugRenderer";
import { KiteGeometry } from "../config/KiteGeometry";
import type { KiteState } from "../types";

export interface BridleLengths {
  nez: number;
  inter: number;
  centre: number;
}

export interface WindSnapshot {
  baseSpeed: number; // m/s
  baseDirection: THREE.Vector3;
  turbulence: number; // %
}

export interface ControlLineDiagnostics {
  lineLength: number;
  leftDistance: number;
  rightDistance: number;
  leftTaut: boolean;
  rightTaut: boolean;
  leftTension?: number;
  rightTension?: number;
}

export interface AerodynamicForcesSnapshot {
  lift: THREE.Vector3;
  drag: THREE.Vector3;
}

export interface SimulationControls {
  getBridleLengths(): BridleLengths;
  setBridleLength(type: "nez" | "inter" | "centre", length: number): void;
  setLineLength(length: number): void;
  setWindParams(params: { speed?: number; direction?: number; turbulence?: number }): void;
  getForceSmoothing(): number;
  setForceSmoothing(value: number): void;
  getKiteState(): KiteState;
  getWindState(): WindSnapshot;
  getLineLength(): number;
  getControlLineDiagnostics(): ControlLineDiagnostics | null;
  getAerodynamicForces(): AerodynamicForcesSnapshot | null;
}

/**
 * Gestionnaire de l'interface utilisateur
 *
 * Gère les contrôles et interactions utilisateur
 */
export interface SliderConfig {
  id: string;
  initialValue: number;
  onInput: (value: number) => void;
  formatter?: (value: number) => string;
  step?: number;
}

export class UIManager {
  private simulation: SimulationControls;
  private debugRenderer: DebugRenderer;
  private resetCallback: () => void;
  private togglePlayCallback: () => void;

  constructor(
    simulation: SimulationControls,
    debugRenderer: DebugRenderer,
    resetCallback: () => void,
    togglePlayCallback: () => void,
  ) {
    this.simulation = simulation;
    this.debugRenderer = debugRenderer;
    this.resetCallback = resetCallback;
    this.togglePlayCallback = togglePlayCallback;
    this.setupControls();
  }

  private setupControls(): void {
    const resetBtn = document.getElementById("reset-sim");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.resetCallback();
      });
    }

    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.togglePlayCallback();
      });
    }

    const debugBtn = document.getElementById("debug-physics");
    if (debugBtn) {
      debugBtn.textContent = this.debugRenderer.isDebugMode() ? "🔍 Debug ON" : "🔍 Debug OFF";
      debugBtn.classList.toggle("active", this.debugRenderer.isDebugMode());

      debugBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.debugRenderer.toggleDebugMode();
      });
    }

    if (this.debugRenderer.isDebugMode()) {
      document.body.classList.add("debug-mode");
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        debugPanel.style.display = "block";
      }
    }

    this.setupWindControls();
  }

  // Interface SliderConfig définie en dehors de la classe

  /**
   * Crée et configure un slider générique
   */
  private createSlider(config: SliderConfig): void {
    const slider = document.getElementById(config.id) as HTMLInputElement | null;
    const valueElement = document.getElementById(`${config.id}-value`);

    if (!slider || !valueElement) return;

    slider.value = config.initialValue.toFixed(config.step ?? 1);
    valueElement.textContent = config.formatter
      ? config.formatter(config.initialValue)
      : config.initialValue.toFixed(config.step ?? 1);

    slider.oninput = () => {
      const value = parseFloat(slider.value);
      config.onInput(value);

      valueElement.textContent = config.formatter
        ? config.formatter(value)
        : value.toFixed(config.step ?? 1);
    };
  }

  /**
   * Configure les contrôles de vent
   */
  private setupWindControlsGroup(): void {
    const currentWind = this.simulation.getWindState();

    // Vitesse du vent
    this.createSlider({
      id: "wind-speed",
      initialValue: (currentWind?.baseSpeed ?? CONFIG.wind.defaultSpeed) * (1 / CONFIG.conversions.kmhToMs),
      onInput: (speed) => this.simulation.setWindParams({ speed }),
      formatter: (value) => `${value.toFixed(1)} km/h`
    });

    // Direction du vent
    this.createSlider({
      id: "wind-direction",
      initialValue: this.computeDirectionDegrees(currentWind?.baseDirection),
      onInput: (direction) => this.simulation.setWindParams({ direction }),
      formatter: (value) => `${value.toFixed(0)}°`,
      step: 1
    });

    // Turbulence du vent
    this.createSlider({
      id: "wind-turbulence",
      initialValue: currentWind?.turbulence ?? CONFIG.wind.defaultTurbulence,
      onInput: (turbulence) => this.simulation.setWindParams({ turbulence }),
      formatter: (value) => `${value.toFixed(1)}%`
    });
  }

  /**
   * Configure les contrôles des lignes
   */
  private setupLineControlsGroup(): void {
    // Longueur des lignes
    this.createSlider({
      id: "line-length",
      initialValue: this.simulation.getLineLength(),
      onInput: (length) => this.simulation.setLineLength(length),
      formatter: (value) => `${value.toFixed(0)}m`,
      step: 1
    });

    // Brides
    const currentBridle = this.simulation.getBridleLengths();

    this.createSlider({
      id: "bridle-nez",
      initialValue: currentBridle.nez,
      onInput: (length) => this.simulation.setBridleLength("nez", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });

    this.createSlider({
      id: "bridle-inter",
      initialValue: currentBridle.inter,
      onInput: (length) => this.simulation.setBridleLength("inter", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });

    this.createSlider({
      id: "bridle-centre",
      initialValue: currentBridle.centre,
      onInput: (length) => this.simulation.setBridleLength("centre", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });
  }

  /**
   * Configure les contrôles de physique
   */
  private setupPhysicsControlsGroup(): void {
    // Amortissement linéaire
    this.createSlider({
      id: "linear-damping",
      initialValue: CONFIG.physics.linearDampingCoeff,
      onInput: (damping) => { CONFIG.physics.linearDampingCoeff = damping; }
    });

    // Facteur de traînée angulaire
    this.createSlider({
      id: "angular-damping",
      initialValue: CONFIG.physics.angularDragFactor,
      onInput: (dragFactor) => { CONFIG.physics.angularDragFactor = dragFactor; }
    });

    // Niveau de subdivision du maillage
    this.createSlider({
      id: "mesh-subdivision-level",
      initialValue: CONFIG.kite.defaultMeshSubdivisionLevel,
      onInput: (level) => {
        const intLevel = parseInt(level.toString(), 10);
        CONFIG.kite.defaultMeshSubdivisionLevel = intLevel;
        KiteGeometry.setMeshSubdivisionLevel(intLevel);
      },
      formatter: (value) => {
        const level = parseInt(value.toString(), 10);
        const triangleCount = Math.pow(4, level + 1);
        return `${level} (${triangleCount} triangles)`;
      },
      step: 1
    });
  }

  /**
   * Configure les contrôles aérodynamiques
   */
  private setupAerodynamicControlsGroup(): void {
    // Échelle de portance
    this.createSlider({
      id: "lift-scale",
      initialValue: CONFIG.aero.liftScale,
      onInput: (scale) => { CONFIG.aero.liftScale = scale; }
    });

    // Échelle de traînée
    this.createSlider({
      id: "drag-scale",
      initialValue: CONFIG.aero.dragScale,
      onInput: (scale) => { CONFIG.aero.dragScale = scale; }
    });

    // Lissage des forces
    this.createSlider({
      id: "force-smoothing",
      initialValue: this.simulation.getForceSmoothing(),
      onInput: (smoothing) => this.simulation.setForceSmoothing(smoothing)
    });
  }

  private setupWindControls(): void {
    this.setupWindControlsGroup();
    this.setupLineControlsGroup();
    this.setupPhysicsControlsGroup();
    this.setupAerodynamicControlsGroup();
  }

  updatePlayButton(isPlaying: boolean): void {
    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.textContent = isPlaying ? "⏸️ Pause" : "▶️ Lancer";
    }
  }

  updateDebugInfo(): void {
    const debugInfo = document.getElementById("debug-info");
    if (!debugInfo || !this.debugRenderer.isDebugMode()) return;

    const kiteState = this.simulation.getKiteState();
    const windState = this.simulation.getWindState();
    const controlDiagnostics = this.simulation.getControlLineDiagnostics();
    const aeroForces = this.simulation.getAerodynamicForces();

    const kitePosition = kiteState?.position ?? new THREE.Vector3();
    const kiteVelocity = kiteState?.velocity ?? new THREE.Vector3();

    let tensionInfo = "N/A";
    if (controlDiagnostics) {
      const leftState = controlDiagnostics.leftTaut ? "TENDU" : "RELÂCHÉ";
      const rightState = controlDiagnostics.rightTaut ? "TENDU" : "RELÂCHÉ";
      const leftDistance = controlDiagnostics.leftDistance.toFixed(2);
      const rightDistance = controlDiagnostics.rightDistance.toFixed(2);
      const leftTension = controlDiagnostics.leftTension ?? 0;
      const rightTension = controlDiagnostics.rightTension ?? 0;
      tensionInfo = `L:${leftState}(${leftDistance}m, ${leftTension.toFixed(1)}N) R:${rightState}(${rightDistance}m, ${rightTension.toFixed(1)}N)`;
    }

    const liftMagnitude = aeroForces ? aeroForces.lift.length() : 0;
    const dragMagnitude = aeroForces ? aeroForces.drag.length() : 0;
    const totalForce = Math.sqrt(liftMagnitude * liftMagnitude + dragMagnitude * dragMagnitude);

    debugInfo.innerHTML = `
      <strong>🪁 Position Cerf-volant:</strong><br>
      X: ${kitePosition.x.toFixed(2)}m, Y: ${kitePosition.y.toFixed(2)}m, Z: ${kitePosition.z.toFixed(2)}m<br><br>

      <strong>💨 Vent:</strong><br>
      Vitesse: ${windState.baseSpeed.toFixed(1)} m/s (${(windState.baseSpeed * 3.6).toFixed(1)} km/h)<br>
      Direction: (${windState.baseDirection.x.toFixed(0)}, ${windState.baseDirection.y.toFixed(0)}, ${windState.baseDirection.z.toFixed(0)})<br>
      Turbulence: ${windState.turbulence.toFixed(1)}%<br><br>

      <strong>⚡ Forces Aérodynamiques:</strong><br>
      Portance: ${liftMagnitude.toFixed(3)} N<br>
      Traînée: ${dragMagnitude.toFixed(3)} N<br>
      Force Totale: ${totalForce.toFixed(3)} N<br><br>

      <strong>🔗 Tensions Lignes:</strong><br>
      ${tensionInfo}<br><br>

      <strong>🏃 Vitesse Cerf-volant:</strong><br>
      ${kiteVelocity.length().toFixed(2)} m/s<br><br>

      <strong>⚙️ Performance:</strong><br>
      Statut: <span style="color: #00ff88;">STABLE</span>
    `;
  }

  private computeDirectionDegrees(direction?: THREE.Vector3): number {
    if (!direction || direction.lengthSq() === 0) {
      return CONFIG.wind.defaultDirection;
    }

    const normalized = direction.clone().normalize();
    const radians = Math.atan2(normalized.x, -normalized.z);
    const degrees = THREE.MathUtils.radToDeg(radians);

    return (degrees + 360) % 360;
  }
}

=== types/index.ts ===

/**
 * Types centralisés pour le système de visualisation 3D
 * Interface unique et cohérente pour tous les objets
 */

import * as THREE from 'three';

/**
 * Position 3D simple [x, y, z]
 */
export type Position3D = [number, number, number];

/**
 * Interface principale que TOUS les objets doivent implémenter
 * 🎮 v3.0: Compatible avec l'architecture StructuredObject + Node3D
 */
export interface ICreatable {
  /**
   * Retourne l'objet lui-même (StructuredObject hérite de Node3D)
   * Pattern fluent pour la nouvelle architecture
   */
  create(): this;

  /**
   * Nom affiché dans l'interface utilisateur
   */
  getName(): string;

  /**
   * Description courte de l'objet
   */
  getDescription(): string;

  /**
   * Nombre de primitives utilisées (pour statistiques)
   */
  getPrimitiveCount(): number;
}

/**
 * Options pour créer des surfaces
 */
export interface SurfaceOptions {
  color?: string;
  transparent?: boolean;
  opacity?: number;
  doubleSide?: boolean;
  wireframe?: boolean;
}

/**
 * Configuration pour les matériaux
 */
export interface MaterialConfig {
  color: string;
  transparent?: boolean;
  opacity?: number;
  metalness?: number;
  roughness?: number;
  side?: THREE.Side;
}

/**
 * Interface pour un point nommé dans l'espace 3D
 */
export interface NamedPoint {
  name: string;
  position: THREE.Vector3;
  visible?: boolean;
}

/**
 * Métadonnées optionnelles pour les objets
 */
export interface ObjectMetadata {
  category?: string;
  complexity?: 'simple' | 'medium' | 'complex';
  tags?: string[];
  author?: string;
  version?: string;
}

=== utils/GeometryUtils.ts ===

/**
 * GeometryUtils.ts - Utilitaires géométriques pour la simulation 3D
 */

import * as THREE from 'three';

export class GeometryUtils {
  /**
   * Calcule l'aire d'un triangle 3D
   */
  static triangleArea(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): number {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const cross = edge1.cross(edge2);
    return cross.length() * 0.5;
  }

  /**
   * Calcule la normale d'un triangle
   */
  static triangleNormal(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    return edge1.cross(edge2).normalize();
  }

  /**
   * Calcule le centroïde d'un triangle
   */
  static triangleCentroid(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    return v1.clone().add(v2).add(v3).divideScalar(3);
  }

  /**
   * Vérifie si un point est à l'intérieur d'un triangle (dans le plan)
   */
  static pointInTriangle2D(point: THREE.Vector2, v1: THREE.Vector2, v2: THREE.Vector2, v3: THREE.Vector2): boolean {
    const d1 = this.sign(point, v1, v2);
    const d2 = this.sign(point, v2, v3);
    const d3 = this.sign(point, v3, v1);

    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(hasNeg && hasPos);
  }

  /**
   * Calcule le barycentre d'un ensemble de points
   */
  static centroid(points: THREE.Vector3[]): THREE.Vector3 {
    if (points.length === 0) return new THREE.Vector3();

    const sum = points.reduce((acc, point) => acc.add(point), new THREE.Vector3());
    return sum.divideScalar(points.length);
  }

  /**
   * Calcule la bounding box d'un ensemble de points
   */
  static boundingBox(points: THREE.Vector3[]): { min: THREE.Vector3; max: THREE.Vector3 } {
    if (points.length === 0) {
      return { min: new THREE.Vector3(), max: new THREE.Vector3() };
    }

    const min = points[0].clone();
    const max = points[0].clone();

    for (let i = 1; i < points.length; i++) {
      min.min(points[i]);
      max.max(points[i]);
    }

    return { min, max };
  }

  /**
   * Projette un point sur un plan défini par un point et une normale
   */
  static projectPointOnPlane(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): THREE.Vector3 {
    const toPoint = point.clone().sub(planePoint);
    const distance = toPoint.dot(planeNormal);
    return point.clone().sub(planeNormal.clone().multiplyScalar(distance));
  }

  /**
   * Calcule la distance d'un point à un plan
   */
  static pointToPlaneDistance(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): number {
    const toPoint = point.clone().sub(planePoint);
    return toPoint.dot(planeNormal);
  }

  /**
   * Vérifie si deux segments se croisent (2D)
   */
  static segmentsIntersect2D(
    a1: THREE.Vector2, a2: THREE.Vector2,
    b1: THREE.Vector2, b2: THREE.Vector2
  ): boolean {
    const denom = (a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x);
    if (Math.abs(denom) < 1e-6) return false; // Parallèles

    const t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x)) / denom;
    const u = -((a1.x - a2.x) * (a1.y - b1.y) - (a1.y - a2.y) * (a1.x - b1.x)) / denom;

    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }

  /**
   * Calcule l'angle solide d'un triangle vu depuis un point
   */
  static solidAngle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3, viewpoint: THREE.Vector3): number {
    const a = v1.clone().sub(viewpoint).normalize();
    const b = v2.clone().sub(viewpoint).normalize();
    const c = v3.clone().sub(viewpoint).normalize();

    const numerator = Math.abs(a.dot(b.cross(c)));
    const denominator = 1 + a.dot(b) + b.dot(c) + c.dot(a);
    return 2 * Math.atan2(numerator, denominator);
  }

  /**
   * Génère des points sur une sphère
   */
  static fibonacciSphere(samples: number, radius: number = 1): THREE.Vector3[] {
    const points: THREE.Vector3[] = [];
    const phi = Math.PI * (3 - Math.sqrt(5)); // Angle d'or

    for (let i = 0; i < samples; i++) {
      const y = 1 - (i / (samples - 1)) * 2; // y entre -1 et 1
      const radiusAtY = Math.sqrt(1 - y * y);

      const theta = phi * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      points.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
    }

    return points;
  }

  /**
   * Fonction auxiliaire pour pointInTriangle2D
   */
  private static sign(p1: THREE.Vector2, p2: THREE.Vector2, p3: THREE.Vector2): number {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  }
}

=== utils/Logging.ts ===

/**
 * Logging.ts - Système de logging configurable pour la simulation
 */

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: number;
  category?: string;
  data?: any;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.INFO;
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;
  private categories: Set<string> = new Set();

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Configure le niveau de log minimum
   */
  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }

  /**
   * Active/désactive une catégorie de logs
   */
  setCategoryEnabled(category: string, enabled: boolean): void {
    if (enabled) {
      this.categories.add(category);
    } else {
      this.categories.delete(category);
    }
  }

  /**
   * Log de debug
   */
  debug(message: string, category?: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, category, data);
  }

  /**
   * Log d'information
   */
  info(message: string, category?: string, data?: any): void {
    this.log(LogLevel.INFO, message, category, data);
  }

  /**
   * Log d'avertissement
   */
  warn(message: string, category?: string, data?: any): void {
    this.log(LogLevel.WARN, message, category, data);
  }

  /**
   * Log d'erreur
   */
  error(message: string, category?: string, data?: any): void {
    this.log(LogLevel.ERROR, message, category, data);
  }

  /**
   * Log générique
   */
  private log(level: LogLevel, message: string, category?: string, data?: any): void {
    // Vérifier le niveau
    if (level < this.logLevel) return;

    // Vérifier la catégorie si spécifiée
    if (category && !this.categories.has(category)) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: Date.now(),
      category,
      data
    };

    // Ajouter aux logs internes
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift(); // Supprimer le plus ancien
    }

    // Afficher dans la console selon le niveau
    const prefix = category ? `[${category}]` : '';
    const formattedMessage = `${prefix} ${message}`;

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`🐛 ${formattedMessage}`, data || '');
        break;
      case LogLevel.INFO:
        console.info(`ℹ️ ${formattedMessage}`, data || '');
        break;
      case LogLevel.WARN:
        console.warn(`⚠️ ${formattedMessage}`, data || '');
        break;
      case LogLevel.ERROR:
        console.error(`❌ ${formattedMessage}`, data || '');
        break;
    }
  }

  /**
   * Obtient tous les logs
   */
  getLogs(level?: LogLevel, category?: string): LogEntry[] {
    return this.logs.filter(entry => {
      if (level !== undefined && entry.level < level) return false;
      if (category && entry.category !== category) return false;
      return true;
    });
  }

  /**
   * Obtient les derniers logs
   */
  getRecentLogs(count: number = 10): LogEntry[] {
    return this.logs.slice(-count);
  }

  /**
   * Efface tous les logs
   */
  clearLogs(): void {
    this.logs = [];
  }

  /**
   * Exporte les logs au format JSON
   */
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * Importe des logs depuis JSON
   */
  importLogs(json: string): void {
    try {
      const imported = JSON.parse(json) as LogEntry[];
      this.logs.push(...imported);
      // Garder seulement les maxLogs plus récents
      if (this.logs.length > this.maxLogs) {
        this.logs = this.logs.slice(-this.maxLogs);
      }
    } catch (error) {
      this.error('Erreur lors de l\'import des logs', 'Logger', error);
    }
  }

  /**
   * Statistiques des logs
   */
  getStats(): {
    total: number;
    byLevel: Record<LogLevel, number>;
    byCategory: Record<string, number>;
  } {
    const byLevel = {
      [LogLevel.DEBUG]: 0,
      [LogLevel.INFO]: 0,
      [LogLevel.WARN]: 0,
      [LogLevel.ERROR]: 0,
      [LogLevel.NONE]: 0
    };

    const byCategory: Record<string, number> = {};

    for (const entry of this.logs) {
      byLevel[entry.level]++;

      if (entry.category) {
        byCategory[entry.category] = (byCategory[entry.category] || 0) + 1;
      }
    }

    return {
      total: this.logs.length,
      byLevel,
      byCategory
    };
  }
}

// Instance globale pour utilisation facile
export const log = Logger.getInstance();

=== utils/MathUtils.ts ===

/**
 * MathUtils.ts - Utilitaires mathématiques pour la simulation 3D
 */

import * as THREE from 'three';

export class MathUtils {
  /**
   * Clamp une valeur entre min et max
   */
  static clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }

  /**
   * Interpolation linéaire
   */
  static lerp(a: number, b: number, t: number): number {
    return a + (b - a) * MathUtils.clamp(t, 0, 1);
  }

  /**
   * Interpolation sphérique (pour les rotations)
   */
  static slerp(q1: THREE.Quaternion, q2: THREE.Quaternion, t: number): THREE.Quaternion {
    return new THREE.Quaternion().slerpQuaternions(q1, q2, MathUtils.clamp(t, 0, 1));
  }

  /**
   * Distance euclidienne entre deux points 3D
   */
  static distance(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceTo(p2);
  }

  /**
   * Distance au carré (plus rapide pour les comparaisons)
   */
  static distanceSquared(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceToSquared(p2);
  }

  /**
   * Angle entre deux vecteurs (en radians)
   */
  static angleBetween(v1: THREE.Vector3, v2: THREE.Vector3): number {
    return v1.angleTo(v2);
  }

  /**
   * Projection d'un vecteur sur un autre
   */
  static project(v: THREE.Vector3, onto: THREE.Vector3): THREE.Vector3 {
    const ontoNormalized = onto.clone().normalize();
    return ontoNormalized.multiplyScalar(v.dot(ontoNormalized));
  }

  /**
   * Composante perpendiculaire d'un vecteur par rapport à un autre
   */
  static perpendicular(v: THREE.Vector3, to: THREE.Vector3): THREE.Vector3 {
    return v.clone().sub(this.project(v, to));
  }

  /**
   * Vérifie si un nombre est proche de zéro
   */
  static isZero(value: number, epsilon: number = 1e-6): boolean {
    return Math.abs(value) < epsilon;
  }

  /**
   * Vérifie si deux nombres sont égaux avec une tolérance
   */
  static equals(a: number, b: number, epsilon: number = 1e-6): boolean {
    return Math.abs(a - b) < epsilon;
  }

  /**
   * Génère un nombre aléatoire entre min et max
   */
  static random(min: number = 0, max: number = 1): number {
    return Math.random() * (max - min) + min;
  }

  /**
   * Convertit degrés en radians
   */
  static degToRad(degrees: number): number {
    return degrees * Math.PI / 180;
  }

  /**
   * Convertit radians en degrés
   */
  static radToDeg(radians: number): number {
    return radians * 180 / Math.PI;
  }

  /**
   * Normalise un angle en radians entre -PI et PI
   */
  static normalizeAngle(angle: number): number {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  /**
   * Interpolation smoothstep (plus douce que lerp)
   */
  static smoothstep(edge0: number, edge1: number, x: number): number {
    const t = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }

  /**
   * Fonction de easing (ease-in-out)
   */
  static easeInOut(t: number): number {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  /**
   * Calcule la position initiale du kite avec lignes tendues
   * Utilise le théorème de Pythagore pour placer le kite devant le pilote
   * 
   * @param pilotPosition - Position du pilote
   * @param kiteY - Hauteur Y du kite
   * @param lineLength - Longueur des lignes
   * @param distanceFactor - Facteur de distance initiale (0-1, typiquement 0.98 pour lignes presque tendues)
   * @param initialKiteZ - Position Z fixe (optionnelle, sinon calculée automatiquement)
   * @returns Position 3D calculée du kite
   */
  static calculateInitialKitePosition(
    pilotPosition: THREE.Vector3,
    kiteY: number,
    lineLength: number,
    distanceFactor: number,
    initialKiteZ?: number | null
  ): THREE.Vector3 {
    // Si une position Z fixe est fournie, l'utiliser directement
    if (initialKiteZ !== null && initialKiteZ !== undefined) {
      return new THREE.Vector3(pilotPosition.x, kiteY, initialKiteZ);
    }

    // Calculer la distance initiale (98% de la longueur des lignes par défaut)
    const initialDistance = lineLength * distanceFactor;

    // Différence de hauteur entre kite et pilote
    const dy = kiteY - pilotPosition.y;

    // Calculer la distance horizontale avec Pythagore: horizontal² = distance² - dy²
    const horizontal = Math.max(
      0.1, // Minimum pour éviter division par zéro
      Math.sqrt(Math.max(0, initialDistance * initialDistance - dy * dy))
    );

    // Position Z : devant le pilote (direction -Z)
    const kiteZ = pilotPosition.z - horizontal;

    return new THREE.Vector3(pilotPosition.x, kiteY, kiteZ);
  }
}

=== utils/UidGenerator.ts ===

/**
 * UidGenerator.ts - Générateur d'identifiants uniques
 */

export class UidGenerator {
  private static counter = 0;
  private static readonly chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  /**
   * Génère un UID simple basé sur timestamp et compteur
   */
  static generate(prefix: string = ''): string {
    const timestamp = Date.now().toString(36);
    const count = (this.counter++).toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `${prefix}${timestamp}${count}${random}`;
  }

  /**
   * Génère un UID court (8 caractères)
   */
  static generateShort(): string {
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += this.chars.charAt(Math.floor(Math.random() * this.chars.length));
    }
    return result;
  }

  /**
   * Génère un UID basé sur des propriétés d'objet
   */
  static generateFromObject(obj: any, properties: string[]): string {
    let hash = 0;
    const str = properties.map(prop => obj[prop] || '').join('|');

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }

  /**
   * Génère un UUID v4 standard
   */
  static generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Génère un ID séquentiel
   */
  static generateSequential(prefix: string = 'id_'): string {
    return `${prefix}${(this.counter++).toString().padStart(6, '0')}`;
  }

  /**
   * Réinitialise le compteur (utile pour les tests)
   */
  static reset(): void {
    this.counter = 0;
  }

  /**
   * Vérifie si une chaîne est un UID valide (format de base)
   */
  static isValid(uid: string): boolean {
    // Vérification basique : contient des lettres, chiffres, et fait une longueur raisonnable
    return /^[A-Za-z0-9_-]{8,}$/.test(uid);
  }

  /**
   * Génère un hash simple d'une chaîne
   */
  static hashString(str: string): string {
    let hash = 0;
    if (str.length === 0) return hash.toString(36);

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }
}

