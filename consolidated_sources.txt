CONSOLIDATION DES SOURCES - Thu Oct  9 13:33:30 UTC 2025
==================================

=== base/BaseComponent.ts ===

/**
 * BaseComponent.ts - Syst√®me de composants pour les objets 3D
 *
 * Pattern : Component Pattern (similaire √† Unity/ECS)
 * Permet d'ajouter des fonctionnalit√©s optionnelles aux Node3D
 * sans h√©riter de classes lourdes.
 */

import { Node3D } from '../core/Node3D';

export interface ComponentContext {
  deltaTime: number;
  totalTime: number;
  parent: Node3D;
}

export abstract class BaseComponent {
  protected name: string;
  protected enabled: boolean = true;
  protected parent?: Node3D;

  constructor(name: string) {
    this.name = name;
  }

  /**
   * Attache le composant √† un parent
   */
  attachTo(parent: Node3D): void {
    this.parent = parent;
    this.onAttach();
  }

  /**
   * D√©tache le composant de son parent
   */
  detach(): void {
    this.onDetach();
    this.parent = undefined;
  }

  /**
   * Appel√© quand le composant est attach√©
   */
  protected onAttach(): void {
    // Override dans les sous-classes
  }

  /**
   * Appel√© quand le composant est d√©tach√©
   */
  protected onDetach(): void {
    // Override dans les sous-classes
  }

  /**
   * Met √† jour le composant
   */
  abstract update(context: ComponentContext): void;

  /**
   * Active/d√©sactive le composant
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getParent(): Node3D | undefined {
    return this.parent;
  }
}

/**
 * Composant de debug visuel
 */
export class DebugComponent extends BaseComponent {
  update(context: ComponentContext): void {
    // Logique de debug visuel
  }
}

/**
 * Composant de physique
 */
export class PhysicsComponent extends BaseComponent {
  update(context: ComponentContext): void {
    // Logique de physique
  }
}

=== base/BaseFactory.ts ===

/**
 * BaseFactory.ts - Factory abstraite pour tous les objets 3D
 * 
 * Pattern Factory Method avec support des param√®tres configurables
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';
import { BaseFactory as RegistryBaseFactory, FactoryMetadata } from '../factories/FactoryRegistry';

export interface FactoryParams {
  [key: string]: any;
}

export interface ObjectMetadata {
  category: string;
  name: string;
  description: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'complex';
}

/**
 * Factory abstraite pour la cr√©ation d'objets 3D
 */
export abstract class BaseFactory<T extends StructuredObject & ICreatable> {
  protected abstract metadata: ObjectMetadata;

  /**
   * Cr√©er un objet avec des param√®tres optionnels
   */
  abstract createObject(params?: FactoryParams): T | Promise<T>;

  /**
   * Obtenir les m√©tadonn√©es de l'objet
   */
  getMetadata(): ObjectMetadata {
    return { ...this.metadata };
  }

  /**
   * Obtenir la cat√©gorie de l'objet
   */
  getCategory(): string {
    return this.metadata.category;
  }

  /**
   * Obtenir le nom de l'objet
   */
  getName(): string {
    return this.metadata.name;
  }

  /**
   * Valider les param√®tres avant cr√©ation
   */
  protected validateParams(params?: FactoryParams): void {
    // Validation de base - √† surcharger dans les classes d√©riv√©es
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value === null || value === undefined) {
          throw new Error(`Param√®tre '${key}' ne peut pas √™tre null ou undefined`);
        }
      });
    }
  }

  /**
   * Param√®tres par d√©faut - √† surcharger dans les classes d√©riv√©es
   */
  protected getDefaultParams(): FactoryParams {
    return {};
  }

  /**
   * Fusionner les param√®tres par d√©faut avec les param√®tres fournis
   */
  protected mergeParams(params?: FactoryParams): FactoryParams {
    return {
      ...this.getDefaultParams(),
      ...params
    };
  }

  /**
   * Nettoyer les ressources de la factory
   */
  dispose(): void {
    // √Ä surcharger dans les classes d√©riv√©es si n√©cessaire
  }
}


=== base/BaseSimulationSystem.ts ===

/**
 * BaseSimulationSystem.ts - Interface de base pour tous les syst√®mes de simulation
 *
 * Pattern : Template Method pour les syst√®mes de simulation
 * Chaque syst√®me (Physics, Wind, Input, etc.) h√©rite de cette classe
 * et impl√©mente ses m√©thodes sp√©cifiques.
 */

export interface SimulationContext {
  deltaTime: number;
  totalTime: number;
  isPaused: boolean;
  debugMode: boolean;
}

export abstract class BaseSimulationSystem {
  protected name: string;
  protected enabled: boolean = true;
  protected priority: number = 0; // Ordre d'ex√©cution (plus petit = plus prioritaire)

  constructor(name: string, priority: number = 0) {
    this.name = name;
    this.priority = priority;
  }

  /**
   * Initialise le syst√®me (appel√© une fois au d√©marrage)
   */
  abstract initialize(): void;

  /**
   * Met √† jour le syst√®me (appel√© chaque frame)
   */
  abstract update(context: SimulationContext): void;

  /**
   * R√©initialise le syst√®me √† son √©tat initial
   */
  abstract reset(): void;

  /**
   * Nettoie les ressources du syst√®me
   */
  abstract dispose(): void;

  /**
   * Active/d√©sactive le syst√®me
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getPriority(): number {
    return this.priority;
  }

  /**
   * Validation interne du syst√®me
   */
  validate(): boolean {
    return true; // Override dans les sous-classes si n√©cessaire
  }
}

=== core/DebugLayer.ts ===

/**
 * DebugLayer.ts - Couche de debug visuel pour les objets 3D
 *
 * R√¥le : Gestion centralis√©e de tous les √©l√©ments de debug visuel
 * S√©pare compl√®tement la logique de debug du mesh principal
 */

import * as THREE from 'three';
import { Node3D } from './Node3D';

export interface DebugOptions {
  showPoints?: boolean;
  showLabels?: boolean;
  showAxes?: boolean;
  showNormals?: boolean;
  pointSize?: number;
  labelSize?: number;
  axisLength?: number;
}

export class DebugLayer {
  public group: THREE.Group;
  private parent: Node3D;
  private options: DebugOptions;
  private pointsGroup: THREE.Group;
  private labelsGroup: THREE.Group;
  private axesGroup: THREE.Group;
  private normalsGroup: THREE.Group;

  constructor(parent: Node3D, options: DebugOptions = {}) {
    this.parent = parent;
    this.options = {
      showPoints: false,
      showLabels: false,
      showAxes: false,
      showNormals: false,
      pointSize: 0.05,
      labelSize: 0.1,
      axisLength: 1.0,
      ...options
    };

    this.group = new THREE.Group();
    this.group.name = `${parent.name}_debug`;

    this.pointsGroup = new THREE.Group();
    this.pointsGroup.name = 'points';
    this.group.add(this.pointsGroup);

    this.labelsGroup = new THREE.Group();
    this.labelsGroup.name = 'labels';
    this.group.add(this.labelsGroup);

    this.axesGroup = new THREE.Group();
    this.axesGroup.name = 'axes';
    this.group.add(this.axesGroup);

    this.normalsGroup = new THREE.Group();
    this.normalsGroup.name = 'normals';
    this.group.add(this.normalsGroup);

    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des points
   */
  setShowPoints(show: boolean): void {
    this.options.showPoints = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des labels
   */
  setShowLabels(show: boolean): void {
    this.options.showLabels = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des axes
   */
  setShowAxes(show: boolean): void {
    this.options.showAxes = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des normales
   */
  setShowNormals(show: boolean): void {
    this.options.showNormals = show;
    this.updateVisibility();
  }

  /**
   * Ajoute un point de debug
   */
  addPoint(position: THREE.Vector3, color: number = 0xff0000, name?: string): void {
    const geometry = new THREE.SphereGeometry(this.options.pointSize, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const point = new THREE.Mesh(geometry, material);

    point.position.copy(position);
    if (name) point.name = name;

    this.pointsGroup.add(point);
  }

  /**
   * Ajoute une √©tiquette de debug
   */
  addLabel(position: THREE.Vector3, text: string, color: number = 0xffffff): void {
    // Note: Pour une vraie impl√©mentation, il faudrait une biblioth√®que de texte 3D
    // Pour l'instant, on utilise un point color√© avec le nom
    const geometry = new THREE.SphereGeometry(this.options.labelSize! * 0.5, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const label = new THREE.Mesh(geometry, material);

    label.position.copy(position);
    label.name = text;

    this.labelsGroup.add(label);
  }

  /**
   * Dessine les axes XYZ
   */
  drawAxes(length: number = this.options.axisLength!): void {
    this.clearAxes();

    // Axe X (rouge)
    const xAxis = this.createAxis(new THREE.Vector3(length, 0, 0), 0xff0000);
    this.axesGroup.add(xAxis);

    // Axe Y (vert)
    const yAxis = this.createAxis(new THREE.Vector3(0, length, 0), 0x00ff00);
    this.axesGroup.add(yAxis);

    // Axe Z (bleu)
    const zAxis = this.createAxis(new THREE.Vector3(0, 0, length), 0x0000ff);
    this.axesGroup.add(zAxis);
  }

  /**
   * Nettoie tous les √©l√©ments de debug
   */
  clear(): void {
    this.clearPoints();
    this.clearLabels();
    this.clearAxes();
    this.clearNormals();
  }

  /**
   * Met √† jour la visibilit√© selon les options
   */
  private updateVisibility(): void {
    this.pointsGroup.visible = this.options.showPoints!;
    this.labelsGroup.visible = this.options.showLabels!;
    this.axesGroup.visible = this.options.showAxes!;
    this.normalsGroup.visible = this.options.showNormals!;
  }

  private createAxis(direction: THREE.Vector3, color: number): THREE.Group {
    const group = new THREE.Group();

    // Ligne de l'axe
    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      direction
    ]);
    const material = new THREE.LineBasicMaterial({ color });
    const line = new THREE.Line(geometry, material);
    group.add(line);

    // Fl√®che √† l'extr√©mit√©
    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ color });
    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    arrow.position.copy(direction);
    arrow.lookAt(direction);
    group.add(arrow);

    return group;
  }

  private clearPoints(): void {
    while (this.pointsGroup.children.length > 0) {
      const child = this.pointsGroup.children[0];
      this.pointsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearLabels(): void {
    while (this.labelsGroup.children.length > 0) {
      const child = this.labelsGroup.children[0];
      this.labelsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearAxes(): void {
    while (this.axesGroup.children.length > 0) {
      const child = this.axesGroup.children[0];
      this.axesGroup.remove(child);
      // Nettoyer r√©cursivement les g√©om√©tries et mat√©riaux
      child.traverse((obj) => {
        if (obj instanceof THREE.Mesh) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        } else if (obj instanceof THREE.Line) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        }
      });
    }
  }

  private clearNormals(): void {
    while (this.normalsGroup.children.length > 0) {
      const child = this.normalsGroup.children[0];
      this.normalsGroup.remove(child);
      if (child instanceof THREE.Line) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }
}

=== core/Node3D.ts ===


/**
 * Node3D.ts - Couche d'abstraction Godot-compatible pour la simulation Kite
 *
 * R√¥le :
 *   - Encapsule THREE.Group avec une API similaire √† Godot
 *   - Fournit des propri√©t√©s et m√©thodes compatibles avec le moteur Godot
 *   - Sert de base √† StructuredObject et √† tous les objets 3D du projet
 *
 * D√©pendances principales :
 *   - Three.js : Pour la gestion des groupes et transformations 3D
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) h√©rite de Node3D
 *   - Tous les objets 3D du projet h√©ritent indirectement de Node3D
 *
 * Utilisation typique :
 *   - Sert de base √† la hi√©rarchie d'objets 3D
 *   - Permet la compatibilit√© avec Godot pour la portabilit√©
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';
import { SceneManager } from './SceneManager';

/**
 * Transform3D compatible Godot
 */
export interface Transform3D {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    scale: THREE.Vector3;
}

/**
 * Signal basique pour la communication entre nodes
 */
export interface Signal {
    name: string;
    callbacks: Array<{ target: Node3D; method: string }>;
}

/**
 * Node3D - √âquivalent du Node3D de Godot
 * H√©rite de THREE.Group pour la compatibilit√©
 */
export class Node3D extends THREE.Group {
    // üéÆ Propri√©t√©s Godot-like
    public transform: Transform3D;
    public signals: Map<string, Signal> = new Map();
    
    // üè∑Ô∏è M√©tadonn√©es
    public readonly nodeId: string;
    public nodeType: string = 'Node3D';
    
    // üîß √âtat interne
    protected isReady: boolean = false;
    protected active: boolean = true;

    constructor(name: string = 'Node3D') {
        super();
        this.name = name;
        this.nodeId = this.generateNodeId();

        // Transform3D unifi√©
        this.transform = {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale
        };

        // Auto-enregistrement dans SceneManager
        SceneManager.getInstance().register(this);

        // Auto-initialisation
        this.callReady();
    }
    
    /**
     * G√©n√®re un ID unique pour le node (compatible Godot)
     */
    private generateNodeId(): string {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `node_${timestamp}_${random}`;
    }
    
    // === üéÆ M√©thodes Cycle de Vie Godot ===
    
    /**
     * _ready() - Appel√© une seule fois quand le node est ajout√© √† la sc√®ne
     */
    protected _ready(): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _process() - Appel√© √† chaque frame
     */
    protected _process(delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _physics_process() - Appel√© √† chaque frame physique
     */
    protected _physics_process(delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * Appel automatique de _ready()
     */
    private callReady(): void {
        if (!this.isReady) {
            this.isReady = true;
            this._ready();
        }
    }
    
    // === üîó Gestion des Signaux ===
    
    /**
     * D√©finit un signal (√©quivalent signal en GDScript)
     */
    public define_signal(name: string): void {
        if (!this.signals.has(name)) {
            this.signals.set(name, {
                name,
                callbacks: []
            });
        }
    }
    
    /**
     * √âmet un signal
     */
    public emit_signal(name: string, ...args: any[]): void {
        const signal = this.signals.get(name);
        if (signal) {
            signal.callbacks.forEach(callback => {
                const method = (callback.target as any)[callback.method];
                if (typeof method === 'function') {
                    method.call(callback.target, ...args);
                }
            });
        }
    }
    
    /**
     * Connecte un signal √† une m√©thode
     */
    public connect(signal: string, target: Node3D, method: string): void {
        if (!this.signals.has(signal)) {
            this.define_signal(signal);
        }
        
        const signalObj = this.signals.get(signal)!;
        signalObj.callbacks.push({ target, method });
    }
    
    // === üå≥ Gestion de l'Arbre de Nodes ===
    
    /**
     * Ajoute un enfant (compatible Godot)
     */
    public add_child(child: Node3D): void {
        this.add(child);
        child.callReady();
    }
    
    /**
     * Retire un enfant
     */
    public remove_child(child: Node3D): void {
        this.remove(child);
    }
    
    /**
     * Trouve un enfant par nom
     */
    public get_node(path: string): Node3D | null {
        return this.getObjectByName(path) as Node3D || null;
    }
    
    /**
     * Trouve tous les enfants d'un type donn√©
     */
    public get_children_of_type<T extends Node3D>(type: new (...args: any[]) => T): T[] {
        const result: T[] = [];
        this.traverse((obj) => {
            if (obj instanceof type) {
                result.push(obj);
            }
        });
        return result;
    }
    
    // === üîÑ Mise √† Jour du Cycle de Vie ===
    
    /**
     * Met √† jour le node et tous ses enfants
     */
    public update(delta: number): void {
        if (this.isReady) {
            this._process(delta);
            this._physics_process(delta);
            
            // Mettre √† jour les enfants Node3D
            this.children.forEach(child => {
                if (child instanceof Node3D) {
                    child.update(delta);
                }
            });
        }
    }
    
    /**
     * Active/d√©sactive le node
     */
    public setActive(active: boolean): void {
        this.active = active;
    }

    /**
     * V√©rifie si le node est actif
     */
    public isActive(): boolean {
        return this.active;
    }

    /**
     * Obtient le nom du node
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Appel√© quand le node est enregistr√© dans SceneManager
     */
    public onRegister(): void {
        // √Ä overrider dans les sous-classes
    }

    /**
     * Appel√© quand le node est d√©senregistr√© de SceneManager
     */
    public onUnregister(): void {
        // √Ä overrider dans les sous-classes
    }

    /**
     * D√©truit le node et nettoie les ressources
     */
    public destroy(): void {
        // D√©senregistrer du SceneManager
        SceneManager.getInstance().unregister(this);

        // Nettoyer les signaux
        this.signals.clear();

        // Nettoyer les enfants
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.destroy();
            }
        });

        // Nettoyer Three.js
        this.clear();
    }
    
    // === üè∑Ô∏è M√©tadonn√©es et Debug ===
    
    /**
     * Retourne une description du node
     */
    public get_description(): string {
        return `${this.nodeType}:${this.name} (${this.nodeId})`;
    }
    
    /**
     * Affiche l'arbre des nodes (debug)
     */
    public print_tree(indent: number = 0): void {
        const spaces = '  '.repeat(indent);
        console.log(`${spaces}${this.get_description()}`);
        
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.print_tree(indent + 1);
            }
        });
    }
    
    // === üéØ Compatibilit√© Three.js ===
    
    /**
     * Acc√®s direct au transform Three.js
     */
    public get three_transform() {
        return {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale,
            matrix: this.matrix,
            matrixWorld: this.matrixWorld
        };
    }
}


=== core/Primitive.ts ===


/**
 * Primitive.ts - G√©n√©rateurs de primitives Three.js pour la simulation Kite
 *
 * R√¥le :
 *   - Fournit des utilitaires pour cr√©er les formes de base (cube, sph√®re, cylindre, etc.)
 *   - Permet de g√©n√©rer des mat√©riaux coh√©rents pour les objets 3D
 *   - Sert √† la construction des objets structur√©s (cerf-volant, barre, etc.)
 *
 * D√©pendances principales :
 *   - Three.js : Pour la g√©om√©trie et les mat√©riaux
 *   - Types : MaterialConfig pour la configuration des mat√©riaux
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) utilise Primitive pour cr√©er les √©l√©ments 3D
 *   - Tous les objets 3D du projet peuvent utiliser Primitive pour g√©n√©rer leurs formes
 *
 * Utilisation typique :
 *   - Appel√© par les factories et objets structur√©s pour g√©n√©rer la g√©om√©trie
 *   - Sert √† la cr√©ation rapide et coh√©rente des primitives
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { MaterialConfig } from '../types/index';

/**
 * Classe statique pour g√©n√©rer les primitives de base
 */
export class Primitive {
  /**
   * Cr√©er un mat√©riau standardis√©
   */
  private static createMaterial(config: string | MaterialConfig): THREE.MeshStandardMaterial {
    if (typeof config === 'string') {
      return new THREE.MeshStandardMaterial({ color: config });
    }

    return new THREE.MeshStandardMaterial({
      color: config.color,
      transparent: config.transparent || false,
      opacity: config.opacity || 1,
      metalness: config.metalness || 0,
      roughness: config.roughness || 0.5,
      side: config.side || THREE.FrontSide
    });
  }

  /**
   * Cr√©er une bo√Æte (cube ou parall√©l√©pip√®de)
   */
  static box(
    width: number,
    height: number,
    depth: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BoxGeometry(width, height, depth);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une sph√®re
   */
  static sphere(
    radius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un cylindre
   */
  static cylinder(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un c√¥ne
   */
  static cone(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un plan (surface plate)
   */
  static plane(
    width: number,
    height: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(width, height);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un tore (anneau)
   */
  static torus(
    radius: number,
    tubeRadius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.TorusGeometry(radius, tubeRadius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une surface √† partir de points (triangulation simple)
   */
  static surface(
    points: THREE.Vector3[],
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BufferGeometry();
    const vertices: number[] = [];

    // Ajouter les points
    points.forEach(point => {
      vertices.push(point.x, point.y, point.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    // Triangulation am√©lior√©e pour les quads (faces du cube)
    const indices: number[] = [];
    if (points.length === 3) {
      // Triangle simple
      indices.push(0, 1, 2);
    }

    if (points.length === 4) {
      // Quad - utiliser une triangulation qui pr√©serve la manifold
      // Pour un cube, on utilise toujours la m√™me diagonale (0,2)
      // Cela garantit que l'ar√™te diagonale n'est pas partag√©e avec d'autres faces
      indices.push(0, 1, 2);  // Premier triangle
      indices.push(0, 2, 3);  // Deuxi√®me triangle
    }

    if (points.length > 4) {
      // Fan triangulation pour plus de points
      for (let i = 1; i < points.length - 1; i++) {
        indices.push(0, i, i + 1);
      }
    }

    geometry.setIndex(indices);

    // Calculer les normales de mani√®re coh√©rente
    geometry.computeVertexNormals();

    // S'assurer que les normales pointent vers l'ext√©rieur pour un cube
    // En inversant si n√©cessaire
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une fl√®che de debug (ArrowHelper)
   *
   * @param direction - Direction normalis√©e de la fl√®che
   * @param origin - Point d'origine de la fl√®che
   * @param length - Longueur de la fl√®che
   * @param color - Couleur (hex) de la fl√®che
   * @param headLength - Longueur de la t√™te de fl√®che (optionnel)
   * @param headWidth - Largeur de la t√™te de fl√®che (optionnel)
   * @returns THREE.ArrowHelper configur√©
   */
  static arrow(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    headLength?: number,
    headWidth?: number
  ): THREE.ArrowHelper {
    return new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      headLength,
      headWidth
    );
  }
}

=== core/SceneManager.ts ===

/**
 * SceneManager.ts - Gestionnaire central de la sc√®ne 3D
 *
 * R√¥le : Orchestrateur principal de tous les objets 3D
 * G√®re le cycle de vie, les updates et la hi√©rarchie des Node3D
 */

import { Node3D } from './Node3D';
import * as THREE from 'three';

export class SceneManager {
  private static instance: SceneManager;
  private nodes: Set<Node3D> = new Set();
  private rootScene: THREE.Scene;
  private totalTime: number = 0;

  private constructor() {
    this.rootScene = new THREE.Scene();
  }

  static getInstance(): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  /**
   * Enregistre un nouveau n≈ìud dans la sc√®ne
   */
  register(node: Node3D): void {
    if (!this.nodes.has(node)) {
      this.nodes.add(node);
      node.onRegister();
    }
  }

  /**
   * D√©senregistre un n≈ìud de la sc√®ne
   */
  unregister(node: Node3D): void {
    if (this.nodes.has(node)) {
      node.onUnregister();
      this.nodes.delete(node);
    }
  }

  /**
   * Met √† jour tous les n≈ìuds enregistr√©s
   */
  update(deltaTime: number): void {
    this.totalTime += deltaTime;

    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: false,
      debugMode: false
    };

    // Mise √† jour de tous les n≈ìuds
    for (const node of this.nodes) {
      if (node.isActive()) {
        node.update(deltaTime);
      }
    }
  }

  /**
   * Ajoute un objet √† la sc√®ne Three.js racine
   */
  addToScene(object: THREE.Object3D): void {
    this.rootScene.add(object);
  }

  /**
   * Retire un objet de la sc√®ne Three.js racine
   */
  removeFromScene(object: THREE.Object3D): void {
    this.rootScene.remove(object);
  }

  /**
   * Obtient la sc√®ne Three.js racine
   */
  getScene(): THREE.Scene {
    return this.rootScene;
  }

  /**
   * Recherche un n≈ìud par nom
   */
  findNodeByName(name: string): Node3D | undefined {
    for (const node of this.nodes) {
      if (node.getName() === name) {
        return node;
      }
    }
    return undefined;
  }

  /**
   * Obtient tous les n≈ìuds d'un certain type
   */
  getNodesOfType<T extends Node3D>(type: new (...args: any[]) => T): T[] {
    const result: T[] = [];
    for (const node of this.nodes) {
      if (node instanceof type) {
        result.push(node as T);
      }
    }
    return result;
  }

  /**
   * Nettoie tous les n≈ìuds
   */
  clear(): void {
    for (const node of this.nodes) {
      node.destroy();
    }
    this.nodes.clear();
    this.rootScene.clear();
    this.totalTime = 0;
  }

  /**
   * Statistiques de la sc√®ne
   */
  getStats(): { nodeCount: number; totalTime: number } {
    return {
      nodeCount: this.nodes.size,
      totalTime: this.totalTime
    };
  }
}

=== core/StructuredObject.ts ===


/**
 * StructuredObject.ts - Classe de base unifi√©e pour tous les objets 3D structur√©s du projet Kite
 *
 * R√¥le :
 *   - Fournit une architecture orient√©e objet avec points anatomiques nomm√©s
 *   - Sert de classe m√®re pour tous les objets 3D complexes (cerf-volant, barre, etc.)
 *   - Compatible Godot via Node3D
 *
 * D√©pendances principales :
 *   - Node3D.ts : Couche d'abstraction Godot-compatible
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : Position3D, NamedPoint, SurfaceOptions, MaterialConfig
 *   - Three.js : Pour la g√©om√©trie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Node3D.ts (dossier core) est la classe m√®re directe
 *   - Primitive.ts fournit les utilitaires de cr√©ation
 *   - Tous les objets 3D du projet h√©ritent de StructuredObject
 *
 * Utilisation typique :
 *   - Sert de base √† la cr√©ation de tous les objets 3D structur√©s
 *   - Permet la gestion des points, labels et debug
 *
 * Voir aussi :
 *   - src/core/Node3D.ts
 *   - src/core/Primitive.ts
 */

import * as THREE from 'three';

import { Position3D, NamedPoint, SurfaceOptions, MaterialConfig } from '../types/index';

import { Primitive } from './Primitive';
import { Node3D } from './Node3D';
import { DebugLayer } from './DebugLayer';

/**
 * Classe abstraite de base pour tous les objets 3D structur√©s
 * üéÆ H√©rite de Node3D pour la compatibilit√© Godot
 */
export abstract class StructuredObject extends Node3D {
  /**
   * Points anatomiques nomm√©s de l'objet
   */
  protected points: Map<string, THREE.Vector3> = new Map();

  /**
   * Points avec marqueurs visuels (debug)
   */
  protected namedPoints: NamedPoint[] = [];

  /**
   * Couche de debug s√©par√©e
   */
  protected debugLayer: DebugLayer;

  /**
   * Affichage des labels en mode debug
   */
  public showDebugPoints: boolean = false;

  /**
   * Affichage des labels de texte
   */
  public showLabels: boolean = false;

  constructor(name: string, showDebugPoints: boolean = false) {
    super(name);
    this.nodeType = 'StructuredObject';
    this.showDebugPoints = showDebugPoints;

    // Initialiser la couche de debug
    this.debugLayer = new DebugLayer(this, {
      showPoints: showDebugPoints,
      showLabels: false,
      showNormals: false,
      showAxes: false,
      pointSize: 0.02
    });

    // L'initialisation sera appel√©e par la classe enfant apr√®s configuration
  }

  /**
   * Initialisation automatique de l'objet
   */
  protected initialize(): void {
    // Vider le groupe au cas o√π
    this.clear();

    // Construire l'objet dans l'ordre
    this.definePoints();
    this.buildStructure();
    this.buildSurfaces();

    // Mettre √† jour la couche de debug
    this.updateDebugLayer();
  }

  /**
   * Initialisation publique √† appeler par les classes enfants
   */
  public init(): void {
    this.initialize();
  }

  /**
   * D√©finit tous les points anatomiques de l'objet
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract definePoints(): void;

  /**
   * Construit la structure rigide de l'objet (frame, squelette)
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildStructure(): void;

  /**
   * Construit les surfaces et d√©tails visuels
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildSurfaces(): void;

  /**
   * D√©finit un point nomm√© dans l'espace
   */
  protected setPoint(name: string, position: Position3D): void {
    const vector = new THREE.Vector3(position[0], position[1], position[2]);
    this.points.set(name, vector);
    
    // Ajouter aux points nomm√©s pour le debug
    this.namedPoints.push({
      name,
      position: vector.clone(),
      visible: this.showDebugPoints
    });
  }

  /**
   * R√©cup√®re un point par son nom
   */
  public getPoint(name: string): THREE.Vector3 | undefined {
    return this.points.get(name);
  }

  /**
   * Cr√©e un cylindre entre deux points nomm√©s
   */
  protected addCylinderBetweenPoints(
    point1Name: string,
    point2Name: string,
    radius: number,
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    const p1 = this.getPoint(point1Name);
    const p2 = this.getPoint(point2Name);
    
    if (!p1 || !p2) {
      console.warn(`Points ${point1Name} ou ${point2Name} non trouv√©s`);
      return null;
    }

    // Calculer la distance et l'orientation
    const distance = p1.distanceTo(p2);
    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
    
    // Cr√©er le cylindre
    const cylinder = Primitive.cylinder(radius, distance, material);
    
    // Orienter le cylindre
    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction
    );
    cylinder.quaternion.copy(quaternion);
    cylinder.position.copy(midpoint);
    
    // Ajouter au groupe
    this.add(cylinder);
    return cylinder;
  }

  /**
   * Cr√©e une surface entre des points nomm√©s
   */
  protected addSurfaceBetweenPoints(
    pointNames: string[],
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    if (pointNames.length < 3) {
      console.warn('Il faut au moins 3 points pour cr√©er une surface');
      return null;
    }

    const points: THREE.Vector3[] = [];
    
    // R√©cup√©rer tous les points
    for (const name of pointNames) {
      const point = this.getPoint(name);
      if (!point) {
        console.warn(`Point ${name} non trouv√©`);
        return null;
      }
      points.push(point);
    }

    // Cr√©er la surface
    const surface = Primitive.surface(points, material);
    this.add(surface);
    return surface;
  }

  /**
   * Ajoute une primitive √† une position donn√©e
   */
  protected addPrimitiveAt(
    primitive: THREE.Mesh,
    position: Position3D
  ): void {
    primitive.position.set(position[0], position[1], position[2]);
    this.add(primitive);
  }

  /**
   * Ajoute une primitive √† la position d'un point nomm√©
   */
  protected addPrimitiveAtPoint(
    primitive: THREE.Mesh,
    pointName: string
  ): boolean {
    const point = this.getPoint(pointName);
    if (!point) {
      console.warn(`Point ${pointName} non trouv√©`);
      return false;
    }
    
    primitive.position.copy(point);
    this.add(primitive);
    return true;
  }

  /**
   * Met √† jour la couche de debug avec les points actuels
   */
  protected updateDebugLayer(): void {
    // Vider la couche de debug
    this.debugLayer.clear();

    if (this.showDebugPoints) {
      // Ajouter tous les points nomm√©s
      for (const [name, position] of this.points.entries()) {
        this.debugLayer.addPoint(position, 0xffff00, this.showLabels ? name : undefined);
      }
    }
  }
  
  /**
   * Cr√©e un label de texte pour un point
   */
  private createTextLabel(text: string): THREE.Sprite {
    // Cr√©er un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 64;
    
    // Style du texte
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.font = 'Bold 24px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);
    
    // Cr√©er une texture depuis le canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Cr√©er un sprite avec la texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Ajuster la taille du sprite
    sprite.scale.set(0.3, 0.075, 1);
    
    return sprite;
  }

  /**
   * Active/d√©sactive l'affichage des marqueurs de debug
   */
  public setShowDebugPoints(show: boolean): void {
    this.showDebugPoints = show;
    this.debugLayer.setShowPoints(show);
  }

  /**
   * Active/d√©sactive l'affichage des labels de texte
   */
  public setShowLabels(show: boolean): void {
    this.showLabels = show;
    this.debugLayer.setShowLabels(show);
    // Si les points de debug ne sont pas activ√©s et qu'on veut les labels, activer les deux
    if (show && !this.showDebugPoints) {
      this.setShowDebugPoints(true);
    }
  }  /**
   * Retourne tous les noms de points d√©finis
   */
  public getPointNames(): string[] {
    return Array.from(this.points.keys());
  }

  /**
   * Retourne le nombre de points d√©finis
   */
  public getPointCount(): number {
    return this.points.size;
  }

  /**
   * Retourne les informations sur un point
   */
  public getPointInfo(name: string): NamedPoint | undefined {
    const point = this.getPoint(name);
    if (!point) return undefined;
    
    return {
      name,
      position: point.clone(),
      visible: this.showDebugPoints
    };
  }
}

=== factories/BridleFactory.ts ===

/**
 * BridleFactory.ts - Factory pour cr√©er les instances Line repr√©sentant les brides
 *
 * R√¥le :
 *   - Cr√©e les 6 brides (3 gauches + 3 droites) comme instances de Line
 *   - Fournit une configuration physique sp√©cifique aux brides (Dyneema courtes et rigides)
 *   - Centralise la cr√©ation pour garantir coh√©rence et validation
 *
 * Architecture :
 *   - R√©utilise la classe Line (m√™me que lignes principales)
 *   - Config diff√©rente : plus rigides, plus courtes, moins √©lastiques
 *   - Pattern Factory comme LineFactory
 *
 * Relation avec les autres modules :
 *   - Utilise Line (src/objects/mechanical/Line.ts)
 *   - Utilis√© par BridleSystem
 *   - Config bas√©e sur BridleLengths (BridleTypes.ts)
 *
 * Voir aussi :
 *   - src/factories/LineFactory.ts (pattern similaire)
 *   - src/objects/mechanical/Line.ts
 *   - src/simulation/types/BridleTypes.ts
 */

import { Line, LineConfig, LineAttachments } from "@objects/mechanical/Line";

import { BridleLengths, BridleAttachment, BridleSide, BridlePosition } from "../simulation/types/BridleTypes";

/**
 * Factory pour cr√©er les brides du cerf-volant
 *
 * Les brides sont des lignes courtes et rigides en Dyneema qui relient
 * les points anatomiques du kite (NEZ, INTER, CENTRE) aux points de contr√¥le (CTRL).
 */
export class BridleFactory {
  /**
   * Configuration physique standard pour les brides
   *
   * Les brides sont plus rigides et moins √©lastiques que les lignes principales :
   * - Plus courtes (0.5-0.7m vs 15m)
   * - Plus rigides (5000 N/m vs 2200 N/m)
   * - Moins d'amortissement (quasi-rigides)
   * - Tr√®s l√©g√®res
   */
  private static readonly BRIDLE_CONFIG: Omit<LineConfig, 'length'> = {
    stiffness: 5000,           // N/m - Tr√®s rigides (Dyneema courte)
    preTension: 10,            // N - Pr√©-tension faible
    maxTension: 300,           // N - R√©sistance avant rupture
    dampingCoeff: 0.02,        // Sans dimension - Peu d'amortissement
    linearMassDensity: 0.0003, // kg/m - Tr√®s l√©g√®res
  };

  /**
   * Mapping des positions vers les points anatomiques
   */
  private static readonly POINT_MAPPING = {
    left: {
      nez: { start: "NEZ", end: "CTRL_GAUCHE" },
      inter: { start: "INTER_GAUCHE", end: "CTRL_GAUCHE" },
      centre: { start: "CENTRE", end: "CTRL_GAUCHE" },
    },
    right: {
      nez: { start: "NEZ", end: "CTRL_DROIT" },
      inter: { start: "INTER_DROIT", end: "CTRL_DROIT" },
      centre: { start: "CENTRE", end: "CTRL_DROIT" },
    },
  } as const;

  /**
   * Cr√©e une bride individuelle
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @param length - Longueur en m√®tres
   * @returns Instance Line configur√©e
   */
  static createBridle(
    side: BridleSide,
    position: BridlePosition,
    length: number
  ): Line {
    const points = this.POINT_MAPPING[side][position];
    const id = `bridle_${side}_${position}`;

    const config: LineConfig = {
      ...this.BRIDLE_CONFIG,
      length,
    };

    const attachments: LineAttachments = {
      kitePoint: points.start,
      barPoint: points.end,
    };

    return new Line(config, attachments, id);
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© gauche
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createLeftBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('left', 'nez', lengths.nez),
      this.createBridle('left', 'inter', lengths.inter),
      this.createBridle('left', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© droit
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createRightBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('right', 'nez', lengths.nez),
      this.createBridle('right', 'inter', lengths.inter),
      this.createBridle('right', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e toutes les 6 brides (gauches + droites)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Objet contenant les brides gauches et droites
   */
  static createAllBridles(lengths: BridleLengths): {
    left: [Line, Line, Line];
    right: [Line, Line, Line];
  } {
    return {
      left: this.createLeftBridles(lengths),
      right: this.createRightBridles(lengths),
    };
  }

  /**
   * Cr√©e les m√©tadonn√©es d'attache pour toutes les brides
   * (utilis√© pour documentation/debug)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 6 BridleAttachment
   */
  static createBridleAttachments(lengths: BridleLengths): BridleAttachment[] {
    const attachments: BridleAttachment[] = [];

    // Brides gauches
    Object.entries(this.POINT_MAPPING.left).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_left_${position}`,
      });
    });

    // Brides droites
    Object.entries(this.POINT_MAPPING.right).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_right_${position}`,
      });
    });

    return attachments;
  }

  /**
   * Valide les longueurs de brides
   *
   * @param lengths - Longueurs √† valider
   * @throws Error si longueurs invalides
   */
  static validateBridleLengths(lengths: BridleLengths): void {
    const { nez, inter, centre } = lengths;

    // V√©rifier valeurs positives
    if (nez <= 0 || inter <= 0 || centre <= 0) {
      throw new Error(
        `Longueurs de brides doivent √™tre positives: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier plage raisonnable (0.2m √† 1.5m)
    const min = 0.2;
    const max = 1.5;
    if (nez < min || nez > max || inter < min || inter > max || centre < min || centre > max) {
      throw new Error(
        `Longueurs de brides hors plage [${min}, ${max}]m: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier coh√©rence g√©om√©trique (bride nez g√©n√©ralement plus longue)
    if (nez < inter * 0.8 || nez < centre * 0.8) {
      console.warn(
        `‚ö†Ô∏è Bride NEZ plus courte que INTER/CENTRE peut causer instabilit√©: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }
  }

  /**
   * Obtient la configuration physique utilis√©e pour les brides
   * (utile pour debug/documentation)
   */
  static getBridleConfig(): Omit<LineConfig, 'length'> {
    return { ...this.BRIDLE_CONFIG };
  }
}


=== factories/FactoryRegistry.ts ===

/**
 * FactoryRegistry.ts - Registre centralis√© des factories
 *
 * Permet la cr√©ation dynamique d'objets depuis un nom ou un type
 * Pattern : Factory Registry + Plugin Architecture
 */

export interface FactoryMetadata {
  id: string;
  name: string;
  version: string;
  description: string;
  supportedTypes: string[];
  dependencies: string[];
}

export interface BaseFactory {
  createObject(type: string, config: any): any;
  getSupportedTypes(): string[];
  getMetadata(): FactoryMetadata;
  dispose(): void;
}

type FactoryConstructor = new () => BaseFactory;

export interface FactoryParams {
  [key: string]: any;
}

export class FactoryRegistry {
  private static factories = new Map<string, FactoryConstructor>();
  private static instances = new Map<string, BaseFactory>();

  /**
   * Enregistre une factory dans le registre
   */
  static register(name: string, factoryClass: FactoryConstructor): void {
    if (this.factories.has(name)) {
      console.warn(`Factory "${name}" is already registered. Overwriting.`);
    }
    this.factories.set(name, factoryClass);
  }

  /**
   * D√©senregistre une factory
   */
  static unregister(name: string): void {
    if (this.factories.has(name)) {
      // Nettoyer l'instance si elle existe
      if (this.instances.has(name)) {
        const instance = this.instances.get(name)!;
        instance.dispose();
        this.instances.delete(name);
      }
      this.factories.delete(name);
    }
  }

  /**
   * Cr√©e un objet en utilisant la factory enregistr√©e
   */
  static createObject(name: string, params?: FactoryParams): any {
    const factoryClass = this.factories.get(name);
    if (!factoryClass) {
      throw new Error(`Factory "${name}" not found. Available factories: ${Array.from(this.factories.keys()).join(', ')}`);
    }

    // Obtenir ou cr√©er l'instance de factory
    let factory = this.instances.get(name);
    if (!factory) {
      factory = new factoryClass();
      this.instances.set(name, factory);
    }

    // Cr√©er l'objet
    return factory.createObject('default', params);
  }

  /**
   * V√©rifie si une factory est enregistr√©e
   */
  static hasFactory(name: string): boolean {
    return this.factories.has(name);
  }

  /**
   * Obtient la liste des factories enregistr√©es
   */
  static getRegisteredFactories(): string[] {
    return Array.from(this.factories.keys());
  }

  /**
   * Obtient les m√©tadonn√©es d'une factory
   */
  static getFactoryMetadata(name: string): { name: string; description?: string } | null {
    const factory = this.instances.get(name);
    if (factory) {
      return factory.getMetadata();
    }
    return null;
  }

  /**
   * Nettoie toutes les factories et instances
   */
  static clear(): void {
    // Nettoyer toutes les instances
    for (const [name, instance] of this.instances) {
      try {
        instance.dispose();
      } catch (error) {
        console.error(`Error disposing factory "${name}":`, error);
      }
    }

    this.instances.clear();
    this.factories.clear();
  }

  /**
   * Recharge une factory (utile pour le d√©veloppement)
   */
  static reloadFactory(name: string): void {
    if (this.instances.has(name)) {
      const instance = this.instances.get(name)!;
      instance.dispose();
      this.instances.delete(name);
    }
    // La prochaine cr√©ation recr√©era l'instance
  }
}

=== factories/FrameFactory.ts ===

/**
 * FrameFactory.ts - Factory pour cr√©er des structures filaires (frames)
 */

import { BaseFactory, FactoryMetadata } from './FactoryRegistry';
import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export interface FrameParams {
  diameter?: number;
  material?: string;
  points?: Array<[string, number[]]>;
  connections?: Array<[string, string]>;
}

/**
 * Factory pour cr√©er des structures filaires
 */
export class FrameFactory implements BaseFactory {
  getSupportedTypes(): string[] {
    return ['frame', 'structure'];
  }

  getMetadata(): FactoryMetadata {
    return {
      id: 'frame_factory',
      name: 'Frame Factory',
      version: '1.0.0',
      description: 'Creates wireframe structures from connected points',
      supportedTypes: this.getSupportedTypes(),
      dependencies: []
    };
  }

  createObject(type: string, config: FrameParams = {}): StructuredObject & ICreatable {
    const params = {
      diameter: 0.01,
      material: '#333333',
      points: [],
      connections: [],
      ...config
    };

    class FrameObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Frame", false);
      }

      protected definePoints(): void {
        if (params.points) {
          params.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        if (params.connections) {
          params.connections.forEach(([point1, point2]) => {
            this.addCylinderBetweenPoints(
              point1,
              point2,
              params.diameter || 0.01,
              params.material || '#333333'
            );
          });
        }
      }

      protected buildSurfaces(): void {
        // Pas de surfaces pour un frame
      }

      create(): this { return this; }
      getName(): string { return 'Frame'; }
      getDescription(): string { return 'Structure filaire'; }
      getPrimitiveCount(): number { return params.connections?.length || 0; }
    }

    const frame = new FrameObject();
    frame.init();
    return frame;
  }

  dispose(): void {
    // Cleanup if needed
  }
}

=== factories/LineFactory.ts ===

/**
 * LineFactory.ts - Factory pour cr√©er des lignes de cerf-volant (OOP pattern)
 *
 * R√¥le :
 *   - Cr√©er des objets Line selon le pattern Factory du projet
 *   - Valider les param√®tres avant cr√©ation
 *   - Fournir des presets pour configurations typiques
 *
 * Responsabilit√© :
 *   - Instanciation coh√©rente des objets Line
 *   - Application des valeurs par d√©faut
 *   - Validation des param√®tres physiques
 *
 * Pattern :
 *   - Ne suit PAS BaseFactory<StructuredObject> car Line n'est pas un objet 3D
 *   - Factory simple avec m√©thodes statiques pour configurations communes
 *   - S√©paration claire : Line (m√©tier) vs LineVisual (3D)
 *
 * Relation avec les autres modules :
 *   - Cr√©e des objets Line
 *   - Utilis√© par LineSystem pour instancier les lignes
 *   - Ind√©pendant de Three.js (pure TypeScript)
 *
 * Philosophie :
 *   - "Make invalid states unrepresentable" : Validation stricte
 *   - Presets pour cas d'usage communs
 *   - Immutabilit√© : Les lignes cr√©√©es sont immutables (config readonly)
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts
 *   - src/base/BaseFactory.ts (pattern de r√©f√©rence)
 */

import { Line, LineConfig, LineAttachments } from '@objects/mechanical/Line';

import { CONFIG } from '@/simulation/config/SimulationConfig';

/**
 * Param√®tres pour cr√©er une ligne via factory
 */
export interface LineFactoryParams {
  /** Longueur au repos (m) - D√©faut: CONFIG.lines.defaultLength */
  length?: number;

  /** Point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;

  /** Rigidit√© personnalis√©e (N/m) - D√©faut: CONFIG.lines.stiffness */
  stiffness?: number;

  /** Pr√©-tension personnalis√©e (N) - D√©faut: CONFIG.lines.preTension */
  preTension?: number;

  /** Tension max personnalis√©e (N) - D√©faut: CONFIG.lines.maxTension */
  maxTension?: number;

  /** Damping personnalis√© - D√©faut: CONFIG.lines.dampingCoeff */
  dampingCoeff?: number;

  /** Masse lin√©ique personnalis√©e (kg/m) - D√©faut: CONFIG.lines.linearMassDensity */
  linearMassDensity?: number;

  /** Identifiant personnalis√© (optionnel) */
  id?: string;
}

/**
 * Erreur de validation lors de la cr√©ation d'une ligne
 */
export class LineValidationError extends Error {
  constructor(message: string, public field: string) {
    super(`LineFactory validation error [${field}]: ${message}`);
    this.name = 'LineValidationError';
  }
}

/**
 * Factory pour cr√©er des lignes de cerf-volant
 *
 * @example
 * ```typescript
 * // Ligne standard avec param√®tres par d√©faut
 * const leftLine = LineFactory.createLine({
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Ligne personnalis√©e
 * const customLine = LineFactory.createLine({
 *   length: 20,
 *   stiffness: 1800,
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Preset d√©butant
 * const beginnerLine = LineFactory.createBeginnerLine("CTRL_GAUCHE", "HANDLE_LEFT");
 * ```
 */
export class LineFactory {
  /**
   * Cr√©e une ligne avec param√®tres personnalis√©s
   *
   * @param params - Param√®tres de configuration
   * @returns Instance de Line configur√©e
   * @throws LineValidationError si param√®tres invalides
   */
  static createLine(params: LineFactoryParams): Line {
    // Valider les param√®tres
    this.validateParams(params);

    // Configuration avec valeurs par d√©faut depuis SimulationConfig
    const config: LineConfig = {
      length: params.length ?? CONFIG.lines.defaultLength,
      stiffness: params.stiffness ?? CONFIG.lines.stiffness,
      preTension: params.preTension ?? CONFIG.lines.preTension,
      maxTension: params.maxTension ?? CONFIG.lines.maxTension,
      dampingCoeff: params.dampingCoeff ?? CONFIG.lines.dampingCoeff,
      linearMassDensity: params.linearMassDensity ?? CONFIG.lines.linearMassDensity
    };

    // Points d'attache
    const attachments: LineAttachments = {
      kitePoint: params.kitePoint,
      barPoint: params.barPoint
    };

    // Cr√©er et retourner la ligne
    return new Line(config, attachments, params.id);
  }

  /**
   * Cr√©e une paire de lignes gauche/droite standard
   *
   * @param length - Longueur commune (m)
   * @returns Tuple [ligne gauche, ligne droite]
   */
  static createLinePair(length?: number): [Line, Line] {
    const leftLine = this.createLine({
      length,
      kitePoint: "CTRL_GAUCHE",
      barPoint: "HANDLE_LEFT",
      id: "line_left"
    });

    const rightLine = this.createLine({
      length,
      kitePoint: "CTRL_DROIT",
      barPoint: "HANDLE_RIGHT",
      id: "line_right"
    });

    return [leftLine, rightLine];
  }

  /**
   * Preset : Ligne pour d√©butant
   * - Plus courte (12m)
   * - Moins rigide (1800 N/m)
   * - Pr√©-tension plus faible (50N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour d√©butant
   */
  static createBeginnerLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 12,
      stiffness: 1800,
      preTension: 50,
      maxTension: 600,
      dampingCoeff: 0.08, // Plus de damping = plus stable
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne pour expert
   * - Plus longue (20m)
   * - Rigidit√© standard (2200 N/m)
   * - Haute tension max (1000N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour expert
   */
  static createExpertLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 20,
      stiffness: 2200,
      preTension: 100,
      maxTension: 1000,
      dampingCoeff: 0.03, // Moins de damping = plus r√©actif
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne de s√©curit√© (ultra-r√©sistante)
   * - Tension max tr√®s √©lev√©e (1500N)
   * - Rigidit√© renforc√©e (3000 N/m)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne de s√©curit√©
   */
  static createSafetyLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 15,
      stiffness: 3000,
      preTension: 150,
      maxTension: 1500,
      dampingCoeff: 0.05,
      linearMassDensity: 0.001, // Plus lourde
      kitePoint,
      barPoint
    });
  }

  /**
   * Cr√©e une ligne depuis JSON (d√©s√©rialisation)
   *
   * @param json - Donn√©es JSON (depuis Line.toJSON())
   * @returns Instance de Line recr√©√©e
   */
  static fromJSON(json: any): Line {
    return Line.fromJSON(json);
  }

  /**
   * Valide les param√®tres avant cr√©ation
   *
   * @param params - Param√®tres √† valider
   * @throws LineValidationError si invalide
   */
  private static validateParams(params: LineFactoryParams): void {
    // Points d'attache obligatoires
    if (!params.kitePoint || params.kitePoint.trim() === '') {
      throw new LineValidationError('Kite attachment point is required', 'kitePoint');
    }

    if (!params.barPoint || params.barPoint.trim() === '') {
      throw new LineValidationError('Bar attachment point is required', 'barPoint');
    }

    // Longueur positive
    if (params.length !== undefined && params.length <= 0) {
      throw new LineValidationError('Length must be positive', 'length');
    }

    // Rigidit√© positive
    if (params.stiffness !== undefined && params.stiffness <= 0) {
      throw new LineValidationError('Stiffness must be positive', 'stiffness');
    }

    // Pr√©-tension non-n√©gative
    if (params.preTension !== undefined && params.preTension < 0) {
      throw new LineValidationError('PreTension cannot be negative', 'preTension');
    }

    // Tension max > pr√©-tension
    if (params.maxTension !== undefined && params.preTension !== undefined) {
      if (params.maxTension <= params.preTension) {
        throw new LineValidationError(
          'MaxTension must be greater than preTension',
          'maxTension'
        );
      }
    }

    // Damping dans [0, 1]
    if (params.dampingCoeff !== undefined) {
      if (params.dampingCoeff < 0 || params.dampingCoeff > 1) {
        throw new LineValidationError(
          'DampingCoeff must be between 0 and 1',
          'dampingCoeff'
        );
      }
    }

    // Masse lin√©ique positive
    if (params.linearMassDensity !== undefined && params.linearMassDensity <= 0) {
      throw new LineValidationError(
        'LinearMassDensity must be positive',
        'linearMassDensity'
      );
    }
  }

  /**
   * Obtient les valeurs par d√©faut utilis√©es par la factory
   *
   * @returns Configuration par d√©faut
   */
  static getDefaultConfig(): LineConfig {
    return {
      length: CONFIG.lines.defaultLength,
      stiffness: CONFIG.lines.stiffness,
      preTension: CONFIG.lines.preTension,
      maxTension: CONFIG.lines.maxTension,
      dampingCoeff: CONFIG.lines.dampingCoeff,
      linearMassDensity: CONFIG.lines.linearMassDensity
    };
  }

  /**
   * V√©rifie si deux lignes ont la m√™me configuration physique
   *
   * @param line1 - Premi√®re ligne
   * @param line2 - Deuxi√®me ligne
   * @returns true si configurations identiques
   */
  static areConfigsEqual(line1: Line, line2: Line): boolean {
    const c1 = line1.config;
    const c2 = line2.config;

    return (
      c1.length === c2.length &&
      c1.stiffness === c2.stiffness &&
      c1.preTension === c2.preTension &&
      c1.maxTension === c2.maxTension &&
      c1.dampingCoeff === c2.dampingCoeff &&
      c1.linearMassDensity === c2.linearMassDensity
    );
  }
}


=== factories/PointFactory.ts ===

/**
 * PointFactory.ts - Encapsule la logique de calcul des points anatomiques
 *
 * Responsabilit√© : Calculer les positions des points d'un cerf-volant delta
 */

import * as THREE from 'three';

/**
 * Longueurs physiques des brides (en m√®tres)
 */
export interface BridleLengths {
  nez: number;      // Longueur bride NEZ -> CTRL (avant)
  inter: number;    // Longueur bride INTER -> CTRL (lat√©ral)
  centre: number;   // Longueur bride CENTRE -> CTRL (arri√®re)
}

export interface KiteParams {
  width: number;   // Envergure
  height: number;  // Hauteur
  depth: number;   // Profondeur whiskers
  bridleLengths?: BridleLengths;  // Longueurs physiques des brides
}

/**
 * Factory simple qui encapsule la logique de calcul des points
 */
export class PointFactory {
  /**
   * Longueurs de brides par d√©faut (en m√®tres)
   * LONGUEURS IDENTIQUES : L'√©quilibre g√©om√©trique vient de la structure, pas des brides
   */
  private static readonly DEFAULT_BRIDLE_LENGTHS: BridleLengths = {
    nez: 0.65,     // 65cm - identique pour toutes les brides
    inter: 0.65,   // 65cm - identique pour toutes les brides
    centre: 0.65,  // 65cm - identique pour toutes les brides
  };

  /**
   * Calcule la position du point de contr√¥le (CTRL) par trilat√©ration 3D analytique
   * R√©sout l'intersection de 3 sph√®res centr√©es en NEZ, INTER, CENTRE
   * avec rayons = longueurs de brides respectives
   */
  private static calculateControlPoint(
    nez: [number, number, number],
    inter: [number, number, number],
    centre: [number, number, number],
    bridleLengths: BridleLengths,
    side: 'left' | 'right'
  ): [number, number, number] {
    // Convertir en Vector3
    const p1 = new THREE.Vector3(...nez);      // Point 1 : NEZ
    const p2 = new THREE.Vector3(...inter);    // Point 2 : INTER
    const p3 = new THREE.Vector3(...centre);   // Point 3 : CENTRE

    const r1 = bridleLengths.nez;     // Rayon sph√®re 1
    const r2 = bridleLengths.inter;   // Rayon sph√®re 2
    const r3 = bridleLengths.centre;  // Rayon sph√®re 3

    // Trilat√©ration 3D analytique
    // √âtape 1 : Cr√©er un rep√®re local avec p1 √† l'origine
    const ex = new THREE.Vector3().subVectors(p2, p1).normalize(); // axe X : direction p1->p2
    const d = p2.distanceTo(p1); // distance entre p1 et p2

    // √âtape 2 : Calculer composante Y du rep√®re
    const p3_p1 = new THREE.Vector3().subVectors(p3, p1);
    const i = ex.dot(p3_p1); // projection de p3-p1 sur ex
    const ey_temp = new THREE.Vector3().copy(p3_p1).addScaledVector(ex, -i);
    const ey = ey_temp.normalize(); // axe Y : perpendiculaire √† ex dans le plan

    // √âtape 3 : Axe Z (perpendiculaire au plan p1-p2-p3)
    const ez = new THREE.Vector3().crossVectors(ex, ey);

    // IMPORTANT : Pour garantir la sym√©trie, ez doit toujours pointer vers l'arri√®re (+Z global)
    // Si ez.z < 0, on inverse la direction
    if (ez.z < 0) {
      ez.negate();
    }

    // √âtape 4 : Coordonn√©es de p3 dans le rep√®re local
    const j = ey.dot(p3_p1);

    // √âtape 5 : R√©solution du syst√®me dans le rep√®re local
    // x = (r1¬≤ - r2¬≤ + d¬≤) / (2d)
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);

    // y = (r1¬≤ - r3¬≤ + i¬≤ + j¬≤) / (2j) - (i/j) * x
    const y = (r1 * r1 - r3 * r3 + i * i + j * j) / (2 * j) - (i / j) * x;

    // z¬≤ = r1¬≤ - x¬≤ - y¬≤
    const zSquared = r1 * r1 - x * x - y * y;

    // Si z¬≤ < 0, les sph√®res ne se croisent pas (configuration impossible)
    let z: number;
    if (zSquared < 0) {
      console.warn(`‚ö†Ô∏è Configuration de brides impossible (z¬≤=${zSquared.toFixed(3)}), approximation`);
      z = 0; // Solution d√©g√©n√©r√©e : CTRL dans le plan des 3 points
    } else {
      // Deux solutions possibles (devant/derri√®re le plan)
      // On prend z > 0 (vers l'arri√®re du kite, direction +Z)
      // Pour garantir la SYM√âTRIE, les deux c√¥t√©s doivent avoir le m√™me Z
      z = Math.sqrt(zSquared);
    }

    // √âtape 6 : Convertir les coordonn√©es locales en coordonn√©es globales
    const result = new THREE.Vector3();
    result.copy(p1); // Partir de p1
    result.addScaledVector(ex, x); // Ajouter x * ex
    result.addScaledVector(ey, y); // Ajouter y * ey
    result.addScaledVector(ez, z); // Ajouter z * ez

    return [result.x, result.y, result.z];
  }

  /**
   * Calcule toutes les positions des points anatomiques d'un cerf-volant delta
   */
  static calculateDeltaKitePoints(params: KiteParams): Map<string, [number, number, number]> {
    const { width, height, depth, bridleLengths = PointFactory.DEFAULT_BRIDLE_LENGTHS } = params;

    // Logique m√©tier extraite de Kite.ts
    const centreY = height / 4;
    const ratio = (height - centreY) / height;
    const interGaucheX = ratio * (-width / 2);
    const interDroitX = ratio * (width / 2);
    const fixRatio = 2 / 3;

    // Points d'ancrage fixes des brides
    const nezPos: [number, number, number] = [0, height, 0];
    const centrePos: [number, number, number] = [0, height / 4, 0];
    const interGauchePos: [number, number, number] = [interGaucheX, centreY, 0];
    const interDroitPos: [number, number, number] = [interDroitX, centreY, 0];

    // Calculer la position du point de contr√¥le DROIT par trilat√©ration.
    // Le point GAUCHE sera d√©duit par sym√©trie pour garantir une g√©om√©trie parfaite.
    const ctrlDroit = PointFactory.calculateControlPoint(
      nezPos,
      interDroitPos, // Utilise le point d'ancrage droit
      centrePos,
      bridleLengths,
      'right'
    );

    // Le point de contr√¥le GAUCHE est le miroir du point droit par rapport √† l'axe YZ.
    // On prend la position du point droit et on inverse simplement sa coordonn√©e X.
    const ctrlGauche: [number, number, number] = [-ctrlDroit[0], ctrlDroit[1], ctrlDroit[2]];

    // Retourner la Map exactement comme dans le code original
    return new Map<string, [number, number, number]>([
      // Points structurels principaux
      ["SPINE_BAS", [0, 0, 0]],
      ["CENTRE", centrePos],
      ["NEZ", nezPos],

      // Points des bords d'attaque
      ["BORD_GAUCHE", [-width / 2, 0, 0]],
      ["BORD_DROIT", [width / 2, 0, 0]],

      // Points d'intersection pour le spreader
      ["INTER_GAUCHE", interGauchePos],
      ["INTER_DROIT", interDroitPos],

      // Points de fixation whiskers
      ["FIX_GAUCHE", [fixRatio * interGaucheX, centreY, 0]],
      ["FIX_DROIT", [fixRatio * interDroitX, centreY, 0]],

      // Points des whiskers
      ["WHISKER_GAUCHE", [-width / 4, 0.1, -depth]],
      ["WHISKER_DROIT", [width / 4, 0.1, -depth]],

      // Points de contr√¥le (bridage) - CALCUL√âS depuis longueurs physiques
      ["CTRL_GAUCHE", ctrlGauche],
      ["CTRL_DROIT", ctrlDroit],

      // Points d'ancrage des brides
      ["BRIDE_GAUCHE_A", nezPos],
      ["BRIDE_GAUCHE_B", interGauchePos],
      ["BRIDE_GAUCHE_C", centrePos],
      ["BRIDE_DROITE_A", nezPos],
      ["BRIDE_DROITE_B", interDroitPos],
      ["BRIDE_DROITE_C", centrePos],
    ]);
  }
}

=== factories/SurfaceFactory.ts ===

/**
 * SurfaceFactory.ts - Factory pour cr√©er des surfaces et toiles
 *
 * Pattern actuel KISS : Points ‚Üí Triangles pour surfaces
 * Compatible avec buildSurfaces() de StructuredObject
 */

import * as THREE from "three";

import { BaseFactory, FactoryParams } from "../base/BaseFactory";
import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";

export interface SurfaceParams extends FactoryParams {
  points?: Array<[string, number[]]>; // Points nomm√©s pour la surface
  panels?: Array<string[]>; // Groupes de 3-4 points formant des panneaux
  material?: {
    color?: string;
    opacity?: number;
    transparent?: boolean;
    doubleSided?: boolean; // true = visible des deux c√¥t√©s (d√©faut), false = une face
    side?: THREE.Side;
  };
  tension?: number; // Tension de la toile (future feature)
}

/**
 * Factory pour cr√©er des surfaces tendues
 *
 * TODO: Questions pour √©volution future
 * - [ ] Impl√©menter subdivision de surfaces pour plus de d√©tail ? non
 * - [ ] Ajouter simulation de tension/d√©formation ? non
 * - [ ] Supporter surfaces courbes (NURBS simplifi√©es) ? non
 * - [ ] Calculer automatiquement la triangulation optimale ? non
 * - [ ] Ajouter textures proc√©durales (tissage, ripstop) ? non
 * - [ ] G√©rer les plis et d√©formations ? non
 *
 */
export class SurfaceFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: "surface",
    name: "Surface",
    description: "Surface tendue param√©trique",
    tags: ["surface", "toile", "membrane"],
    complexity: "simple" as const,
  };

  protected getDefaultParams(): SurfaceParams {
    return {
      points: [],
      panels: [],
      material: {
        color: "#ff0000",
        opacity: 0.9,
        transparent: true,
        doubleSided: true, // Par d√©faut, visible des deux c√¥t√©s
      },
      tension: 1.0,
    };
  }

  createObject(params?: SurfaceParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as SurfaceParams;

    class SurfaceObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Surface", false);
      }

      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        // Pas de structure pour une surface pure
      }

      protected buildSurfaces(): void {
        // Cr√©er les panneaux de surface
        if (mergedParams.panels) {
          mergedParams.panels.forEach((panel) => {
            // Convertir doubleSided en THREE.Side
            const mat = mergedParams.material || {};
            const side =
              mat.doubleSided !== false ? THREE.DoubleSide : THREE.FrontSide;

            // Chaque panneau est un triangle (3 points) ou quad (4 points)
            this.addSurfaceBetweenPoints(panel, {
              color: mat.color || "#ff0000",
              opacity: mat.opacity !== undefined ? mat.opacity : 0.9,
              transparent: mat.transparent !== false,
              side: mat.side || side,
            });
          });
        }
      }

      // Impl√©mentation ICreatable
      create(): this {
        return this;
      }
      getName(): string {
        return "Surface";
      }
      getDescription(): string {
        return "Surface tendue";
      }
      getPrimitiveCount(): number {
        return (mergedParams.panels || []).length;
      }
    }

    const surface = new SurfaceObject();
    surface.init();
    return surface;
  }
}


=== factories/presets/PhysicalPresets.ts ===

/**
 * PhysicalPresets.ts - Constantes physiques centralis√©es
 *
 * Toutes les constantes physiques, mat√©riaux et configurations
 * utilis√©es dans la simulation du cerf-volant.
 */

import * as THREE from 'three';

// ============================================================================
// CONSTANTES PHYSIQUES FONDAMENTALES
// ============================================================================

export const PHYSICAL_CONSTANTS = {
  gravity: 9.81, // m/s¬≤ - Acc√©l√©ration gravitationnelle terrestre
  airDensity: 1.225, // kg/m¬≥ - Densit√© de l'air √† 15¬∞C
  speedOfSound: 343, // m/s - Vitesse du son dans l'air
  dynamicViscosity: 1.81e-5, // Pa¬∑s - Viscosit√© dynamique de l'air
} as const;

// ============================================================================
// PR√âSETS DE MAT√âRIAUX PHYSIQUES
// ============================================================================

export const MATERIAL_PRESETS = {
  // Mat√©riaux de structure (carbone/kevlar)
  carbon: {
    density: 1600, // kg/m¬≥
    youngModulus: 230e9, // Pa - Module de Young
    tensileStrength: 3500e6, // Pa - R√©sistance √† la traction
    color: 0x333333,
    name: 'Carbone'
  },

  kevlar: {
    density: 1440, // kg/m¬≥
    youngModulus: 130e9, // Pa
    tensileStrength: 3600e6, // Pa
    color: 0x666666,
    name: 'Kevlar'
  },

  // Mat√©riaux de surface (tissus)
  ripstopNylon: {
    density: 40, // g/m¬≤ (surface density)
    thickness: 0.00015, // m
    tensileStrength: 150e6, // Pa
    color: 0xffffff,
    name: 'Ripstop Nylon'
  },

  dacron: {
    density: 45, // g/m¬≤
    thickness: 0.00018, // m
    tensileStrength: 180e6, // Pa
    color: 0xf0f0f0,
    name: 'Dacron'
  }
} as const;

// ============================================================================
// PR√âSETS DE LIGNES ET BRIDES
// ============================================================================

export const LINE_PRESETS = {
  standard: {
    stiffness: 2200, // N/m - Rigidit√©
    preTension: 75, // N - Tension minimale
    maxTension: 800, // N - Tension maximale
    dampingCoeff: 0.05, // Coefficient d'amortissement
    linearMassDensity: 0.0005, // kg/m - Masse lin√©ique
    color: 0xffaa00,
    name: 'Ligne Standard'
  },

  bridle: {
    stiffness: 5000, // N/m - Plus rigide pour les brides
    preTension: 10, // N - Tension minimale faible
    maxTension: 300, // N - Tension maximale
    dampingCoeff: 0.02, // Amortissement faible
    linearMassDensity: 0.0003, // kg/m - Plus l√©ger
    color: 0x00aaff,
    name: 'Bride'
  },

  control: {
    stiffness: 1800, // N/m - Moins rigide pour le contr√¥le
    preTension: 50, // N
    maxTension: 600, // N
    dampingCoeff: 0.08, // Amortissement plus fort
    linearMassDensity: 0.0007, // kg/m - Plus lourd
    color: 0xff4444,
    name: 'Ligne de Contr√¥le'
  }
} as const;

// ============================================================================
// PR√âSETS A√âRODYNAMIQUES
// ============================================================================

export const AERODYNAMIC_PRESETS = {
  // Coefficients de portance (lift) selon l'angle d'attaque
  liftCoefficients: {
    low: 0.2,     // Angle d'attaque faible
    medium: 0.8,  // Angle d'attaque moyen
    high: 1.2,    // Angle d'attaque √©lev√©
    stall: 0.1    // D√©crochage
  },

  // Coefficients de tra√Æn√©e (drag)
  dragCoefficients: {
    low: 0.05,    // Profil optimis√©
    medium: 0.08, // Profil standard
    high: 0.15,   // Profil d√©grad√©
    stall: 0.3    // D√©crochage
  },

  // Facteurs d'√©chelle pour √©quilibrer la simulation
  scaleFactors: {
    lift: 1.2,    // Facteur de portance
    drag: 1.2,    // Facteur de tra√Æn√©e
    torque: 1.0   // Facteur de couple
  }
} as const;

// ============================================================================
// PR√âSETS DE VENT
// ============================================================================

export const WIND_PRESETS = {
  calm: {
    speed: 5,      // km/h
    direction: 0,  // degr√©s
    turbulence: 0.001, // %
    name: 'Calme'
  },

  light: {
    speed: 15,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.005, // %
    name: 'L√©ger'
  },

  moderate: {
    speed: 25,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.01, // %
    name: 'Mod√©r√©'
  },

  strong: {
    speed: 35,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.02, // %
    name: 'Fort'
  }
} as const;

// ============================================================================
// PR√âSETS DE CONFIGURATION KITE
// ============================================================================

export const KITE_PRESETS = {
  standard: {
    area: 0.5288,  // m¬≤ - Surface calcul√©e
    mass: 0.31,    // kg - Masse calcul√©e
    span: 1.65,    // m - Envergure
    aspectRatio: 3.12, // Rapport d'allongement
    name: 'Kite Standard'
  },

  sport: {
    area: 0.6,     // m¬≤
    mass: 0.28,    // kg
    span: 1.8,     // m
    aspectRatio: 3.5,
    name: 'Kite Sport'
  },

  beginner: {
    area: 0.8,     // m¬≤
    mass: 0.35,    // kg
    span: 2.0,     // m
    aspectRatio: 2.8,
    name: 'Kite D√©butant'
  }
} as const;

// ============================================================================
// UTILITAIRES
// ============================================================================

export class PhysicalUtils {
  /**
   * Calcule la pression dynamique
   */
  static dynamicPressure(velocity: THREE.Vector3, airDensity: number = PHYSICAL_CONSTANTS.airDensity): number {
    const speed = velocity.length();
    return 0.5 * airDensity * speed * speed;
  }

  /**
   * Calcule le nombre de Reynolds
   */
  static reynoldsNumber(velocity: number, length: number, viscosity: number = PHYSICAL_CONSTANTS.dynamicViscosity): number {
    return (velocity * length) / viscosity;
  }

  /**
   * Convertit km/h en m/s
   */
  static kmhToMs(speedKmh: number): number {
    return speedKmh / 3.6;
  }

  /**
   * Convertit m/s en km/h
   */
  static msToKmh(speedMs: number): number {
    return speedMs * 3.6;
  }
}

=== main.ts ===

import { Simulation } from "./simulation";

// Initialisation de la simulation
console.log("üöÄ D√©marrage de la simulation ...");

async function startSimulation() {
  try {
    const app = new Simulation();
    await app.initialize();
    console.log("‚úÖ Simulation initialis√©e avec succ√®s");
    
    // D√©marrer la simulation
    await app.start();
    console.log("‚ñ∂Ô∏è Simulation d√©marr√©e");

    // Gestion du nettoyage lors de la fermeture de la page
    window.addEventListener("beforeunload", () => {
      if (app && typeof app.cleanup === "function") {
        app.cleanup();
      }
    });
  } catch (error) {
    console.error("‚ùå Erreur lors de l'initialisation de la simulation:", error);
  }
}

// Lancer la simulation au chargement
startSimulation();


=== objects/mechanical/Line.ts ===

/**
 * Line.ts - Entit√© m√©tier repr√©sentant une ligne de cerf-volant
 *
 * R√¥le :
 *   - Encapsule les propri√©t√©s physiques d'une ligne (Dyneema/Spectra)
 *   - Repr√©sente une ligne individuelle du syst√®me de pilotage
 *   - Pure data object, pas de logique de calcul
 *
 * Responsabilit√© :
 *   - Stocker les param√®tres physiques (longueur, rigidit√©, tension)
 *   - G√©rer les points d'attache (nom des points anatomiques)
 *   - Fournir un √©tat coh√©rent pour les calculs physiques
 *
 * Relation avec les autres modules :
 *   - Utilis√© par LinePhysics pour les calculs de force
 *   - Cr√©√© par LineFactory
 *   - Consomm√© par LineSystem (orchestration)
 *
 * Philosophie :
 *   - "Tell, don't ask" : La ligne expose son √©tat, ne fait pas de calculs
 *   - Immutabilit√© partielle : Les param√®tres physiques sont readonly
 *   - Single Responsibility : Repr√©sentation m√©tier uniquement
 *
 * Voir aussi :
 *   - src/simulation/physics/LinePhysics.ts (calculs)
 *   - src/factories/LineFactory.ts (cr√©ation)
 *   - src/objects/mechanical/LineVisual.ts (rendu)
 */

import * as THREE from "three";

/**
 * Configuration physique d'une ligne de cerf-volant
 */
export interface LineConfig {
  /** Longueur au repos (m√®tres) */
  length: number;

  /** Rigidit√© axiale EA/L (N/m) - Typique Dyneema : 2200 N/m pour 15m */
  stiffness: number;

  /** Pr√©-tension minimale (N) - Toujours pr√©sente, m√™me ligne molle */
  preTension: number;

  /** Tension maximale avant rupture (N) */
  maxTension: number;

  /** Coefficient d'amortissement interne (sans dimension, 0-1) */
  dampingCoeff: number;

  /** Masse lin√©ique (kg/m) - Pour calcul cat√©naire */
  linearMassDensity: number;
}

/**
 * Points d'attache d'une ligne
 */
export interface LineAttachments {
  /** Nom du point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Nom du point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;
}

/**
 * Entit√© repr√©sentant une ligne de cerf-volant
 *
 * @example
 * ```typescript
 * const leftLine = new Line({
 *   length: 15,
 *   stiffness: 2200,
 *   preTension: 75,
 *   maxTension: 800,
 *   dampingCoeff: 0.05,
 *   linearMassDensity: 0.0005
 * }, {
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 * ```
 */
export class Line {
  /** Identifiant unique de la ligne */
  public readonly id: string;

  /** Configuration physique (immuable) */
  public readonly config: Readonly<LineConfig>;

  /** Points d'attache (immuables) */
  public readonly attachments: Readonly<LineAttachments>;

  /** √âtat actuel de la ligne */
  private currentLength: number;
  private currentTension: number;

  /** Timestamp derni√®re mise √† jour */
  private lastUpdateTime: number;

  constructor(
    config: LineConfig,
    attachments: LineAttachments,
    id?: string
  ) {
    this.id = id || `line_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = Object.freeze({ ...config });
    this.attachments = Object.freeze({ ...attachments });

    // √âtat initial
    this.currentLength = config.length;
    this.currentTension = config.preTension;
    this.lastUpdateTime = 0;
  }

  /**
   * Met √† jour l'√©tat actuel de la ligne
   * (Appel√© par LinePhysics apr√®s calcul)
   */
  updateState(length: number, tension: number, timestamp: number): void {
    this.currentLength = length;
    this.currentTension = tension;
    this.lastUpdateTime = timestamp;
  }

  /**
   * Obtient la longueur actuelle (√©tir√©e)
   */
  getCurrentLength(): number {
    return this.currentLength;
  }

  /**
   * Obtient la tension actuelle
   */
  getCurrentTension(): number {
    return this.currentTension;
  }

  /**
   * Calcule l'extension actuelle (Œîx = L_current - L_rest)
   */
  getExtension(): number {
    return Math.max(0, this.currentLength - this.config.length);
  }

  /**
   * V√©rifie si la ligne est tendue
   */
  isTaut(): boolean {
    return this.currentLength > this.config.length;
  }

  /**
   * V√©rifie si la ligne est proche de la rupture
   */
  isNearBreaking(threshold: number = 0.9): boolean {
    return this.currentTension >= this.config.maxTension * threshold;
  }

  /**
   * Obtient le timestamp de derni√®re mise √† jour
   */
  getLastUpdateTime(): number {
    return this.lastUpdateTime;
  }

  /**
   * Clone cette ligne avec une nouvelle configuration
   */
  clone(newConfig?: Partial<LineConfig>): Line {
    return new Line(
      { ...this.config, ...newConfig },
      { ...this.attachments }
    );
  }

  /**
   * Repr√©sentation textuelle pour debug
   */
  toString(): string {
    return `Line[${this.id}](${this.attachments.kitePoint} ‚Üí ${this.attachments.barPoint}) ` +
           `L=${this.currentLength.toFixed(3)}m T=${this.currentTension.toFixed(1)}N`;
  }

  /**
   * Export JSON pour s√©rialisation
   */
  toJSON(): object {
    return {
      id: this.id,
      config: this.config,
      attachments: this.attachments,
      state: {
        currentLength: this.currentLength,
        currentTension: this.currentTension,
        lastUpdateTime: this.lastUpdateTime
      }
    };
  }

  /**
   * Cr√©e une ligne depuis JSON
   */
  static fromJSON(data: any): Line {
    const line = new Line(data.config, data.attachments, data.id);
    if (data.state) {
      line.updateState(
        data.state.currentLength,
        data.state.currentTension,
        data.state.lastUpdateTime
      );
    }
    return line;
  }
}


=== objects/organic/Kite.ts ===


/**
 * Kite.ts - Mod√®le 3D du cerf-volant delta pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la structure, les points anatomiques et les surfaces du cerf-volant
 *   - Utilise les factories pour g√©n√©rer la g√©om√©trie, la structure et la toile
 *   - Sert de base √† tous les calculs physiques et au rendu
 *
 * D√©pendances principales :
 *   - StructuredObject.ts : Classe de base pour tous les objets 3D structur√©s
 *   - FrameFactory.ts, SurfaceFactory.ts, PointFactory.ts : Factories pour la cr√©ation des √©l√©ments du kite
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : ICreatable pour l'interface de cr√©ation
 *   - Three.js : Pour la g√©om√©trie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Les factories (FrameFactory, SurfaceFactory, PointFactory) sont utilis√©es pour g√©n√©rer la structure et la toile
 *   - StructuredObject.ts (dossier core) est la classe m√®re
 *
 * Utilisation typique :
 *   - Instanci√© par le moteur physique et le rendu pour manipuler le kite
 *   - Sert de source unique pour les points et la g√©om√©trie du kite
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 *   - src/factories/FrameFactory.ts
 *   - src/factories/SurfaceFactory.ts
 *   - src/factories/PointFactory.ts
 */

import * as THREE from "three";

import { StructuredObject } from "../../core/StructuredObject";
import { ICreatable } from "../../types/index";
import { Primitive } from "../../core/Primitive";
import { FrameFactory } from "../../factories/FrameFactory";
import { SurfaceFactory } from "../../factories/SurfaceFactory";
import { PointFactory, BridleLengths } from "../../factories/PointFactory";
import { FactoryRegistry } from "../../factories/FactoryRegistry";
import { CONFIG } from "../../simulation/config/SimulationConfig";

export class Kite extends StructuredObject implements ICreatable {
  private frameFactory: FrameFactory;
  private surfaceFactory: SurfaceFactory;
  // Map centrale des points - Single Source of Truth
  private pointsMap: Map<string, [number, number, number]> = new Map();
  private bridleLines: THREE.Group | null = null;
  private bridleLengthFactor: number = 1.0; // Facteur de longueur virtuelle des brides principales

  // Longueurs physiques des brides (en m√®tres)
  // LONGUEURS IDENTIQUES : L'√©quilibre vient de la g√©om√©trie, pas des brides
  // Principe: Kite suspendu par CTRL_GAUCHE et CTRL_DROIT sera horizontal
  // si le centre de masse se trouve entre ces deux points (axe X)
  private bridleLengths: BridleLengths = {
    nez: 0.65,     // 65cm - longueur standard
    inter: 0.65,   // 65cm - longueur standard
    centre: 0.65,  // 65cm - longueur standard
  };

  // Param√®tres du cerf-volant
  private params = {
    width: 1.65, // Envergure
    height: 0.65, // Hauteur
    depth: 0.20, // Profondeur whiskers
    frameDiameter: 0.01,
    frameColor: "#2a2a2a",
    sailColor: "#ff3333",
    sailOpacity: 0.9,
  };

  constructor(customParams = {}) {
    super("Cerf-volant Delta", false);
    this.params = { ...this.params, ...customParams };
    this.frameFactory = new FrameFactory();
    this.surfaceFactory = new SurfaceFactory();
    this.init();
  }

  /**
   * D√©finit tous les points anatomiques du cerf-volant
   * Utilise PointFactory pour encapsuler la logique de calcul
   */
  protected definePoints(): void {
    const { width, height, depth } = this.params;

    // Utiliser PointFactory pour calculer les positions avec bridleLengths physiques
    this.pointsMap = PointFactory.calculateDeltaKitePoints({
      width,
      height,
      depth,
      bridleLengths: this.bridleLengths
    });

    // Enregistrer dans StructuredObject pour compatibilit√© avec le syst√®me existant
    this.pointsMap.forEach((position, name) => {
      this.setPoint(name, position);
    });
  }

  /**
   * Construit la structure rigide avec FrameFactory
   */
  protected buildStructure(): void {
    const { frameDiameter, frameColor } = this.params;

    // Cr√©er le frame principal avec la Map de points partag√©e
    const mainFrameParams = {
      diameter: frameDiameter,
      material: frameColor,
      points: Array.from(this.pointsMap.entries()), // Passer LA Map de r√©f√©rence
      connections: [
        // √âpine centrale
        ["NEZ", "SPINE_BAS"] as [string, string],
        // Bords d'attaque
        ["NEZ", "BORD_GAUCHE"] as [string, string],
        ["NEZ", "BORD_DROIT"] as [string, string],
        // Spreader
        ["INTER_GAUCHE", "INTER_DROIT"] as [string, string],
      ],
    };

    const mainFrame = this.frameFactory.createObject('frame', mainFrameParams);
    this.add(mainFrame);

    // Cr√©er les whiskers avec un frame s√©par√© (plus fin)
    const whiskerFrameParams = {
      diameter: frameDiameter / 2,
      material: "#444444",
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      connections: [
        ["WHISKER_GAUCHE", "FIX_GAUCHE"] as [string, string],
        ["WHISKER_DROIT", "FIX_DROIT"] as [string, string],
      ],
    };

    const whiskerFrame = this.frameFactory.createObject('frame', whiskerFrameParams);
    this.add(whiskerFrame);

    // Cr√©er le syst√®me de bridage avec des lignes souples
    this.createBridleLines();
  }

  /**
   * Cr√©e les lignes de bridage souples (visuelles uniquement)
   * Ces lignes repr√©sentent des cordes sans √©lasticit√© ni effet ressort
   */
  private createBridleLines(): void {
    // Supprimer les anciennes lignes si elles existent
    if (this.bridleLines) {
      this.remove(this.bridleLines);
    }

    this.bridleLines = new THREE.Group();
    this.bridleLines.name = "BridleLines";

    // Configuration des brides
    const bridleConnections = [
      // Bridage gauche (3 lignes partant de CTRL_GAUCHE)
      ["CTRL_GAUCHE", "NEZ"],
      ["CTRL_GAUCHE", "INTER_GAUCHE"],
      ["CTRL_GAUCHE", "CENTRE"],
      // Bridage droit (3 lignes partant de CTRL_DROIT)
      ["CTRL_DROIT", "NEZ"],
      ["CTRL_DROIT", "INTER_DROIT"],
      ["CTRL_DROIT", "CENTRE"],
    ];

    // Mat√©riau pour les lignes de bridage
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: 1,
      opacity: 0.8,
      transparent: true,
    });

    // Cr√©er chaque ligne de bridage
    bridleConnections.forEach(([startName, endName]) => {
      const startPos = this.pointsMap.get(startName);
      const endPos = this.pointsMap.get(endName);

      if (startPos && endPos) {
        // Cr√©er une ligne droite simple (sans effet cat√©naire pour les brides internes)
        const geometry = new THREE.BufferGeometry();
        const points = [
          new THREE.Vector3(...startPos),
          new THREE.Vector3(...endPos),
        ];
        geometry.setFromPoints(points);

        const line = new THREE.Line(geometry, lineMaterial);
        line.name = `Bridle_${startName}_${endName}`;

        // Stocker la longueur de repos de la bride
        const restLength = new THREE.Vector3(...startPos).distanceTo(
          new THREE.Vector3(...endPos)
        );
        line.userData.restLength = restLength;
        line.userData.startPoint = startName;
        line.userData.endPoint = endName;

        this.bridleLines!.add(line);
      }
    });

    this.add(this.bridleLines!);
  }

  /**
   * Met √† jour les lignes de bridage pour suivre les points
   * √Ä appeler si les points bougent dynamiquement
   */
  public updateBridleLines(): void {
    if (!this.bridleLines) return;

    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const startName = line.userData.startPoint;
        const endName = line.userData.endPoint;
        const startPos = this.pointsMap.get(startName);
        const endPos = this.pointsMap.get(endName);

        if (startPos && endPos) {
          const geometry = line.geometry as THREE.BufferGeometry;
          const points = [
            new THREE.Vector3(...startPos),
            new THREE.Vector3(...endPos),
          ];
          geometry.setFromPoints(points);
          geometry.attributes.position.needsUpdate = true;
        }
      }
    });
  }

  /**
   * Met √† jour la visualisation des brides selon leurs tensions
   * Couleurs : vert (molle) ‚Üí jaune (moyenne) ‚Üí rouge (tendue)
   *
   * @param tensions - Tensions des 6 brides en Newtons
   */
  public updateBridleVisualization(tensions: {
    leftNez: number;
    leftInter: number;
    leftCentre: number;
    rightNez: number;
    rightInter: number;
    rightCentre: number;
  }): void {
    if (!this.bridleLines) return;

    // Mapping nom ligne ‚Üí tension
    const tensionMap = new Map<string, number>([
      ["Bridle_CTRL_GAUCHE_NEZ", tensions.leftNez],
      ["Bridle_CTRL_GAUCHE_INTER_GAUCHE", tensions.leftInter],
      ["Bridle_CTRL_GAUCHE_CENTRE", tensions.leftCentre],
      ["Bridle_CTRL_DROIT_NEZ", tensions.rightNez],
      ["Bridle_CTRL_DROIT_INTER_DROIT", tensions.rightInter],
      ["Bridle_CTRL_DROIT_CENTRE", tensions.rightCentre],
    ]);

    // Mettre √† jour couleur de chaque bride
    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const tension = tensionMap.get(line.name) ?? 0;
        const material = line.material as THREE.LineBasicMaterial;

        // Seuils de tension (N) - centralis√©s dans CONFIG
        const lowThreshold = CONFIG.debug.bridleTensionLow;
        const highThreshold = CONFIG.debug.bridleTensionHigh;

        if (tension < lowThreshold) {
          // Vert : bride molle
          material.color.setHex(0x00ff00);
          material.opacity = 0.5;
        } else if (tension < highThreshold) {
          // Jaune : tension moyenne
          // Interpolation vert ‚Üí jaune
          const t = (tension - lowThreshold) / (highThreshold - lowThreshold);
          const r = Math.floor(t * 255);
          const g = 255;
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.6 + t * 0.2; // 0.6 ‚Üí 0.8
        } else {
          // Rouge : bride tendue
          // Interpolation jaune ‚Üí rouge
          const t = Math.min((tension - highThreshold) / 100, 1);
          const r = 255;
          const g = Math.floor((1 - t) * 255);
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.8 + t * 0.2; // 0.8 ‚Üí 1.0
        }
      }
    });
  }

  /**
   * Construit les surfaces avec SurfaceFactory
   */
  protected buildSurfaces(): void {
    const { sailColor, sailOpacity } = this.params;

    // Cr√©er la toile avec 4 panneaux triangulaires
    const sailParams = {
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      panels: [
        // Toile gauche
        ["NEZ", "BORD_GAUCHE", "WHISKER_GAUCHE"],
        ["NEZ", "WHISKER_GAUCHE", "SPINE_BAS"],
        // Toile droite
        ["NEZ", "BORD_DROIT", "WHISKER_DROIT"],
        ["NEZ", "WHISKER_DROIT", "SPINE_BAS"],
      ],
      material: {
        color: sailColor,
        transparent: true,
        opacity: sailOpacity,
        doubleSided: true, // Visible des deux c√¥t√©s
      },
    };

    const sail = this.surfaceFactory.createObject(sailParams);
    this.add(sail);

    // Ajouter des marqueurs visuels aux points cl√©s
    this.addVisualMarkers();
  }

  /**
   * M√©thode helper pour obtenir la Map de points
   * Peut √™tre utilis√©e si d'autres objets ont besoin des points
   */
  public getPointsMap(): Map<string, [number, number, number]> {
    return new Map(this.pointsMap); // Retourner une copie pour √©viter les modifications externes
  }

  /**
   * Ajuste le facteur de longueur virtuelle des brides principales (NEZ vers CTRL_*)
   * @param factor - Facteur de longueur (0.5 = 50% plus court, 1.0 = normal, 1.5 = 50% plus long)
   */
  public adjustBridleLength(factor: number): void {
    // Limiter la valeur entre 0.5 et 1.5
    this.bridleLengthFactor = Math.max(0.5, Math.min(1.5, factor));
    console.log(
      `üìè Facteur de longueur des brides principales: ${this.bridleLengthFactor}`
    );
  }

  /**
   * Retourne la longueur de repos virtuelle pour les brides principales
   * Utilis√© par la physique pour calculer les tensions
   * @param bridleName - 'left' ou 'right'
   * @returns La longueur de repos modifi√©e ou undefined si pas une bride principale
   */
  public getBridleRestLength(bridleName: "left" | "right"): number | undefined {
    const nez = this.getPoint("NEZ");
    const ctrl = this.getPoint(
      bridleName === "left" ? "CTRL_GAUCHE" : "CTRL_DROIT"
    );

    if (!nez || !ctrl) return undefined;

    // Calculer la distance g√©om√©trique r√©elle
    const realDistance = nez.distanceTo(ctrl);

    // Appliquer le facteur de longueur virtuelle
    // factor < 1 = bride plus courte = plus de tension
    // factor > 1 = bride plus longue = moins de tension
    return realDistance * this.bridleLengthFactor;
  }

  /**
   * Retourne le facteur de longueur actuel des brides
   */
  public getBridleLengthFactor(): number {
    return this.bridleLengthFactor;
  }

  /**
   * Ajuste les longueurs physiques des brides (en m√®tres)
   * @param lengths - Longueurs des 3 brides { nez, inter, centre }
   */
  public setBridleLengths(lengths: Partial<BridleLengths>): void {
    // Mettre √† jour les longueurs (merge avec les valeurs existantes)
    this.bridleLengths = {
      ...this.bridleLengths,
      ...lengths
    };

    console.log(`ü™Å Longueurs brides: NEZ=${this.bridleLengths.nez.toFixed(2)}m, INTER=${this.bridleLengths.inter.toFixed(2)}m, CENTRE=${this.bridleLengths.centre.toFixed(2)}m`);

    // Supprimer tous les enfants pour nettoyer l'ancienne g√©om√©trie
    this.clearChildren();

    // Recalculer les points avec les nouvelles longueurs
    this.definePoints();

    // Reconstruire le kite avec les nouveaux points
    this.buildStructure();
    this.buildSurfaces();
    this.createBridleLines();

    // Recr√©er les marqueurs visuels aux nouvelles positions
    this.addVisualMarkers();
  }

  /**
   * Supprime tous les enfants du kite (g√©om√©trie, marqueurs, etc.)
   */
  private clearChildren(): void {
    // Supprimer tous les enfants Three.js
    while (this.children.length > 0) {
      this.remove(this.children[0]);
    }
  }

  /**
   * Retourne les longueurs actuelles des brides
   */
  public getBridleLengths(): BridleLengths {
    return { ...this.bridleLengths };
  }

  /**
   * Transforme un point local en coordonn√©es monde
   *
   * Cette m√©thode utilitaire √©vite la duplication du pattern:
   * `localPos.clone().applyQuaternion(kite.quaternion).add(kite.position)`
   *
   * @param localPos - Position dans le rep√®re local du kite
   * @returns Position dans le rep√®re monde
   *
   * @example
   * ```typescript
   * const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
   * const worldPos = kite.localToWorld(ctrlLeft);
   * ```
   */
  public localToWorld(localPos: THREE.Vector3): THREE.Vector3 {
    return localPos
      .clone()
      .applyQuaternion(this.quaternion)
      .add(this.position);
  }

  /**
   * Ajoute des marqueurs visuels aux points importants
   */
  private addVisualMarkers(): void {
    // Nez (point rouge)
    const nez = this.getPoint("NEZ");
    if (nez) {
      const marker = Primitive.sphere(0.025, "#ff0000");
      this.addPrimitiveAt(marker, [nez.x, nez.y, nez.z]);
    }

    // Points de contr√¥le
    const ctrlG = this.getPoint("CTRL_GAUCHE");
    if (ctrlG) {
      const marker = Primitive.sphere(0.025, "#dc143c");
      this.addPrimitiveAt(marker, [ctrlG.x, ctrlG.y, ctrlG.z]);
    }

    const ctrlD = this.getPoint("CTRL_DROIT");
    if (ctrlD) {
      const marker = Primitive.sphere(0.025, "#b22222");
      this.addPrimitiveAt(marker, [ctrlD.x, ctrlD.y, ctrlD.z]);
    }
  }

  // Impl√©mentation de l'interface ICreatable
  create(): this {
    return this;
  }

  getName(): string {
    return "Cerf-volant Delta v2";
  }

  getDescription(): string {
    return "Cerf-volant delta construit avec les factories CAO";
  }

  getPrimitiveCount(): number {
    return 25; // Frame + surfaces + marqueurs
  }
}

/**
 * AVANTAGES de cette approche avec factories:
 *
 * 1. **Modularit√©** : Points, frames et surfaces sont g√©r√©s par des factories d√©di√©es
 * 2. **R√©utilisabilit√©** : Les factories peuvent √™tre utilis√©es pour d'autres objets
 * 3. **Param√©trage** : Facile de modifier les param√®tres de chaque composant
 * 4. **Composition** : On peut combiner diff√©rentes factories
 * 5. **√âvolutivit√©** : Facile d'ajouter de nouvelles fonctionnalit√©s aux factories
 *
 * UTILISATION DE POINTFACTORY:
 * - Tous les points sont d√©finis dans une Map centralis√©e
 * - PointFactory cr√©e un objet points r√©utilisable
 * - Pas de sym√©trie automatique : chaque point est d√©fini explicitement
 * - Permet une gestion coh√©rente et valid√©e des points anatomiques
 *
 * WORKFLOW CAO:
 * 1. PointFactory ‚Üí D√©finir tous les points anatomiques
 * 2. FrameFactory ‚Üí Construire la structure rigide
 * 3. SurfaceFactory ‚Üí Ajouter les surfaces/toiles
 * 4. Assembly ‚Üí Combiner le tout (futur)
 */


=== simulation.ts ===

/**
 * Point d'entr√©e de compatibilit√©
 *
 * Ce fichier maintient la compatibilit√© avec l'ancien import
 * tout en redirigeant vers la nouvelle structure modulaire
 */

export { SimulationApp as Simulation } from './simulation/SimulationApp';

=== simulation/SimulationApp.ts ===

/**
 * SimulationApp.ts - Application principale de simulation (Architecture ECS-inspired)
 *
 * Nouvelle architecture modulaire avec syst√®mes de simulation s√©par√©s.
 * Chaque syst√®me (Physics, Wind, Input, Render) fonctionne ind√©pendamment
 * et communique via un contexte partag√©.
 */

import * as THREE from 'three';
import { Logger } from '../utils/Logging';
import { UidGenerator } from '../utils/UidGenerator';

// Import des syst√®mes modulaires
import {
  PhysicsSystem,
  WindSystem,
  InputSystem,
  RenderSystem,
  type PhysicsState,
  type PhysicsConfig,
  type WindConfig,
  type InputConfig,
  type RenderConfig
} from './systems';

// Import des composants existants (temporairement pour compatibilit√©)
import { Kite } from '../objects/organic/Kite';
import { UIManager } from './ui/UIManager';
import { CONFIG } from './config/SimulationConfig';
import { KiteGeometry } from './config/KiteGeometry';

export interface SimulationConfig {
  targetFPS: number;
  maxFrameTime: number;
  enableDebug: boolean;
  enableRenderSystem: boolean;
  enableLegacyComponents: boolean; // Nouveau flag pour contr√¥ler les composants legacy
  physics: Partial<PhysicsConfig>;
  wind: Partial<WindConfig>;
  input: Partial<InputConfig>;
  render: Partial<RenderConfig>;
}

export class SimulationApp {
  private logger: Logger;
  private config: SimulationConfig;

  // Syst√®mes ECS-inspired
  private physicsSystem!: PhysicsSystem;
  private windSystem!: WindSystem;
  private inputSystem!: InputSystem;
  private renderSystem!: RenderSystem;

  // Composants existants (pour compatibilit√©)
  private kite!: Kite;
  private uiManager!: UIManager;
  private controlBar!: THREE.Group;

  // √âtat de simulation
  private isRunning: boolean = false;
  private isInitialized: boolean = false;
  private clock: THREE.Clock;
  private frameCount: number = 0;
  private totalTime: number = 0;
  private lastFrameTime: number = 0;

  // Gestion des objets physiques
  private physicsObjects = new Map<string, PhysicsState>();

  constructor(config: Partial<SimulationConfig> = {}) {
    this.logger = Logger.getInstance();
    this.clock = new THREE.Clock();

    // Configuration par d√©faut
    this.config = {
      targetFPS: 60,
      maxFrameTime: 1/30, // 30 FPS minimum
      enableDebug: true,
      enableRenderSystem: true,
      enableLegacyComponents: false, // D√©sactiver par d√©faut pour √©viter les erreurs de mocks
      physics: {},
      wind: {},
      input: {},
      render: {},
      ...config
    };

    this.logger.info('SimulationApp initializing with ECS architecture', 'SimulationApp');

    // Initialiser les syst√®mes
    this.initializeSystems();

    // Initialiser les composants existants (si activ√©s)
    if (this.config.enableLegacyComponents) {
      this.initializeLegacyComponents();
    }
  }

  /**
   * Initialise tous les syst√®mes de simulation
   */
  private initializeSystems(): void {
    this.logger.info('Initializing simulation systems...', 'SimulationApp');

    // Cr√©er les syst√®mes avec leurs configurations
    this.physicsSystem = new PhysicsSystem(this.config.physics);
    this.windSystem = new WindSystem(this.config.wind);
    this.inputSystem = new InputSystem(this.config.input);

    // Cr√©er le syst√®me de rendu seulement si activ√©
    if (this.config.enableRenderSystem) {
      this.renderSystem = new RenderSystem(this.config.render);
    }

    this.logger.info('All simulation systems created', 'SimulationApp');
  }

  /**
   * Initialise les composants existants pour compatibilit√©
   */
  private initializeLegacyComponents(): void {
    this.logger.info('Initializing legacy components...', 'SimulationApp');

    // Configurer la g√©om√©trie du kite
    KiteGeometry.setMeshSubdivisionLevel(CONFIG.kite.defaultMeshSubdivisionLevel);

    // Cr√©er la barre de contr√¥le
    this.setupControlBar();

    // Cr√©er le kite
    this.kite = new Kite();
    this.kite.position.set(0, 5, 0);

    // Ajouter le kite √† la sc√®ne de rendu (si RenderSystem activ√©)
    if (this.config.enableRenderSystem && this.renderSystem) {
      const scene = this.renderSystem.getScene();
      if (scene) {
        scene.add(this.kite);
        scene.add(this.controlBar);
      }
    }

    // Cr√©er l'UI Manager (avec mocks appropri√©s)
    const physicsEngineMock = {
      getBridleLengths: () => ({ nez: 0.5, center: 0.5, tip: 0.5 }),
      setBridleLength: () => {},
      getKiteState: () => ({}),
      getWindState: () => ({}),
      update: () => {}
    } as any;

    const debugRendererMock = {
      isDebugMode: () => false,
      toggleDebugMode: () => {},
      renderDebugInfo: () => {},
      clearDebugInfo: () => {},
      setDebugMode: () => {},
      renderManager: {} as any,
      debugArrows: [],
      debugMode: false,
      vectorVisibility: {}
    } as any;

    this.uiManager = new UIManager(
      physicsEngineMock,
      debugRendererMock,
      () => this.reset(), // resetCallback
      () => { /* toggle play */ } // togglePlayCallback
    );

    // Enregistrer le kite comme objet physique
    this.registerPhysicsObject('kite', {
      position: this.kite.position.clone(),
      velocity: new THREE.Vector3(),
      acceleration: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      angularAcceleration: new THREE.Vector3(),
      mass: 0.5, // kg
      momentOfInertia: new THREE.Matrix3().identity()
    });

    this.logger.info('Legacy components initialized', 'SimulationApp');
  }

  /**
   * Configure la barre de contr√¥le
   */
  private setupControlBar(): void {
    this.controlBar = new THREE.Group();
    this.controlBar.name = 'ControlBar';

    // Cr√©er une barre simple pour l'instant
    const barGeometry = new THREE.CylinderGeometry(0.02, 0.02, 2);
    const barMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
    const bar = new THREE.Mesh(barGeometry, barMaterial);

    this.controlBar.add(bar);
    this.controlBar.position.set(0, 1, 5);
  }

  /**
   * Initialise l'application de simulation
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('Starting SimulationApp initialization...', 'SimulationApp');

      // Initialiser tous les syst√®mes
      const initPromises = [
        this.physicsSystem.initialize(),
        this.windSystem.initialize(),
        this.inputSystem.initialize()
      ];

      // Ajouter RenderSystem seulement si activ√©
      if (this.config.enableRenderSystem) {
        initPromises.push(this.renderSystem.initialize());
      }

      await Promise.all(initPromises);

      // D√©marrer le rendu (si activ√©)
      if (this.config.enableRenderSystem) {
        this.renderSystem.startRendering();
      }

      this.isInitialized = true;
      this.logger.info('SimulationApp fully initialized', 'SimulationApp');

    } catch (error) {
      this.logger.error(`SimulationApp initialization failed: ${error}`, 'SimulationApp');
      throw error;
    }
  }

  /**
   * Boucle principale de simulation (ECS-inspired)
   */
  update = (): void => {
    if (!this.isInitialized || !this.isRunning) return;

    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, this.config.maxFrameTime);
    this.lastFrameTime = currentTime;

    this.totalTime += deltaTime;
    this.frameCount++;

    // Cr√©er le contexte de simulation partag√©
    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: !this.isRunning,
      debugMode: this.config.enableDebug
    };

    try {
      // 1. Mise √† jour des entr√©es (priorit√© haute)
      this.inputSystem.update(context);

      // 2. Mise √† jour du vent
      this.windSystem.update(context);

      // 3. Mise √† jour de la physique
      this.physicsSystem.update(context);

      // 4. Mise √† jour du rendu (priorit√© basse)
      if (this.config.enableRenderSystem) {
        this.renderSystem.update(context);
      }

      // 5. Synchronisation avec les composants existants
      this.syncLegacyComponents(context);

      // 6. Mise √† jour de l'UI
      this.updateUI(context);

    } catch (error) {
      this.logger.error(`Simulation update error: ${error}`, 'SimulationApp');
    }

    // Continuer la boucle
    if (this.isRunning) {
      requestAnimationFrame(this.update);
    }
  };

  /**
   * Synchronise les composants existants avec les syst√®mes
   */
  private syncLegacyComponents(context: any): void {
    if (!this.config.enableLegacyComponents) return;

    // Obtenir l'√©tat des entr√©es
    const inputState = this.inputSystem.getInputState();

    // Appliquer la rotation de la barre
    this.controlBar.rotation.z = inputState.barPosition * Math.PI / 6; // Max ¬±30¬∞

    // Obtenir l'√©tat physique du kite
    const kitePhysics = this.physicsObjects.get('kite');
    if (kitePhysics) {
      // Synchroniser la position du kite
      this.kite.position.copy(kitePhysics.position);

      // Calculer le vent apparent pour le kite
      const apparentWind = this.windSystem.getApparentWind(
        kitePhysics.position,
        kitePhysics.velocity
      );

      // TODO: Appliquer les forces a√©rodynamiques bas√©es sur le vent apparent
      // Pour l'instant, juste une force de gravit√© simple
      if (kitePhysics.position.y > 0) {
        kitePhysics.acceleration.set(0, -9.81, 0);
      } else {
        kitePhysics.acceleration.set(0, 0, 0);
        kitePhysics.velocity.set(0, 0, 0);
        kitePhysics.position.y = 0;
      }

      // Int√©gration simple d'Euler
      kitePhysics.velocity.add(kitePhysics.acceleration.clone().multiplyScalar(context.deltaTime));
      kitePhysics.position.add(kitePhysics.velocity.clone().multiplyScalar(context.deltaTime));
    }

    // Gestion du reset
    if (inputState.resetPressed) {
      this.reset();
    }
  }

  /**
   * Met √† jour l'interface utilisateur
   */
  private updateUI(context: any): void {
    // Mettre √† jour l'UI si elle existe
    this.updateUIOverlay();
  }

  /**
   * Met √† jour l'overlay UI avec les donn√©es actuelles
   */
  private updateUIOverlay(): void {
    if (typeof document === 'undefined') return;

    const fpsElement = document.getElementById('fps');
    const posElement = document.getElementById('kite-pos');
    const velElement = document.getElementById('kite-vel');
    const windElement = document.getElementById('wind-speed');
    const barElement = document.getElementById('bar-pos');

    if (fpsElement || posElement || velElement || windElement || barElement) {
      const renderStats = this.renderSystem ? this.renderSystem.getRenderStats() : { fps: 0 };
      const kitePhysics = this.physicsObjects.get('kite');
      const inputState = this.inputSystem.getInputState();
      const windState = this.windSystem.getWindState();

      if (fpsElement) {
        fpsElement.textContent = `FPS: ${renderStats.fps}`;
      }

      if (posElement && kitePhysics) {
        posElement.textContent = `Position: (${kitePhysics.position.x.toFixed(1)}, ${kitePhysics.position.y.toFixed(1)}, ${kitePhysics.position.z.toFixed(1)})`;
      }

      if (velElement && kitePhysics) {
        velElement.textContent = `Vitesse: (${kitePhysics.velocity.x.toFixed(1)}, ${kitePhysics.velocity.y.toFixed(1)}, ${kitePhysics.velocity.z.toFixed(1)})`;
      }

      if (windElement) {
        windElement.textContent = `Vent: ${windState.baseSpeed.toFixed(1)} m/s`;
      }

      if (barElement) {
        barElement.textContent = `Barre: ${(inputState.barPosition * 100).toFixed(0)}%`;
      }
    }
  }

  /**
   * Enregistre un objet physique dans le syst√®me
   */
  registerPhysicsObject(id: string, state: PhysicsState): void {
    this.physicsObjects.set(id, state);
    this.physicsSystem.registerPhysicsObject(id, state);
  }

  /**
   * D√©marre la simulation
   */
  start(): void {
    if (!this.isInitialized) {
      throw new Error('SimulationApp must be initialized before starting');
    }

    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.logger.info('SimulationApp started', 'SimulationApp');

    // D√©marrer la boucle
    requestAnimationFrame(this.update);
  }

  /**
   * Arr√™te la simulation
   */
  stop(): void {
    this.isRunning = false;
    this.logger.info('SimulationApp stopped', 'SimulationApp');
  }

  /**
   * R√©initialise la simulation
   */
  reset(): void {
    this.logger.info('Resetting simulation...', 'SimulationApp');

    // R√©initialiser les syst√®mes
    this.physicsSystem.reset();
    this.windSystem.reset();
    this.inputSystem.reset();
    if (this.renderSystem) {
      this.renderSystem.reset();
    }

    // R√©initialiser l'√©tat
    this.frameCount = 0;
    this.totalTime = 0;

    // R√©initialiser les objets physiques
    for (const [id, state] of this.physicsObjects) {
      // TODO: Impl√©menter une logique de reset par objet
    }

    // R√©initialiser les composants existants
    this.kite.position.set(0, 5, 0);
    this.controlBar.rotation.z = 0;

    this.logger.info('Simulation reset complete', 'SimulationApp');
  }

  /**
   * Obtient les statistiques de performance
   */
  getStats(): {
    fps: number;
    frameCount: number;
    totalTime: number;
    isRunning: boolean;
    physicsObjects: number;
  } {
    const renderStats = this.renderSystem ? this.renderSystem.getRenderStats() : { fps: 0 };

    return {
      fps: renderStats.fps,
      frameCount: this.frameCount,
      totalTime: this.totalTime,
      isRunning: this.isRunning,
      physicsObjects: this.physicsObjects.size
    };
  }

  /**
   * Nettoie les ressources
   */
  dispose(): void {
    this.logger.info('Disposing SimulationApp...', 'SimulationApp');

    this.stop();

    // Disposer les syst√®mes
    this.physicsSystem.dispose();
    this.windSystem.dispose();
    this.inputSystem.dispose();
    if (this.config.enableRenderSystem) {
      this.renderSystem.dispose();
    }

    // Disposer les composants existants
    if (this.config.enableLegacyComponents) {
      if (this.uiManager) {
        // Note: UIManager n'a pas de m√©thode dispose
      }
    }

    this.logger.info('SimulationApp disposed', 'SimulationApp');
  }

  /**
   * Alias pour dispose() pour compatibilit√© avec l'ancien code
   */
  cleanup(): void {
    this.dispose();
  }
}

=== simulation/SimulationApp_legacy.ts ===

/**
 * SimulationApp.ts - Application principale de simulation
 *
 * Point d'entr√©e refactoris√© qui assemble tous les composants modulaires
 */

import * as THREE from "three";

import { Kite } from "../objects/organic/Kite";

import { RenderManager } from "./rendering/RenderManager";
import { DebugRenderer } from "./rendering/DebugRenderer";
import { PhysicsEngine } from "./physics/PhysicsEngine";
import { InputHandler } from "./controllers/InputHandler";
import { UIManager } from "./ui/UIManager";
import { CONFIG } from "./config/SimulationConfig";
import { KiteGeometry } from "./config/KiteGeometry";

export class Simulation {
  private renderManager: RenderManager;
  private debugRenderer: DebugRenderer;
  private physicsEngine!: PhysicsEngine;
  private inputHandler: InputHandler;
  private uiManager!: UIManager;
  private kite!: Kite;
  private controlBar!: THREE.Group;
  private clock: THREE.Clock;
  private isPlaying: boolean = true;
  private leftLine: THREE.Line | null = null;
  private rightLine: THREE.Line | null = null;
  private frameCount: number = 0;

  constructor() {
    console.log("üöÄ D√©marrage de la Simulation V8 - Version modulaire");

    try {
      const container = document.getElementById("app");
      if (!container) {
        throw new Error("Container #app non trouv√©");
      }

      this.renderManager = new RenderManager(container);
      this.debugRenderer = new DebugRenderer(this.renderManager);
      this.inputHandler = new InputHandler();
      this.clock = new THREE.Clock();

      // üîß Initialiser le niveau de subdivision du maillage
      KiteGeometry.setMeshSubdivisionLevel(CONFIG.kite.defaultMeshSubdivisionLevel);

      this.setupControlBar();
      this.setupKite();
      this.physicsEngine = new PhysicsEngine(
        this.kite,
        this.controlBar.position
      );
      this.setupUI();
      this.createControlLines();
      this.animate();
    } catch (error) {
      console.error(
        "‚ùå Erreur lors de l'initialisation de la Simulation:",
        error
      );
      throw error;
    }
  }

  private setupKite(): void {
    this.kite = new Kite();
    const pilot = this.controlBar.position.clone();
    // Position initiale : 95% de la longueur de ligne pour avoir lignes l√©g√®rement tendues
    const initialDistance = CONFIG.lines.defaultLength * CONFIG.initialization.initialDistanceFactor;

    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);

    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);
    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();

    console.log(
      `üìç Position initiale du kite: ${this.kite.position.toArray()}`
    );
    this.renderManager.addObject(this.kite);
  }

  private setupControlBar(): void {
    this.controlBar = new THREE.Group();
    this.controlBar.position.copy(CONFIG.controlBar.position);

    const barGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.width
    );
    const barMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.7,
      roughness: 0.3,
    });
    const bar = new THREE.Mesh(barGeometry, barMaterial);
    bar.rotation.z = CONFIG.controlBar.barRotation;
    this.controlBar.add(bar);

    const handleGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleLength
    );
    const handleMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      roughness: 0.6,
    });

    const halfWidth = CONFIG.controlBar.width / 2;
    const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    leftHandle.position.set(-halfWidth, 0, 0);
    this.controlBar.add(leftHandle);

    const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    rightHandle.position.set(halfWidth, 0, 0);
    this.controlBar.add(rightHandle);

    const pilotGeometry = new THREE.BoxGeometry(
      CONFIG.pilot.width,
      CONFIG.pilot.height,
      CONFIG.pilot.depth
    );
    const pilotMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a4a4a,
      roughness: 0.8,
    });
    const pilot = new THREE.Mesh(pilotGeometry, pilotMaterial);
    pilot.position.set(0, CONFIG.pilot.offsetY, CONFIG.pilot.offsetZ);
    pilot.castShadow = true;

    this.renderManager.addObject(this.controlBar);
    this.renderManager.addObject(pilot);
  }

  /**
   * Calcule la distance horizontale via Pythagore
   * √âvite la duplication de code (utilis√© dans setupKite et resetSimulation)
   */
  private calculateHorizontalDistance(hypotenuse: number, vertical: number): number {
    const minHorizontal = 0.1; // m - Distance horizontale minimale pour √©viter kite au-dessus du pilote
    return Math.max(
      minHorizontal,
      Math.sqrt(Math.max(0, hypotenuse * hypotenuse - vertical * vertical))
    );
  }

  private createControlLines(): void {
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: CONFIG.visualization.lineWidth,
    });

    const leftGeometry = new THREE.BufferGeometry();
    const rightGeometry = new THREE.BufferGeometry();

    this.leftLine = new THREE.Line(leftGeometry, lineMaterial);
    this.rightLine = new THREE.Line(rightGeometry, lineMaterial);

    this.renderManager.addObject(this.leftLine);
    this.renderManager.addObject(this.rightLine);
  }

  private updateControlLines(): void {
    if (!this.leftLine || !this.rightLine) return;

    const ctrlLeft = this.kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = this.kite.getPoint("CTRL_DROIT");

    if (!ctrlLeft || !ctrlRight) return;

    const kiteLeftWorld = ctrlLeft.clone();
    const kiteRightWorld = ctrlRight.clone();
    this.kite.localToWorld(kiteLeftWorld);
    this.kite.localToWorld(kiteRightWorld);

    const handles = this.physicsEngine
      .getControlBarManager()
      .getHandlePositions(this.kite.position);

    const leftPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.left, kiteLeftWorld);
    const rightPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.right, kiteRightWorld);

    this.leftLine.geometry.setFromPoints(leftPoints);
    this.rightLine.geometry.setFromPoints(rightPoints);

    this.physicsEngine
      .getControlBarManager()
      .updateVisual(this.controlBar, this.kite);
  }

  private setupUI(): void {
    this.uiManager = new UIManager(
      this.physicsEngine,
      this.debugRenderer,
      () => this.resetSimulation(),
      () => this.togglePlayPause()
    );
  }

  private resetSimulation(): void {
    const currentLineLength =
      this.physicsEngine.getLineSystem().lineLength ||
      CONFIG.lines.defaultLength;
    const initialDistance = currentLineLength * CONFIG.initialization.initialDistanceFactor;

    const pilot = this.controlBar.position.clone();
    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);
    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);

    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();
    this.controlBar.quaternion.identity();

    this.physicsEngine = new PhysicsEngine(this.kite, this.controlBar.position);
    this.physicsEngine.setLineLength(currentLineLength);

    this.updateControlLines();
    console.log(`üîÑ Simulation r√©initialis√©e`);
  }

  private togglePlayPause(): void {
    this.isPlaying = !this.isPlaying;
    this.uiManager.updatePlayButton(this.isPlaying);
  }

  private animate = (): void => {
    requestAnimationFrame(this.animate);

    this.frameCount++;

    if (this.isPlaying) {
      try {
        const deltaTime = this.clock.getDelta();
        this.inputHandler.update(deltaTime);
        const targetRotation = this.inputHandler.getTargetBarRotation();

        this.physicsEngine.update(deltaTime, targetRotation, false);
        this.updateControlLines();
        this.debugRenderer.updateDebugArrows(this.kite, this.physicsEngine);
      } catch (error) {
        console.error("‚ùå Erreur dans la boucle d'animation:", error);
        this.isPlaying = false;
      }
    }

    this.renderManager.render();
  };

  public cleanup(): void {
    console.log("üßπ Nettoyage de la Simulation...");
    this.isPlaying = false;

    this.debugRenderer.clearDebugArrows();

    if (this.leftLine) {
      this.renderManager.removeObject(this.leftLine);
      this.leftLine = null;
    }
    if (this.rightLine) {
      this.renderManager.removeObject(this.rightLine);
      this.rightLine = null;
    }

    if (this.kite) {
      this.renderManager.removeObject(this.kite);
    }

    if (this.controlBar) {
      this.renderManager.removeObject(this.controlBar);
    }

    console.log("‚úÖ Simulation nettoy√©e");
  }
}

=== simulation/config/KiteGeometry.ts ===

/**
 * KiteGeometry.ts - D√©finition de la g√©om√©trie du cerf-volant pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la forme, les points anatomiques et les surfaces du cerf-volant
 *   - Sert de plan de construction pour tous les calculs physiques et graphiques
 *   - Utilis√© pour le calcul des forces, la cr√©ation du mod√®le 3D et la configuration
 *
 * D√©pendances principales :
 *   - Three.js : Utilis√© pour les coordonn√©es et la g√©om√©trie
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise KiteGeometry pour la surface et les points
 *   - Tous les modules physiques et graphiques utilisent KiteGeometry pour les calculs
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de rendu et de configuration
 *   - Sert √† positionner les points et surfaces du kite
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

/**
 * G√©om√©trie du cerf-volant
 *
 * La forme du cerf-volant - comme un plan de construction
 * On d√©finit o√π sont tous les points importants du cerf-volant
 */
export class KiteGeometry {
  // Les points cl√©s du cerf-volant (comme les coins d'une maison)
  // Coordonn√©es en m√®tres : [gauche/droite, haut/bas, avant/arri√®re]
  static readonly POINTS = {
    NEZ: new THREE.Vector3(0, 0.65, 0), // Le bout pointu en haut
    SPINE_BAS: new THREE.Vector3(0, 0, 0), // Le centre en bas
    BORD_GAUCHE: new THREE.Vector3(-0.825, 0, 0), // L'extr√©mit√© de l'aile gauche
    BORD_DROIT: new THREE.Vector3(0.825, 0, 0), // L'extr√©mit√© de l'aile droite
    WHISKER_GAUCHE: new THREE.Vector3(-0.4125, 0.1, -0.15), // Stabilisateur gauche (l√©g√®rement en arri√®re)
    WHISKER_DROIT: new THREE.Vector3(0.4125, 0.1, -0.15), // Stabilisateur droit (l√©g√®rement en arri√®re)
    CTRL_GAUCHE: new THREE.Vector3(-0.15, 0.3, -0.2), // O√π s'attache la ligne gauche
    CTRL_DROIT: new THREE.Vector3(0.15, 0.3, -0.2), // O√π s'attache la ligne droite
  };

  /**
   * Calcule l'aire d'un triangle 3D √† partir de ses 3 sommets
   * Utilise la formule : Aire = 0.5 √ó ||AB √ó AC||
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle
   * @param v3 Troisi√®me sommet du triangle
   * @returns L'aire du triangle en m¬≤
   */
  private static calculateTriangleArea(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): number {
    // Cr√©er deux vecteurs repr√©sentant deux c√¥t√©s du triangle
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    
    // Le produit vectoriel donne un vecteur perpendiculaire
    // dont la longueur = aire du parall√©logramme form√© par edge1 et edge2
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    
    // L'aire du triangle = la moiti√© de l'aire du parall√©logramme
    return cross.length() / 2;
  }

  /**
   * Calcule le centro√Øde (centre g√©om√©trique) d'un triangle
   * Le centro√Øde est situ√© √† l'intersection des m√©dianes du triangle
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle  
   * @param v3 Troisi√®me sommet du triangle
   * @returns Le point centro√Øde du triangle
   */
  static calculateTriangleCentroid(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): THREE.Vector3 {
    return v1.clone()
      .add(v2)
      .add(v3)
      .divideScalar(3);
  }

  // Le cerf-volant est fait de 4 triangles de tissu
  // Chaque triangle a 3 coins (vertices) et une surface en m√®tres carr√©s
  //
  // ORDRE DES VERTICES (r√®gle main droite) :
  // Les normales doivent pointer vers l'ARRI√àRE (Z positif) pour recevoir le vent
  // qui vient de l'arri√®re (direction -Z).
  // Order : sens horaire vu de l'arri√®re = normale vers l'arri√®re
  //
  // NOTE : Les aires sont calcul√©es automatiquement √† partir de la g√©om√©trie r√©elle
  // pour garantir la coh√©rence physique
  //
  // NOTE : Les masses sont calcul√©es apr√®s, voir SURFACES_WITH_MASS ci-dessous
  static readonly SURFACES = [
    {
      // Surface haute gauche (normale doit pointer vers arri√®re)
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE
      ),
    },
    {
      // Surface basse gauche
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS
      ),
    },
    {
      // Surface haute droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT
      ),
    },
    {
      // Surface basse droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT
      ),
    },
  ];

  /**
   * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
   * @param v1, v2, v3 : sommets du triangle
   * @returns Tableau de 4 sous-triangles {vertices, area}
   */
  private static subdivideTriangle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3) {
    // Calcul des milieux
    const m12 = v1.clone().add(v2).multiplyScalar(0.5);
    const m23 = v2.clone().add(v3).multiplyScalar(0.5);
    const m31 = v3.clone().add(v1).multiplyScalar(0.5);

    // 4 sous-triangles
    const tris = [
      { vertices: [v1, m12, m31] },
      { vertices: [v2, m23, m12] },
      { vertices: [v3, m31, m23] },
      { vertices: [m12, m23, m31] },
    ];
    // Ajoute l'aire √† chaque sous-triangle
    return tris.map(t => ({
      vertices: t.vertices,
      area: KiteGeometry.calculateTriangleArea(t.vertices[0], t.vertices[1], t.vertices[2])
    }));
  }

  /**
   * Subdivise r√©cursivement un triangle selon un niveau donn√©
   * @param v1, v2, v3 : sommets du triangle
   * @param level : niveau de subdivision (0 = pas de subdivision)
   * @returns Tableau de tous les sous-triangles
   */
  private static subdivideTriangleRecursive(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3,
    level: number
  ): { vertices: THREE.Vector3[]; area: number }[] {
    if (level <= 0) {
      // Pas de subdivision : retourner le triangle original
      return [{
        vertices: [v1, v2, v3],
        area: KiteGeometry.calculateTriangleArea(v1, v2, v3)
      }];
    }

    // Subdiviser en 4 sous-triangles
    const subTriangles = KiteGeometry.subdivideTriangle(v1, v2, v3);

    // Appliquer r√©cursivement la subdivision √† chaque sous-triangle
    const result: { vertices: THREE.Vector3[]; area: number }[] = [];
    for (const subTri of subTriangles) {
      const [sv1, sv2, sv3] = subTri.vertices;
      result.push(...KiteGeometry.subdivideTriangleRecursive(sv1, sv2, sv3, level - 1));
    }

    return result;
  }

  /**
   * Subdivision du maillage pour am√©liorer la pr√©cision a√©rodynamique.
   *
   * POURQUOI LA SUBDIVISION :
   * - Un triangle unique ne peut avoir qu'une seule normale ‚Üí angle d'attaque uniforme
   * - Avec subdivision, chaque sous-triangle peut avoir un angle d'attaque local diff√©rent
   * - Permet de capturer les variations spatiales du vent et de la courbure virtuelle
   * - Am√©liore le r√©alisme des couples a√©rodynamiques distribu√©s
   *
   * CO√õT PERFORMANCE :
   * - Niveau 0 : 4 triangles (rapide, peu pr√©cis)
   * - Niveau 1 : 16 triangles (bon compromis)
   * - Niveau 2 : 64 triangles (pr√©cis, co√ªt mod√©r√©) ‚Üê recommand√©
   * - Niveau 3 : 256 triangles (tr√®s pr√©cis, co√ªteux)
   * - Niveau 4+ : 1024+ triangles (impact performance significatif)
   */

  /**
   * Niveau de subdivision actuel du maillage
   * Par d√©faut niveau 1 (16 triangles), peut √™tre chang√© via setMeshSubdivisionLevel()
   */
  private static meshSubdivisionLevel: number = 1; // Niveau par d√©faut, sera initialis√© depuis CONFIG dans SimulationApp

  /**
   * Cache typ√© des surfaces subdivis√©es
   */
  private static _subdividedSurfaces: { vertices: THREE.Vector3[]; area: number }[] | null = null;

  /**
   * Constantes pour la subdivision
   */
  private static readonly MAX_SUBDIVISION_LEVEL = 3; // Limite raisonnable pour √©viter surcharge

  /**
   * Calcule le nombre de triangles par surface originale pour un niveau donn√©
   * Formule : 4^niveau (car chaque subdivision d√©coupe en 4)
   *
   * @param level - Niveau de subdivision (0, 1, 2, 3...)
   * @returns Nombre de sous-triangles par surface originale
   *
   * @example
   * TRIANGLES_PER_SURFACE_AT_LEVEL(0) ‚Üí 1 triangle
   * TRIANGLES_PER_SURFACE_AT_LEVEL(1) ‚Üí 4 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(2) ‚Üí 16 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(3) ‚Üí 64 triangles
   */
  static TRIANGLES_PER_SURFACE_AT_LEVEL(level: number): number {
    return Math.pow(4, level);
  }

  /**
   * Modifie le niveau de subdivision du maillage
   *
   * @param level - Niveau de subdivision (0=4 triangles, 1=16, 2=64, 3=256)
   *
   * IMPORTANT : Des niveaux √©lev√©s (>3) peuvent causer des probl√®mes de performance.
   * Le niveau est automatiquement limit√© √† MAX_SUBDIVISION_LEVEL (3).
   */
  static setMeshSubdivisionLevel(level: number): void {
    // Clamper entre 0 et MAX
    const clampedLevel = Math.max(0, Math.min(level, KiteGeometry.MAX_SUBDIVISION_LEVEL));

    // Warning si niveau trop √©lev√©
    if (level > KiteGeometry.MAX_SUBDIVISION_LEVEL) {
      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(level);
      console.warn(
        `‚ö†Ô∏è Niveau de subdivision ${level} trop √©lev√© (${totalTriangles} triangles).\n` +
        `Limit√© √† ${KiteGeometry.MAX_SUBDIVISION_LEVEL} pour √©viter surcharge performance.\n` +
        `Si vous avez vraiment besoin de plus, augmentez MAX_SUBDIVISION_LEVEL.`
      );
    }

    if (clampedLevel !== KiteGeometry.meshSubdivisionLevel) {
      KiteGeometry.meshSubdivisionLevel = clampedLevel;
      // Invalider le cache des surfaces subdivis√©es
      KiteGeometry._subdividedSurfaces = null;

      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(clampedLevel);
      console.log(`üîß Maillage subdivis√© : niveau ${clampedLevel} ‚Üí ${totalTriangles} triangles au total`);
    }
  }

  /**
   * Retourne le niveau de subdivision actuel du maillage
   */
  static getMeshSubdivisionLevel(): number {
    return KiteGeometry.meshSubdivisionLevel;
  }

  /**
   * Maillage fin : tous les sous-triangles du kite selon le niveau de subdivision configur√©
   *
   * CACHE : Les surfaces sont calcul√©es une seule fois puis mises en cache.
   * Le cache est invalid√© automatiquement quand le niveau change.
   *
   * @returns Tableau de tous les sous-triangles avec leurs vertices et aires
   */
  static get SUBDIVIDED_SURFACES(): { vertices: THREE.Vector3[]; area: number }[] {
    if (!KiteGeometry._subdividedSurfaces) {
      KiteGeometry._subdividedSurfaces = KiteGeometry.SURFACES.flatMap(surface =>
        KiteGeometry.subdivideTriangleRecursive(
          surface.vertices[0],
          surface.vertices[1],
          surface.vertices[2],
          KiteGeometry.meshSubdivisionLevel
        )
      );
    }
    return KiteGeometry._subdividedSurfaces;
  }

  // Calcul automatique de la surface totale
  static readonly TOTAL_AREA = KiteGeometry.SURFACES.reduce(
    (sum, surface) => sum + surface.area,
    0
  );  // ============================================================================
  // CALCUL AUTOMATIQUE DE LA MASSE DU CERF-VOLANT
  // ============================================================================

  /**
   * Sp√©cifications des mat√©riaux utilis√©s pour calculer la masse
   * Bas√© sur des composants r√©els de kites sport/stunt
   *
   * CORRECTION: Grammages augment√©s pour atteindre masse r√©aliste de 0.3-0.4 kg
   * (Pr√©c√©dente masse calcul√©e de ~0.153 kg √©tait √ó2.5 trop l√©g√®re)
   */
  private static readonly MATERIAL_SPECS = {
    // Tubes de carbone (masse lin√©ique en g/m)
    carbon: {
      spine: 10,        // 5mm diam√®tre renforc√© (corrig√© de 10)
      leadingEdge: 10,  // 5mm diam√®tre standard (corrig√© de 10)
      strut: 4,         // 4mm diam√®tre l√©ger (corrig√© de 2)
    },
    // Tissu (grammage en g/m¬≤)
    fabric: {
      ripstop: 40,     // Ripstop nylon standard (corrig√© de 40)
    },
    // Accessoires (masse en grammes)
    accessories: {
      connectorsLeadingEdge: 1,  // Connecteurs pour les bords d'attaque
      connectorCenterT: 1,       // Connecteur central en T
      connectorsStruts: 1,       // Connecteurs pour les struts
      bridleSystem: 1,          // Syst√®me de brides complet
      reinforcements: 1,        // Renforts et coutures
    },
  };

  /**
   * Calcule la longueur totale de tous les tubes de la frame
   * @returns Objet contenant les longueurs par type de tube et le total
   */
  private static calculateFrameLengths(): {
    spine: number;
    leadingEdges: number;
    struts: number;
    total: number;
  } {
    const spine = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.SPINE_BAS
    );

    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_GAUCHE
    );
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_DROIT
    );
    const leadingEdges = leadingEdgeLeft + leadingEdgeRight;

    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_GAUCHE
    );
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const struts = strutLeft + strutRight + spreader;

    return {
      spine,
      leadingEdges,
      struts,
      total: spine + leadingEdges + struts,
    };
  }

  /**
   * Calcule la masse de la structure (frame) en carbone
   * @returns Masse en kilogrammes
   */
  private static calculateFrameMass(): number {
    const lengths = KiteGeometry.calculateFrameLengths();
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;

    const spineMass = lengths.spine * specs.spine;
    const leadingEdgesMass = lengths.leadingEdges * specs.leadingEdge;
    const strutsMass = lengths.struts * specs.strut;

    // Somme en grammes, conversion en kg
    return (spineMass + leadingEdgesMass + strutsMass) / 1000;
  }

  /**
   * Calcule la masse du tissu (voile)
   * @returns Masse en kilogrammes
   */
  private static calculateFabricMass(): number {
    const grammage = KiteGeometry.MATERIAL_SPECS.fabric.ripstop;
    // Surface en m¬≤ √ó grammage en g/m¬≤ ‚Üí conversion en kg
    return (KiteGeometry.TOTAL_AREA * grammage) / 1000;
  }

  /**
   * Calcule la masse totale des accessoires
   * @returns Masse en kilogrammes
   */
  private static calculateAccessoriesMass(): number {
    const acc = KiteGeometry.MATERIAL_SPECS.accessories;
    const total =
      acc.connectorsLeadingEdge +
      acc.connectorCenterT +
      acc.connectorsStruts +
      acc.bridleSystem +
      acc.reinforcements;

    // Conversion g ‚Üí kg
    return total / 1000;
  }

  /**
   * Calcule la masse totale du cerf-volant (frame + tissu + accessoires)
   * Calcul√©e automatiquement depuis la g√©om√©trie et les sp√©cifications mat√©riaux
   * @returns Masse en kilogrammes
   */
  static calculateTotalMass(): number {
    return (
      KiteGeometry.calculateFrameMass() +
      KiteGeometry.calculateFabricMass() +
      KiteGeometry.calculateAccessoriesMass()
    );
  }

  /**
   * Masse totale du cerf-volant calcul√©e automatiquement
   * Bas√©e sur la g√©om√©trie r√©elle et les mat√©riaux standards
   */
  static readonly TOTAL_MASS = KiteGeometry.calculateTotalMass();

  /**
   * üî¥ BUG FIX #2 : Distribution masse frame selon g√©om√©trie R√âELLE
   * 
   * Topologie du kite (4 surfaces triangulaires) :
   *   Surface 0 (haute gauche)  : NEZ ‚Üí BORD_GAUCHE ‚Üí WHISKER_GAUCHE
   *   Surface 1 (basse gauche)  : NEZ ‚Üí WHISKER_GAUCHE ‚Üí SPINE_BAS
   *   Surface 2 (haute droite)  : NEZ ‚Üí BORD_DROIT ‚Üí WHISKER_DROIT
   *   Surface 3 (basse droite)  : NEZ ‚Üí WHISKER_DROIT ‚Üí SPINE_BAS
   * 
   * Attribution des segments de frame aux surfaces :
   *   - Spine (NEZ ‚Üí SPINE_BAS) : partag√©e 50/50 entre hautes et basses
   *   - Leading edge gauche (NEZ ‚Üí BORD_GAUCHE) : 100% surface 0
   *   - Leading edge droit (NEZ ‚Üí BORD_DROIT) : 100% surface 2
   *   - Strut gauche (BORD_GAUCHE ‚Üí WHISKER_GAUCHE) : partag√© surface 0/1
   *   - Strut droit (BORD_DROIT ‚Üí WHISKER_DROIT) : partag√© surface 2/3
   *   - Spreader (WHISKER_GAUCHE ‚Üí WHISKER_DROIT) : partag√© entre toutes
   * 
   * @returns Tableau de 4 masses (kg) pour chaque surface
   */
  private static calculateFrameMassDistribution(): number[] {
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;
    
    // Masses lin√©iques (kg/m)
    const spineUnitMass = specs.spine / 1000;        // g/m ‚Üí kg/m
    const leadingEdgeUnitMass = specs.leadingEdge / 1000;
    const strutUnitMass = specs.strut / 1000;
    
    // Longueurs individuelles des segments
    const spineLength = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.SPINE_BAS);
    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_GAUCHE);
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_DROIT);
    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_GAUCHE);
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    /**
     * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
     * @param v1, v2, v3 : sommets du triangle
     * @returns Tableau de 4 sous-triangles {vertices, area}
     */

    // Masses individuelles des segments
    const spineMass = spineLength * spineUnitMass;
    const leadingEdgeLeftMass = leadingEdgeLeft * leadingEdgeUnitMass;
    const leadingEdgeRightMass = leadingEdgeRight * leadingEdgeUnitMass;
    const strutLeftMass = strutLeft * strutUnitMass;
    const strutRightMass = strutRight * strutUnitMass;
    const spreaderMass = spreader * strutUnitMass;
    
    // Attribution g√©om√©trique r√©aliste aux surfaces
    const frameMasses = [
      // Surface 0 (haute gauche) : spine + leading edge gauche + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeLeftMass +         // 100% leading edge gauche
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 1 (basse gauche) : spine + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 2 (haute droite) : spine + leading edge droit + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeRightMass +        // 100% leading edge droit
      (strutRightMass * 0.5) +      // 50% strut droit (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)

      // Surface 3 (basse droite) : spine + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutRightMass * 0.5) +      // 50% strut droit (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)
    ];
    
    return frameMasses;
  }

  /**
   * Distribution de la masse sur les surfaces
   * Chaque surface porte une fraction de la masse totale
   * 
   * Mod√®le physique CORRIG√â :
   * - Masse de tissu (fabric) : Distribu√©e proportionnellement √† l'aire
   * - Masse de frame : Distribu√©e selon g√©om√©trie r√©elle (üî¥ BUG FIX #2)
   * - Masse d'accessoires : Distribu√©e uniform√©ment sur les 4 surfaces
   * 
   * @returns Masse de chaque surface en kg
   */
  static calculateSurfaceMasses(): number[] {
    const fabricMass = KiteGeometry.calculateFabricMass();
    const frameMasses = KiteGeometry.calculateFrameMassDistribution();  // üî¥ BUG FIX #2
    const accessoriesMass = KiteGeometry.calculateAccessoriesMass();
    
    // Accessoires r√©partis uniform√©ment (connecteurs dispers√©s sur tout le kite)
    const uniformAccessories = accessoriesMass / KiteGeometry.SURFACES.length;
    
    // La masse de tissu est r√©partie proportionnellement √† l'aire
    return KiteGeometry.SURFACES.map((surface, index) => {
      const fabricMassRatio = surface.area / KiteGeometry.TOTAL_AREA;
      const surfaceFabricMass = fabricMass * fabricMassRatio;
      
      return surfaceFabricMass + frameMasses[index] + uniformAccessories;
    });
  }

  /**
   * Masses pr√©calcul√©es pour chaque surface (en kg)
   * Index correspond √† l'index dans SURFACES
   */
  static readonly SURFACE_MASSES = KiteGeometry.calculateSurfaceMasses();

  /**
   * Surfaces enrichies avec leur masse individuelle
   * Utilis√©es par AerodynamicsCalculator pour appliquer la gravit√© distribu√©e
   */
  static readonly SURFACES_WITH_MASS = KiteGeometry.SURFACES.map((surface, index) => ({
    ...surface,
    mass: KiteGeometry.SURFACE_MASSES[index],
  }));

  /**
   * Calcule le moment d'inertie approximatif du cerf-volant
   * Utilise la formule simplifi√©e : I ‚âà m √ó r¬≤
   * o√π r est le rayon de giration moyen
   * @returns Moment d'inertie en kg¬∑m¬≤
   */
  static calculateInertia(): number {
    // Constantes pour calcul d'inertie (√©viter d√©pendance circulaire avec CONFIG)
    const GYRATION_DIVISOR = Math.sqrt(2); // wingspan / ‚àö2 pour forme delta (triangle isoc√®le)

    // Rayon de giration correct pour forme delta wing
    // Formule r√©aliste : r = wingspan / ‚àö2 (au lieu de /4)
    // R√©f√©rence : g√©om√©trie d'un triangle isoc√®le
    const wingspan =
      KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
        KiteGeometry.POINTS.BORD_DROIT
      );
    const radiusOfGyration = wingspan / GYRATION_DIVISOR;  // ‚âà 1.167 m au lieu de 0.4125 m

    const physicalInertia = KiteGeometry.TOTAL_MASS * radiusOfGyration * radiusOfGyration;

    // üîß FIX INERTIE: Factor 0.1 pour r√©activit√© imm√©diate au vent
    // Le kite doit √™tre "emport√©" par le vent, pas r√©sister par inertie
    // Factor 0.1 ram√®ne √† ~0.042 kg¬∑m¬≤ (tr√®s r√©actif, comme un tissu l√©ger)
    const REACTIVE_INERTIA_FACTOR = 0.1;
    return physicalInertia * REACTIVE_INERTIA_FACTOR;
  }

  /**
   * Moment d'inertie calcul√© automatiquement
   */
  static readonly INERTIA = KiteGeometry.calculateInertia();
}


=== simulation/config/PhysicsConstants.ts ===

/**
 * PhysicsConstants.ts - Constantes physiques globales pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les limites physiques, tol√©rances et facteurs de s√©curit√© du monde virtuel
 *   - Sert √† garantir la stabilit√© et la coh√©rence de la simulation
 *   - Utilis√© pour √©viter les comportements irr√©alistes ou dangereux
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par tous les modules physiques et de configuration
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise PhysicsConstants pour fixer les limites
 *   - Tous les modules du projet importent PhysicsConstants pour les v√©rifications
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de contr√¥le et de rendu
 *   - Sert √† valider les valeurs et √† limiter les extr√™mes
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
export class PhysicsConstants {
  // Tol√©rances num√©riques
  static readonly EPSILON = 1e-4; // Sans unit√© - Seuil pour "presque z√©ro" (comparaisons flottants)
  static readonly EPSILON_FINE = 1e-6; // Sans unit√© - Seuil fin pour calculs pr√©cis (LinePhysics)

  // Contr√¥les et contraintes
  static readonly CONTROL_DEADZONE = 0.01; // rad - Zone morte pour input barre de contr√¥le
  static readonly LINE_CONSTRAINT_TOLERANCE = 0.0005; // m - Tol√©rance contraintes lignes (0.5mm)
  static readonly LINE_TENSION_FACTOR = 0.99; // Sans unit√© - Facteur tension lignes (99% = l√©g√®rement tendues)
  static readonly CONSTRAINT_ITERATIONS = 2; // Sans unit√© - Nombre d'it√©rations pour convergence PBD

  // Sol et friction
  static readonly GROUND_FRICTION = 0.95; // Sans unit√© - Facteur friction sol (5% perte vitesse)

  // Rendu cat√©naire
  static readonly CATENARY_SEGMENTS = 10; // Sans unit√© - Nombre segments pour courbe cat√©naire

  // Limites de s√©curit√© physique (√©viter explosions num√©riques)
  static readonly MAX_FORCE = 1000; // N - Force maximale (√©quivalent ~100kg)
  static readonly MAX_VELOCITY = 30; // m/s - Vitesse maximale kite (108 km/h)
  static readonly MAX_ANGULAR_VELOCITY = 15; // rad/s - Limite √©lev√©e pour permettre convergence naturelle
  static readonly MAX_ACCELERATION = 100; // m/s¬≤ - Acc√©l√©ration maximale (~10G)
  static readonly MAX_ANGULAR_ACCELERATION = 5; // rad/s¬≤ - Acc√©l√©ration angulaire r√©aliste
}

=== simulation/config/SimulationConfig.ts ===

/**
 * SimulationConfig.ts - Configuration         // C  // Facteurs d'√©chelle a√©rodynamiques √©quilibr√©s
  liftScale: 1.2, // Facteur de portance
  dragScale: 1.2, // Facteur de tra√Æn√©e (√©quilibr√© avec portance)ficients d'amortissement (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 0.2, // Amortissement lin√©aire mod√©r√©
  angularDragFactor: 1.0, // Amortissement angulaire √©quilibr√© pour stabilisation naturelleamping coefficients (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 1.5, // üîß R√âALISTE: Friction a√©rodynamique mod√©r√©e pour stabilisation naturelle
    // Angular damping : UN SEUL m√©canisme (angular drag proportionnel √† œâ)
  angularDragFactor: 5.0, // üîß STABILIT√â CRITIQUE: Tr√®s fort amortissement pour √©viter rotation excessive
  },le de la simulation K  wind: {
    defaultSpeed: 25, // km/h - Vitesse r√©aliste pour cerf-volant sport (15-30 km/h typique)
    defaultDirection: 0, // degr√©s
    defaultTurbulence: 5, // % - Turbulence r√©aliste pour conditions normales
    turbulenceScale: 0.05,*
 * R√¥le :
 *   - D√©finit tous les param√®tres physiques, a√©rodynamiques, g√©om√©triques et environnementaux
 *   - Sert de source unique de v√©rit√© pour les r√©glages du monde virtuel
 *   - Permet d'ajuster le comportement du kite, du vent, des lignes, etc.
 *
 * D√©pendances principales :
 *   - KiteGeometry.ts : Utilis√© pour la surface et les points du kite
 *   - Utilis√© par tous les modules physiques et de rendu
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsConstants.ts : D√©finit les limites et tol√©rances physiques
 *   - KiteGeometry.ts : D√©finit la g√©om√©trie du kite
 *   - Tous les modules du projet importent SimulationConfig pour acc√©der aux param√®tres
 *
 * Utilisation typique :
 *   - Import√© dans tous les modules pour acc√©der aux r√©glages
 *   - Sert √† personnaliser la simulation (test, debug, tuning)
 *
 * Voir aussi :
 *   - src/simulation/config/PhysicsConstants.ts
 *   - src/simulation/config/KiteGeometry.ts
 */
import * as THREE from "three";

import { KiteGeometry } from "./KiteGeometry";

/**
 * Configuration √©pur√©e de la simulation
 *
 * Les r√©glages de notre monde virtuel - comme les r√®gles d'un jeu
 * Vous pouvez changer ces valeurs pour voir comment le cerf-volant r√©agit
 */
export const CONFIG = {
  physics: {
    gravity: 9.81, // La gravit√© terrestre (fait tomber les objets)
    airDensity: 1.225, // Densit√© de l'air (l'air √©pais pousse plus fort)
    deltaTimeMax: 0.016, // Mise √† jour max 60 fois par seconde (pour rester fluide)
    // Damping coefficients (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 1, // üîß FIX INERTIE: Drastiquement r√©duit pour r√©activit√© imm√©diate
    // üî¥ SOLUTION #2 : Amortissement angulaire r√©duit pour √©quilibre naturel
  angularDragFactor: 1.5, // ÔøΩ √âQUILIBRE: R√©duit de 5.0 ‚Üí 1.0 pour permettre stabilisation naturelle
  },
  aero: {
  // üî¥ SOLUTION #2 : Forces a√©rodynamiques √©quilibr√©es
  liftScale: 1.2, // ÔøΩ √âQUILIBR√â: R√©duit de 1.5 ‚Üí 1.2 
  dragScale: 1.2, // ÔøΩ √âQUILIBR√â: Maintenu √† 1.2 (coh√©rent avec lift)
  },
  kite: {
    // Masse et inertie calcul√©es AUTOMATIQUEMENT depuis la g√©om√©trie
    // Bas√©es sur:
    // - Frame carbone (spine 5mm, leading edges 5mm, struts 4mm)
    // - Tissu ripstop nylon 120 g/m¬≤ (corrig√© pour atteindre masse r√©aliste)
    // - Accessoires (connecteurs, bridage, renforts)
    // Voir KiteGeometry.calculateTotalMass() pour les d√©tails
    mass: KiteGeometry.TOTAL_MASS, // kg - Calcul√©e automatiquement (~0.31 kg apr√®s correction)
    area: KiteGeometry.TOTAL_AREA, // m¬≤ - Surface totale (calcul√©e automatiquement)
    inertia: KiteGeometry.INERTIA, // kg¬∑m¬≤ - Moment d'inertie (I ‚âà m¬∑r¬≤, calcul√© automatiquement)
    minHeight: 0, // m - Altitude minimale (plus haut pour √©viter le sol)
    // üîß MAILLAGE FIN PARAM√âTRABLE (d√©faut = niveau 1 = 16 triangles)
    defaultMeshSubdivisionLevel: 1, // Niveau par d√©faut (0=4, 1=16, 2=64, 3=256 triangles)
  },
  lines: {
    defaultLength: 15, // m - Longueur par d√©faut
    stiffness: 1200, // N/m - Rigidit√© r√©duite pour plus de souplesse (2200 √©tait trop rigide)
    preTension: 75, // N - Tension minimale toujours pr√©sente
    maxTension: 800, // N - Tension max avant rupture (~80% charge nominale)
    dampingCoeff: 0.05, // Coefficient d'amortissement interne (0-1)
    linearMassDensity: 0.0005, // kg/m - Masse lin√©ique pour calcul cat√©naire
  },
  wind: {
    defaultSpeed: 20, // km/h - Vitesse id√©ale pour cerf-volant
    defaultDirection: 0, // degr√©s
    defaultTurbulence: 0.001, // % - Turbulence r√©aliste (0.001 ‚Üí 10)
    turbulenceScale: 0.05,
    turbulenceFreqBase: 0.05,
    turbulenceFreqY: 0.3,
    turbulenceFreqZ: 0.3,
    turbulenceIntensityXZ: 0.2,
    turbulenceIntensityY: 0.2,
  },
  rendering: {
    shadowMapSize: 2048,
    antialias: true,
    fogStart: 100,
    fogEnd: 1000,
  },
  debugVectors: true, // Active ou d√©sactive l'affichage des vecteurs de debug
  controlBar: {
    width: 0.6, // m - Largeur de la barre
    position: new THREE.Vector3(0, 1.2, 8), // Position initiale
    barRadius: 0.02, // m - Rayon du cylindre de la barre
    barRotation: Math.PI / 2, // rad - Rotation pour orientation horizontale
    handleRadius: 0.03, // m - Rayon des poign√©es
    handleLength: 0.15, // m - Longueur des poign√©es
  },
  pilot: {
    width: 0.4, // m - Largeur du corps du pilote
    height: 1.6, // m - Hauteur du corps du pilote
    depth: 0.3, // m - Profondeur du corps du pilote
    offsetY: 0.8, // m - D√©calage vertical par rapport √† la barre
    offsetZ: 8.5, // m - Distance derri√®re la barre
  },
  initialization: {
    initialKiteY: 7.0, // m - Altitude initiale du kite
    initialDistanceFactor: 0.98, // Sans unit√© - Facteur de distance initiale (98% de longueur ligne ‚Üí lignes l√©g√®rement tendues au d√©part)
  },
  visualization: {
    lineWidth: 2, // pixels - Largeur des lignes de contr√¥le
  },
  debug: {
    // Seuils de tension des brides pour couleurs visuelles
    bridleTensionLow: 1, // N - Seuil tension molle (vert)
    bridleTensionHigh: 100, // N - Seuil tension √©lev√©e (rouge)
    // Seuils pour vecteurs debug
    minVectorLength: 0.01, // m - Longueur minimale pour afficher un vecteur
    minVelocityDisplay: 0.1, // m/s - Vitesse minimale pour afficher vecteur vitesse
  },
  input: {
    rotationSpeed: 0.5, // rad/s - Vitesse de rotation de la barre (input utilisateur)
    returnSpeed: 3.0, // rad/s - Vitesse de retour au centre de la barre
    maxRotation: Math.PI / 3, // rad - Rotation maximale de la barre (¬∞)
  },
  kiteInertia: {
    gyrationDivisor: Math.sqrt(2), // Sans unit√© - Diviseur pour rayon de giration (wingspan / ‚àö2)
    inertiaFactor: 1, // Sans unit√© - Facteur ajustement inertie (compromis stabilit√©/r√©activit√©)
  },
};

=== simulation/controllers/ControlBarManager.ts ===

/**
 * ControlBarManager.ts - Gestionnaire de la barre de contr√¥le pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re la position et l'orientation de la barre de contr√¥le du cerf-volant
 *   - Calcule les positions des poign√©es et la rotation de la barre
 *   - Sert d'interface entre le pilote et le syst√®me de lignes
 *
 * D√©pendances principales :
 *   - Kite.ts : Mod√®le 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres et limites physiques
 *   - Types : HandlePositions pour typer les poign√©es
 *   - Three.js : Pour la g√©om√©trie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par KiteController et PhysicsEngine pour manipuler la barre et les lignes
 *   - Interagit avec LineSystem pour la gestion des tensions
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, appel√© √† chaque frame pour mettre √† jour la position des poign√©es
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/simulation/physics/LineSystem.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { HandlePositions } from "../types";

/**
 * Gestionnaire de la barre de contr√¥le
 *
 * G√®re la position et l'orientation de la barre de contr√¥le du cerf-volant
 */
export class ControlBarManager {
  private position: THREE.Vector3;
  private rotation: number = 0;

  constructor(position: THREE.Vector3 = CONFIG.controlBar.position) {
    this.position = position.clone();
  }

  /**
   * Calcule le quaternion de rotation de la barre
   */
  private computeRotationQuaternion(
    toKiteVector: THREE.Vector3
  ): THREE.Quaternion {
    const barDirection = new THREE.Vector3(1, 0, 0);
    const rotationAxis = new THREE.Vector3()
      .crossVectors(barDirection, toKiteVector)
      .normalize();

    if (rotationAxis.length() < PhysicsConstants.CONTROL_DEADZONE) {
      rotationAxis.set(0, 1, 0);
    }

    return new THREE.Quaternion().setFromAxisAngle(rotationAxis, this.rotation);
  }

  /**
   * Obtient les positions des poign√©es (m√©thode unique centralis√©e)
   */
  getHandlePositions(kitePosition: THREE.Vector3): HandlePositions {
    const toKiteVector = kitePosition.clone().sub(this.position).normalize();
    const rotationQuaternion = this.computeRotationQuaternion(toKiteVector);

    const halfWidth = CONFIG.controlBar.width / 2;
    const handleLeftLocal = new THREE.Vector3(-halfWidth, 0, 0);
    const handleRightLocal = new THREE.Vector3(halfWidth, 0, 0);

    handleLeftLocal.applyQuaternion(rotationQuaternion);
    handleRightLocal.applyQuaternion(rotationQuaternion);

    return {
      left: handleLeftLocal.clone().add(this.position),
      right: handleRightLocal.clone().add(this.position),
    };
  }

  /**
   * Met √† jour la rotation de la barre
   */
  setRotation(rotation: number): void {
    this.rotation = rotation;
  }

  getRotation(): number {
    return this.rotation;
  }

  getPosition(): THREE.Vector3 {
    return this.position.clone();
  }

  /**
   * Met √† jour l'objet 3D visuel de la barre
   */
  updateVisual(bar: THREE.Group, kite: Kite): void {
    if (!bar) return;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const centerKite = kiteLeftWorld
        .clone()
        .add(kiteRightWorld)
        .multiplyScalar(0.5);
      const toKiteVector = centerKite.clone().sub(this.position).normalize();

      bar.quaternion.copy(this.computeRotationQuaternion(toKiteVector));
    }
  }
}

=== simulation/controllers/InputHandler.ts ===

/**
 * InputHandler.ts - Gestionnaire des entr√©es utilisateur pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re les contr√¥les clavier pour piloter le cerf-volant
 *   - Traduit les actions utilisateur en rotation de la barre de contr√¥le
 *   - Sert d'interface entre l'utilisateur et le syst√®me de contr√¥le
 *
 * D√©pendances principales :
 *   - PhysicsConstants.ts : Param√®tres et limites pour la gestion des entr√©es
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par ControlBarManager et PhysicsEngine pour appliquer les commandes utilisateur
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, √©coute les √©v√©nements clavier pour piloter le kite
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/simulation/controllers/ControlBarManager.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 */
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire des entr√©es utilisateur
 *
 * G√®re les contr√¥les clavier pour piloter le cerf-volant
 */
export class InputHandler {
  private currentRotation: number = 0;
  private keysPressed = new Set<string>();
  private rotationSpeed: number = CONFIG.input.rotationSpeed;
  private returnSpeed: number = CONFIG.input.returnSpeed;
  private maxRotation: number = CONFIG.input.maxRotation;

  constructor() {
    this.setupKeyboardControls();
  }

  private setupKeyboardControls(): void {
    window.addEventListener("keydown", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.add(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });

    window.addEventListener("keyup", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.delete(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });
  }

  update(deltaTime: number): void {
    const left =
      this.keysPressed.has("ArrowLeft") ||
      this.keysPressed.has("q") ||
      this.keysPressed.has("a");
    const right =
      this.keysPressed.has("ArrowRight") || this.keysPressed.has("d");
    const dir = (left ? 1 : 0) + (right ? -1 : 0);

    if (dir !== 0) {
      this.currentRotation += dir * this.rotationSpeed * deltaTime;
    } else {
      if (Math.abs(this.currentRotation) > PhysicsConstants.EPSILON) {
        const sign = Math.sign(this.currentRotation);
        this.currentRotation -= sign * this.returnSpeed * deltaTime;
        if (Math.sign(this.currentRotation) !== sign) {
          this.currentRotation = 0;
        }
      } else {
        this.currentRotation = 0;
      }
    }

    this.currentRotation = Math.max(
      -this.maxRotation,
      Math.min(this.maxRotation, this.currentRotation)
    );
  }

  getTargetBarRotation(): number {
    return this.currentRotation;
  }
}

=== simulation/controllers/KiteController.ts ===

/**
 * KiteController.ts - Contr√¥leur du cerf-volant pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re l'√©tat physique et le mouvement du cerf-volant
 *   - Applique les forces, met √† jour la position, la vitesse et l'orientation
 *   - D√©tecte les situations extr√™mes (acc√©l√©ration, vitesse, rotation)
 *
 * D√©pendances principales :
 *   - Kite.ts : Mod√®le 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres et limites physiques
 *   - ConstraintSolver.ts : Applique les contraintes de ligne
 *   - Types : KiteState, HandlePositions pour typer l'√©tat
 *   - Three.js : Pour la g√©om√©trie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par PhysicsEngine pour manipuler le kite
 *   - Interagit avec ControlBarManager pour la gestion des lignes
 *
 * Utilisation typique :
 *   - Instanci√© par PhysicsEngine, appel√© √† chaque frame pour mettre √† jour l'√©tat du kite
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/controllers/ControlBarManager.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, HandlePositions } from "../types";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { ConstraintSolver } from "../physics/ConstraintSolver";

/**
 * Contr√¥leur du cerf-volant
 *
 * G√®re l'√©tat physique et le mouvement du cerf-volant
 */
export class KiteController {
  private kite: Kite;
  private state: KiteState;
  private previousPosition: THREE.Vector3;
  // √âtats pour les warnings
  private hasExcessiveAccel: boolean = false;
  private hasExcessiveVelocity: boolean = false;
  private hasExcessiveAngular: boolean = false;
  private lastAccelMagnitude: number = 0;
  private lastVelocityMagnitude: number = 0;

  // Lissage temporel des forces
  private smoothedForce: THREE.Vector3;
  private smoothedTorque: THREE.Vector3;
  private forceSmoothingRate: number = KiteController.DEFAULT_FORCE_SMOOTHING_RATE; // üîß PHASE 1: Quasi-d√©sactiv√© pour restaurer r√©activit√©

  // Constantes pour √©viter les facteurs magiques
  private static readonly DEFAULT_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MIN_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MAX_FORCE_SMOOTHING_RATE = 20.0;

  constructor(kite: Kite) {
    this.kite = kite;
    this.state = {
      position: kite.position.clone(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: kite.quaternion.clone(),
    };
    this.previousPosition = kite.position.clone();
    this.kite.userData.lineLength = CONFIG.lines.defaultLength;

    // Initialiser les forces liss√©es avec gravit√© initiale (√©vite chute au d√©marrage)
    const initialGravity = new THREE.Vector3(0, -CONFIG.kite.mass * CONFIG.physics.gravity, 0);
    this.smoothedForce = initialGravity.clone();
    this.smoothedTorque = new THREE.Vector3();
  }

  /**
   * Met √† jour la position et l'orientation du cerf-volant
   */
  update(
    forces: THREE.Vector3,
    torque: THREE.Vector3,
    handles: HandlePositions,
    deltaTime: number
  ): void {
    // Valider les forces brutes
    const validForces = this.validateForces(forces);
    const validTorque = this.validateTorque(torque);

    // Lissage exponentiel des forces (ind√©pendant du framerate)
    // smoothingFactor = 1 - e^(-rate √ó dt)
    const smoothingFactor = 1 - Math.exp(-this.forceSmoothingRate * deltaTime);
    this.smoothedForce.lerp(validForces, smoothingFactor);
    this.smoothedTorque.lerp(validTorque, smoothingFactor);

    // Utiliser les forces liss√©es pour la physique
    const newPosition = this.integratePhysics(this.smoothedForce, deltaTime);

    // R√©solution it√©rative des contraintes PBD pour convergence stable
    // Les contraintes lignes ‚Üî brides s'influencent mutuellement
    // Une seule passe n'est pas suffisante - il faut it√©rer jusqu'√† convergence

    for (let iter = 0; iter < PhysicsConstants.CONSTRAINT_ITERATIONS; iter++) {
      // Appliquer les contraintes de lignes (Position-Based Dynamics)
      // Le solveur peut modifier newPosition ainsi que state.velocity / state.angularVelocity
      try {
        ConstraintSolver.enforceLineConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          handles
        );
      } catch (err) {
        // Ne pas laisser une exception du solveur casser la boucle principale
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceLineConstraints (iter ${iter}):`, err);
      }

      // Appliquer les contraintes des brides (Position-Based Dynamics)
      // Les brides sont des contraintes INTERNES qui lient les points du kite entre eux
      try {
        ConstraintSolver.enforceBridleConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          this.kite.getBridleLengths()
        );
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceBridleConstraints (iter ${iter}):`, err);
      }
    }

    // G√©rer la collision avec le sol - corrige newPosition et vitesse si n√©cessaire
    try {
      ConstraintSolver.handleGroundCollision(this.kite, newPosition, this.state.velocity);
    } catch (err) {
      console.error("‚ö†Ô∏è Erreur dans ConstraintSolver.handleGroundCollision:", err);
    }

    // Valider la position finale
    this.validatePosition(newPosition);

    // Appliquer la position et l'orientation
    this.kite.position.copy(newPosition);
    this.updateOrientation(this.smoothedTorque, deltaTime); // Utiliser le torque liss√©
    this.previousPosition.copy(newPosition);
  }
  /**
   * Valide les forces appliqu√©es au cerf-volant
   */
  private validateForces(forces: THREE.Vector3): THREE.Vector3 {
    if (
      !forces ||
      forces.length() > PhysicsConstants.MAX_FORCE ||
      isNaN(forces.length())
    ) {
      console.error(
        `‚ö†Ô∏è Forces invalides: ${forces ? forces.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return forces;
  }

  /**
   * Valide le couple
   */
  private validateTorque(torque: THREE.Vector3): THREE.Vector3 {
    if (!torque || isNaN(torque.length())) {
      console.error(
        `‚ö†Ô∏è Couple invalide: ${torque ? torque.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return torque;
  }

  /**
   * Int√®gre les forces pour calculer la nouvelle position (m√©thode d'Euler)
   * Impl√©mente la 2√®me loi de Newton : F = ma ‚Üí a = F/m
   */
  private integratePhysics(
    forces: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Newton : acc√©l√©ration = Force / masse
    // IMPORTANT: clone() pour ne pas modifier le vecteur forces en place!
    const acceleration = forces.clone().divideScalar(CONFIG.kite.mass);
    this.lastAccelMagnitude = acceleration.length();

    // S√©curit√© : limiter pour √©viter l'explosion num√©rique
    this.hasExcessiveAccel = acceleration.length() > PhysicsConstants.MAX_ACCELERATION;
    if (this.hasExcessiveAccel) {
      acceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ACCELERATION);
    }

    // Int√©gration d'Euler : v(t+dt) = v(t) + a¬∑dt
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier acceleration!
    this.state.velocity.add(acceleration.clone().multiplyScalar(deltaTime));

    // Amortissement exponentiel : v(t) = v‚ÇÄ √ó e^(-c√ódt)
    // Formule physiquement correcte, ind√©pendante du framerate
    const linearDampingFactor = Math.exp(-CONFIG.physics.linearDampingCoeff * deltaTime);
    this.state.velocity.multiplyScalar(linearDampingFactor);
    this.lastVelocityMagnitude = this.state.velocity.length();

    // Garde-fou vitesse max (r√©alisme physique)
    this.hasExcessiveVelocity = this.state.velocity.length() > PhysicsConstants.MAX_VELOCITY;
    if (this.hasExcessiveVelocity) {
      this.state.velocity
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_VELOCITY);
    }

    // Position : x(t+dt) = x(t) + v¬∑dt
    return this.kite.position
      .clone()
      .add(this.state.velocity.clone().multiplyScalar(deltaTime));
  }

  /**
   * Valide la position finale
   */
  private validatePosition(newPosition: THREE.Vector3): void {
    if (isNaN(newPosition.x) || isNaN(newPosition.y) || isNaN(newPosition.z)) {
      console.error(`‚ö†Ô∏è Position NaN d√©tect√©e! Reset √† la position pr√©c√©dente`);
      newPosition.copy(this.previousPosition);
      this.state.velocity.set(0, 0, 0);
    }
  }

  /**
   * Met √† jour l'orientation du cerf-volant - Dynamique du corps rigide
   */
  private updateOrientation(torque: THREE.Vector3, deltaTime: number): void {
    // Couple d'amortissement (r√©sistance a√©rodynamique √† la rotation)
    // œÑ_drag = -I √ó k_drag √ó œâ  (unit√©s correctes: kg¬∑m¬≤ √ó 1/s √ó rad/s = N¬∑m)
    const dampTorque = this.state.angularVelocity
      .clone()
      .multiplyScalar(-CONFIG.kite.inertia * CONFIG.physics.angularDragFactor);
    const effectiveTorque = torque.clone().add(dampTorque);

    // Dynamique rotationnelle : Œ± = T / I
    // IMPORTANT: clone() pour ne pas modifier effectiveTorque en place!
    const angularAcceleration = effectiveTorque.clone().divideScalar(
      CONFIG.kite.inertia
    );

    // Limiter l'acc√©l√©ration angulaire
    if (
      angularAcceleration.length() > PhysicsConstants.MAX_ANGULAR_ACCELERATION
    ) {
      angularAcceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ANGULAR_ACCELERATION);
    }

    // Mise √† jour de la vitesse angulaire
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier angularAcceleration!
    this.state.angularVelocity.add(
      angularAcceleration.clone().multiplyScalar(deltaTime)
    );

    // Note: Amortissement d√©j√† appliqu√© via dampTorque ci-dessus
    // Pas de damping exponentiel suppl√©mentaire pour √©viter sur-amortissement

    // üîß D√âSACTIVATION TEMPORAIRE : Limiter la vitesse angulaire
    // Cause des positions impossibles car emp√™che la convergence naturelle
    // this.hasExcessiveAngular = this.state.angularVelocity.length() > PhysicsConstants.MAX_ANGULAR_VELOCITY;
    // if (this.hasExcessiveAngular) {
    //   this.state.angularVelocity
    //     .normalize()
    //     .multiplyScalar(PhysicsConstants.MAX_ANGULAR_VELOCITY);
    // }
    this.hasExcessiveAngular = false; // Toujours faux pour l'instant

    // Appliquer la rotation
    if (this.state.angularVelocity.length() > PhysicsConstants.EPSILON) {
      const deltaRotation = new THREE.Quaternion();
      const axis = this.state.angularVelocity.clone().normalize();
      const angle = this.state.angularVelocity.length() * deltaTime;
      deltaRotation.setFromAxisAngle(axis, angle);

      this.kite.quaternion.multiply(deltaRotation);
      this.kite.quaternion.normalize();
    }
  }

  getState(): KiteState {
    return { ...this.state };
  }

  getKite(): Kite {
    return this.kite;
  }

  setLineLength(length: number): void {
    this.kite.userData.lineLength = length;
  }

  /**
   * Retourne les √©tats de warning pour l'affichage
   */
  getWarnings(): {
    accel: boolean;
    velocity: boolean;
    angular: boolean;
    accelValue: number;
    velocityValue: number;
  } {
    return {
      accel: this.hasExcessiveAccel,
      velocity: this.hasExcessiveVelocity,
      angular: this.hasExcessiveAngular,
      accelValue: this.lastAccelMagnitude,
      velocityValue: this.lastVelocityMagnitude,
    };
  }

  /**
   * D√©finit le taux de lissage des forces physiques
   * @param rate - Taux en 1/s (valeurs typiques: 1-10, plus √©lev√© = lissage plus rapide)
   */
  setForceSmoothing(rate: number): void {
    this.forceSmoothingRate = Math.max(
      KiteController.MIN_FORCE_SMOOTHING_RATE,
      Math.min(KiteController.MAX_FORCE_SMOOTHING_RATE, rate)
    );
  }

  /**
   * Retourne le taux de lissage actuel des forces (en 1/s)
   */
  getForceSmoothing(): number {
    return this.forceSmoothingRate;
  }
}

=== simulation/index.ts ===

/**
 * Point d'entr√©e principal de la simulation modulaire
 */

// Export de la classe principale
export { SimulationApp as Simulation } from './SimulationApp';

// Re-export de tous les modules pour faciliter l'importation
export * from './config/PhysicsConstants';
export * from './config/KiteGeometry';
export * from './config/SimulationConfig';

export * from './types';

export * from './physics/WindSimulator';
export * from './physics/AerodynamicsCalculator';
export * from './physics/LineSystem';
export * from './physics/PhysicsEngine';

export * from './controllers/ControlBarManager';
export * from './controllers/KiteController';
export * from './controllers/InputHandler';

export * from './rendering/RenderManager';
export * from './rendering/DebugRenderer';

export * from './ui/UIManager';

export * from './physics/ConstraintSolver';

=== simulation/physics/AerodynamicsCalculator.ts ===

/**
 * AerodynamicsCalculator.ts - Calculateur de forces a√©rodynamiques distribu√©es
 *
 * Calcule les forces a√©rodynamiques (portance, tra√Æn√©e) et gravitationnelles 
 * distribu√©es sur chaque surface du kite selon les principes de la m√©canique des fluides.
 *
 * Mod√®le physique :
 *   - Portance : CL = sin(Œ±)√ócos(Œ±) (plaqu      gravity: gravityForce,  // Gravit√© distribu√©e par surface plane)
 *   - Tra√Æn√©e : CD = sin¬≤(Œ±) (plaque plane)
 *   - Gravit√© distribu√©e par masse surfacique
 *   - Couples √©mergents de la distribution spatiale des forces
 *
 * @see PhysicsEngine.ts - Utilise les forces calcul√©es
 * @see KiteGeometry.ts - D√©finit les surfaces et masses
 */
import * as THREE from "three";

import { KiteGeometry } from "../config/KiteGeometry";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { SurfaceForce } from "../types/PhysicsTypes";

/**
 * Calculateur de forces a√©rodynamiques
 *
 * Calcule comment le vent pousse sur le cerf-volant selon sa forme et orientation
 */
export class AerodynamicsCalculator {
  // Constantes de calculs a√©rodynamiques
  private static readonly HALF_AIR_DENSITY = 0.5 * CONFIG.physics.airDensity;
  private static readonly MIN_WIND_SPEED = 0.01; // m/s - seuil minimal pour calculs a√©ro

  /**
   * Calcule le couple (moment) d'une force appliqu√©e √† un point
   * M√©thode utilitaire pour √©viter la r√©p√©tition de new THREE.Vector3().crossVectors()
   */
  private static calculateTorque(lever: THREE.Vector3, force: THREE.Vector3): THREE.Vector3 {
    return new THREE.Vector3().crossVectors(lever, force);
  }

  /**
   * Calcule la normale d'un triangle dans l'espace monde
   * M√©thode utilitaire pour √©viter la duplication de code
   *
   * @param surface - Surface triangulaire avec vertices
   * @param kiteOrientation - Quaternion d'orientation du kite (optionnel)
   * @returns Vecteur normal unitaire dans l'espace monde
   */
  private static calculateSurfaceNormal(
    surface: { vertices: THREE.Vector3[] },
    kiteOrientation?: THREE.Quaternion
  ): THREE.Vector3 {
    // Calcul des ar√™tes du triangle
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    
    // Normale locale (produit vectoriel normalis√©)
    const normal = new THREE.Vector3()
      .crossVectors(edge1, edge2)
      .normalize();
    
    // Transformation dans l'espace monde si orientation fournie
    return kiteOrientation ? normal.applyQuaternion(kiteOrientation) : normal;
  }

  /**
   * Calcule comment le vent pousse sur le cerf-volant
   *
   * COMMENT √áA MARCHE :
   * 1. On regarde chaque triangle du cerf-volant
   * 2. On calcule sous quel angle le vent frappe ce triangle
   * 3. Plus le vent frappe de face, plus la force est grande
   * 4. On additionne toutes les forces pour avoir la force totale
   *
   * POURQUOI C'EST IMPORTANT :
   * Si un c√¥t√© du kite re√ßoit plus de vent, il sera pouss√© plus fort
   * Cette diff√©rence fait tourner le kite naturellement !
   */
  static calculateForces(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion,
    kitePosition?: THREE.Vector3,
    kiteVelocity?: THREE.Vector3,
    angularVelocity?: THREE.Vector3
  ): {
    lift: THREE.Vector3;
    drag: THREE.Vector3;
    gravity: THREE.Vector3;  // Gravit√© distribu√©e par surface
    torque: THREE.Vector3;
    leftForce?: THREE.Vector3;
    rightForce?: THREE.Vector3;
    surfaceForces: SurfaceForce[];
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < 0.1) {
      return {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),  // Pas de gravit√© si vent nul
        torque: new THREE.Vector3(),
        surfaceForces: [],
      };
    }

    const windDir = apparentWind.clone().normalize();
    const dynamicPressure = AerodynamicsCalculator.HALF_AIR_DENSITY * windSpeed * windSpeed;

    // Forces s√©par√©es pour gauche et droite
    const leftForce = new THREE.Vector3();
    const rightForce = new THREE.Vector3();
    const totalForce = new THREE.Vector3();
    const totalTorque = new THREE.Vector3();
    
    // Accumulation des forces par type (formules plaque plane : CL = sin(Œ±)√ócos(Œ±), CD = sin¬≤(Œ±))
    const totalLift = new THREE.Vector3();      // Portance totale
    const totalDrag = new THREE.Vector3();      // Tra√Æn√©e totale
    const gravityForce = new THREE.Vector3();   // Gravit√© distribu√©e par surface/frame
    
    // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent
    const aeroTorque = new THREE.Vector3();
    const gravityTorque = new THREE.Vector3();
    
    // Collection des forces par surface pour le debug
    const surfaceForces: SurfaceForce[] = [];

    // On examine chaque triangle du cerf-volant un par un
    // C'est comme v√©rifier comment le vent frappe chaque panneau d'un parasol
    KiteGeometry.SUBDIVIDED_SURFACES.forEach((surface, surfaceIndex) => {
      // üî¥ MAILLAGE FIN : Distribuer la masse proportionnellement √† l'aire
      // Trouver quelle surface originale contient ce sous-triangle
      const trianglesPerSurface = KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(
        KiteGeometry.getMeshSubdivisionLevel()
      );
      const originalSurfaceIndex = Math.floor(surfaceIndex / trianglesPerSurface);
      const originalSurfaceMass = KiteGeometry.SURFACE_MASSES[originalSurfaceIndex];

      // Distribuer la masse proportionnellement √† l'aire relative
      const totalAreaForOriginal = KiteGeometry.SURFACES[originalSurfaceIndex].area;
      const massRatio = surface.area / totalAreaForOriginal;
      const surfaceMass = originalSurfaceMass * massRatio;
      // üî¥ D√âSACTIVATION TEMPORAIRE du vent apparent local pour debug
      // Le calcul local peut r√©duire trop fortement le vent per√ßu en rotation
      
      // Utiliser le vent apparent GLOBAL pour toutes les surfaces
      const localApparentWind = apparentWind.clone();
      const localWindSpeed = localApparentWind.length();
      
      if (localWindSpeed < 0.1) {
        return; // Pas de vent sur cette surface
      }
      
      const localWindDir = localApparentWind.clone().normalize();
      const localDynamicPressure = 0.5 * CONFIG.physics.airDensity * localWindSpeed * localWindSpeed;
      
      // Pour comprendre comment le vent frappe ce triangle,
      // on doit savoir dans quelle direction il "regarde"
      // (comme l'orientation d'un panneau solaire)
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      // Calcul de l'angle d'incidence pour une plaque plane (cerf-volant)
      // Œ± = angle entre la direction du vent et la surface
      const windDotNormal = localWindDir.dot(normaleMonde);
      const cosTheta = Math.abs(windDotNormal); // cos(Œ∏) o√π Œ∏ = angle vent-normale

      // Pour une plaque : sin(Œ±) = cos(Œ∏) et cos(Œ±) = sin(Œ∏)
      const sinAlpha = cosTheta;
      const cosAlpha = Math.sqrt(1 - sinAlpha * sinAlpha); // sin¬≤+cos¬≤=1

      // Si le vent glisse sur le c√¥t√© (angle = 0), pas de force
      if (sinAlpha <= PhysicsConstants.EPSILON) {
        return;
      }

      // üî¥ BUG FIX #4 : COEFFICIENTS PLAQUE PLANE CORRECTS (Hoerner)
      // Formules physiques pour plaque plane inclin√©e √† angle Œ± :
      //   C_L = sin(Œ±) √ó cos(Œ±)  ‚Üí Coefficient de portance
      //   C_D = sin¬≤(Œ±)           ‚Üí Coefficient de tra√Æn√©e
      // Ces coefficients sont valid√©s exp√©rimentalement !
      
      const CL = sinAlpha * cosAlpha;  // Coefficient lift
      const CD = sinAlpha * sinAlpha;   // Coefficient drag (= CN)
      
      // üîç DEBUG premi√®re surface (angle et coefficients) - DISABLED for performance
      // if (surfaceIndex === 0) {
      //   const alphaDeg = Math.asin(sinAlpha) * 180 / Math.PI;

      // }
      
      // Direction : normale √† la surface, orient√©e face au vent
      const windFacingNormal = windDotNormal >= 0 ? normaleMonde.clone() : normaleMonde.clone().negate();
      
      // DIRECTION LIFT : Perpendiculaire au vent, dans le plan (vent, normale)
      // M√©thode : liftDir = normalize(windFacingNormal - (windFacingNormal¬∑windDir)√ówindDir)
      const liftDir = windFacingNormal.clone()
        .sub(localWindDir.clone().multiplyScalar(windFacingNormal.dot(localWindDir)))
        .normalize();
      
      // V√©rifier validit√© (√©viter division par z√©ro si vent // normale)
      if (liftDir.lengthSq() < PhysicsConstants.EPSILON) {
        liftDir.copy(windFacingNormal);  // Fallback : utiliser normale
      }
      
      // DIRECTION DRAG : Parall√®le au vent
      const dragDir = localWindDir.clone();
      
      // FORCES A√âRODYNAMIQUES (AVANT scaling) avec pression dynamique LOCALE
      const liftMagnitude = localDynamicPressure * surface.area * CL;
      const dragMagnitude = localDynamicPressure * surface.area * CD;
      
      const liftForce = liftDir.clone().multiplyScalar(liftMagnitude);
      const dragForce = dragDir.clone().multiplyScalar(dragMagnitude);
      
      // Force a√©rodynamique totale = lift + drag (vectoriel)
      const aeroForce = liftForce.clone().add(dragForce);
      
      // GRAVIT√â DISTRIBU√âE (√©mergente, pas script√©e !)
      // Chaque surface porte une fraction de la masse totale
      // La gravit√© est appliqu√©e au centre g√©om√©trique de chaque surface
      // ‚Üí Couple gravitationnel √©merge naturellement de r √ó F_gravity
      const gravity = new THREE.Vector3(0, -surfaceMass * CONFIG.physics.gravity, 0);
      
      // Accumulation des forces par type
      totalLift.add(liftForce);
      totalDrag.add(dragForce);
      gravityForce.add(gravity);
      
      // Force totale sur cette surface = a√©ro + gravit√©
      const totalSurfaceForce = aeroForce.clone().add(gravity);
      
      // Pour le debug : conserver lift/drag locaux
      const lift = liftForce.clone();
      const drag = dragForce.clone();

      // 6. Centre de pression = centre g√©om√©trique du triangle
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // üîç DEBUG TOUTES les surfaces : g√©om√©trie + forces - DISABLED for performance


      // On note si cette force est sur le c√¥t√© gauche ou droit
      // C'est important car si un c√¥t√© a plus de force,
      // le kite va tourner (comme un bateau avec une seule rame)
      const isLeft = centre.x < 0; // N√©gatif = gauche, Positif = droite

      if (isLeft) {
        leftForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      } else {
        rightForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      }

      totalForce.add(totalSurfaceForce);

      // Friction (n√©gligeable pour l'air, nulle)
      const friction = new THREE.Vector3();

      // R√©sultante = force a√©ro totale (lift + drag vectoriel)
      const resultant = aeroForce.clone();

      surfaceForces.push({
        surfaceIndex,
        lift,
        drag,
        friction,
        resultant,
        center: centre.clone(), // Coordonn√©es locales du kite
        normal: normaleMonde.clone(),
        area: surface.area,
      });

      // Le couple, c'est ce qui fait tourner le kite
      // Imaginez une porte : si vous poussez pr√®s des gonds, elle tourne peu
      // Si vous poussez loin des gonds, elle tourne beaucoup
      // Ici, plus la force est loin du centre, plus elle fait tourner
      //
      // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent :
      // - Couple a√©ro : sera scal√© proportionnellement aux forces (liftScale/dragScale)
      // - Couple gravit√© : physique pure, pas de scaling
      // Note: centre est d√©j√† en coordonn√©es locales, on applique seulement la rotation
      const centreWorldForTorque = centre.clone().applyQuaternion(kiteOrientation);
      
      // Couples calcul√©s via m√©thode utilitaire
      aeroTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, aeroForce));
      gravityTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, gravity));
      totalTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, totalSurfaceForce));


    });

    // PHYSIQUE √âMERGENTE : Le couple vient de la diff√©rence G/D
    // Si leftForce > rightForce ‚Üí rotation vers la droite
    // Si rightForce > leftForce ‚Üí rotation vers la gauche
    // AUCUN facteur artificiel n√©cessaire!

    // üî¥ BUG FIX #4 : PAS DE D√âCOMPOSITION GLOBALE !
    // Les lift/drag ont d√©j√† √©t√© calcul√©s CORRECTEMENT par surface avec CL/CD
    // Il suffit d'appliquer les scaling factors directement
    const lift = totalLift.multiplyScalar(CONFIG.aero.liftScale);
    const drag = totalDrag.multiplyScalar(CONFIG.aero.dragScale);

    // üîç DEBUG : Afficher forces calcul√©es - DISABLED for performance
    // Uncomment for debugging:


    // üîç DEBUG CRITIQUE : Asym√©trie gauche/droite - DISABLED for performance
    // const leftMag = leftForce.length();
    // const rightMag = rightForce.length();
    // const asymmetry = leftMag - rightMag;
    // const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag * 100) : 0;
    // const leftArr = leftForce.toArray();
    // const rightArr = rightForce.toArray();
    // const diffArr = leftForce.clone().sub(rightForce).toArray();


    // CORRECTION CRITIQUE : Scaling coh√©rent du couple a√©rodynamique
    // Le couple DOIT √™tre scal√© proportionnellement aux forces a√©ro pour coh√©rence physique
    // Si les forces sont doubl√©es (scale=2), le couple doit l'√™tre aussi
    // MAIS la gravit√© reste inchang√©e (physique pure)
    const averageAeroScale = (CONFIG.aero.liftScale + CONFIG.aero.dragScale) / 2;
    const scaledAeroTorque = aeroTorque.multiplyScalar(averageAeroScale);
    
    // Couple total = couple a√©ro scal√© + couple gravit√© (non scal√©)
    const finalTorque = scaledAeroTorque.clone().add(gravityTorque);

    return {
      lift,
      drag,
      gravity: gravityForce,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e par surface
      torque: finalTorque,  // Couple coh√©rent avec forces scal√©es
      leftForce, // Exposer les forces pour analyse
      rightForce, // Permet de voir l'asym√©trie √©mergente
      surfaceForces, // Forces individuelles par surface pour debug
    };
  }

  /**
   * Calcule des m√©triques pour le debug
   */
  static computeMetrics(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): {
    apparentSpeed: number;
    liftMag: number;
    dragMag: number;
    lOverD: number;
    aoaDeg: number;
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < PhysicsConstants.EPSILON) {
      return { apparentSpeed: 0, liftMag: 0, dragMag: 0, lOverD: 0, aoaDeg: 0 };
    }

    const { lift } = this.calculateForces(apparentWind, kiteOrientation);
    const liftMag = lift.length();
    const dragMag = 0; // Tra√Æn√©e int√©gr√©e dans les forces totales
    const lOverD = 0; // Ratio non applicable pour un cerf-volant

    // Calcul approximatif de l'angle d'attaque
    const windDir = apparentWind.clone().normalize();
    const weightedNormal = new THREE.Vector3();

    KiteGeometry.SURFACES.forEach((surface) => {
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      const facing = windDir.dot(normaleMonde);
      const cosIncidence = Math.max(0, Math.abs(facing));

      const normalDir =
        facing >= 0 ? normaleMonde : normaleMonde.clone().negate();
      weightedNormal.add(normalDir.multiplyScalar(surface.area * cosIncidence));
    });

    let aoaDeg = 0;
    if (
      weightedNormal.lengthSq() >
      PhysicsConstants.EPSILON * PhysicsConstants.EPSILON
    ) {
      const eff = weightedNormal.normalize();
      const dot = Math.max(-1, Math.min(1, eff.dot(windDir)));
      const phiDeg = (Math.acos(dot) * 180) / Math.PI;
      aoaDeg = Math.max(0, 90 - phiDeg);
    }

    return { apparentSpeed: windSpeed, liftMag, dragMag, lOverD, aoaDeg };
  }
}

=== simulation/physics/BridleSystem.ts ===

/**
 * BridleSystem.ts - Orchestrateur du syst√®me de bridage du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les 6 brides (3 gauches + 3 droites)
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les brides sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT les points d'attache (distance max)
 *   - Elles ne TIRENT PAS les points les uns vers les autres
 *   - Le ConstraintSolver.enforceBridleConstraints() g√®re la contrainte g√©om√©trique
 *
 * Architecture :
 *   - Similar √† LineSystem mais pour les brides internes au kite
 *   - R√©utilise LinePhysics pour les calculs de tension
 *   - Les 6 brides sont des instances Line ind√©pendantes
 *
 * Relation avec les autres modules :
 *   - Utilise BridleFactory pour cr√©er les brides
 *   - Utilise LinePhysics pour calculer tensions
 *   - Utilis√© par PhysicsEngine
 *   - Les contraintes sont appliqu√©es dans ConstraintSolver
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts (pattern similaire)
 *   - src/factories/BridleFactory.ts
 *   - src/simulation/physics/ConstraintSolver.ts
 */

import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { BridleFactory } from "@factories/BridleFactory";

import { BridleLengths, BridleTensions } from "../types/BridleTypes";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

/**
 * Syst√®me de gestion des brides
 *
 * G√®re les 6 brides qui relient les points anatomiques du kite
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */
export class BridleSystem {
  // Brides gauches (3)
  private leftNez: Line;
  private leftInter: Line;
  private leftCentre: Line;

  // Brides droites (3)
  private rightNez: Line;
  private rightInter: Line;
  private rightCentre: Line;

  // Services de calcul physique (r√©utilis√©s)
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(bridleLengths: BridleLengths) {
    // Valider les longueurs
    BridleFactory.validateBridleLengths(bridleLengths);

    // Cr√©er les 6 brides via factory
    const { left, right } = BridleFactory.createAllBridles(bridleLengths);

    // Assigner brides gauches
    [this.leftNez, this.leftInter, this.leftCentre] = left;

    // Assigner brides droites
    [this.rightNez, this.rightInter, this.rightCentre] = right;

    // Services de calcul physique
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  /**
   * Calcule les tensions de toutes les brides
   *
   * Note : Ces tensions sont calcul√©es pour affichage/debug uniquement.
   * Les brides sont des contraintes g√©om√©triques g√©r√©es par ConstraintSolver,
   * elles n'appliquent PAS de forces au kite.
   *
   * @param kite - Instance du cerf-volant
   * @returns Tensions des 6 brides (Newtons)
   */
  calculateBridleTensions(kite: Kite): BridleTensions {
    const deltaTime = 1 / 60; // Approximation pour calcul v√©locit√©

    // Configuration des 6 brides avec leur m√©tadonn√©es
    const bridleConfigs = [
      { line: this.leftNez, start: "NEZ", end: "CTRL_GAUCHE", key: "leftNez" },
      { line: this.leftInter, start: "INTER_GAUCHE", end: "CTRL_GAUCHE", key: "leftInter" },
      { line: this.leftCentre, start: "CENTRE", end: "CTRL_GAUCHE", key: "leftCentre" },
      { line: this.rightNez, start: "NEZ", end: "CTRL_DROIT", key: "rightNez" },
      { line: this.rightInter, start: "INTER_DROIT", end: "CTRL_DROIT", key: "rightInter" },
      { line: this.rightCentre, start: "CENTRE", end: "CTRL_DROIT", key: "rightCentre" },
    ] as const;

    // Calculer toutes les tensions en une passe
    const tensionsMap = new Map<string, number>();
    for (const config of bridleConfigs) {
      const tension = this.calculateSingleBridleTension(
        kite,
        config.line,
        config.start,
        config.end,
        deltaTime
      );
      tensionsMap.set(config.key, tension);
    }

    // Construire le r√©sultat
    return {
      leftNez: tensionsMap.get("leftNez")!,
      leftInter: tensionsMap.get("leftInter")!,
      leftCentre: tensionsMap.get("leftCentre")!,
      rightNez: tensionsMap.get("rightNez")!,
      rightInter: tensionsMap.get("rightInter")!,
      rightCentre: tensionsMap.get("rightCentre")!,
    };
  }

  /**
   * Calcule la tension d'une bride individuelle
   *
   * @param kite - Instance du cerf-volant
   * @param bridle - Instance Line de la bride
   * @param startPointName - Nom du point de d√©part (ex: "NEZ")
   * @param endPointName - Nom du point d'arriv√©e (ex: "CTRL_GAUCHE")
   * @param deltaTime - Pas de temps pour calcul v√©locit√©
   * @returns Tension en Newtons
   */
  private calculateSingleBridleTension(
    kite: Kite,
    bridle: Line,
    startPointName: string,
    endPointName: string,
    deltaTime: number
  ): number {
    // R√©cup√©rer positions locales
    const startLocal = kite.getPoint(startPointName);
    const endLocal = kite.getPoint(endPointName);

    if (!startLocal || !endLocal) {
      console.warn(`‚ö†Ô∏è Points bride introuvables: ${startPointName} ou ${endPointName}`);
      return 0;
    }

    // Convertir en coordonn√©es monde
    const startWorld = kite.localToWorld(startLocal);
    const endWorld = kite.localToWorld(endLocal);

    // Calculer v√©locit√© relative avec VelocityCalculator
    const key = `${startPointName}_${endPointName}`;
    const velocity = this.velocityCalculator.calculateRelative(
      `${key}_start`,
      `${key}_end`,
      startWorld,
      endWorld,
      deltaTime
    );

    // Calculer tension via LinePhysics
    const result = this.physics.calculateTensionForce(
      bridle,
      startWorld,
      endWorld,
      velocity
    );

    // Mettre √† jour l'√©tat de la bride
    bridle.updateState(result.currentLength, result.tension, performance.now());

    return result.tension;
  }

  /**
   * Met √† jour les longueurs des brides
   *
   * @param newLengths - Nouvelles longueurs (partial update)
   * @deprecated Utilisez PhysicsEngine.setBridleLength() √† la place
   */
  setBridleLengths(newLengths: Partial<BridleLengths>): void {
    // Note: Les instances Line sont immuables. Pour changer les longueurs,
    // il faut recr√©er BridleSystem avec les nouvelles longueurs.
    // Cette m√©thode est d√©pr√©ci√©e - utilisez PhysicsEngine.setBridleLength()
    console.warn("‚ö†Ô∏è BridleSystem.setBridleLengths() est d√©pr√©ci√©. Utilisez PhysicsEngine.setBridleLength() √† la place");
    console.log("   Nouvelles longueurs demand√©es:", newLengths);
  }

  /**
   * Obtient les longueurs actuelles des brides
   *
   * @returns BridleLengths actuelles
   */
  getBridleLengths(): BridleLengths {
    return {
      nez: this.leftNez.config.length,
      inter: this.leftInter.config.length,
      centre: this.leftCentre.config.length,
    };
  }

  /**
   * Obtient toutes les instances Line des brides
   * (utile pour ConstraintSolver)
   *
   * @returns Objet contenant les 6 brides
   */
  getAllBridles(): {
    left: { nez: Line; inter: Line; centre: Line };
    right: { nez: Line; inter: Line; centre: Line };
  } {
    return {
      left: {
        nez: this.leftNez,
        inter: this.leftInter,
        centre: this.leftCentre,
      },
      right: {
        nez: this.rightNez,
        inter: this.rightInter,
        centre: this.rightCentre,
      },
    };
  }

  /**
   * V√©rifie si une bride est tendue
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @returns true si tendue
   */
  isBridleTaut(side: 'left' | 'right', position: 'nez' | 'inter' | 'centre'): boolean {
    const bridleMap = {
      left: { nez: this.leftNez, inter: this.leftInter, centre: this.leftCentre },
      right: { nez: this.rightNez, inter: this.rightInter, centre: this.rightCentre },
    };

    return bridleMap[side][position].isTaut();
  }

  /**
   * Obtient des statistiques sur l'√©tat des brides
   * (utile pour debug/monitoring)
   */
  getStats(): {
    tautCount: number;
    avgTension: number;
    maxTension: number;
    minTension: number;
  } {
    const bridles = [
      this.leftNez,
      this.leftInter,
      this.leftCentre,
      this.rightNez,
      this.rightInter,
      this.rightCentre,
    ];

    const tautCount = bridles.filter(b => b.isTaut()).length;
    const tensions = bridles.map(b => b.getCurrentTension());
    const avgTension = tensions.reduce((sum, t) => sum + t, 0) / tensions.length;
    const maxTension = Math.max(...tensions);
    const minTension = Math.min(...tensions);

    return { tautCount, avgTension, maxTension, minTension };
  }
}


=== simulation/physics/ConstraintSolver.ts ===

/**
 * ConstraintSolver.ts - Solveur de contraintes pour les lignes du cerf-volant
 *
 * R√¥le :
 *   - Applique les contraintes de distance sur les lignes via l'algorithme Position-Based Dynamics (PBD)
 *   - Garantit la stabilit√© g√©om√©trique du kite et le respect des longueurs de ligne
 *   - Permet la rotation naturelle et le d√©crochage du kite
 *
 * D√©pendances principales :
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et points du cerf-volant
 *   - PhysicsConstants.ts : Constantes physiques pour la tol√©rance et la gestion des contraintes
 *   - SimulationConfig.ts : Param√®tres de configuration
 *   - Types : Utilise HandlePositions pour typer les poign√©es
 *
 * Relation avec les fichiers adjacents :
 *   - LineSystem.ts : Utilise ConstraintSolver pour appliquer les contraintes sur les lignes
 *   - PhysicsEngine.ts : Orchestration de l'appel au solveur
 *
 * Utilisation typique :
 *   - Appel√© par LineSystem ou PhysicsEngine pour maintenir la contrainte de distance
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { HandlePositions } from "../types";
import { BridleLengths } from "../types/BridleTypes";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Solveur de contraintes pour les lignes
 *
 * Impl√©mente l'algorithme Position-Based Dynamics (PBD) pour maintenir
 * les contraintes de distance des lignes
 */
export class ConstraintSolver {
  /**
   * Applique les contraintes des lignes - Solver PBD (Position-Based Dynamics)
   * Algorithme sophistiqu√© qui respecte la contrainte de distance tout en
   * permettant la rotation naturelle du kite
   */
  static enforceLineConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    handles: HandlePositions
  ): void {
    // PRINCIPE DE LA PYRAMIDE DE CONTRAINTE :
    // Le cerf-volant est constamment pouss√© par le vent contre la sph√®re de contrainte
    // Les lignes + brides forment une pyramide qui maintient une g√©om√©trie stable
    // Le kite "glisse" sur la surface de la sph√®re d√©finie par la longueur des lignes
    // C'est quand il sort de cette sph√®re qu'il "d√©croche"

    const lineLength =
      kite.userData.lineLength || CONFIG.lines.defaultLength;
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) return;

    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // R√©solution PBD pour chaque ligne
    const solveLine = (ctrlLocal: THREE.Vector3, handle: THREE.Vector3) => {
      // Utiliser position pr√©dite pour transformation locale‚Üímonde
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const cpWorld = kite.localToWorld(ctrlLocal);
      kite.position.copy(originalPos);
      const diff = cpWorld.clone().sub(handle);
      const dist = diff.length();

      if (dist <= lineLength - tol) return; // Ligne molle

      const n = diff.clone().normalize();
      const C = dist - lineLength;

      const r = cpWorld.clone().sub(predictedPosition);
      const alpha = new THREE.Vector3().crossVectors(r, n);
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);
      const denom = invMass + alpha.lengthSq() * invInertia;
      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections
      const dPos = n.clone().multiplyScalar(-invMass * lambda);
      predictedPosition.add(dPos);

      const dTheta = alpha.clone().multiplyScalar(-invInertia * lambda);
      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse
      kite.position.copy(predictedPosition);
      const cpWorld2 = kite.localToWorld(ctrlLocal);
      kite.position.copy(originalPos);
      const n2 = cpWorld2.clone().sub(handle).normalize();
      const r2 = cpWorld2.clone().sub(predictedPosition);
      const pointVel = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, r2));
      const radialSpeed = pointVel.dot(n2);

      if (radialSpeed > 0) {
        const rxn = new THREE.Vector3().crossVectors(r2, n2);
        const eff = invMass + rxn.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        state.velocity.add(n2.clone().multiplyScalar(J * invMass));
        const angImpulse = new THREE.Vector3().crossVectors(
          r2,
          n2.clone().multiplyScalar(J)
        );
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Plusieurs passes pour mieux satisfaire les contraintes
    for (let i = 0; i < PhysicsConstants.CONSTRAINT_ITERATIONS; i++) {
      solveLine(ctrlLeft, handles.left);
      solveLine(ctrlRight, handles.right);
    }
  }

  /**
   * Applique les contraintes des brides - Solver PBD (Position-Based Dynamics)
   * 
   * Les brides sont des contraintes INTERNES au kite qui relient :
   * - NEZ ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * - INTER_GAUCHE ‚Üí CTRL_GAUCHE
   * - INTER_DROIT ‚Üí CTRL_DROIT
   * - CENTRE ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * 
   * Contrairement aux lignes principales (kite ‚Üî pilote), les brides lient
   * des points du M√äME objet (le kite). Elles d√©finissent la forme et rigidit√©
   * interne du cerf-volant.
   */
  static enforceBridleConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    bridleLengths: BridleLengths
  ): void {
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;
    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // D√©finition des 6 brides (3 par c√¥t√©)
    const bridles = [
      // Brides gauches
      { start: "NEZ", end: "CTRL_GAUCHE", length: bridleLengths.nez },
      { start: "INTER_GAUCHE", end: "CTRL_GAUCHE", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_GAUCHE", length: bridleLengths.centre },
      // Brides droites
      { start: "NEZ", end: "CTRL_DROIT", length: bridleLengths.nez },
      { start: "INTER_DROIT", end: "CTRL_DROIT", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_DROIT", length: bridleLengths.centre },
    ];

    // R√©solution PBD pour chaque bride
    const solveBridle = (
      startName: string,
      endName: string,
      bridleLength: number
    ) => {
      const startLocal = kite.getPoint(startName);
      const endLocal = kite.getPoint(endName);

      if (!startLocal || !endLocal) {
        console.warn(`‚ö†Ô∏è Points bride introuvables: ${startName} ou ${endName}`);
        return;
      }

      // Convertir points locaux en coordonn√©es monde (avec position pr√©dite)
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const startWorld = kite.localToWorld(startLocal);
      const endWorld = kite.localToWorld(endLocal);
      kite.position.copy(originalPos);

      // Calculer distance actuelle
      const diff = endWorld.clone().sub(startWorld);
      const dist = diff.length();

      // Si bride molle, pas de contrainte
      if (dist <= bridleLength - tol) return;

      // Direction de contrainte (normalis√©e)
      const n = diff.clone().normalize();

      // Violation de contrainte C = distance - longueur_bride
      const C = dist - bridleLength;

      // Calcul des bras de levier pour rotation
      const rStart = startWorld.clone().sub(predictedPosition);
      const rEnd = endWorld.clone().sub(predictedPosition);

      // Moments angulaires
      const alphaStart = new THREE.Vector3().crossVectors(rStart, n);
      const alphaEnd = new THREE.Vector3().crossVectors(rEnd, n.clone().negate());

      // Inverse masses
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);

      // D√©nominateur pour lambda (inclut rotation)
      // Les deux points appartiennent au m√™me corps rigide, donc contribution double
      const denom =
        2 * invMass +
        alphaStart.lengthSq() * invInertia +
        alphaEnd.lengthSq() * invInertia;

      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections de position
      // Point start : pouss√© dans direction -n
      const dPosStart = n.clone().multiplyScalar(-invMass * lambda);
      // Point end : pouss√© dans direction +n
      const dPosEnd = n.clone().multiplyScalar(invMass * lambda);

      // Correction nette de position (moyenne)
      const dPos = dPosStart.clone().add(dPosEnd).multiplyScalar(0.5);
      predictedPosition.add(dPos);

      // Correction de rotation (moyenne des deux contributions)
      const dThetaStart = alphaStart.clone().multiplyScalar(-invInertia * lambda);
      const dThetaEnd = alphaEnd.clone().multiplyScalar(-invInertia * lambda);
      const dTheta = dThetaStart.clone().add(dThetaEnd).multiplyScalar(0.5);

      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse (dampening)
      kite.position.copy(predictedPosition);
      const startWorld2 = kite.localToWorld(startLocal);
      const endWorld2 = kite.localToWorld(endLocal);
      kite.position.copy(originalPos);

      const n2 = endWorld2.clone().sub(startWorld2).normalize();
      const rStart2 = startWorld2.clone().sub(predictedPosition);
      const rEnd2 = endWorld2.clone().sub(predictedPosition);

      // Vitesses des points
      const velStart = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rStart2));
      const velEnd = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rEnd2));

      // Vitesse relative le long de la bride
      const relVel = velEnd.clone().sub(velStart);
      const radialSpeed = relVel.dot(n2);

      // Si les points s'√©loignent, appliquer correction de vitesse
      if (radialSpeed > 0) {
        const rxnStart = new THREE.Vector3().crossVectors(rStart2, n2);
        const rxnEnd = new THREE.Vector3().crossVectors(rEnd2, n2.clone().negate());
        const eff =
          2 * invMass + rxnStart.lengthSq() * invInertia + rxnEnd.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        // Correction vitesse lin√©aire
        state.velocity.add(n2.clone().multiplyScalar(J * invMass));

        // Correction vitesse angulaire (moyenne des deux contributions)
        const angImpulseStart = new THREE.Vector3().crossVectors(
          rStart2,
          n2.clone().multiplyScalar(J)
        );
        const angImpulseEnd = new THREE.Vector3().crossVectors(
          rEnd2,
          n2.clone().multiplyScalar(-J)
        );
        const angImpulse = angImpulseStart.clone().add(angImpulseEnd).multiplyScalar(0.5);
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // R√©soudre toutes les brides (1 passe suffit g√©n√©ralement)
    // Les brides sont courtes et rigides, convergence rapide
    bridles.forEach(({ start, end, length }) => {
      solveBridle(start, end, length);
    });
  }

  /**
   * G√®re la collision avec le sol
   */
  static handleGroundCollision(
    kite: Kite,
    newPosition: THREE.Vector3,
    velocity: THREE.Vector3
  ): void {
    const groundY = CONFIG.kite.minHeight;
    const pointsMap = kite.getPointsMap?.() as
      | Map<string, [number, number, number]>
      | undefined;

    if (pointsMap && pointsMap.size > 0) {
      let minY = Infinity;
      const q = kite.quaternion;

      pointsMap.forEach(([px, py, pz]) => {
        const world = new THREE.Vector3(px, py, pz)
          .applyQuaternion(q)
          .add(newPosition);
        if (world.y < minY) minY = world.y;
      });

      if (minY < groundY) {
        const lift = groundY - minY;
        newPosition.y += lift;

        if (velocity.y < 0) velocity.y = 0;
        velocity.x *= PhysicsConstants.GROUND_FRICTION;
        velocity.z *= PhysicsConstants.GROUND_FRICTION;
      }
      return;
    }

    // Fallback simple
    if (newPosition.y < groundY) {
      newPosition.y = groundY;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x *= PhysicsConstants.GROUND_FRICTION;
      velocity.z *= PhysicsConstants.GROUND_FRICTION;
    }
  }
}

=== simulation/physics/LinePhysics.ts ===

/**
 * LinePhysics.ts - Service de calculs physiques pour les lignes de cerf-volant
 *
 * R√¥le :
 *   - Calculer les forces de tension dans une ligne (mod√®le Dyneema r√©aliste)
 *   - Appliquer pr√©-tension, √©lasticit√© lin√©aire et damping
 *   - Calculer l'affaissement cat√©naire pour le rendu
 *
 * Responsabilit√© :
 *   - Physique pure : F = F‚ÇÄ + k√óŒîx - c√óv_radial
 *   - Pas de gestion d'√©tat (stateless)
 *   - Pas de d√©pendance Three.js (calculs vectoriels purs)
 *
 * Mod√®le Physique :
 *   - Lignes haute performance (Dyneema/Spectra)
 *   - √âlasticit√© ~2-3%, rigidit√© EA/L ‚âà 2200 N/m pour 15m
 *   - Toujours pr√©-tendues (50-100N minimum)
 *   - Damping interne (dissipation d'√©nergie)
 *
 * Relation avec les autres modules :
 *   - Op√®re sur des objets Line
 *   - Appel√© par LineSystem pour calculer forces
 *   - Pas de d√©pendance sur la sc√®ne 3D
 *
 * Philosophie :
 *   - Pure function : Entr√©es ‚Üí Sorties, pas d'effet de bord
 *   - Testable unitairement (pas de mock Three.js requis)
 *   - Single Responsibility : Calculs physiques uniquement
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts (entit√© m√©tier)
 *   - docs/LINE_PHYSICS_AUDIT_2025-10-01.md (r√©f√©rences physiques)
 */

import { Vector3 } from 'three';
import { Line } from '@objects/mechanical/Line';
import { PhysicsConstants } from '../config/PhysicsConstants';

/**
 * R√©sultat d'un calcul de force de tension
 */
export interface TensionResult {
  /** Force vectorielle √† appliquer (N) */
  force: Vector3;

  /** Magnitude de la tension (N) */
  tension: number;

  /** Extension actuelle (m) */
  extension: number;

  /** Longueur actuelle (m) */
  currentLength: number;

  /** Ligne tendue ou molle */
  isTaut: boolean;
}

/**
 * Service de calculs physiques pour lignes de cerf-volant
 *
 * @example
 * ```typescript
 * const physics = new LinePhysics();
 * const result = physics.calculateTensionForce(
 *   line,
 *   new Vector3(0, 10, 0),  // Position kite
 *   new Vector3(0, 0, 0),   // Position poign√©e
 *   new Vector3(0, -1, 0)   // Vitesse relative
 * );
 * console.log(`Tension: ${result.tension}N`);
 * ```
 */
export class LinePhysics {
  /** Constante gravitationnelle (m/s¬≤) */
  private static readonly GRAVITY = 9.81;

  /** Epsilon fin pour calculs de pr√©cision (r√©utilise PhysicsConstants) */
  private static readonly EPSILON = PhysicsConstants.EPSILON_FINE;

  /**
   * Calcule la force de tension dans une ligne
   *
   * Mod√®le : F = F‚ÇÄ + k√óŒîx - c√óv_radial
   * - F‚ÇÄ : Pr√©-tension minimale (toujours pr√©sente)
   * - k√óŒîx : Composante √©lastique (si ligne tendue)
   * - c√óv_radial : Damping (dissipation d'√©nergie)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position point d'attache d√©part (kite ou barre)
   * @param endPos - Position point d'attache arriv√©e (barre ou kite)
   * @param relativeVelocity - Vitesse relative entre les deux points (pour damping)
   * @returns R√©sultat du calcul (force, tension, extension)
   */
  calculateTensionForce(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    relativeVelocity: Vector3 = new Vector3()
  ): TensionResult {
    // Vecteur ligne et direction
    const lineVector = new Vector3().subVectors(endPos, startPos);
    const currentLength = lineVector.length();

    // √âviter division par z√©ro
    if (currentLength < LinePhysics.EPSILON) {
      return {
        force: new Vector3(),
        tension: 0,
        extension: 0,
        currentLength: 0,
        isTaut: false
      };
    }

    const lineDir = lineVector.clone().normalize();
    const restLength = line.config.length;

    // 1. Composante √©lastique : F_elastic = F‚ÇÄ + k√óŒîx
    let elasticTension: number;
    let extension: number;
    let isTaut: boolean;

    if (currentLength > restLength) {
      // Ligne tendue : ajouter force √©lastique √† la pr√©-tension
      extension = currentLength - restLength;
      elasticTension = line.config.preTension + line.config.stiffness * extension;
      isTaut = true;
    } else {
      // Ligne molle : maintenir pr√©-tension minimale
      extension = 0;
      elasticTension = line.config.preTension;
      isTaut = false;
    }

    // 2. Composante de damping : F_damp = -c √ó v_along_line
    const velocityAlongLine = relativeVelocity.dot(lineDir);
    const dampingTension = -line.config.dampingCoeff * velocityAlongLine;

    // 3. Tension totale (limit√©e par maxTension)
    const totalTension = Math.min(
      Math.max(elasticTension + dampingTension, 0), // Jamais n√©gative
      line.config.maxTension
    );

    // 4. Force vectorielle
    const force = lineDir.clone().multiplyScalar(totalTension);

    return {
      force,
      tension: totalTension,
      extension,
      currentLength,
      isTaut
    };
  }

  /**
   * Calcule l'affaissement cat√©naire r√©el pour une ligne horizontale
   *
   * Formule simplifi√©e : sag = (œÅ √ó g √ó L¬≤) / (8 √ó T)
   * o√π :
   * - œÅ : masse lin√©ique (kg/m)
   * - g : gravit√© (9.81 m/s¬≤)
   * - L : longueur ligne (m)
   * - T : tension (N)
   *
   * @param line - Ligne √† analyser
   * @param tension - Tension actuelle (N)
   * @returns Affaissement vertical au centre (m)
   *
   * @example
   * ```typescript
   * const sag = physics.calculateCatenarySag(line, 100);
   * console.log(`Sag: ${sag * 1000}mm`); // ~1.4mm pour Dyneema 15m @ 100N
   * ```
   */
  calculateCatenarySag(line: Line, tension: number): number {
    if (tension < LinePhysics.EPSILON) {
      return 0; // Pas de tension = pas d'affaissement d√©fini
    }

    const rho = line.config.linearMassDensity;
    const L = line.config.length;

    // Formule cat√©naire simplifi√©e (ligne horizontale)
    const sag = (rho * LinePhysics.GRAVITY * L * L) / (8 * tension);

    return Math.max(0, sag); // Toujours positif
  }

  /**
   * Calcule les points d'une vraie cat√©naire pour le rendu
   *
   * √âquation compl√®te : y(x) = a √ó cosh(x/a) - a
   * o√π a = T / (œÅ √ó g)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position d√©part
   * @param endPos - Position arriv√©e
   * @param tension - Tension actuelle (N)
   * @param segments - Nombre de segments pour la courbe
   * @returns Tableau de points 3D formant la cat√©naire
   *
   * @remarks
   * Pour lignes tr√®s tendues (T > 100N), la cat√©naire est quasi-lin√©aire
   * Pour lignes molles (T < 50N), l'affaissement devient visible
   */
  calculateCatenaryPoints(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    tension: number,
    segments: number = 10
  ): Vector3[] {
    const directDistance = startPos.distanceTo(endPos);

    // Si ligne tendue ou tr√®s courte, approximation lin√©aire suffit
    if (directDistance >= line.config.length * 0.98 || tension > 100) {
      return [startPos.clone(), endPos.clone()];
    }

    // Param√®tre de la cat√©naire : a = T / (œÅ √ó g)
    const rho = line.config.linearMassDensity;
    const a = tension / (rho * LinePhysics.GRAVITY);

    // Calcul sag maximal
    const sag = this.calculateCatenarySag(line, tension);

    const points: Vector3[] = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Position lin√©aire interpol√©e
      const point = new Vector3().lerpVectors(startPos, endPos, t);

      // Ajout de l'affaissement en Y (forme parabolique simplifi√©e)
      // Pour un vrai cosh, il faudrait transformer en coordonn√©es locales
      point.y -= sag * 4 * t * (1 - t); // Maximum au centre (t=0.5)

      points.push(point);
    }

    return points;
  }

  /**
   * Calcule l'√©nergie √©lastique stock√©e dans une ligne
   *
   * E = ¬Ω √ó k √ó Œîx¬≤
   *
   * @param line - Ligne √† analyser
   * @returns √ânergie en Joules
   */
  calculateElasticEnergy(line: Line): number {
    const extension = line.getExtension();
    return 0.5 * line.config.stiffness * extension * extension;
  }

  /**
   * Estime la fr√©quence propre d'oscillation de la ligne
   *
   * f ‚âà (1/2œÄ) √ó ‚àö(k/m_effective)
   *
   * @param line - Ligne √† analyser
   * @param attachedMass - Masse attach√©e au bout (kg)
   * @returns Fr√©quence en Hz
   */
  calculateNaturalFrequency(line: Line, attachedMass: number): number {
    if (attachedMass < LinePhysics.EPSILON) {
      return 0;
    }

    // Masse effective de la ligne (1/3 de la masse totale)
    const lineMass = line.config.linearMassDensity * line.config.length;
    const effectiveMass = attachedMass + lineMass / 3;

    const omega = Math.sqrt(line.config.stiffness / effectiveMass);
    const frequency = omega / (2 * Math.PI);

    return frequency;
  }

  /**
   * V√©rifie si la ligne est dans un √©tat physique valide
   *
   * @param line - Ligne √† valider
   * @returns true si valide, false sinon
   */
  validateLine(line: Line): boolean {
    const config = line.config;

    return (
      config.length > 0 &&
      config.stiffness > 0 &&
      config.preTension >= 0 &&
      config.maxTension > config.preTension &&
      config.dampingCoeff >= 0 &&
      config.dampingCoeff <= 1 &&
      config.linearMassDensity > 0
    );
  }
}


=== simulation/physics/LineSystem.ts ===

/**
 * LineSystem.ts - Orchestrateur du syst√®me de lignes du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les lignes gauche/droite du syst√®me de pilotage
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les lignes sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT le kite (distance max)
 *   - Elles ne TIRENT PAS le kite vers le pilote
 *   - Le ConstraintSolver.enforceLineConstraints() g√®re la contrainte g√©om√©trique
 */
import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { LineFactory } from "@factories/LineFactory";

import { ControlBarManager } from "../controllers/ControlBarManager";
import { PhysicsConstants } from "../config/PhysicsConstants";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

export class LineSystem {
  private leftLine: Line;
  private rightLine: Line;
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(lineLength?: number) {
    const [left, right] = LineFactory.createLinePair(lineLength);
    this.leftLine = left;
    this.rightLine = right;
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  calculateLineTensions(
    kite: Kite,
    controlRotation: number,
    pilotPosition: THREE.Vector3
  ): {
    leftForce: THREE.Vector3;
    rightForce: THREE.Vector3;
    torque: THREE.Vector3;
  } {
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) {
      return {
        leftForce: new THREE.Vector3(),
        rightForce: new THREE.Vector3(),
        torque: new THREE.Vector3(),
      };
    }

    const leftWorld = kite.localToWorld(ctrlLeft);
    const rightWorld = kite.localToWorld(ctrlRight);

    const tempControlBar = new ControlBarManager(pilotPosition);
    tempControlBar.setRotation(controlRotation);
    const handles = tempControlBar.getHandlePositions(kite.position);

    // Calculer v√©locit√©s relatives avec VelocityCalculator
    const leftVelocity = this.velocityCalculator.calculateRelative(
      "leftKite", "leftBar",
      leftWorld, handles.left,
      1 / 60
    );
    const rightVelocity = this.velocityCalculator.calculateRelative(
      "rightKite", "rightBar",
      rightWorld, handles.right,
      1 / 60
    );

    // Calculer tensions pour info/debug uniquement (pas de force appliqu√©e)
    const leftResult = this.physics.calculateTensionForce(this.leftLine, leftWorld, handles.left, leftVelocity);
    const rightResult = this.physics.calculateTensionForce(this.rightLine, rightWorld, handles.right, rightVelocity);

    // Mettre √† jour l'√©tat des lignes (pour affichage)
    this.leftLine.updateState(leftResult.currentLength, leftResult.tension, performance.now());
    this.rightLine.updateState(rightResult.currentLength, rightResult.tension, performance.now());

    // ‚ö†Ô∏è IMPORTANT : PAS DE FORCES NI DE COUPLE APPLIQU√âS
    // Les lignes sont des contraintes g√©om√©triques (ConstraintSolver)
    // Le kite est retenu √† distance max, pas tir√© vers le pilote
    return {
      leftForce: new THREE.Vector3(), // Force nulle
      rightForce: new THREE.Vector3(), // Force nulle
      torque: new THREE.Vector3(), // Couple nul
    };
  }

  calculateCatenary(start: THREE.Vector3, end: THREE.Vector3, segments: number = PhysicsConstants.CATENARY_SEGMENTS): THREE.Vector3[] {
    const tension = this.leftLine.getCurrentTension();
    return this.physics.calculateCatenaryPoints(this.leftLine, start, end, tension, segments);
  }

  setLineLength(length: number): void {
    const [left, right] = LineFactory.createLinePair(length);
    this.leftLine = left;
    this.rightLine = right;
    // R√©initialiser l'historique des v√©locit√©s
    this.velocityCalculator.resetAll();
  }

  get lineLength(): number {
    return this.leftLine.config.length;
  }

  set lineLength(length: number) {
    this.setLineLength(length);
  }

  /**
   * Retourne les tensions actuelles des lignes gauche et droite
   * @returns Objet contenant les tensions en Newtons
   */
  getTensions(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentTension(),
      right: this.rightLine.getCurrentTension()
    };
  }
}


=== simulation/physics/PhysicsEngine.ts ===

/**
 * PhysicsEngine.ts - Moteur physique principal de la simulation Kite
 *
 * R√¥le :
 *   - Orchestration de tou    // C      gravity,  // Gravit√© distribu√©e par surfacelcul des forces a√©rodynamiques et gravitationnelles distribu√©es calculs physiques du cerf-volant (vent, lignes, forces, contr√¥les)
 *   - Point d'entr√©e pour la boucle de simulation physique (appel√© √† chaque frame)
 *   - Centralise l'acc√®s aux sous-modules physiques
 *
 * D√©pendances principales :
 *   - WindSimulator.ts : Simulation du vent et turbulences
 *   - LineSystem.ts : Calcul des tensions et contraintes des lignes
 *   - AerodynamicsCalculator.ts : Calcul des forces a√©rodynamiques
 *   - KiteController.ts : Gestion de l'√©tat physique du cerf-volant
 *   - ControlBarManager.ts : Gestion de la barre de contr√¥le du pilote
 *   - SimulationConfig.ts : Param√®tres globaux de la simulation
 *   - Kite.ts : Mod√®le 3D et points anatomiques du cerf-volant
 *
 * Relation avec les fichiers adjacents :
 *   - Tous les fichiers du dossier 'physics' sont des sous-modules utilis√©s par PhysicsEngine
 *   - Les modules 'controllers' et 'objects' sont utilis√©s pour manipuler le kite et la barre
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, appel√© √† chaque frame pour mettre √† jour la physique
 *   - Sert d'API centrale pour acc√©der √† l'√©tat physique du kite
 *
 * Voir aussi :
 *   - src/simulation/physics/WindSimulator.ts
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteController } from "../controllers/KiteController";
import { ControlBarManager } from "../controllers/ControlBarManager";
import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

import { WindSimulator } from "./WindSimulator";
import { LineSystem } from "./LineSystem";
import { BridleSystem } from "./BridleSystem";
import { AerodynamicsCalculator } from "./AerodynamicsCalculator";

/**
 * Moteur physique principal
 *
 * Orchestre toutes les simulations physiques du cerf-volant
 */
export class PhysicsEngine {
  private windSimulator: WindSimulator;
  private lineSystem: LineSystem;
  private bridleSystem: BridleSystem;
  private kiteController: KiteController;
  private controlBarManager: ControlBarManager;
  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = 1000; // Log toutes les 1000ms (1 seconde)
  private startTime: number = Date.now(); // Temps de d√©marrage pour elapsed time
  private frameCount: number = 0; // Compteur de frames

  constructor(kite: Kite, controlBarPosition: THREE.Vector3) {
    this.windSimulator = new WindSimulator();
    this.lineSystem = new LineSystem();
    this.bridleSystem = new BridleSystem(kite.getBridleLengths());
    this.kiteController = new KiteController(kite);
    this.controlBarManager = new ControlBarManager(controlBarPosition);
  }

  /**
   * LE C≈íUR DE LA SIMULATION - Appel√©e 60 fois par seconde
   *
   * C'est ici que tout se passe ! Cette fonction orchestre toute la physique.
   *
   * VOICI CE QUI SE PASSE √Ä CHAQUE INSTANT :
   * 1. On regarde comment la barre est tourn√©e
   * 2. On calcule o√π sont les mains du pilote
   * 3. On calcule le vent que ressent le kite
   * 4. On calcule toutes les forces :
   *    - Le vent qui pousse
   *    - Les lignes qui tirent
   *    - La gravit√© qui attire vers le bas
   * 5. On fait bouger le kite selon ces forces
   *
   * C'est comme une boucle infinie qui simule la r√©alit√© !
   */
  update(
    deltaTime: number,
    targetBarRotation: number,
    isPaused: boolean = false
  ): void {
    // Si en pause, ne rien faire
    if (isPaused) return;

    // Limiter le pas de temps pour √©viter l'instabilit√© num√©rique
    deltaTime = Math.min(deltaTime, CONFIG.physics.deltaTimeMax);

    // Appliquer directement la rotation de la barre (pas de lissage, d√©j√† g√©r√© par InputHandler)
    this.controlBarManager.setRotation(targetBarRotation);

    // R√©cup√©rer l'√©tat actuel du syst√®me
    const kite = this.kiteController.getKite();
    const handles = this.controlBarManager.getHandlePositions(kite.position);

    // Vent apparent = vent r√©el - vitesse du kite (principe de relativit√©)
    const kiteState = this.kiteController.getState();

    // üîç DEBUG: V√©rifier la vitesse du kite pour comprendre le vent apparent faible - DISABLED for performance


    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );


    // ÔøΩ PHYSIQUE √âMERGENTE : Forces a√©ro + gravit√© distribu√©e calcul√©es par surface
    // - Chaque surface porte une fraction de la masse (fabric + frame + accessoires)
    // - Gravit√© appliqu√©e au centre g√©om√©trique de chaque surface
    // - Le couple gravitationnel √©merge naturellement de r √ó F_gravity
    // - Le couple total √©merge de la diff√©rence gauche/droite naturelle
    const {
      lift,
      drag,
      gravity,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e (plus r√©aliste physiquement)
      torque: totalTorque,  // Inclut d√©j√† couple a√©ro + couple gravitationnel !
    } = AerodynamicsCalculator.calculateForces(
      apparentWind, 
      kite.quaternion,
      kite.position,
      kiteState.velocity,
      kiteState.angularVelocity
    );

    // CALCUL DES TENSIONS (pour affichage/debug uniquement)
    // Les lignes ne TIRENT PAS le kite - elles le RETIENNENT √† distance max
    // La contrainte g√©om√©trique est appliqu√©e par ConstraintSolver dans KiteController
    const pilotPosition = this.controlBarManager.getPosition();
    this.lineSystem.calculateLineTensions(kite, this.controlBarManager.getRotation(), pilotPosition);

    // CALCUL DES TENSIONS DES BRIDES (pour affichage/debug uniquement)
    // Les brides sont des contraintes INTERNES au kite
    // Les contraintes g√©om√©triques sont appliqu√©es par ConstraintSolver.enforceBridleConstraints()
    const bridleTensions = this.bridleSystem.calculateBridleTensions(kite);

    // Incr√©menter le compteur de frames
    this.frameCount++;

    // üìä LOG COMPLET toutes les secondes
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;
      this.logPhysicsState(kite, kiteState, apparentWind, lift, drag, gravity, totalTorque, bridleTensions, deltaTime, currentTime);
    }

    // Mettre √† jour la visualisation des brides selon leurs tensions
    kite.updateBridleVisualization(bridleTensions);

    // Somme vectorielle des forces (2√®me loi de Newton : F = ma)
    const totalForce = new THREE.Vector3()
      .add(lift)     // Portance a√©rodynamique (perpendiculaire au vent)
      .add(drag)     // Tra√Æn√©e a√©rodynamique (parall√®le au vent)
      .add(gravity); // Gravit√© distribu√©e (d√©j√† calcul√©e par surface)
      // PAS de forces de lignes - elles sont des contraintes g√©om√©triques

    // Couple total = moment a√©rodynamique + moment gravitationnel (√©mergent)
    // Les lignes n'appliquent PAS de couple - elles contraignent la position
    // L'orientation √©merge de l'√©quilibre des forces distribu√©es + contraintes

    // Int√©gration physique : F=ma et T=IŒ± pour calculer nouvelle position/orientation
    this.kiteController.update(totalForce, totalTorque, handles, deltaTime);
  }

  setBridleFactor(_factor: number): void {
    // Fonctionnalit√© d√©sactiv√©e dans V8 - physique √©mergente pure
  }

  /**
   * Ajuste une longueur de bride physique (en m√®tres)
   * @param bridleName - 'nez', 'inter' ou 'centre'
   * @param length - longueur en m√®tres
   */
  setBridleLength(bridleName: 'nez' | 'inter' | 'centre', length: number): void {
    this.kiteController.getKite().setBridleLengths({ [bridleName]: length });
  }

  setWindParams(params: Partial<WindParams>): void {
    this.windSimulator.setParams(params);
  }

  setLineLength(length: number): void {
    this.lineSystem.setLineLength(length);
    this.kiteController.setLineLength(length);
  }

  getKiteController(): KiteController {
    return this.kiteController;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getControlBarManager(): ControlBarManager {
    return this.controlBarManager;
  }

  /**
   * Retourne les longueurs actuelles des brides du kite
   */
  getBridleLengths() {
    return this.kiteController.getKite().getBridleLengths();
  }

  /**
   * D√©finit le taux de lissage des forces (en 1/s)
   */
  setForceSmoothing(rate: number): void {
    this.kiteController.setForceSmoothing(rate);
  }

  /**
   * Retourne le taux de lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController.getForceSmoothing();
  }

  /**
   * Affiche l'√©tat physique complet du kite (appel√© toutes les secondes)
   */
  private logPhysicsState(
    kite: Kite,
    kiteState: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    apparentWind: THREE.Vector3,
    lift: THREE.Vector3,
    drag: THREE.Vector3,
    gravity: THREE.Vector3,
    totalTorque: THREE.Vector3,
    bridleTensions: { leftNez: number; rightNez: number; leftInter: number; rightInter: number; leftCentre: number; rightCentre: number },
    deltaTime: number,
    currentTime: number
  ): void {
    // Calculs suppl√©mentaires pour le log
    const elapsedTime = (currentTime - this.startTime) / 1000; // en secondes
    const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
    const pitch = euler.x * (180 / Math.PI); // Convertir en degr√©s
    const roll = euler.z * (180 / Math.PI);
    const yaw = euler.y * (180 / Math.PI);

    // Tensions des lignes
    const lineTensions = this.lineSystem.getTensions();

    // Acc√©l√©ration (approximation : F/m)
    const totalForceCalc = new THREE.Vector3().add(lift).add(drag).add(gravity);
    const acceleration = totalForceCalc.clone().divideScalar(CONFIG.kite.mass);

    // Ratio portance/tra√Æn√©e
    const liftMag = lift.length();
    const dragMag = drag.length();
    const ldRatio = dragMag > 0.01 ? liftMag / dragMag : 0;

    console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log(`‚ïë üìä √âTAT COMPLET DU KITE - Frame #${this.frameCount.toString().padStart(6, '0')}                              ‚ïë`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ‚è±Ô∏è  Temps: ${elapsedTime.toFixed(3)}s | Œît: ${(deltaTime * 1000).toFixed(2)}ms | FPS: ${(1/deltaTime).toFixed(1)}    ‚ïë`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üìç POSITION & ORIENTATION                                                 ‚ïë`);
    console.log(`‚ïë    Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m`);
    console.log(`‚ïë    Distance pilote: ${kite.position.length().toFixed(2)} m`);
    console.log(`‚ïë    Angles: Pitch ${pitch.toFixed(1)}¬∞ | Roll ${roll.toFixed(1)}¬∞ | Yaw ${yaw.toFixed(1)}¬∞`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üöÄ CIN√âMATIQUE                                                            ‚ïë`);
    console.log(`‚ïë    Vitesse: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s`);
    console.log(`‚ïë    Acc√©l√©ration: (${acceleration.x.toFixed(2)}, ${acceleration.y.toFixed(2)}, ${acceleration.z.toFixed(2)}) m/s¬≤ | Mag: ${acceleration.length().toFixed(2)} m/s¬≤`);
    console.log(`‚ïë    Vit. angulaire: (${kiteState.angularVelocity.x.toFixed(2)}, ${kiteState.angularVelocity.y.toFixed(2)}, ${kiteState.angularVelocity.z.toFixed(2)}) rad/s | Mag: ${kiteState.angularVelocity.length().toFixed(2)} rad/s`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë üí® A√âRODYNAMIQUE                                                          ‚ïë`);
    console.log(`‚ïë    Vent apparent: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s`);
    console.log(`‚ïë    Portance: (${lift.x.toFixed(2)}, ${lift.y.toFixed(2)}, ${lift.z.toFixed(2)}) N | Mag: ${liftMag.toFixed(2)} N`);
    console.log(`‚ïë    Tra√Æn√©e: (${drag.x.toFixed(2)}, ${drag.y.toFixed(2)}, ${drag.z.toFixed(2)}) N | Mag: ${dragMag.toFixed(2)} N`);
    console.log(`‚ïë    Ratio L/D: ${ldRatio.toFixed(2)}`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ‚öñÔ∏è  FORCES & COUPLES                                                       ‚ïë`);
    console.log(`‚ïë    Gravit√©: (${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}, ${gravity.z.toFixed(2)}) N | Mag: ${gravity.length().toFixed(2)} N`);
    console.log(`‚ïë    Force totale: (${totalForceCalc.x.toFixed(2)}, ${totalForceCalc.y.toFixed(2)}, ${totalForceCalc.z.toFixed(2)}) N | Mag: ${totalForceCalc.length().toFixed(2)} N`);
    console.log(`‚ïë    Couple total: (${totalTorque.x.toFixed(2)}, ${totalTorque.y.toFixed(2)}, ${totalTorque.z.toFixed(2)}) N‚ãÖm | Mag: ${totalTorque.length().toFixed(2)} N‚ãÖm`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë ü™¢ TENSIONS                                                                ‚ïë`);
    console.log(`‚ïë    Ligne gauche: ${lineTensions.left.toFixed(2)} N | Ligne droite: ${lineTensions.right.toFixed(2)} N`);
    console.log(`‚ïë    Asym√©trie: ${(lineTensions.left - lineTensions.right).toFixed(2)} N (${((lineTensions.left - lineTensions.right) / Math.max(lineTensions.left, lineTensions.right) * 100).toFixed(1)}%)`);
    console.log(`‚ïë    Brides: NEZ L/R: ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)} N`);
    console.log(`‚ïë            INTER L/R: ${bridleTensions.leftInter.toFixed(1)}/${bridleTensions.rightInter.toFixed(1)} N`);
    console.log(`‚ïë            CENTRE L/R: ${bridleTensions.leftCentre.toFixed(1)}/${bridleTensions.rightCentre.toFixed(1)} N`);
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  }
}

=== simulation/physics/VelocityCalculator.ts ===

/**
 * VelocityCalculator.ts - Service de calcul de v√©locit√© relative
 *
 * R√¥le :
 *   - Calcule la v√©locit√© relative entre deux points √† partir de leur historique de positions
 *   - Stocke les positions pr√©c√©dentes pour permettre la d√©rivation temporelle
 *   - Service r√©utilisable par LineSystem et BridleSystem
 *
 * Principe :
 *   v = Œîpos / Œît
 *   o√π Œîpos = position_actuelle - position_pr√©c√©dente
 *
 * Responsabilit√© :
 *   - Gestion de l'historique des positions (Map cl√© ‚Üí position)
 *   - Calcul de v√©locit√© par diff√©rence finie
 *   - Service stateless r√©utilisable
 *
 * Relation avec les autres modules :
 *   - Utilis√© par LineSystem pour calculer v√©locit√© relative lignes
 *   - Utilis√© par BridleSystem pour calculer v√©locit√© relative brides
 *
 * Philosophie :
 *   - DRY (Don't Repeat Yourself) : √©limine duplication LineSystem/BridleSystem
 *   - Single Responsibility : calcul v√©locit√© uniquement
 *   - Testable unitairement
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/BridleSystem.ts
 */

import * as THREE from "three";

/**
 * Service de calcul de v√©locit√© relative par diff√©rence finie
 *
 * Maintient un historique des positions pr√©c√©dentes pour calculer
 * la d√©riv√©e temporelle (v√©locit√©) par diff√©rence finie d'ordre 1.
 *
 * @example
 * ```typescript
 * const velCalc = new VelocityCalculator();
 *
 * // Frame 1
 * const vel1 = velCalc.calculate("kite", pos1, deltaTime);
 * // vel1 = (0, 0, 0) car pas d'historique
 *
 * // Frame 2
 * const vel2 = velCalc.calculate("kite", pos2, deltaTime);
 * // vel2 = (pos2 - pos1) / deltaTime
 * ```
 */
export class VelocityCalculator {
  /**
   * Historique des positions pr√©c√©dentes
   * Cl√© : identifiant unique (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * Valeur : derni√®re position connue
   */
  private previousPositions: Map<string, THREE.Vector3> = new Map();

  /**
   * Calcule la v√©locit√© relative d'un point entre deux frames
   *
   * Utilise la diff√©rence finie d'ordre 1 :
   * v = (pos_actuelle - pos_pr√©c√©dente) / Œît
   *
   * Au premier appel pour une cl√©, retourne (0, 0, 0) car pas d'historique.
   *
   * @param key - Identifiant unique du point (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * @param currentPos - Position actuelle du point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vecteur v√©locit√© en m/s
   *
   * @example
   * ```typescript
   * const vel = calculator.calculate(
   *   "line_left_kite",
   *   new THREE.Vector3(0, 10, 0),
   *   1/60 // 60 FPS
   * );
   * ```
   */
  calculate(
    key: string,
    currentPos: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // R√©cup√©rer position pr√©c√©dente
    const prevPos = this.previousPositions.get(key);

    // Si pas d'historique ou deltaTime invalide, retourner v√©locit√© nulle
    if (!prevPos || deltaTime <= 0) {
      // M√©moriser position actuelle pour prochain frame
      this.previousPositions.set(key, currentPos.clone());
      return new THREE.Vector3();
    }

    // Calculer v√©locit√© par diff√©rence finie
    const velocity = currentPos.clone().sub(prevPos).divideScalar(deltaTime);

    // M√©moriser position actuelle pour prochain frame
    this.previousPositions.set(key, currentPos.clone());

    return velocity;
  }

  /**
   * Calcule la v√©locit√© relative entre deux points (utilis√© par LineSystem)
   *
   * Cette version calcule la diff√©rence de v√©locit√© entre deux points,
   * utile pour calculer la vitesse relative d'une ligne qui relie deux objets.
   *
   * v_relative = v_point1 - v_point2
   *
   * @param keyPoint1 - Identifiant unique du premier point
   * @param keyPoint2 - Identifiant unique du second point
   * @param currentPos1 - Position actuelle du premier point
   * @param currentPos2 - Position actuelle du second point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns V√©locit√© relative entre les deux points
   *
   * @example
   * ```typescript
   * const velRelative = calculator.calculateRelative(
   *   "kite", "bar",
   *   kitePos, barPos,
   *   1/60
   * );
   * ```
   */
  calculateRelative(
    keyPoint1: string,
    keyPoint2: string,
    currentPos1: THREE.Vector3,
    currentPos2: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    const vel1 = this.calculate(keyPoint1, currentPos1, deltaTime);
    const vel2 = this.calculate(keyPoint2, currentPos2, deltaTime);

    // V√©locit√© relative = diff√©rence des v√©locit√©s
    return new THREE.Vector3().subVectors(vel1, vel2);
  }

  /**
   * R√©initialise l'historique pour une cl√© donn√©e
   *
   * Utile quand on change drastiquement la position d'un objet
   * (ex: reset de simulation)
   *
   * @param key - Identifiant du point √† r√©initialiser
   */
  reset(key: string): void {
    this.previousPositions.delete(key);
  }

  /**
   * R√©initialise tout l'historique
   *
   * Utile pour reset complet de la simulation
   */
  resetAll(): void {
    this.previousPositions.clear();
  }

  /**
   * Retourne le nombre de points suivis
   *
   * Utile pour debug/monitoring
   */
  getTrackedCount(): number {
    return this.previousPositions.size;
  }
}


=== simulation/physics/WindSimulator.ts ===

/**
 * WindSimulator.ts - Simulateur de vent et turbulences pour la simulation Kite
 *
 * R√¥le :
 *   - G√©n√®re le vent et ses variations (direction, vitesse, turbulence)
 *   - Fournit le vent apparent ressenti par le cerf-volant
 *   - Sert de source d'environnement pour la physique et le rendu
 *
 * D√©pendances principales :
 *   - SimulationConfig.ts : Param√®tres de vent et turbulence
 *   - Types/WindTypes.ts : Typage des param√®tres de vent
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsEngine.ts : Utilise WindSimulator pour obtenir le vent √† chaque frame
 *   - Les autres modules du dossier 'physics' utilisent le vent pour calculer les forces
 *
 * Utilisation typique :
 *   - Instanci√© par PhysicsEngine, appel√© pour obtenir le vent local ou global
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Simulateur de vent et turbulences
 *
 * G√®re le vent et ses variations pour cr√©er des conditions r√©alistes
 */
export class WindSimulator {
  private params: WindParams;
  private time: number = 0; // Compteur de temps pour faire varier les turbulences
  private windSpeedMs: number = 0;
  private windRad: number = 0;

  constructor() {
    // On d√©marre avec les r√©glages par d√©faut du vent
    this.params = {
      speed: CONFIG.wind.defaultSpeed,
      direction: CONFIG.wind.defaultDirection,
      turbulence: CONFIG.wind.defaultTurbulence,
    };
    this.updateWindInternals();
  }

  private updateWindInternals(): void {
    this.windSpeedMs = this.params.speed / 3.6;
    this.windRad = (this.params.direction * Math.PI) / 180;
  }

  /**
   * Calcule les turbulences du vent
   * M√©thode extraite pour √©viter la duplication de code
   */
  private calculateTurbulence(baseWindVector: THREE.Vector3): THREE.Vector3 {
    if (this.params.turbulence <= 0) {
      return baseWindVector.clone();
    }

    const turbIntensity =
      (this.params.turbulence / 100) * CONFIG.wind.turbulenceScale;
    const freq = CONFIG.wind.turbulenceFreqBase;

    const turbulenceVector = baseWindVector.clone();

    // Utiliser des sinus pour cr√©er des variations douces et naturelles
    turbulenceVector.x +=
      Math.sin(this.time * freq) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;
    turbulenceVector.y +=
      Math.sin(this.time * freq * CONFIG.wind.turbulenceFreqY) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityY;
    turbulenceVector.z +=
      Math.cos(this.time * freq * CONFIG.wind.turbulenceFreqZ) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;

    return turbulenceVector;
  }

  /**
   * Calcule le vent que "ressent" le cerf-volant
   * C'est comme quand vous mettez la main par la fen√™tre d'une voiture :
   * - Si la voiture roule vite, vous sentez plus de vent
   * - Si vous allez contre le vent, il est plus fort
   * - Si vous allez avec le vent, il est plus faible
   */
  getApparentWind(
    kiteVelocity: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    this.time += deltaTime;

    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    const windVector = this.calculateTurbulence(baseWindVector);

    // Le vent apparent = vent r√©el - vitesse du kite
    // Si le kite va vite vers l'avant, il "cr√©e" du vent de face
    const apparent = windVector.clone().sub(kiteVelocity);

    // üîç DEBUG: V√©rifier le calcul du vent apparent - DISABLED for performance
    // console.log(`üîç WIND CALC: Real wind (${windVector.x.toFixed(2)}, ${windVector.y.toFixed(2)}, ${windVector.z.toFixed(2)}) = ${windVector.length().toFixed(2)} m/s | Kite vel (${kiteVelocity.x.toFixed(2)}, ${kiteVelocity.y.toFixed(2)}, ${kiteVelocity.z.toFixed(2)}) = ${kiteVelocity.length().toFixed(2)} m/s | Apparent (${apparent.x.toFixed(2)}, ${apparent.y.toFixed(2)}, ${apparent.z.toFixed(2)}) = ${apparent.length().toFixed(2)} m/s`);

    return apparent;
  }

  /**
   * Obtient le vecteur de vent √† une position donn√©e
   */
  getWindAt(_position: THREE.Vector3): THREE.Vector3 {
    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    return this.calculateTurbulence(baseWindVector);
  }

  setParams(params: Partial<WindParams>): void {
    Object.assign(this.params, params);
    this.updateWindInternals();
  }

  getParams(): WindParams {
    return { ...this.params };
  }
}

=== simulation/rendering/DebugRenderer.ts ===

/**
 * DebugRenderer.ts - Gestionnaire du rendu de debug pour la simulation Kite
 *
 * R√¥le :
 *   - Affiche visuellement les forces physiques (portance, tra√Æn√©e, friction, r√©sultante) et la vitesse du cerf-volant
 *   - Met √† jour le panneau d'informations de debug (HTML)
 *   - Permet d'activer/d√©sactiver le mode debug et de g√©rer l'affichage des vecteurs
 *
 * D√©pendances principales :
 *   - RenderManager.ts : Ajoute/retire les objets de debug √† la sc√®ne Three.js
 *   - PhysicsEngine.ts : R√©cup√®re l'√©tat physique du cerf-volant et les forces calcul√©es
 *   - AerodynamicsCalculator.ts : Calcule les forces a√©rodynamiques sur chaque surface du kite
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et aux points anatomiques du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres physiques et configuration
 *   - Types : Utilise SurfaceForce, KiteState pour typer les donn√©es physiques
 *
 * Relation avec les fichiers adjacents :
 *   - RenderManager.ts : Fichier adjacent direct, g√®re la sc√®ne 3D et l'environnement visuel. DebugRenderer utilise RenderManager pour afficher les fl√®ches de debug.
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec RenderManager.
 *
 * Utilisation typique :
 *   - Instanci√© dans la boucle de simulation pour afficher les vecteurs de forces et la vitesse du kite
 *   - Interagit avec le DOM pour afficher les infos de debug
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/rendering/RenderManager.ts
 */
import * as THREE from "three";
import { Primitive } from "@core/Primitive";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, SurfaceForce } from "../types";
import { PhysicsEngine } from "../physics/PhysicsEngine";
import { AerodynamicsCalculator } from "../physics/AerodynamicsCalculator";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { KiteGeometry } from "../config/KiteGeometry";

import { RenderManager } from "./RenderManager";

/**
 * Palette de couleurs am√©lior√©e pour les vecteurs de debug
 */
const DEBUG_COLORS = {
  // Vecteurs de mouvement
  velocity: 0x00ff00,        // Vert vif - Vitesse du kite
  apparentWind: 0x00ffff,    // Cyan - Vent apparent

  // Forces globales
  globalLift: 0x4169e1,      // Bleu royal - Portance globale
  globalResultant: 0xffffff, // Blanc - R√©sultante globale

  // Forces par surface
  surfaceLift: 0x00bfff,     // Bleu ciel profond - Portance locale
  surfaceDrag: 0xff4444,     // Rouge vif - Tra√Æn√©e
  surfaceFriction: 0xaaaaaa, // Gris moyen - Friction
  surfaceResultant: 0xffdd00,// Jaune vif - R√©sultante locale
  
  // Masse distribu√©e
  surfaceMass: 0xff00ff,     // Magenta - Force gravitationnelle par surface
};

/**
 * Tailles des vecteurs pour meilleure lisibilit√©
 */
const VECTOR_SCALES = {
  velocity: 0.6,
  apparentWind: 0.5,
  globalLift: 0.25,
  globalResultant: 0.35,
  surfaceLift: 0.35,
  surfaceDrag: 0.35,
  surfaceFriction: 0.25,
  surfaceResultant: 0.45,
  surfaceMass: 3.0,  // Amplifier pour visibilit√© (gravit√© ~0.8N par surface)
};

/**
 * Configuration des t√™tes de fl√®ches pour un rendu plus fin et pr√©cis
 */
const ARROW_HEAD_CONFIG = {
  // Grandes fl√®ches (vitesse, vent apparent, r√©sultantes)
  large: {
    headLength: 0.15,  // Longueur de la t√™te de fl√®che
    headWidth: 0.12,   // Largeur de la t√™te de fl√®che
  },
  // Fl√®ches moyennes (forces globales)
  medium: {
    headLength: 0.12,
    headWidth: 0.09,
  },
  // Petites fl√®ches (forces par surface)
  small: {
    headLength: 0.10,
    headWidth: 0.07,
  },
  // Tr√®s petites fl√®ches (friction)
  tiny: {
    headLength: 0.08,
    headWidth: 0.06,
  },
};

/**
 * Gestionnaire du rendu de debug
 *
 * Affiche les forces, vitesses et informations de debug
 */
/**
 * Configuration des vecteurs visibles
 */
interface VectorVisibility {
  velocity: boolean;
  apparentWind: boolean;
  globalForces: boolean;
  surfaceForces: boolean;
  surfaceMass: boolean;  // Afficher forces gravitationnelles distribu√©es
}

export class DebugRenderer {
  private renderManager: RenderManager;
  private debugArrows: THREE.ArrowHelper[] = [];
  private debugMode: boolean;
  private vectorVisibility: VectorVisibility = {
    velocity: true,
    apparentWind: true,
    globalForces: true,
    surfaceForces: true,
    surfaceMass: false,  // D√©sactiv√© par d√©faut (peut surcharger l'affichage)
  };

  constructor(renderManager: RenderManager) {
    this.renderManager = renderManager;
    this.debugMode = CONFIG.debugVectors === true;
    this.setupDebugControls();
  }

  isDebugMode(): boolean {
    return this.debugMode;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;

    const debugBtn = document.getElementById("debug-physics");
    const debugPanel = document.getElementById("debug-panel");

    if (debugBtn) {
      debugBtn.textContent = this.debugMode ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugMode);
    }

    if (debugPanel) {
      debugPanel.style.display = this.debugMode ? "block" : "none";
    }

    document.body.classList.toggle("debug-mode", this.debugMode);

    if (!this.debugMode) {
      this.clearDebugArrows();
    }
  }

  toggleDebugMode(): void {
    this.setDebugMode(!this.debugMode);
  }

  /**
   * Configure le panneau de contr√¥le des vecteurs de debug
   */
  private setupDebugControls(): void {
    // Trouver ou cr√©er le conteneur de contr√¥les
    let controlsContainer = document.getElementById("debug-vector-controls");

    if (!controlsContainer) {
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        controlsContainer = document.createElement("div");
        controlsContainer.id = "debug-vector-controls";
        controlsContainer.style.cssText = `
          margin-top: 15px;
          padding-top: 15px;
          border-top: 1px solid rgba(255,255,255,0.2);
        `;

        controlsContainer.innerHTML = `
          <strong style="display: block; margin-bottom: 10px;">üé® Vecteurs visibles:</strong>
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-velocity" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ff00;">‚óè</span> Vitesse kite
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-apparent-wind" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ffff;">‚óè</span> Vent apparent
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-global-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #4169e1;">‚óè</span> Forces globales
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ffdd00;">‚óè</span> Forces surfaces
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-mass" style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ff00ff;">‚óè</span> Masse distribu√©e
            </label>
          </div>
        `;

        debugPanel.appendChild(controlsContainer);

        // Ajouter les event listeners
        document.getElementById("toggle-velocity")?.addEventListener("change", (e) => {
          this.vectorVisibility.velocity = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-apparent-wind")?.addEventListener("change", (e) => {
          this.vectorVisibility.apparentWind = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-global-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.globalForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-mass")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceMass = (e.target as HTMLInputElement).checked;
        });
      }
    }
  }

  clearDebugArrows(): void {
    this.debugArrows.forEach((arrow) => {
      this.renderManager.removeObject(arrow);
    });
    this.debugArrows = [];
  }

  updateDebugArrows(kite: Kite, physicsEngine: PhysicsEngine): void {
    if (!this.debugMode) return;

    this.clearDebugArrows();

    const kiteState = physicsEngine.getKiteController().getState();
    const kitePosition = kite.position.clone();

    // Calculer le centre g√©om√©trique entre NEZ et SPINE_BAS
    const centerLocal = new THREE.Vector3(0, 0.325, 0);
    const centerWorld = kite.localToWorld(centerLocal.clone());

    // Vecteur de vitesse du kite (vert vif)
    if (this.vectorVisibility.velocity && kiteState.velocity.length() > CONFIG.debug.minVelocityDisplay) {
      const velocityArrow = Primitive.arrow(
        kiteState.velocity.clone().normalize(),
        centerWorld,
        kiteState.velocity.length() * VECTOR_SCALES.velocity,
        DEBUG_COLORS.velocity,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(velocityArrow);
      this.debugArrows.push(velocityArrow);
    }

    const windSim = physicsEngine.getWindSimulator();
    const wind = windSim.getWindAt(kitePosition);
    const relativeWind = wind.clone().sub(kiteState.velocity);

    // Vecteur de vent apparent (cyan)
    if (this.vectorVisibility.apparentWind && relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const apparentWindArrow = Primitive.arrow(
        relativeWind.clone().normalize(),
        centerWorld,
        relativeWind.length() * VECTOR_SCALES.apparentWind,
        DEBUG_COLORS.apparentWind,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(apparentWindArrow);
      this.debugArrows.push(apparentWindArrow);
    }

    if (relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const { lift, drag, surfaceForces } = AerodynamicsCalculator.calculateForces(
        relativeWind,
        kite.quaternion
      );

      // Forces globales (si activ√©)
      if (this.vectorVisibility.globalForces) {
        // Portance globale (bleu royal)
        if (lift.length() > CONFIG.debug.minVectorLength) {
          const liftArrow = Primitive.arrow(
            lift.clone().normalize(),
            centerWorld,
            Math.sqrt(lift.length()) * VECTOR_SCALES.globalLift,
            DEBUG_COLORS.globalLift,
            ARROW_HEAD_CONFIG.medium.headLength,
            ARROW_HEAD_CONFIG.medium.headWidth
          );
          this.renderManager.addObject(liftArrow);
          this.debugArrows.push(liftArrow);
        }

        // R√©sultante globale (blanc) - somme de toutes les surfaces
        const globalResultant = surfaceForces.reduce((sum, sf) => sum.add(sf.resultant.clone()), new THREE.Vector3());
        if (globalResultant.length() > CONFIG.debug.minVectorLength) {
          const resultantArrow = Primitive.arrow(
            globalResultant.clone().normalize(),
            centerWorld,
            Math.sqrt(globalResultant.length()) * VECTOR_SCALES.globalResultant,
            DEBUG_COLORS.globalResultant,
            ARROW_HEAD_CONFIG.large.headLength,
            ARROW_HEAD_CONFIG.large.headWidth
          );
          this.renderManager.addObject(resultantArrow);
          this.debugArrows.push(resultantArrow);
        }
      }

      // Afficher les forces par surface (si activ√©)
      if (this.vectorVisibility.surfaceForces) {
        this.displaySurfaceForces(surfaceForces, kite);
      }

      // Afficher les vecteurs de masse distribu√©e (si activ√©)
      if (this.vectorVisibility.surfaceMass) {
        this.displaySurfaceMass(kite);
      }

      this.updateDebugDisplay(kiteState, kitePosition, { lift, drag }, physicsEngine);
    }
  }

  private updateDebugDisplay(
    kiteState: KiteState,
    kitePosition: THREE.Vector3,
    forces: { lift: THREE.Vector3; drag: THREE.Vector3 },
    physicsEngine: PhysicsEngine
  ): void {
    const debugInfo = document.getElementById("debug-info");
    if (!debugInfo || !this.debugMode) return;

    const { lift, drag } = forces;

    // Calcul des tensions des lignes
    const lineLength = physicsEngine.getLineSystem().lineLength;
    const handles = physicsEngine
      .getControlBarManager()
      .getHandlePositions(kitePosition);

    const kite = physicsEngine.getKiteController().getKite();
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    let tensionInfo = "N/A";
    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const distL = kiteLeftWorld.distanceTo(handles.left);
      const distR = kiteRightWorld.distanceTo(handles.right);
      const tautL = distL >= lineLength - PhysicsConstants.CONTROL_DEADZONE;
      const tautR = distR >= lineLength - PhysicsConstants.CONTROL_DEADZONE;

      tensionInfo = `L:${tautL ? "TENDU" : "REL√ÇCH√â"}(${distL.toFixed(2)}m) R:${
        tautR ? "TENDU" : "REL√ÇCH√â"
      }(${distR.toFixed(2)}m)`;
    }

    // Informations du vent
    const windParams = physicsEngine.getWindSimulator().getParams();

    // Assemblage des informations de debug
    const totalForce = Math.sqrt(lift.lengthSq() + drag.lengthSq());

    debugInfo.innerHTML = `
            <strong>ü™Å Position Cerf-volant:</strong><br>
            X: ${kitePosition.x.toFixed(2)}m, Y: ${kitePosition.y.toFixed(
      2
    )}m, Z: ${kitePosition.z.toFixed(2)}m<br><br>

            <strong>üí® Vent:</strong><br>
            Vitesse: ${windParams.speed.toFixed(1)} km/h<br>
            Direction: ${windParams.direction.toFixed(0)}¬∞<br>
            Turbulence: ${windParams.turbulence.toFixed(1)}%<br><br>

            <strong>‚ö° Forces A√©rodynamiques:</strong><br>
            Portance: ${lift.length().toFixed(3)} N<br>
            Tra√Æn√©e: ${drag.length().toFixed(3)} N<br>
            Force Totale: ${totalForce.toFixed(3)} N<br><br>

            <strong>üîó Tensions Lignes:</strong><br>
            ${tensionInfo}<br><br>

            <strong>üèÉ Vitesse Cerf-volant:</strong><br>
            ${kiteState.velocity.length().toFixed(2)} m/s<br><br>

            <strong>‚öôÔ∏è Performance:</strong><br>
            Statut: <span style="color: #00ff88;">STABLE</span>
        `;
  }

  /**
   * Affiche une fl√®che de force pour chaque surface du kite
   */
  private displaySurfaceForces(surfaceForces: SurfaceForce[], kite: Kite): void {
    const colorPalette = [
      0xff6b6b, // Rouge - Surface 0 (haute gauche)
      0x51cf66, // Vert - Surface 1 (basse gauche) 
      0x667eea, // Bleu - Surface 2 (haute droite)
      0xff9f43, // Orange - Surface 3 (basse droite)
    ];

    surfaceForces.forEach((surfaceForce) => {
      const { lift, drag, friction, resultant, center, surfaceIndex } = surfaceForce;
      const centerWorld = center.clone();
      kite.localToWorld(centerWorld);

      // Portance locale (bleu ciel profond)
      if (lift.length() > CONFIG.debug.minVectorLength) {
        const liftArrow = Primitive.arrow(
          lift.clone().normalize(),
          centerWorld,
          Math.sqrt(lift.length()) * VECTOR_SCALES.surfaceLift,
          DEBUG_COLORS.surfaceLift,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(liftArrow);
        this.debugArrows.push(liftArrow);
      }

      // Tra√Æn√©e (rouge vif)
      if (drag.length() > CONFIG.debug.minVectorLength) {
        const dragArrow = Primitive.arrow(
          drag.clone().normalize(),
          centerWorld,
          Math.sqrt(drag.length()) * VECTOR_SCALES.surfaceDrag,
          DEBUG_COLORS.surfaceDrag,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(dragArrow);
        this.debugArrows.push(dragArrow);
      }

      // Friction (gris moyen)
      if (friction && friction.length() > CONFIG.debug.minVectorLength) {
        const frictionArrow = Primitive.arrow(
          friction.clone().normalize(),
          centerWorld,
          Math.sqrt(friction.length()) * VECTOR_SCALES.surfaceFriction,
          DEBUG_COLORS.surfaceFriction,
          ARROW_HEAD_CONFIG.tiny.headLength,
          ARROW_HEAD_CONFIG.tiny.headWidth
        );
        this.renderManager.addObject(frictionArrow);
        this.debugArrows.push(frictionArrow);
      }

      // R√©sultante locale (jaune vif)
      if (resultant.length() > CONFIG.debug.minVectorLength) {
        const resultantArrow = Primitive.arrow(
          resultant.clone().normalize(),
          centerWorld,
          Math.sqrt(resultant.length()) * VECTOR_SCALES.surfaceResultant,
          DEBUG_COLORS.surfaceResultant,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(resultantArrow);
        this.debugArrows.push(resultantArrow);
      }
    });
  }

  /**
   * Affiche les vecteurs de force gravitationnelle pour chaque surface
   * Visualise la masse distribu√©e (physique √©mergente)
   */
  private displaySurfaceMass(kite: Kite): void {
    // Pour chaque surface avec sa masse
    KiteGeometry.SURFACES_WITH_MASS.forEach((surface: any, surfaceIndex: number) => {
      // Centre g√©om√©trique de la surface (coordonn√©es locales)
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Transformer en coordonn√©es monde
      const centerWorld = kite.localToWorld(centre.clone());

      // Force gravitationnelle = m √ó g (vers le bas)
      const gravityForce = new THREE.Vector3(0, -surface.mass * CONFIG.physics.gravity, 0);
      const forceMagnitude = gravityForce.length();

      // Afficher fl√®che magenta pointant vers le bas
      if (forceMagnitude > CONFIG.debug.minVectorLength) {
        const gravityArrow = Primitive.arrow(
          gravityForce.clone().normalize(),
          centerWorld,
          forceMagnitude * VECTOR_SCALES.surfaceMass,
          DEBUG_COLORS.surfaceMass,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(gravityArrow);
        this.debugArrows.push(gravityArrow);

        // Optionnel : Ajouter une sph√®re pour montrer la masse
        // Taille proportionnelle √† la masse
        const sphereRadius = surface.mass * 0.2; // 0.2m pour 1kg
        const massIndicator = new THREE.Mesh(
          new THREE.SphereGeometry(sphereRadius, 8, 8),
          new THREE.MeshBasicMaterial({
            color: DEBUG_COLORS.surfaceMass,
            transparent: true,
            opacity: 0.3,
            wireframe: true
          })
        );
        massIndicator.position.copy(centerWorld);
        this.renderManager.addObject(massIndicator);
        this.debugArrows.push(massIndicator as any); // Pour cleanup
      }
    });
  }
}



=== simulation/rendering/RenderManager.ts ===

/**
 * RenderManager.ts - Gestionnaire du rendu 3D pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re la sc√®ne Three.js, la cam√©ra, le rendu et l'environnement visuel (ciel, sol, nuages, lumi√®res)
 *   - Ajoute et retire dynamiquement des objets 3D (cerf-volant, fl√®ches de debug, etc.)
 *   - Fournit l'API pour le rendu et la gestion de la sc√®ne
 *
 * D√©pendances principales :
 *   - Three.js : Moteur de rendu 3D
 *   - SimulationConfig.ts : Param√®tres de configuration du rendu (fog, ombres, etc.)
 *
 * Relation avec les fichiers adjacents :
 *   - DebugRenderer.ts : Fichier adjacent direct, utilise RenderManager pour afficher les vecteurs de debug (fl√®ches de forces, vitesse, etc.)
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec DebugRenderer.
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage de la simulation pour initialiser la sc√®ne et le rendu
 *   - Utilis√© par DebugRenderer pour ajouter/retirer des objets de debug
 *
 * Voir aussi :
 *   - src/simulation/rendering/DebugRenderer.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire du rendu 3D
 *
 * G√®re la sc√®ne 3D, la cam√©ra, le rendu et l'environnement visuel
 */
export class RenderManager {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(
      0x87ceeb,
      CONFIG.rendering.fogStart,
      CONFIG.rendering.fogEnd
    );

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 5, 12);
    this.camera.lookAt(0, 3, -5);

    this.renderer = new THREE.WebGLRenderer({
      antialias: CONFIG.rendering.antialias,
      alpha: true,
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxDistance = 50;
    this.controls.minDistance = 2;

    this.setupEnvironment();
    window.addEventListener("resize", () => this.onResize());
  }

  private setupEnvironment(): void {
    // Cr√©ation d'un beau ciel d√©grad√©
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel profond
        bottomColor: { value: new THREE.Color(0x87ceeb) }, // Bleu ciel plus clair
        offset: { value: 400 },
        exponent: { value: 0.6 },
      },
      side: THREE.BackSide,
    });

    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);

    // Ajout de quelques nuages pour plus de r√©alisme
    this.addClouds();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 50, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    sunLight.shadow.mapSize.width = CONFIG.rendering.shadowMapSize;
    sunLight.shadow.mapSize.height = CONFIG.rendering.shadowMapSize;
    this.scene.add(sunLight);

    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    this.scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    this.scene.add(gridHelper);
  }

  private addClouds(): void {
    // Cr√©ation de quelques nuages simples et r√©alistes
    const cloudGroup = new THREE.Group();

    // Mat√©riau pour les nuages - blanc semi-transparent
    const cloudMaterial = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
    });

    // Cr√©ation de plusieurs nuages √† diff√©rentes positions
    for (let i = 0; i < 8; i++) {
      const cloud = new THREE.Group();

      // Chaque nuage est compos√© de plusieurs sph√®res pour un aspect naturel
      for (let j = 0; j < 5; j++) {
        const cloudPart = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random() * 4 + 2, 6, 4),
          cloudMaterial
        );

        cloudPart.position.x = Math.random() * 10 - 5;
        cloudPart.position.y = Math.random() * 2 - 1;
        cloudPart.position.z = Math.random() * 10 - 5;
        cloudPart.scale.setScalar(Math.random() * 0.5 + 0.5);

        cloud.add(cloudPart);
      }

      // Position des nuages dans le ciel
      cloud.position.set(
        (Math.random() - 0.5) * 200, // X: -100 √† 100
        Math.random() * 30 + 20, // Y: 20 √† 50 (hauteur dans le ciel)
        (Math.random() - 0.5) * 200 // Z: -100 √† 100
      );

      cloudGroup.add(cloud);
    }

    this.scene.add(cloudGroup);
  }

  addObject(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  render(): void {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  private onResize(): void {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  getScene(): THREE.Scene {
    return this.scene;
  }
}

=== simulation/systems/InputSystem.ts ===

/**
 * InputSystem.ts - Syst√®me de gestion des entr√©es utilisateur
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface InputState {
  // Entr√©es analogiques (normalis√©es -1 √† 1)
  barPosition: number; // Position de la barre (-1: tir√©e gauche, 0: neutre, 1: tir√©e droite)
  barVelocity: number; // Vitesse de mouvement de la barre

  // Entr√©es num√©riques
  resetPressed: boolean;
  debugTogglePressed: boolean;

  // √âtat interne
  lastBarPosition: number;
  smoothingFactor: number;
}

export interface InputConfig {
  barSmoothingEnabled: boolean;
  barSmoothingFactor: number; // Facteur de lissage (0-1, plus proche de 1 = plus lisse)
  deadzone: number; // Zone morte pour √©viter les oscillations
  maxBarSpeed: number; // Vitesse maximale de changement de la barre
  keyboardEnabled: boolean;
  mouseEnabled: boolean;
}

export class InputSystem extends BaseSimulationSystem {
  private logger: Logger;
  private inputState: InputState;
  private config: InputConfig;

  // Gestion des √©v√©nements
  private keyStates = new Map<string, boolean>();
  private mousePosition = new THREE.Vector2();
  private mouseButtons = new Map<number, boolean>();

  constructor(config: Partial<InputConfig> = {}) {
    super('InputSystem', 1); // Haute priorit√© (trait√© en premier)

    this.logger = Logger.getInstance();
    this.config = {
      barSmoothingEnabled: true,
      barSmoothingFactor: 0.8,
      deadzone: 0.05,
      maxBarSpeed: 2.0, // unit√©s par seconde
      keyboardEnabled: true,
      mouseEnabled: true,
      ...config
    };

    this.inputState = {
      barPosition: 0,
      barVelocity: 0,
      resetPressed: false,
      debugTogglePressed: false,
      lastBarPosition: 0,
      smoothingFactor: this.config.barSmoothingFactor
    };

    this.setupEventListeners();
  }

  async initialize(): Promise<void> {
    this.logger.info('InputSystem initialized', 'InputSystem');
  }

  update(context: SimulationContext): void {
    // Mettre √† jour l'√©tat des entr√©es
    this.updateKeyboardInput();
    this.updateMouseInput();

    // Calculer la position de la barre avec lissage
    this.updateBarPosition(context.deltaTime);

    // Mettre √† jour les √©tats des boutons (pulse)
    this.updateButtonStates();
  }

  /**
   * Configure les √©couteurs d'√©v√©nements
   */
  private setupEventListeners(): void {
    if (typeof window === 'undefined') return;

    // √âcouteurs clavier
    if (this.config.keyboardEnabled) {
      window.addEventListener('keydown', this.onKeyDown.bind(this));
      window.addEventListener('keyup', this.onKeyUp.bind(this));
    }

    // √âcouteurs souris
    if (this.config.mouseEnabled) {
      window.addEventListener('mousemove', this.onMouseMove.bind(this));
      window.addEventListener('mousedown', this.onMouseDown.bind(this));
      window.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
  }

  /**
   * Gestionnaire d'√©v√©nement clavier (appui)
   */
  private onKeyDown(event: KeyboardEvent): void {
    this.keyStates.set(event.code, true);

    // Emp√™cher le comportement par d√©faut pour certaines touches
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyR'].includes(event.code)) {
      event.preventDefault();
    }
  }

  /**
   * Gestionnaire d'√©v√©nement clavier (rel√¢chement)
   */
  private onKeyUp(event: KeyboardEvent): void {
    this.keyStates.set(event.code, false);
  }

  /**
   * Gestionnaire de mouvement de souris
   */
  private onMouseMove(event: MouseEvent): void {
    this.mousePosition.set(event.clientX, event.clientY);
  }

  /**
   * Gestionnaire d'appui souris
   */
  private onMouseDown(event: MouseEvent): void {
    this.mouseButtons.set(event.button, true);
  }

  /**
   * Gestionnaire de rel√¢chement souris
   */
  private onMouseUp(event: MouseEvent): void {
    this.mouseButtons.set(event.button, false);
  }

  /**
   * Met √† jour les entr√©es clavier
   */
  private updateKeyboardInput(): void {
    // Contr√¥le de la barre avec les fl√®ches gauche/droite
    let targetBarPosition = 0;

    if (this.keyStates.get('ArrowLeft')) {
      targetBarPosition = -1; // Barre tir√©e √† gauche
    } else if (this.keyStates.get('ArrowRight')) {
      targetBarPosition = 1; // Barre tir√©e √† droite
    }

    // Appliquer la zone morte
    if (Math.abs(targetBarPosition) < this.config.deadzone) {
      targetBarPosition = 0;
    }

    this.inputState.barPosition = targetBarPosition;

    // Boutons pulse
    this.inputState.resetPressed = this.keyStates.get('KeyR') || false;
    this.inputState.debugTogglePressed = this.keyStates.get('KeyD') || false;
  }

  /**
   * Met √† jour les entr√©es souris (r√©serv√© pour extension future)
   */
  private updateMouseInput(): void {
    // Pour l'instant, la souris n'est pas utilis√©e pour le contr√¥le principal
    // Mais on pourrait l'utiliser pour un contr√¥le plus fin
  }

  /**
   * Met √† jour la position de la barre avec lissage
   */
  private updateBarPosition(deltaTime: number): void {
    const targetPosition = this.inputState.barPosition;

    if (this.config.barSmoothingEnabled) {
      // Lissage exponentiel
      const smoothedPosition = THREE.MathUtils.lerp(
        this.inputState.lastBarPosition,
        targetPosition,
        1.0 - Math.pow(1.0 - this.inputState.smoothingFactor, deltaTime * 60)
      );

      this.inputState.lastBarPosition = smoothedPosition;
      this.inputState.barPosition = smoothedPosition;
    } else {
      this.inputState.lastBarPosition = targetPosition;
    }

    // Calculer la vitesse de changement
    this.inputState.barVelocity = (this.inputState.barPosition - this.inputState.lastBarPosition) / deltaTime;

    // Limiter la vitesse maximale
    if (Math.abs(this.inputState.barVelocity) > this.config.maxBarSpeed) {
      this.inputState.barVelocity = Math.sign(this.inputState.barVelocity) * this.config.maxBarSpeed;
    }
  }

  /**
   * Met √† jour les √©tats des boutons (pulse - seulement true pendant un frame)
   */
  private updateButtonStates(): void {
    // Pour l'instant, pas de logique pulse n√©cessaire car on utilise directement les keyStates
    // Mais on pourrait impl√©menter une logique de pulse ici si n√©cessaire
  }

  /**
   * Obtient l'√©tat actuel des entr√©es
   */
  getInputState(): Readonly<InputState> {
    return this.inputState;
  }

  /**
   * Force une position de barre (pour debug ou automation)
   */
  setBarPosition(position: number): void {
    this.inputState.barPosition = THREE.MathUtils.clamp(position, -1, 1);
    this.inputState.lastBarPosition = this.inputState.barPosition;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<InputConfig> {
    return this.config;
  }

  reset(): void {
    this.inputState.barPosition = 0;
    this.inputState.barVelocity = 0;
    this.inputState.lastBarPosition = 0;
    this.inputState.resetPressed = false;
    this.inputState.debugTogglePressed = false;

    // R√©initialiser les √©tats des touches
    this.keyStates.clear();
    this.mouseButtons.clear();

    this.logger.info('InputSystem reset', 'InputSystem');
  }

  dispose(): void {
    // Supprimer les √©couteurs d'√©v√©nements
    if (typeof window !== 'undefined') {
      window.removeEventListener('keydown', this.onKeyDown.bind(this));
      window.removeEventListener('keyup', this.onKeyUp.bind(this));
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('mousedown', this.onMouseDown.bind(this));
      window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }

    this.logger.info('InputSystem disposed', 'InputSystem');
  }
}

=== simulation/systems/PhysicsSystem.ts ===

/**
 * PhysicsSystem.ts - Syst√®me de simulation physique
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { PHYSICAL_CONSTANTS } from '../../factories/presets/PhysicalPresets';

export interface PhysicsState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  acceleration: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  angularAcceleration: THREE.Vector3;
  mass: number;
  momentOfInertia: THREE.Matrix3;
}

export interface PhysicsConfig {
  gravityEnabled: boolean;
  airResistanceEnabled: boolean;
  groundCollisionEnabled: boolean;
  maxVelocity: number;
  maxAngularVelocity: number;
  timeStep: number;
  airDensity: number;
  gravity: number;
  minVelocity: number;
}

export class PhysicsSystem extends BaseSimulationSystem {
  private logger: Logger;
  private physicsObjects = new Map<string, PhysicsState>();
  private config: PhysicsConfig;

  constructor(config: Partial<PhysicsConfig> = {}) {
    super('PhysicsSystem', 10); // Priorit√© 10 (apr√®s les syst√®mes d'entr√©e)

    this.logger = Logger.getInstance();
    this.config = {
      gravityEnabled: true,
      airResistanceEnabled: true,
      groundCollisionEnabled: true,
      maxVelocity: 100,
      maxAngularVelocity: 50,
      airDensity: PHYSICAL_CONSTANTS.airDensity,
      gravity: PHYSICAL_CONSTANTS.gravity,
      minVelocity: 0.01,
      timeStep: 1/60,
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('PhysicsSystem initialized', 'PhysicsSystem');
  }

  update(context: SimulationContext): void {
    const deltaTime = Math.min(context.deltaTime, this.config.timeStep);

    // Mise √† jour de tous les objets physiques
    for (const [id, state] of this.physicsObjects.entries()) {
      this.updatePhysicsObject(id, state, deltaTime);
    }
  }

  reset(): void {
    this.physicsObjects.clear();
    this.logger.info('PhysicsSystem reset', 'PhysicsSystem');
  }

  dispose(): void {
    this.physicsObjects.clear();
    this.logger.info('PhysicsSystem disposed', 'PhysicsSystem');
  }

  /**
   * Enregistre un objet physique dans le syst√®me
   */
  registerPhysicsObject(id: string, initialState: Partial<PhysicsState>): void {
    const state: PhysicsState = {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      acceleration: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      angularAcceleration: new THREE.Vector3(),
      mass: 1.0,
      momentOfInertia: new THREE.Matrix3().identity(),
      ...initialState
    };

    this.physicsObjects.set(id, state);
    this.logger.debug(`Physics object registered: ${id}`, 'PhysicsSystem');
  }

  /**
   * D√©senregistre un objet physique
   */
  unregisterPhysicsObject(id: string): boolean {
    const removed = this.physicsObjects.delete(id);
    if (removed) {
      this.logger.debug(`Physics object unregistered: ${id}`, 'PhysicsSystem');
    }
    return removed;
  }

  /**
   * Obtient l'√©tat physique d'un objet
   */
  getPhysicsState(id: string): PhysicsState | undefined {
    return this.physicsObjects.get(id);
  }

  /**
   * Applique une force √† un objet
   */
  applyForce(id: string, force: THREE.Vector3, point?: THREE.Vector3): void {
    const state = this.physicsObjects.get(id);
    if (!state) return;

    // F = ma => a = F/m
    const acceleration = force.clone().divideScalar(state.mass);
    state.acceleration.add(acceleration);

    // Si un point d'application est sp√©cifi√©, calculer le couple
    if (point) {
      const r = point.clone().sub(state.position);
      const torque = r.clone().cross(force);
      this.applyTorque(id, torque);
    }
  }

  /**
   * Applique un couple (torque) √† un objet
   */
  applyTorque(id: string, torque: THREE.Vector3): void {
    const state = this.physicsObjects.get(id);
    if (!state) return;

    // œÑ = IŒ± => Œ± = I‚Åª¬πœÑ
    const angularAcceleration = torque.clone();
    angularAcceleration.applyMatrix3(state.momentOfInertia.clone().invert());
    state.angularAcceleration.add(angularAcceleration);
  }

  /**
   * Met √† jour la physique d'un objet
   */
  private updatePhysicsObject(id: string, state: PhysicsState, deltaTime: number): void {
    // Appliquer la gravit√©
    if (this.config.gravityEnabled) {
      const gravity = new THREE.Vector3(0, -PHYSICAL_CONSTANTS.gravity, 0);
      state.acceleration.add(gravity);
    }

    // Appliquer la r√©sistance de l'air
    if (this.config.airResistanceEnabled) {
      this.applyAirResistance(state);
    }

    // Int√©gration des acc√©l√©rations (m√©thode d'Euler)
    state.velocity.add(state.acceleration.clone().multiplyScalar(deltaTime));
    state.position.add(state.velocity.clone().multiplyScalar(deltaTime));

    // Int√©gration angulaire
    state.angularVelocity.add(state.angularAcceleration.clone().multiplyScalar(deltaTime));

    // Limiter les vitesses
    this.clampVelocities(state);

    // Collision avec le sol
    if (this.config.groundCollisionEnabled) {
      this.handleGroundCollision(state);
    }

    // R√©initialiser les acc√©l√©rations pour le prochain frame
    state.acceleration.set(0, 0, 0);
    state.angularAcceleration.set(0, 0, 0);
  }

  /**
   * Applique la r√©sistance de l'air
   */
  private applyAirResistance(state: PhysicsState): void {
    if (state.velocity.lengthSq() < this.config.minVelocity * this.config.minVelocity) {
      return;
    }

    // Force de tra√Æn√©e : F_d = 0.5 * œÅ * v¬≤ * C_d * A
    // Approximation simplifi√©e : F_d = -k * v (lin√©aire)
    const dragCoefficient = 0.1; // Coefficient simplifi√©
    const dragForce = state.velocity.clone()
      .normalize()
      .multiplyScalar(-dragCoefficient * state.velocity.lengthSq());

    state.acceleration.add(dragForce.divideScalar(state.mass));
  }

  /**
   * Limite les vitesses maximales
   */
  private clampVelocities(state: PhysicsState): void {
    if (state.velocity.length() > this.config.maxVelocity) {
      state.velocity.normalize().multiplyScalar(this.config.maxVelocity);
    }

    if (state.angularVelocity.length() > this.config.maxAngularVelocity) {
      state.angularVelocity.normalize().multiplyScalar(this.config.maxAngularVelocity);
    }
  }

  /**
   * G√®re les collisions avec le sol
   */
  private handleGroundCollision(state: PhysicsState): void {
    const groundY = 0;

    if (state.position.y <= groundY && state.velocity.y < 0) {
      // Collision avec le sol
      state.position.y = groundY;
      state.velocity.y *= -0.3; // Coefficient de restitution (rebond)

      // Friction
      const friction = 0.8;
      state.velocity.x *= friction;
      state.velocity.z *= friction;

      // Arr√™ter si la vitesse est tr√®s faible
      if (Math.abs(state.velocity.y) < 0.01) {
        state.velocity.y = 0;
      }
    }
  }

  /**
   * Calcule les forces a√©rodynamiques (pour usage par d'autres syst√®mes)
   */
  calculateAerodynamicForces(
    velocity: THREE.Vector3,
    area: number,
    liftCoeff: number,
    dragCoeff: number,
    normal: THREE.Vector3
  ): { lift: THREE.Vector3, drag: THREE.Vector3 } {
    const speed = velocity.length();
    if (speed < this.config.minVelocity) {
      return { lift: new THREE.Vector3(), drag: new THREE.Vector3() };
    }

    const velocityDir = velocity.clone().normalize();

    // Force de portance (perpendiculaire √† la vitesse)
    const liftDir = normal.clone().cross(velocityDir).cross(velocityDir).normalize();
    const lift = liftDir.multiplyScalar(0.5 * PHYSICAL_CONSTANTS.airDensity * speed * speed * area * liftCoeff);

    // Force de tra√Æn√©e (oppos√©e √† la vitesse)
    const drag = velocityDir.clone().multiplyScalar(-0.5 * PHYSICAL_CONSTANTS.airDensity * speed * speed * area * dragCoeff);

    return { lift, drag };
  }

  /**
   * Obtient tous les IDs des objets physiques
   */
  getPhysicsObjectIds(): string[] {
    return Array.from(this.physicsObjects.keys());
  }

  /**
   * Met √† jour la configuration
   */
  updateConfig(newConfig: Partial<PhysicsConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.logger.info('PhysicsSystem config updated', 'PhysicsSystem');
  }

  /**
   * Obtient les statistiques du syst√®me
   */
  getStats(): any {
    return {
      objectCount: this.physicsObjects.size,
      config: this.config
    };
  }
}

=== simulation/systems/RenderSystem.ts ===

/**
 * RenderSystem.ts - Syst√®me de rendu Three.js
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface RenderState {
  scene: THREE.Scene;
  camera: THREE.Camera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
  isRendering: boolean;
  frameCount: number;
  fps: number;
  lastFrameTime: number;
}

export interface RenderConfig {
  antialias: boolean;
  shadowMapEnabled: boolean;
  shadowMapType: THREE.ShadowMapType;
  pixelRatio: number;
  clearColor: number;
  clearAlpha: number;
  targetFPS: number;
  vsync: boolean;
  powerPreference: 'default' | 'high-performance' | 'low-power';
}

export class RenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private renderState: RenderState | null = null;
  private config: RenderConfig;
  private fpsCounter = { frames: 0, lastTime: 0, fps: 0 };

  constructor(config: Partial<RenderConfig> = {}) {
    super('RenderSystem', 100); // Basse priorit√© (rendu en dernier)

    this.logger = Logger.getInstance();
    this.config = {
      antialias: true,
      shadowMapEnabled: true,
      shadowMapType: THREE.PCFSoftShadowMap,
      pixelRatio: 1, // Valeur par d√©faut, sera mise √† jour dans initialize()
      clearColor: 0x87CEEB, // Bleu ciel
      clearAlpha: 1.0,
      targetFPS: 60,
      vsync: true,
      powerPreference: 'high-performance',
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('RenderSystem initializing...', 'RenderSystem');

    // Mettre √† jour pixelRatio maintenant que window est disponible
    if (typeof window !== 'undefined') {
      this.config.pixelRatio = Math.min(window.devicePixelRatio, 2);
    }

    try {
      await this.initializeRenderer();
      this.logger.info('RenderSystem initialized successfully', 'RenderSystem');
    } catch (error) {
      this.logger.error(`RenderSystem initialization failed: ${error}`, 'RenderSystem');
      throw error;
    }
  }

  /**
   * Initialise le renderer Three.js
   */
  private async initializeRenderer(): Promise<void> {
    if (typeof document === 'undefined') {
      throw new Error('RenderSystem requires a DOM environment');
    }

    // Cr√©er le canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'kite-simulator-canvas';

    // Cr√©er le renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: this.config.antialias,
      alpha: false,
      powerPreference: this.config.powerPreference
    });

    // Configurer le renderer
    renderer.setPixelRatio(this.config.pixelRatio);
    renderer.setClearColor(this.config.clearColor, this.config.clearAlpha);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Configurer les ombres
    if (this.config.shadowMapEnabled) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = this.config.shadowMapType;
    }

    // Cr√©er la sc√®ne
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(this.config.clearColor, 50, 200);

    // Cr√©er la cam√©ra (sera configur√©e par le syst√®me de cam√©ra s√©par√©)
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Initialiser l'√©tat de rendu
    this.renderState = {
      scene,
      camera,
      renderer,
      canvas,
      isRendering: false,
      frameCount: 0,
      fps: 0,
      lastFrameTime: performance.now()
    };

    // Configurer la taille initiale
    this.onResize();

    // Ajouter le canvas au DOM
    const container = document.getElementById('app') || document.body;
    container.appendChild(canvas);

    // √âcouteur de redimensionnement
    window.addEventListener('resize', this.onResize.bind(this));
  }

  update(context: SimulationContext): void {
    if (!this.renderState || !this.renderState.isRendering) return;

    // Calculer le FPS
    this.updateFPS();

    // Rendre la sc√®ne
    this.renderState.renderer.render(this.renderState.scene, this.renderState.camera);

    this.renderState.frameCount++;
  }

  /**
   * Met √† jour le compteur FPS
   */
  private updateFPS(): void {
    if (!this.renderState) return;

    const now = performance.now();
    this.fpsCounter.frames++;

    if (now - this.fpsCounter.lastTime >= 1000) {
      this.renderState.fps = Math.round((this.fpsCounter.frames * 1000) / (now - this.fpsCounter.lastTime));
      this.fpsCounter.frames = 0;
      this.fpsCounter.lastTime = now;
    }
  }

  /**
   * Gestionnaire de redimensionnement de la fen√™tre
   */
  private onResize(): void {
    if (!this.renderState) return;

    const width = window.innerWidth;
    const height = window.innerHeight;

    // Mettre √† jour la cam√©ra
    if (this.renderState.camera instanceof THREE.PerspectiveCamera) {
      this.renderState.camera.aspect = width / height;
      this.renderState.camera.updateProjectionMatrix();
    }

    // Mettre √† jour le renderer
    this.renderState.renderer.setSize(width, height);
  }

  /**
   * D√©marre le rendu
   */
  startRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = true;
      this.logger.info('Rendering started', 'RenderSystem');
    }
  }

  /**
   * Arr√™te le rendu
   */
  stopRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = false;
      this.logger.info('Rendering stopped', 'RenderSystem');
    }
  }

  /**
   * Obtient l'√©tat de rendu actuel
   */
  getRenderState(): Readonly<RenderState> | null {
    return this.renderState;
  }

  /**
   * Obtient la sc√®ne Three.js
   */
  getScene(): THREE.Scene | null {
    return this.renderState?.scene || null;
  }

  /**
   * Obtient la cam√©ra
   */
  getCamera(): THREE.Camera | null {
    return this.renderState?.camera || null;
  }

  /**
   * Obtient le renderer
   */
  getRenderer(): THREE.WebGLRenderer | null {
    return this.renderState?.renderer || null;
  }

  /**
   * Obtient le canvas
   */
  getCanvas(): HTMLCanvasElement | null {
    return this.renderState?.canvas || null;
  }

  /**
   * Obtient les statistiques de rendu
   */
  getRenderStats(): { fps: number; frameCount: number; isRendering: boolean } {
    if (!this.renderState) {
      return { fps: 0, frameCount: 0, isRendering: false };
    }

    return {
      fps: this.renderState.fps,
      frameCount: this.renderState.frameCount,
      isRendering: this.renderState.isRendering
    };
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<RenderConfig> {
    return this.config;
  }

  reset(): void {
    if (this.renderState) {
      this.renderState.frameCount = 0;
      this.renderState.fps = 0;
      this.renderState.lastFrameTime = performance.now();
    }

    this.fpsCounter = { frames: 0, lastTime: 0, fps: 0 };
    this.logger.info('RenderSystem reset', 'RenderSystem');
  }

  dispose(): void {
    if (this.renderState) {
      // Supprimer les √©couteurs
      window.removeEventListener('resize', this.onResize.bind(this));

      // Disposer le renderer
      this.renderState.renderer.dispose();

      // Supprimer le canvas du DOM
      if (this.renderState.canvas.parentNode) {
        this.renderState.canvas.parentNode.removeChild(this.renderState.canvas);
      }

      this.renderState = null;
    }

    this.logger.info('RenderSystem disposed', 'RenderSystem');
  }
}

=== simulation/systems/WindSystem.ts ===

/**
 * WindSystem.ts - Syst√®me de simulation du vent
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { PHYSICAL_CONSTANTS } from '../../factories/presets/PhysicalPresets';

export interface WindState {
  baseDirection: THREE.Vector3; // Direction principale du vent
  baseSpeed: number; // Vitesse de base du vent (m/s)
  turbulence: number; // Intensit√© de la turbulence (0-1)
  gustFrequency: number; // Fr√©quence des rafales (Hz)
  gustAmplitude: number; // Amplitude des rafales
  time: number; // Temps √©coul√© pour l'animation
}

export interface WindConfig {
  baseSpeed: number;
  baseDirection: THREE.Vector3;
  turbulenceEnabled: boolean;
  turbulenceIntensity: number;
  gustsEnabled: boolean;
  gustFrequency: number;
  gustAmplitude: number;
  windShearEnabled: boolean; // Variation de vitesse avec l'altitude
  updateFrequency: number; // Fr√©quence de mise √† jour (Hz)
}

export class WindSystem extends BaseSimulationSystem {
  private logger: Logger;
  private windState: WindState;
  private config: WindConfig;
  private lastUpdateTime: number = 0;

  constructor(config: Partial<WindConfig> = {}) {
    super('WindSystem', 5); // Priorit√© 5 (avant la physique)

    this.logger = Logger.getInstance();
    this.config = {
      baseSpeed: 5.0, // 5 m/s vent l√©ger
      baseDirection: new THREE.Vector3(1, 0, 0), // Vent venant de l'est
      turbulenceEnabled: true,
      turbulenceIntensity: 0.3,
      gustsEnabled: true,
      gustFrequency: 0.1, // Une rafale toutes les 10 secondes
      gustAmplitude: 2.0,
      windShearEnabled: true,
      updateFrequency: 10, // 10 Hz
      ...config
    };

    // Normaliser la direction
    this.config.baseDirection.normalize();

    this.windState = {
      baseDirection: this.config.baseDirection.clone(),
      baseSpeed: this.config.baseSpeed,
      turbulence: this.config.turbulenceIntensity,
      gustFrequency: this.config.gustFrequency,
      gustAmplitude: this.config.gustAmplitude,
      time: 0
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('WindSystem initialized', 'WindSystem');
  }

  update(context: SimulationContext): void {
    // Mise √† jour p√©riodique pour √©viter les calculs trop fr√©quents
    if (context.totalTime - this.lastUpdateTime < 1.0 / this.config.updateFrequency) {
      return;
    }

    this.lastUpdateTime = context.totalTime;
    this.windState.time = context.totalTime;

    // Calculer le vent apparent avec turbulence et rafales
    this.updateWindState(context.deltaTime);
  }

  /**
   * Met √† jour l'√©tat du vent avec turbulence et rafales
   */
  private updateWindState(deltaTime: number): void {
    // Direction de base (peut √™tre modifi√©e par des facteurs externes)
    this.windState.baseDirection.copy(this.config.baseDirection);

    // Ajouter turbulence si activ√©e
    if (this.config.turbulenceEnabled) {
      this.addTurbulence(deltaTime);
    }

    // Ajouter rafales si activ√©es
    if (this.config.gustsEnabled) {
      this.addGustEffect(deltaTime);
    }

    // Normaliser la direction apr√®s modifications
    this.windState.baseDirection.normalize();
  }

  /**
   * Ajoute de la turbulence au vent
   */
  private addTurbulence(deltaTime: number): void {
    // G√©n√©rer du bruit pseudo-al√©atoire bas√© sur le temps
    const noiseX = Math.sin(this.windState.time * 2.1) * Math.cos(this.windState.time * 1.3);
    const noiseY = Math.sin(this.windState.time * 1.7) * Math.cos(this.windState.time * 2.4);
    const noiseZ = Math.sin(this.windState.time * 1.9) * Math.cos(this.windState.time * 1.8);

    // Appliquer l'intensit√© de la turbulence
    const turbulenceVector = new THREE.Vector3(noiseX, noiseY, noiseZ);
    turbulenceVector.multiplyScalar(this.config.turbulenceIntensity * 0.1);

    // Ajouter √† la direction
    this.windState.baseDirection.add(turbulenceVector);
  }

  /**
   * Ajoute l'effet des rafales
   */
  private addGustEffect(deltaTime: number): void {
    // Calculer l'amplitude de la rafale actuelle
    const gustPhase = Math.sin(this.windState.time * this.config.gustFrequency * Math.PI * 2);
    const gustStrength = Math.max(0, gustPhase) * this.config.gustAmplitude;

    // Rafales principalement dans la direction du vent
    const gustVector = this.config.baseDirection.clone();
    gustVector.multiplyScalar(gustStrength * 0.1);

    this.windState.baseDirection.add(gustVector);
  }

  /**
   * Calcule le vent apparent √† une position donn√©e
   * @param position Position dans l'espace 3D
   * @param objectVelocity Vitesse de l'objet (pour vent relatif)
   * @returns Vecteur vent apparent
   */
  getApparentWind(position: THREE.Vector3, objectVelocity: THREE.Vector3 = new THREE.Vector3()): THREE.Vector3 {
    // Vent de base
    let wind = this.windState.baseDirection.clone();
    wind.multiplyScalar(this.windState.baseSpeed);

    // Ajouter cisaillement du vent (variation avec l'altitude)
    if (this.config.windShearEnabled) {
      wind = this.applyWindShear(wind, position.y);
    }

    // Vent apparent = vent absolu - vitesse de l'objet
    const apparentWind = wind.clone();
    apparentWind.sub(objectVelocity);

    return apparentWind;
  }

  /**
   * Applique le cisaillement du vent (variation avec l'altitude)
   */
  private applyWindShear(wind: THREE.Vector3, altitude: number): THREE.Vector3 {
    // Le vent augmente avec l'altitude selon une loi logarithmique simplifi√©e
    // En r√©alit√©, c'est plus complexe, mais cette approximation suffit
    const shearFactor = Math.max(0.5, Math.log(Math.max(1, altitude + 1)) * 0.3 + 0.7);

    const shearedWind = wind.clone();
    shearedWind.multiplyScalar(shearFactor);

    return shearedWind;
  }

  /**
   * Obtient l'√©tat actuel du vent
   */
  getWindState(): Readonly<WindState> {
    return this.windState;
  }

  /**
   * Modifie la direction du vent
   */
  setWindDirection(direction: THREE.Vector3): void {
    this.config.baseDirection.copy(direction);
    this.config.baseDirection.normalize();
    this.windState.baseDirection.copy(this.config.baseDirection);
  }

  /**
   * Modifie la vitesse du vent
   */
  setWindSpeed(speed: number): void {
    this.config.baseSpeed = Math.max(0, speed);
    this.windState.baseSpeed = this.config.baseSpeed;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<WindConfig> {
    return this.config;
  }

  reset(): void {
    this.windState.time = 0;
    this.windState.baseDirection.copy(this.config.baseDirection);
    this.windState.baseSpeed = this.config.baseSpeed;
    this.lastUpdateTime = 0;
    this.logger.info('WindSystem reset', 'WindSystem');
  }

  dispose(): void {
    // Pas de ressources sp√©cifiques √† nettoyer
    this.logger.info('WindSystem disposed', 'WindSystem');
  }
}

=== simulation/systems/index.ts ===

/**
 * systems/index.ts - Export des syst√®mes de simulation
 *
 * Point d'entr√©e centralis√© pour tous les syst√®mes de simulation.
 * Permet d'importer facilement tous les syst√®mes depuis un seul endroit.
 */

export { PhysicsSystem, type PhysicsState, type PhysicsConfig } from './PhysicsSystem';
export { WindSystem, type WindState, type WindConfig } from './WindSystem';
export { InputSystem, type InputState, type InputConfig } from './InputSystem';
export { RenderSystem, type RenderState, type RenderConfig } from './RenderSystem';

=== simulation/types/BridleTypes.ts ===

/**
 * BridleTypes.ts - Types et interfaces pour le syst√®me de bridage
 *
 * D√©finit les structures de donn√©es pour les brides du cerf-volant.
 * Les brides relient des points anatomiques du kite (NEZ, INTER, CENTRE)
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */

/**
 * Longueurs physiques des 3 types de brides
 * (identique pour gauche et droite)
 */
export interface BridleLengths {
  /** Longueur bride NEZ ‚Üí CTRL (m√®tres) */
  nez: number;

  /** Longueur bride INTER ‚Üí CTRL (m√®tres) */
  inter: number;

  /** Longueur bride CENTRE ‚Üí CTRL (m√®tres) */
  centre: number;
}

/**
 * Tensions actuelles des 6 brides
 * (3 gauches + 3 droites)
 */
export interface BridleTensions {
  /** Tension bride NEZ gauche (Newtons) */
  leftNez: number;

  /** Tension bride INTER gauche (Newtons) */
  leftInter: number;

  /** Tension bride CENTRE gauche (Newtons) */
  leftCentre: number;

  /** Tension bride NEZ droite (Newtons) */
  rightNez: number;

  /** Tension bride INTER droite (Newtons) */
  rightInter: number;

  /** Tension bride CENTRE droite (Newtons) */
  rightCentre: number;
}

/**
 * D√©finition d'une attache de bride
 * (relie deux points anatomiques du kite)
 */
export interface BridleAttachment {
  /** Nom du point de d√©part (ex: "NEZ", "INTER_GAUCHE") */
  startPoint: string;

  /** Nom du point d'arriv√©e (ex: "CTRL_GAUCHE", "CTRL_DROIT") */
  endPoint: string;

  /** Longueur au repos (m√®tres) */
  length: number;

  /** Identifiant unique (ex: "bridle_left_nez") */
  id: string;
}

/**
 * Type des c√¥t√©s du bridage
 */
export type BridleSide = 'left' | 'right';

/**
 * Type des positions de bride
 */
export type BridlePosition = 'nez' | 'inter' | 'centre';

/**
 * Configuration compl√®te d'une bride (utilis√© par BridleFactory)
 */
export interface BridleConfig {
  /** C√¥t√© de la bride */
  side: BridleSide;

  /** Position de la bride */
  position: BridlePosition;

  /** Longueur (m√®tres) */
  length: number;

  /** Identifiant unique */
  id: string;
}


=== simulation/types/PhysicsTypes.ts ===

/**
 * PhysicsTypes.ts - Types et interfaces pour la physique de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les structures de donn√©es pour l'√©tat du cerf-volant, les forces, les poign√©es, etc.
 *   - Sert √† typer les √©changes entre les modules physiques et de rendu
 *
 * D√©pendances principales :
 *   - Three.js : Pour les vecteurs et quaternions
 *
 * Relation avec les fichiers adjacents :
 *   - WindTypes.ts : D√©finit les types pour le vent
 *   - Tous les modules physiques et de rendu importent PhysicsTypes pour typer les donn√©es
 *
 * Utilisation typique :
 *   - Utilis√© dans PhysicsEngine, AerodynamicsCalculator, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es physiques
 *
 * Voir aussi :
 *   - src/simulation/types/WindTypes.ts
 */
import * as THREE from "three";

/**
 * Types et interfaces pour la physique de la simulation
 */

export interface KiteState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  orientation: THREE.Quaternion;
}

export interface HandlePositions {
  left: THREE.Vector3;
  right: THREE.Vector3;
}

/**
 * Force appliqu√©e sur une surface sp√©cifique du kite
 */
export interface SurfaceForce {
  /** Indice de la surface dans KiteGeometry.SURFACES */
  surfaceIndex: number;
  /** Portance sur cette surface (en Newton) */
  lift: THREE.Vector3;
  /** Tra√Æn√©e sur cette surface (en Newton) */
  drag: THREE.Vector3;
  /** Friction sur cette surface (optionnel, en Newton) */
  friction?: THREE.Vector3;
  /** Force totale (r√©sultante) sur cette surface (en Newton) */
  resultant: THREE.Vector3;
  /** Centre g√©om√©trique de la surface (en coordonn√©es monde) */
  center: THREE.Vector3;
  /** Normale de la surface (en coordonn√©es monde) */
  normal: THREE.Vector3;
  /** Surface en m¬≤ */
  area: number;
}

=== simulation/types/WindTypes.ts ===


/**
 * WindTypes.ts - Types pour le syst√®me de vent de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la structure des param√®tres de vent (vitesse, direction, turbulence)
 *   - Sert √† typer les √©changes entre le simulateur de vent et les autres modules
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par WindSimulator et PhysicsEngine
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsTypes.ts : D√©finit les types pour la physique
 *   - Tous les modules physiques et de rendu importent WindTypes pour typer le vent
 *
 * Utilisation typique :
 *   - Utilis√© dans WindSimulator, PhysicsEngine, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es de vent
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 */

export interface WindParams {
  speed: number; // km/h
  direction: number; // degr√©s
  turbulence: number; // pourcentage
}

=== simulation/types/index.ts ===


/**
 * index.ts - Export centralis√© de tous les types de la simulation Kite
 *
 * R√¥le :
 *   - Centralise l'export des types physiques et de vent
 *   - Permet d'importer tous les types depuis un seul point
 *
 * D√©pendances principales :
 *   - PhysicsTypes.ts : Types pour la physique
 *   - WindTypes.ts : Types pour le vent
 *
 * Relation avec les fichiers adjacents :
 *   - Sert de point d'entr√©e pour tous les imports de types dans le projet
 *
 * Utilisation typique :
 *   - Import√© dans les modules physiques, de rendu, de configuration, etc.
 *   - Facilite la maintenance et la coh√©rence des types
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 *   - src/simulation/types/WindTypes.ts
 */

export * from './PhysicsTypes';
export * from './WindTypes';

=== simulation/ui/UIManager.ts ===

import { PhysicsEngine } from "../physics/PhysicsEngine";
import { CONFIG } from "../config/SimulationConfig";
import { DebugRenderer } from "../rendering/DebugRenderer";
import { KiteGeometry } from "../config/KiteGeometry";

/**
 * Gestionnaire de l'interface utilisateur
 *
 * G√®re les contr√¥les et interactions utilisateur
 */
export class UIManager {
  private physicsEngine: PhysicsEngine;
  private debugRenderer: DebugRenderer;
  private resetCallback: () => void;
  private togglePlayCallback: () => void;

  constructor(
    physicsEngine: PhysicsEngine,
    debugRenderer: DebugRenderer,
    resetCallback: () => void,
    togglePlayCallback: () => void
  ) {
    this.physicsEngine = physicsEngine;
    this.debugRenderer = debugRenderer;
    this.resetCallback = resetCallback;
    this.togglePlayCallback = togglePlayCallback;
    this.setupControls();
  }

  private setupControls(): void {
    const resetBtn = document.getElementById("reset-sim");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.resetCallback();
      });
    }

    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.togglePlayCallback();
      });
    }

    const debugBtn = document.getElementById("debug-physics");
    if (debugBtn) {
      // Initialiser l'√©tat du bouton
      debugBtn.textContent = this.debugRenderer.isDebugMode() ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugRenderer.isDebugMode());

      debugBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.debugRenderer.toggleDebugMode();
      });
    }

    // Activer la classe debug-mode sur le body si debugMode est true
    if (this.debugRenderer.isDebugMode()) {
      document.body.classList.add("debug-mode");
      // Afficher le panneau de debug si le mode debug est activ√©
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        debugPanel.style.display = "block";
      }
    }

    this.setupWindControls();
  }

  private setupWindControls(): void {
    // Configuration des contr√¥les de vent
    const speedSlider = document.getElementById(
      "wind-speed"
    ) as HTMLInputElement;
    const speedValue = document.getElementById("wind-speed-value");
    if (speedSlider && speedValue) {
      speedSlider.value = CONFIG.wind.defaultSpeed.toString();
      speedValue.textContent = `${CONFIG.wind.defaultSpeed} km/h`;

      speedSlider.oninput = () => {
        const speed = parseFloat(speedSlider.value);
        this.physicsEngine.setWindParams({ speed });
        speedValue.textContent = `${speed} km/h`;
      };
    }

    const dirSlider = document.getElementById(
      "wind-direction"
    ) as HTMLInputElement;
    const dirValue = document.getElementById("wind-direction-value");
    if (dirSlider && dirValue) {
      dirSlider.value = CONFIG.wind.defaultDirection.toString();
      dirValue.textContent = `${CONFIG.wind.defaultDirection}¬∞`;

      dirSlider.oninput = () => {
        const direction = parseFloat(dirSlider.value);
        this.physicsEngine.setWindParams({ direction });
        dirValue.textContent = `${direction}¬∞`;
      };
    }

    const turbSlider = document.getElementById(
      "wind-turbulence"
    ) as HTMLInputElement;
    const turbValue = document.getElementById("wind-turbulence-value");
    if (turbSlider && turbValue) {
      turbSlider.value = CONFIG.wind.defaultTurbulence.toString();
      turbValue.textContent = `${CONFIG.wind.defaultTurbulence}%`;

      turbSlider.oninput = () => {
        const turbulence = parseFloat(turbSlider.value);
        this.physicsEngine.setWindParams({ turbulence });
        turbValue.textContent = `${turbulence}%`;
      };
    }

    const lengthSlider = document.getElementById(
      "line-length"
    ) as HTMLInputElement;
    const lengthValue = document.getElementById("line-length-value");
    if (lengthSlider && lengthValue) {
      lengthSlider.value = CONFIG.lines.defaultLength.toString();
      lengthValue.textContent = `${CONFIG.lines.defaultLength}m`;

      lengthSlider.oninput = () => {
        const length = parseFloat(lengthSlider.value);
        this.physicsEngine.setLineLength(length);
        lengthValue.textContent = `${length}m`;
      };
    }

    // Contr√¥les des brides (3 sliders ind√©pendants)
    // R√©cup√©rer les valeurs actuelles depuis le Kite
    const currentBridleLengths = this.physicsEngine.getBridleLengths();
    
    const bridleNezSlider = document.getElementById("bridle-nez") as HTMLInputElement;
    const bridleNezValue = document.getElementById("bridle-nez-value");
    if (bridleNezSlider && bridleNezValue) {
      bridleNezSlider.value = currentBridleLengths.nez.toString();
      bridleNezValue.textContent = `${currentBridleLengths.nez.toFixed(2)}m`;

      bridleNezSlider.oninput = () => {
        const length = parseFloat(bridleNezSlider.value);
        this.physicsEngine.setBridleLength('nez', length);
        bridleNezValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleInterSlider = document.getElementById("bridle-inter") as HTMLInputElement;
    const bridleInterValue = document.getElementById("bridle-inter-value");
    if (bridleInterSlider && bridleInterValue) {
      bridleInterSlider.value = currentBridleLengths.inter.toString();
      bridleInterValue.textContent = `${currentBridleLengths.inter.toFixed(2)}m`;

      bridleInterSlider.oninput = () => {
        const length = parseFloat(bridleInterSlider.value);
        this.physicsEngine.setBridleLength('inter', length);
        bridleInterValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleCentreSlider = document.getElementById("bridle-centre") as HTMLInputElement;
    const bridleCentreValue = document.getElementById("bridle-centre-value");
    if (bridleCentreSlider && bridleCentreValue) {
      bridleCentreSlider.value = currentBridleLengths.centre.toString();
      bridleCentreValue.textContent = `${currentBridleLengths.centre.toFixed(2)}m`;

      bridleCentreSlider.oninput = () => {
        const length = parseFloat(bridleCentreSlider.value);
        this.physicsEngine.setBridleLength('centre', length);
        bridleCentreValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    // Contr√¥les de damping physique
    const linearDampingSlider = document.getElementById(
      "linear-damping"
    ) as HTMLInputElement;
    const linearDampingValue = document.getElementById("linear-damping-value");
    if (linearDampingSlider && linearDampingValue) {
      linearDampingSlider.value = CONFIG.physics.linearDampingCoeff.toString();
      linearDampingValue.textContent = CONFIG.physics.linearDampingCoeff.toFixed(2);

      linearDampingSlider.oninput = () => {
        const damping = parseFloat(linearDampingSlider.value);
        CONFIG.physics.linearDampingCoeff = damping;
        linearDampingValue.textContent = damping.toFixed(2);
      };
    }

    const angularDampingSlider = document.getElementById(
      "angular-damping"
    ) as HTMLInputElement;
    const angularDampingValue = document.getElementById("angular-damping-value");
    if (angularDampingSlider && angularDampingValue) {
      angularDampingSlider.value = CONFIG.physics.angularDragFactor.toString();
      angularDampingValue.textContent = CONFIG.physics.angularDragFactor.toFixed(2);

      angularDampingSlider.oninput = () => {
        const dragFactor = parseFloat(angularDampingSlider.value);
        CONFIG.physics.angularDragFactor = dragFactor;
        angularDampingValue.textContent = dragFactor.toFixed(2);
      };
    }

    // üîß Contr√¥le du niveau de subdivision du maillage
    const meshLevelSlider = document.getElementById(
      "mesh-subdivision-level"
    ) as HTMLInputElement;
    const meshLevelValue = document.getElementById("mesh-subdivision-level-value");
    if (meshLevelSlider && meshLevelValue) {
      meshLevelSlider.value = CONFIG.kite.defaultMeshSubdivisionLevel.toString();
      meshLevelValue.textContent = `${CONFIG.kite.defaultMeshSubdivisionLevel} (${Math.pow(4, CONFIG.kite.defaultMeshSubdivisionLevel + 1)} triangles)`;

      meshLevelSlider.oninput = () => {
        const level = parseInt(meshLevelSlider.value);
        CONFIG.kite.defaultMeshSubdivisionLevel = level;
        KiteGeometry.setMeshSubdivisionLevel(level);
        const triangleCount = Math.pow(4, level + 1);
        meshLevelValue.textContent = `${level} (${triangleCount} triangles)`;
        console.log(`üîß Maillage chang√© : niveau ${level} = ${triangleCount} triangles`);
      };
    }

    // Contr√¥les a√©rodynamiques
    const liftScaleSlider = document.getElementById(
      "lift-scale"
    ) as HTMLInputElement;
    const liftScaleValue = document.getElementById("lift-scale-value");
    if (liftScaleSlider && liftScaleValue) {
      liftScaleSlider.value = CONFIG.aero.liftScale.toString();
      liftScaleValue.textContent = CONFIG.aero.liftScale.toFixed(2);

      liftScaleSlider.oninput = () => {
        const scale = parseFloat(liftScaleSlider.value);
        CONFIG.aero.liftScale = scale;
        liftScaleValue.textContent = scale.toFixed(2);
      };
    }

    const dragScaleSlider = document.getElementById(
      "drag-scale"
    ) as HTMLInputElement;
    const dragScaleValue = document.getElementById("drag-scale-value");
    if (dragScaleSlider && dragScaleValue) {
      dragScaleSlider.value = CONFIG.aero.dragScale.toString();
      dragScaleValue.textContent = CONFIG.aero.dragScale.toFixed(2);

      dragScaleSlider.oninput = () => {
        const scale = parseFloat(dragScaleSlider.value);
        CONFIG.aero.dragScale = scale;
        dragScaleValue.textContent = scale.toFixed(2);
      };
    }

    // Contr√¥le du lissage des forces physiques
    const forceSmoothingSlider = document.getElementById(
      "force-smoothing"
    ) as HTMLInputElement;
    const forceSmoothingValue = document.getElementById("force-smoothing-value");
    if (forceSmoothingSlider && forceSmoothingValue) {
      forceSmoothingSlider.value = this.physicsEngine.getForceSmoothing().toString();
      forceSmoothingValue.textContent = this.physicsEngine.getForceSmoothing().toFixed(2);

      forceSmoothingSlider.oninput = () => {
        const smoothing = parseFloat(forceSmoothingSlider.value);
        this.physicsEngine.setForceSmoothing(smoothing);
        forceSmoothingValue.textContent = smoothing.toFixed(2);
      };
    }
  }

  updatePlayButton(isPlaying: boolean): void {
    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.textContent = isPlaying ? "‚è∏Ô∏è Pause" : "‚ñ∂Ô∏è Lancer";
    }
  }
}

=== types/index.ts ===

/**
 * Types centralis√©s pour le syst√®me de visualisation 3D
 * Interface unique et coh√©rente pour tous les objets
 */

import * as THREE from 'three';

/**
 * Position 3D simple [x, y, z]
 */
export type Position3D = [number, number, number];

/**
 * Interface principale que TOUS les objets doivent impl√©menter
 * üéÆ v3.0: Compatible avec l'architecture StructuredObject + Node3D
 */
export interface ICreatable {
  /**
   * Retourne l'objet lui-m√™me (StructuredObject h√©rite de Node3D)
   * Pattern fluent pour la nouvelle architecture
   */
  create(): this;

  /**
   * Nom affich√© dans l'interface utilisateur
   */
  getName(): string;

  /**
   * Description courte de l'objet
   */
  getDescription(): string;

  /**
   * Nombre de primitives utilis√©es (pour statistiques)
   */
  getPrimitiveCount(): number;
}

/**
 * Options pour cr√©er des surfaces
 */
export interface SurfaceOptions {
  color?: string;
  transparent?: boolean;
  opacity?: number;
  doubleSide?: boolean;
  wireframe?: boolean;
}

/**
 * Configuration pour les mat√©riaux
 */
export interface MaterialConfig {
  color: string;
  transparent?: boolean;
  opacity?: number;
  metalness?: number;
  roughness?: number;
  side?: THREE.Side;
}

/**
 * Interface pour un point nomm√© dans l'espace 3D
 */
export interface NamedPoint {
  name: string;
  position: THREE.Vector3;
  visible?: boolean;
}

/**
 * M√©tadonn√©es optionnelles pour les objets
 */
export interface ObjectMetadata {
  category?: string;
  complexity?: 'simple' | 'medium' | 'complex';
  tags?: string[];
  author?: string;
  version?: string;
}

=== utils/GeometryUtils.ts ===

/**
 * GeometryUtils.ts - Utilitaires g√©om√©triques pour la simulation 3D
 */

import * as THREE from 'three';

export class GeometryUtils {
  /**
   * Calcule l'aire d'un triangle 3D
   */
  static triangleArea(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): number {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const cross = edge1.cross(edge2);
    return cross.length() * 0.5;
  }

  /**
   * Calcule la normale d'un triangle
   */
  static triangleNormal(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    return edge1.cross(edge2).normalize();
  }

  /**
   * Calcule le centro√Øde d'un triangle
   */
  static triangleCentroid(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    return v1.clone().add(v2).add(v3).divideScalar(3);
  }

  /**
   * V√©rifie si un point est √† l'int√©rieur d'un triangle (dans le plan)
   */
  static pointInTriangle2D(point: THREE.Vector2, v1: THREE.Vector2, v2: THREE.Vector2, v3: THREE.Vector2): boolean {
    const d1 = this.sign(point, v1, v2);
    const d2 = this.sign(point, v2, v3);
    const d3 = this.sign(point, v3, v1);

    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(hasNeg && hasPos);
  }

  /**
   * Calcule le barycentre d'un ensemble de points
   */
  static centroid(points: THREE.Vector3[]): THREE.Vector3 {
    if (points.length === 0) return new THREE.Vector3();

    const sum = points.reduce((acc, point) => acc.add(point), new THREE.Vector3());
    return sum.divideScalar(points.length);
  }

  /**
   * Calcule la bounding box d'un ensemble de points
   */
  static boundingBox(points: THREE.Vector3[]): { min: THREE.Vector3; max: THREE.Vector3 } {
    if (points.length === 0) {
      return { min: new THREE.Vector3(), max: new THREE.Vector3() };
    }

    const min = points[0].clone();
    const max = points[0].clone();

    for (let i = 1; i < points.length; i++) {
      min.min(points[i]);
      max.max(points[i]);
    }

    return { min, max };
  }

  /**
   * Projette un point sur un plan d√©fini par un point et une normale
   */
  static projectPointOnPlane(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): THREE.Vector3 {
    const toPoint = point.clone().sub(planePoint);
    const distance = toPoint.dot(planeNormal);
    return point.clone().sub(planeNormal.clone().multiplyScalar(distance));
  }

  /**
   * Calcule la distance d'un point √† un plan
   */
  static pointToPlaneDistance(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): number {
    const toPoint = point.clone().sub(planePoint);
    return toPoint.dot(planeNormal);
  }

  /**
   * V√©rifie si deux segments se croisent (2D)
   */
  static segmentsIntersect2D(
    a1: THREE.Vector2, a2: THREE.Vector2,
    b1: THREE.Vector2, b2: THREE.Vector2
  ): boolean {
    const denom = (a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x);
    if (Math.abs(denom) < 1e-6) return false; // Parall√®les

    const t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x)) / denom;
    const u = -((a1.x - a2.x) * (a1.y - b1.y) - (a1.y - a2.y) * (a1.x - b1.x)) / denom;

    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }

  /**
   * Calcule l'angle solide d'un triangle vu depuis un point
   */
  static solidAngle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3, viewpoint: THREE.Vector3): number {
    const a = v1.clone().sub(viewpoint).normalize();
    const b = v2.clone().sub(viewpoint).normalize();
    const c = v3.clone().sub(viewpoint).normalize();

    const numerator = Math.abs(a.dot(b.cross(c)));
    const denominator = 1 + a.dot(b) + b.dot(c) + c.dot(a);
    return 2 * Math.atan2(numerator, denominator);
  }

  /**
   * G√©n√®re des points sur une sph√®re
   */
  static fibonacciSphere(samples: number, radius: number = 1): THREE.Vector3[] {
    const points: THREE.Vector3[] = [];
    const phi = Math.PI * (3 - Math.sqrt(5)); // Angle d'or

    for (let i = 0; i < samples; i++) {
      const y = 1 - (i / (samples - 1)) * 2; // y entre -1 et 1
      const radiusAtY = Math.sqrt(1 - y * y);

      const theta = phi * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      points.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
    }

    return points;
  }

  /**
   * Fonction auxiliaire pour pointInTriangle2D
   */
  private static sign(p1: THREE.Vector2, p2: THREE.Vector2, p3: THREE.Vector2): number {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  }
}

=== utils/Logging.ts ===

/**
 * Logging.ts - Syst√®me de logging configurable pour la simulation
 */

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: number;
  category?: string;
  data?: any;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.INFO;
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;
  private categories: Set<string> = new Set();

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Configure le niveau de log minimum
   */
  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }

  /**
   * Active/d√©sactive une cat√©gorie de logs
   */
  setCategoryEnabled(category: string, enabled: boolean): void {
    if (enabled) {
      this.categories.add(category);
    } else {
      this.categories.delete(category);
    }
  }

  /**
   * Log de debug
   */
  debug(message: string, category?: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, category, data);
  }

  /**
   * Log d'information
   */
  info(message: string, category?: string, data?: any): void {
    this.log(LogLevel.INFO, message, category, data);
  }

  /**
   * Log d'avertissement
   */
  warn(message: string, category?: string, data?: any): void {
    this.log(LogLevel.WARN, message, category, data);
  }

  /**
   * Log d'erreur
   */
  error(message: string, category?: string, data?: any): void {
    this.log(LogLevel.ERROR, message, category, data);
  }

  /**
   * Log g√©n√©rique
   */
  private log(level: LogLevel, message: string, category?: string, data?: any): void {
    // V√©rifier le niveau
    if (level < this.logLevel) return;

    // V√©rifier la cat√©gorie si sp√©cifi√©e
    if (category && !this.categories.has(category)) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: Date.now(),
      category,
      data
    };

    // Ajouter aux logs internes
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift(); // Supprimer le plus ancien
    }

    // Afficher dans la console selon le niveau
    const prefix = category ? `[${category}]` : '';
    const formattedMessage = `${prefix} ${message}`;

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`üêõ ${formattedMessage}`, data || '');
        break;
      case LogLevel.INFO:
        console.info(`‚ÑπÔ∏è ${formattedMessage}`, data || '');
        break;
      case LogLevel.WARN:
        console.warn(`‚ö†Ô∏è ${formattedMessage}`, data || '');
        break;
      case LogLevel.ERROR:
        console.error(`‚ùå ${formattedMessage}`, data || '');
        break;
    }
  }

  /**
   * Obtient tous les logs
   */
  getLogs(level?: LogLevel, category?: string): LogEntry[] {
    return this.logs.filter(entry => {
      if (level !== undefined && entry.level < level) return false;
      if (category && entry.category !== category) return false;
      return true;
    });
  }

  /**
   * Obtient les derniers logs
   */
  getRecentLogs(count: number = 10): LogEntry[] {
    return this.logs.slice(-count);
  }

  /**
   * Efface tous les logs
   */
  clearLogs(): void {
    this.logs = [];
  }

  /**
   * Exporte les logs au format JSON
   */
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * Importe des logs depuis JSON
   */
  importLogs(json: string): void {
    try {
      const imported = JSON.parse(json) as LogEntry[];
      this.logs.push(...imported);
      // Garder seulement les maxLogs plus r√©cents
      if (this.logs.length > this.maxLogs) {
        this.logs = this.logs.slice(-this.maxLogs);
      }
    } catch (error) {
      this.error('Erreur lors de l\'import des logs', 'Logger', error);
    }
  }

  /**
   * Statistiques des logs
   */
  getStats(): {
    total: number;
    byLevel: Record<LogLevel, number>;
    byCategory: Record<string, number>;
  } {
    const byLevel = {
      [LogLevel.DEBUG]: 0,
      [LogLevel.INFO]: 0,
      [LogLevel.WARN]: 0,
      [LogLevel.ERROR]: 0,
      [LogLevel.NONE]: 0
    };

    const byCategory: Record<string, number> = {};

    for (const entry of this.logs) {
      byLevel[entry.level]++;

      if (entry.category) {
        byCategory[entry.category] = (byCategory[entry.category] || 0) + 1;
      }
    }

    return {
      total: this.logs.length,
      byLevel,
      byCategory
    };
  }
}

// Instance globale pour utilisation facile
export const log = Logger.getInstance();

=== utils/MathUtils.ts ===

/**
 * MathUtils.ts - Utilitaires math√©matiques pour la simulation 3D
 */

import * as THREE from 'three';

export class MathUtils {
  /**
   * Clamp une valeur entre min et max
   */
  static clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }

  /**
   * Interpolation lin√©aire
   */
  static lerp(a: number, b: number, t: number): number {
    return a + (b - a) * MathUtils.clamp(t, 0, 1);
  }

  /**
   * Interpolation sph√©rique (pour les rotations)
   */
  static slerp(q1: THREE.Quaternion, q2: THREE.Quaternion, t: number): THREE.Quaternion {
    return new THREE.Quaternion().slerpQuaternions(q1, q2, MathUtils.clamp(t, 0, 1));
  }

  /**
   * Distance euclidienne entre deux points 3D
   */
  static distance(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceTo(p2);
  }

  /**
   * Distance au carr√© (plus rapide pour les comparaisons)
   */
  static distanceSquared(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceToSquared(p2);
  }

  /**
   * Angle entre deux vecteurs (en radians)
   */
  static angleBetween(v1: THREE.Vector3, v2: THREE.Vector3): number {
    return v1.angleTo(v2);
  }

  /**
   * Projection d'un vecteur sur un autre
   */
  static project(v: THREE.Vector3, onto: THREE.Vector3): THREE.Vector3 {
    const ontoNormalized = onto.clone().normalize();
    return ontoNormalized.multiplyScalar(v.dot(ontoNormalized));
  }

  /**
   * Composante perpendiculaire d'un vecteur par rapport √† un autre
   */
  static perpendicular(v: THREE.Vector3, to: THREE.Vector3): THREE.Vector3 {
    return v.clone().sub(this.project(v, to));
  }

  /**
   * V√©rifie si un nombre est proche de z√©ro
   */
  static isZero(value: number, epsilon: number = 1e-6): boolean {
    return Math.abs(value) < epsilon;
  }

  /**
   * V√©rifie si deux nombres sont √©gaux avec une tol√©rance
   */
  static equals(a: number, b: number, epsilon: number = 1e-6): boolean {
    return Math.abs(a - b) < epsilon;
  }

  /**
   * G√©n√®re un nombre al√©atoire entre min et max
   */
  static random(min: number = 0, max: number = 1): number {
    return Math.random() * (max - min) + min;
  }

  /**
   * Convertit degr√©s en radians
   */
  static degToRad(degrees: number): number {
    return degrees * Math.PI / 180;
  }

  /**
   * Convertit radians en degr√©s
   */
  static radToDeg(radians: number): number {
    return radians * 180 / Math.PI;
  }

  /**
   * Normalise un angle en radians entre -PI et PI
   */
  static normalizeAngle(angle: number): number {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  /**
   * Interpolation smoothstep (plus douce que lerp)
   */
  static smoothstep(edge0: number, edge1: number, x: number): number {
    const t = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }

  /**
   * Fonction de easing (ease-in-out)
   */
  static easeInOut(t: number): number {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
}

=== utils/UidGenerator.ts ===

/**
 * UidGenerator.ts - G√©n√©rateur d'identifiants uniques
 */

export class UidGenerator {
  private static counter = 0;
  private static readonly chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  /**
   * G√©n√®re un UID simple bas√© sur timestamp et compteur
   */
  static generate(prefix: string = ''): string {
    const timestamp = Date.now().toString(36);
    const count = (this.counter++).toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `${prefix}${timestamp}${count}${random}`;
  }

  /**
   * G√©n√®re un UID court (8 caract√®res)
   */
  static generateShort(): string {
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += this.chars.charAt(Math.floor(Math.random() * this.chars.length));
    }
    return result;
  }

  /**
   * G√©n√®re un UID bas√© sur des propri√©t√©s d'objet
   */
  static generateFromObject(obj: any, properties: string[]): string {
    let hash = 0;
    const str = properties.map(prop => obj[prop] || '').join('|');

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }

  /**
   * G√©n√®re un UUID v4 standard
   */
  static generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * G√©n√®re un ID s√©quentiel
   */
  static generateSequential(prefix: string = 'id_'): string {
    return `${prefix}${(this.counter++).toString().padStart(6, '0')}`;
  }

  /**
   * R√©initialise le compteur (utile pour les tests)
   */
  static reset(): void {
    this.counter = 0;
  }

  /**
   * V√©rifie si une cha√Æne est un UID valide (format de base)
   */
  static isValid(uid: string): boolean {
    // V√©rification basique : contient des lettres, chiffres, et fait une longueur raisonnable
    return /^[A-Za-z0-9_-]{8,}$/.test(uid);
  }

  /**
   * G√©n√®re un hash simple d'une cha√Æne
   */
  static hashString(str: string): string {
    let hash = 0;
    if (str.length === 0) return hash.toString(36);

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }
}

