CONSOLIDATION DES SOURCES - Sun Oct 12 09:27:50 UTC 2025
==================================

=== base/BaseComponent.ts ===

/**
 * BaseComponent.ts - Syst√®me de composants pour les objets 3D
 *
 * Pattern : Component Pattern (similaire √† Unity/ECS)
 * Permet d'ajouter des fonctionnalit√©s optionnelles aux Node3D
 * sans h√©riter de classes lourdes.
 */

import { Node3D } from '../core/Node3D';

export interface ComponentContext {
  deltaTime: number;
  totalTime: number;
  parent: Node3D;
}

export abstract class BaseComponent {
  protected name: string;
  protected enabled: boolean = true;
  protected parent?: Node3D;

  constructor(name: string) {
    this.name = name;
  }

  /**
   * Attache le composant √† un parent
   */
  attachTo(parent: Node3D): void {
    this.parent = parent;
    this.onAttach();
  }

  /**
   * D√©tache le composant de son parent
   */
  detach(): void {
    this.onDetach();
    this.parent = undefined;
  }

  /**
   * Appel√© quand le composant est attach√©
   */
  protected onAttach(): void {
    // Override dans les sous-classes
  }

  /**
   * Appel√© quand le composant est d√©tach√©
   */
  protected onDetach(): void {
    // Override dans les sous-classes
  }

  /**
   * Met √† jour le composant
   */
  abstract update(context: ComponentContext): void;

  /**
   * Active/d√©sactive le composant
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getParent(): Node3D | undefined {
    return this.parent;
  }
}

/**
 * Composant de debug visuel
 */
export class DebugComponent extends BaseComponent {
  update(_context: ComponentContext): void {
    // Logique de debug visuel
  }
}

/**
 * Composant de physique
 */
export class PhysicsComponent extends BaseComponent {
  update(_context: ComponentContext): void {
    // Logique de physique
  }
}

=== base/BaseFactory.ts ===

/**
 * BaseFactory.ts - Factory abstraite pour tous les objets 3D
 * 
 * Pattern Factory Method avec support des param√®tres configurables
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export type FactoryParams = Record<string, unknown>;

export interface ObjectMetadata {
  category: string;
  name: string;
  description: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'complex';
}

/**
 * Factory abstraite pour la cr√©ation d'objets 3D
 */
export abstract class BaseFactory<T extends StructuredObject & ICreatable> {
  protected abstract metadata: ObjectMetadata;

  /**
   * Cr√©er un objet avec des param√®tres optionnels
   */
  abstract createObject(params?: FactoryParams): T | Promise<T>;

  /**
   * Obtenir les m√©tadonn√©es de l'objet
   */
  getMetadata(): ObjectMetadata {
    return { ...this.metadata };
  }

  /**
   * Obtenir la cat√©gorie de l'objet
   */
  getCategory(): string {
    return this.metadata.category;
  }

  /**
   * Obtenir le nom de l'objet
   */
  getName(): string {
    return this.metadata.name;
  }

  /**
   * Valider les param√®tres avant cr√©ation
   */
  protected validateParams(params?: FactoryParams): void {
    // Validation de base - √† surcharger dans les classes d√©riv√©es
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value === null || value === undefined) {
          throw new Error(`Param√®tre '${key}' ne peut pas √™tre null ou undefined`);
        }
      });
    }
  }

  /**
   * Param√®tres par d√©faut - √† surcharger dans les classes d√©riv√©es
   */
  protected getDefaultParams(): FactoryParams {
    return {};
  }

  /**
   * Fusionner les param√®tres par d√©faut avec les param√®tres fournis
   */
  protected mergeParams(params?: FactoryParams): FactoryParams {
    return {
      ...this.getDefaultParams(),
      ...params
    };
  }

  /**
   * Nettoyer les ressources de la factory
   */
  dispose(): void {
    // √Ä surcharger dans les classes d√©riv√©es si n√©cessaire
  }
}


=== base/BaseSimulationSystem.ts ===

/**
 * BaseSimulationSystem.ts - Interface de base pour tous les syst√®mes de simulation
 *
 * Pattern : Template Method pour les syst√®mes de simulation
 * Chaque syst√®me (Physics, Wind, Input, etc.) h√©rite de cette classe
 * et impl√©mente ses m√©thodes sp√©cifiques.
 */

export interface SimulationContext {
  deltaTime: number;
  totalTime: number;
  isPaused: boolean;
  debugMode: boolean;
}

export abstract class BaseSimulationSystem {
  protected name: string;
  protected enabled: boolean = true;
  protected priority: number = 0; // Ordre d'ex√©cution (plus petit = plus prioritaire)

  constructor(name: string, priority: number = 0) {
    this.name = name;
    this.priority = priority;
  }

  /**
   * Initialise le syst√®me (appel√© une fois au d√©marrage)
   */
  abstract initialize(): void;

  /**
   * Met √† jour le syst√®me (appel√© chaque frame)
   */
  abstract update(context: SimulationContext): void;

  /**
   * R√©initialise le syst√®me √† son √©tat initial
   */
  abstract reset(): void;

  /**
   * Nettoie les ressources du syst√®me
   */
  abstract dispose(): void;

  /**
   * Active/d√©sactive le syst√®me
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getPriority(): number {
    return this.priority;
  }

  /**
   * Validation interne du syst√®me
   */
  validate(): boolean {
    return true; // Override dans les sous-classes si n√©cessaire
  }
}

=== core/DebugLayer.ts ===

/**
 * DebugLayer.ts - Couche de debug visuel pour les objets 3D
 *
 * R√¥le : Gestion centralis√©e de tous les √©l√©ments de debug visuel
 * S√©pare compl√®tement la logique de debug du mesh principal
 */

import * as THREE from 'three';

import { Node3D } from './Node3D';

export interface DebugOptions {
  showPoints?: boolean;
  showLabels?: boolean;
  showAxes?: boolean;
  showNormals?: boolean;
  pointSize?: number;
  labelSize?: number;
  axisLength?: number;
}

export class DebugLayer {
  public group: THREE.Group;
  private parent: Node3D;
  private options: DebugOptions;
  private pointsGroup: THREE.Group;
  private labelsGroup: THREE.Group;
  private axesGroup: THREE.Group;
  private normalsGroup: THREE.Group;

  constructor(parent: Node3D, options: DebugOptions = {}) {
    this.parent = parent;
    this.options = {
      showPoints: false,
      showLabels: false,
      showAxes: false,
      showNormals: false,
      pointSize: 0.05,
      labelSize: 0.1,
      axisLength: 1.0,
      ...options
    };

    this.group = new THREE.Group();
    this.group.name = `${parent.name}_debug`;

    this.pointsGroup = new THREE.Group();
    this.pointsGroup.name = 'points';
    this.group.add(this.pointsGroup);

    this.labelsGroup = new THREE.Group();
    this.labelsGroup.name = 'labels';
    this.group.add(this.labelsGroup);

    this.axesGroup = new THREE.Group();
    this.axesGroup.name = 'axes';
    this.group.add(this.axesGroup);

    this.normalsGroup = new THREE.Group();
    this.normalsGroup.name = 'normals';
    this.group.add(this.normalsGroup);

    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des points
   */
  setShowPoints(show: boolean): void {
    this.options.showPoints = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des labels
   */
  setShowLabels(show: boolean): void {
    this.options.showLabels = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des axes
   */
  setShowAxes(show: boolean): void {
    this.options.showAxes = show;
    this.updateVisibility();
  }

  /**
   * Active/d√©sactive l'affichage des normales
   */
  setShowNormals(show: boolean): void {
    this.options.showNormals = show;
    this.updateVisibility();
  }

  /**
   * Ajoute un point de debug
   */
  addPoint(position: THREE.Vector3, color: number = 0xff0000, name?: string): void {
    const geometry = new THREE.SphereGeometry(this.options.pointSize, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const point = new THREE.Mesh(geometry, material);

    point.position.copy(position);
    if (name) point.name = name;

    this.pointsGroup.add(point);
  }

  /**
   * Ajoute une √©tiquette de debug
   */
  addLabel(position: THREE.Vector3, text: string, color: number = 0xffffff): void {
    // Note: Pour une vraie impl√©mentation, il faudrait une biblioth√®que de texte 3D
    // Pour l'instant, on utilise un point color√© avec le nom
    const geometry = new THREE.SphereGeometry(this.options.labelSize! * 0.5, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const label = new THREE.Mesh(geometry, material);

    label.position.copy(position);
    label.name = text;

    this.labelsGroup.add(label);
  }

  /**
   * Dessine les axes XYZ
   */
  drawAxes(length: number = this.options.axisLength!): void {
    this.clearAxes();

    // Axe X (rouge)
    const xAxis = this.createAxis(new THREE.Vector3(length, 0, 0), 0xff0000);
    this.axesGroup.add(xAxis);

    // Axe Y (vert)
    const yAxis = this.createAxis(new THREE.Vector3(0, length, 0), 0x00ff00);
    this.axesGroup.add(yAxis);

    // Axe Z (bleu)
    const zAxis = this.createAxis(new THREE.Vector3(0, 0, length), 0x0000ff);
    this.axesGroup.add(zAxis);
  }

  /**
   * Nettoie tous les √©l√©ments de debug
   */
  clear(): void {
    this.clearPoints();
    this.clearLabels();
    this.clearAxes();
    this.clearNormals();
  }

  /**
   * Met √† jour la visibilit√© selon les options
   */
  private updateVisibility(): void {
    this.pointsGroup.visible = this.options.showPoints!;
    this.labelsGroup.visible = this.options.showLabels!;
    this.axesGroup.visible = this.options.showAxes!;
    this.normalsGroup.visible = this.options.showNormals!;
  }

  private createAxis(direction: THREE.Vector3, color: number): THREE.Group {
    const group = new THREE.Group();

    // Ligne de l'axe
    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      direction
    ]);
    const material = new THREE.LineBasicMaterial({ color });
    const line = new THREE.Line(geometry, material);
    group.add(line);

    // Fl√®che √† l'extr√©mit√©
    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ color });
    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    arrow.position.copy(direction);
    arrow.lookAt(direction);
    group.add(arrow);

    return group;
  }

  private clearPoints(): void {
    while (this.pointsGroup.children.length > 0) {
      const child = this.pointsGroup.children[0];
      this.pointsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearLabels(): void {
    while (this.labelsGroup.children.length > 0) {
      const child = this.labelsGroup.children[0];
      this.labelsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearAxes(): void {
    while (this.axesGroup.children.length > 0) {
      const child = this.axesGroup.children[0];
      this.axesGroup.remove(child);
      // Nettoyer r√©cursivement les g√©om√©tries et mat√©riaux
      child.traverse((obj) => {
        if (obj instanceof THREE.Mesh) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        } else if (obj instanceof THREE.Line) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        }
      });
    }
  }

  private clearNormals(): void {
    while (this.normalsGroup.children.length > 0) {
      const child = this.normalsGroup.children[0];
      this.normalsGroup.remove(child);
      if (child instanceof THREE.Line) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }
}

=== core/Node3D.ts ===


/**
 * Node3D.ts - Couche d'abstraction Godot-compatible pour la simulation Kite
 *
 * R√¥le :
 *   - Encapsule THREE.Group avec une API similaire √† Godot
 *   - Fournit des propri√©t√©s et m√©thodes compatibles avec le moteur Godot
 *   - Sert de base √† StructuredObject et √† tous les objets 3D du projet
 *
 * D√©pendances principales :
 *   - Three.js : Pour la gestion des groupes et transformations 3D
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) h√©rite de Node3D
 *   - Tous les objets 3D du projet h√©ritent indirectement de Node3D
 *
 * Utilisation typique :
 *   - Sert de base √† la hi√©rarchie d'objets 3D
 *   - Permet la compatibilit√© avec Godot pour la portabilit√©
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { SceneManager } from './SceneManager';

/**
 * Transform3D compatible Godot
 */
export interface Transform3D {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    scale: THREE.Vector3;
}

/**
 * Signal basique pour la communication entre nodes
 */
export interface Signal {
    name: string;
    callbacks: Array<{ target: Node3D; method: string }>;
}

/**
 * Node3D - √âquivalent du Node3D de Godot
 * H√©rite de THREE.Group pour la compatibilit√©
 */
export class Node3D extends THREE.Group {
    // üéÆ Propri√©t√©s Godot-like
    public transform: Transform3D;
    public signals: Map<string, Signal> = new Map();
    
    // üè∑Ô∏è M√©tadonn√©es
    public readonly nodeId: string;
    public nodeType: string = 'Node3D';
    
    // üîß √âtat interne
    protected isReady: boolean = false;
    protected active: boolean = true;

    constructor(name: string = 'Node3D') {
        super();
        this.name = name;
        this.nodeId = this.generateNodeId();

        // Transform3D unifi√©
        this.transform = {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale
        };

        // Auto-enregistrement dans SceneManager
        SceneManager.getInstance().register(this);

        // Auto-initialisation
        this.callReady();
    }
    
    /**
     * G√©n√®re un ID unique pour le node (compatible Godot)
     */
    private generateNodeId(): string {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `node_${timestamp}_${random}`;
    }
    
    // === üéÆ M√©thodes Cycle de Vie Godot ===
    
    /**
     * _ready() - Appel√© une seule fois quand le node est ajout√© √† la sc√®ne
     */
    protected _ready(): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _process() - Appel√© √† chaque frame
     */
    protected _process(_delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _physics_process() - Appel√© √† chaque frame physique
     */
    protected _physics_process(_delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * Appel automatique de _ready()
     */
    private callReady(): void {
        if (!this.isReady) {
            this.isReady = true;
            this._ready();
        }
    }
    
    // === üîó Gestion des Signaux ===
    
    /**
     * D√©finit un signal (√©quivalent signal en GDScript)
     */
    public define_signal(name: string): void {
        if (!this.signals.has(name)) {
            this.signals.set(name, {
                name,
                callbacks: []
            });
        }
    }
    
    /**
     * √âmet un signal
     */
    public emit_signal(name: string, ...args: any[]): void {
        const signal = this.signals.get(name);
        if (signal) {
            signal.callbacks.forEach(callback => {
                const method = (callback.target as any)[callback.method];
                if (typeof method === 'function') {
                    method.call(callback.target, ...args);
                }
            });
        }
    }
    
    /**
     * Connecte un signal √† une m√©thode
     */
    public connect(signal: string, target: Node3D, method: string): void {
        if (!this.signals.has(signal)) {
            this.define_signal(signal);
        }
        
        const signalObj = this.signals.get(signal)!;
        signalObj.callbacks.push({ target, method });
    }
    
    // === üå≥ Gestion de l'Arbre de Nodes ===
    
    /**
     * Ajoute un enfant (compatible Godot)
     */
    public add_child(child: Node3D): void {
        this.add(child);
        child.callReady();
    }
    
    /**
     * Retire un enfant
     */
    public remove_child(child: Node3D): void {
        this.remove(child);
    }
    
    /**
     * Trouve un enfant par nom
     */
    public get_node(path: string): Node3D | null {
        return this.getObjectByName(path) as Node3D || null;
    }
    
    /**
     * Trouve tous les enfants d'un type donn√©
     */
    public get_children_of_type<T extends Node3D>(type: new (...args: any[]) => T): T[] {
        const result: T[] = [];
        this.traverse((obj) => {
            if (obj instanceof type) {
                result.push(obj);
            }
        });
        return result;
    }
    
    // === üîÑ Mise √† Jour du Cycle de Vie ===
    
    /**
     * Met √† jour le node et tous ses enfants
     */
    public update(delta: number): void {
        if (this.isReady) {
            this._process(delta);
            this._physics_process(delta);
            
            // Mettre √† jour les enfants Node3D
            this.children.forEach(child => {
                if (child instanceof Node3D) {
                    child.update(delta);
                }
            });
        }
    }
    
    /**
     * Active/d√©sactive le node
     */
    public setActive(active: boolean): void {
        this.active = active;
    }

    /**
     * V√©rifie si le node est actif
     */
    public isActive(): boolean {
        return this.active;
    }

    /**
     * Obtient le nom du node
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Appel√© quand le node est enregistr√© dans SceneManager
     */
    public onRegister(): void {
        // √Ä overrider dans les sous-classes
    }

    /**
     * Appel√© quand le node est d√©senregistr√© de SceneManager
     */
    public onUnregister(): void {
        // √Ä overrider dans les sous-classes
    }

    /**
     * D√©truit le node et nettoie les ressources
     */
    public destroy(): void {
        // D√©senregistrer du SceneManager
        SceneManager.getInstance().unregister(this);

        // Nettoyer les signaux
        this.signals.clear();

        // Nettoyer les enfants
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.destroy();
            }
        });

        // Nettoyer Three.js
        this.clear();
    }
    
    // === üè∑Ô∏è M√©tadonn√©es et Debug ===
    
    /**
     * Retourne une description du node
     */
    public get_description(): string {
        return `${this.nodeType}:${this.name} (${this.nodeId})`;
    }
    
    /**
     * Affiche l'arbre des nodes (debug)
     */
    public print_tree(indent: number = 0): void {
        const spaces = '  '.repeat(indent);
        console.log(`${spaces}${this.get_description()}`);
        
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.print_tree(indent + 1);
            }
        });
    }
    
    // === üéØ Compatibilit√© Three.js ===
    
    /**
     * Acc√®s direct au transform Three.js
     */
    public get three_transform() {
        return {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale,
            matrix: this.matrix,
            matrixWorld: this.matrixWorld
        };
    }
}


=== core/Primitive.ts ===


/**
 * Primitive.ts - G√©n√©rateurs de primitives Three.js pour la simulation Kite
 *
 * R√¥le :
 *   - Fournit des utilitaires pour cr√©er les formes de base (cube, sph√®re, cylindre, etc.)
 *   - Permet de g√©n√©rer des mat√©riaux coh√©rents pour les objets 3D
 *   - Sert √† la construction des objets structur√©s (cerf-volant, barre, etc.)
 *
 * D√©pendances principales :
 *   - Three.js : Pour la g√©om√©trie et les mat√©riaux
 *   - Types : MaterialConfig pour la configuration des mat√©riaux
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) utilise Primitive pour cr√©er les √©l√©ments 3D
 *   - Tous les objets 3D du projet peuvent utiliser Primitive pour g√©n√©rer leurs formes
 *
 * Utilisation typique :
 *   - Appel√© par les factories et objets structur√©s pour g√©n√©rer la g√©om√©trie
 *   - Sert √† la cr√©ation rapide et coh√©rente des primitives
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { MaterialConfig } from '../types/index';

/**
 * Classe statique pour g√©n√©rer les primitives de base
 */
export class Primitive {
  /**
   * Cr√©er un mat√©riau standardis√©
   */
  private static createMaterial(config: string | MaterialConfig): THREE.MeshStandardMaterial {
    if (typeof config === 'string') {
      return new THREE.MeshStandardMaterial({ color: config });
    }

    return new THREE.MeshStandardMaterial({
      color: config.color,
      transparent: config.transparent || false,
      opacity: config.opacity || 1,
      metalness: config.metalness || 0,
      roughness: config.roughness || 0.5,
      side: config.side || THREE.FrontSide
    });
  }

  /**
   * Cr√©er une bo√Æte (cube ou parall√©l√©pip√®de)
   */
  static box(
    width: number,
    height: number,
    depth: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BoxGeometry(width, height, depth);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une sph√®re
   */
  static sphere(
    radius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un cylindre
   */
  static cylinder(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un c√¥ne
   */
  static cone(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un plan (surface plate)
   */
  static plane(
    width: number,
    height: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(width, height);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un tore (anneau)
   */
  static torus(
    radius: number,
    tubeRadius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.TorusGeometry(radius, tubeRadius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une surface √† partir de points (triangulation simple)
   */
  static surface(
    points: THREE.Vector3[],
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BufferGeometry();
    const vertices: number[] = [];

    // Ajouter les points
    points.forEach(point => {
      vertices.push(point.x, point.y, point.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    // Triangulation am√©lior√©e pour les quads (faces du cube)
    const indices: number[] = [];
    if (points.length === 3) {
      // Triangle simple
      indices.push(0, 1, 2);
    }

    if (points.length === 4) {
      // Quad - utiliser une triangulation qui pr√©serve la manifold
      // Pour un cube, on utilise toujours la m√™me diagonale (0,2)
      // Cela garantit que l'ar√™te diagonale n'est pas partag√©e avec d'autres faces
      indices.push(0, 1, 2);  // Premier triangle
      indices.push(0, 2, 3);  // Deuxi√®me triangle
    }

    if (points.length > 4) {
      // Fan triangulation pour plus de points
      for (let i = 1; i < points.length - 1; i++) {
        indices.push(0, i, i + 1);
      }
    }

    geometry.setIndex(indices);

    // Calculer les normales de mani√®re coh√©rente
    geometry.computeVertexNormals();

    // S'assurer que les normales pointent vers l'ext√©rieur pour un cube
    // En inversant si n√©cessaire
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une fl√®che de debug (ArrowHelper)
   *
   * @param direction - Direction normalis√©e de la fl√®che
   * @param origin - Point d'origine de la fl√®che
   * @param length - Longueur de la fl√®che
   * @param color - Couleur (hex) de la fl√®che
   * @param headLength - Longueur de la t√™te de fl√®che (optionnel)
   * @param headWidth - Largeur de la t√™te de fl√®che (optionnel)
   * @returns THREE.ArrowHelper configur√©
   */
  static arrow(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    headLength?: number,
    headWidth?: number
  ): THREE.ArrowHelper {
    return new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      headLength,
      headWidth
    );
  }

  /**
   * Cr√©er un label textuel pour les vecteurs de debug
   *
   * @param text - Texte √† afficher
   * @param position - Position du label
   * @param color - Couleur du texte (hex)
   * @param size - Taille du texte
   * @returns THREE.Sprite avec le texte
   */
  static textLabel(
    text: string,
    position: THREE.Vector3,
    color: number = 0xffffff,
    size: number = 0.5
  ): THREE.Object3D {
    // Cr√©er un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 128;

    // Style du texte
    context.font = `Bold ${size * 20}px Arial`;
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    // Fond semi-transparent
    context.fillStyle = 'rgba(0, 0, 0, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Texte
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    // Cr√©er la texture
    const texture = new THREE.CanvasTexture(canvas);
    texture.generateMipmaps = false;
    texture.minFilter = THREE.LinearFilter;

    // Cr√©er le sprite
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);

    // Positionner et dimensionner
    sprite.position.copy(position);
    sprite.scale.set(size, size * 0.5, 1);

    return sprite;
  }
}

=== core/SceneManager.ts ===

/**
 * SceneManager.ts - Gestionnaire central de la sc√®ne 3D
 *
 * R√¥le : Orchestrateur principal de tous les objets 3D
 * G√®re le cycle de vie, les updates et la hi√©rarchie des Node3D
 */

import * as THREE from 'three';

import { Node3D } from './Node3D';

export class SceneManager {
  private static instance: SceneManager;
  private nodes: Set<Node3D> = new Set();
  private rootScene: THREE.Scene;
  private totalTime: number = 0;

  private constructor() {
    this.rootScene = new THREE.Scene();
  }

  static getInstance(): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  /**
   * Enregistre un nouveau n≈ìud dans la sc√®ne
   */
  register(node: Node3D): void {
    if (!this.nodes.has(node)) {
      this.nodes.add(node);
      node.onRegister();
    }
  }

  /**
   * D√©senregistre un n≈ìud de la sc√®ne
   */
  unregister(node: Node3D): void {
    if (this.nodes.has(node)) {
      node.onUnregister();
      this.nodes.delete(node);
    }
  }

  /**
   * Met √† jour tous les n≈ìuds enregistr√©s
   */
  update(deltaTime: number): void {
    this.totalTime += deltaTime;

    // Mise √† jour de tous les n≈ìuds
    for (const node of this.nodes) {
      if (node.isActive()) {
        node.update(deltaTime);
      }
    }
  }

  /**
   * Ajoute un objet √† la sc√®ne Three.js racine
   */
  addToScene(object: THREE.Object3D): void {
    this.rootScene.add(object);
  }

  /**
   * Retire un objet de la sc√®ne Three.js racine
   */
  removeFromScene(object: THREE.Object3D): void {
    this.rootScene.remove(object);
  }

  /**
   * Obtient la sc√®ne Three.js racine
   */
  getScene(): THREE.Scene {
    return this.rootScene;
  }

  /**
   * Recherche un n≈ìud par nom
   */
  findNodeByName(name: string): Node3D | undefined {
    for (const node of this.nodes) {
      if (node.getName() === name) {
        return node;
      }
    }
    return undefined;
  }

  /**
   * Obtient tous les n≈ìuds d'un certain type
   */
  getNodesOfType<T extends Node3D>(type: new (...args: any[]) => T): T[] {
    const result: T[] = [];
    for (const node of this.nodes) {
      if (node instanceof type) {
        result.push(node as T);
      }
    }
    return result;
  }

  /**
   * Nettoie tous les n≈ìuds
   */
  clear(): void {
    for (const node of this.nodes) {
      node.destroy();
    }
    this.nodes.clear();
    this.rootScene.clear();
    this.totalTime = 0;
  }

  /**
   * Statistiques de la sc√®ne
   */
  getStats(): { nodeCount: number; totalTime: number } {
    return {
      nodeCount: this.nodes.size,
      totalTime: this.totalTime
    };
  }
}

=== core/StructuredObject.ts ===


/**
 * StructuredObject.ts - Classe de base unifi√©e pour tous les objets 3D structur√©s du projet Kite
 *
 * R√¥le :
 *   - Fournit une architecture orient√©e objet avec points anatomiques nomm√©s
 *   - Sert de classe m√®re pour tous les objets 3D complexes (cerf-volant, barre, etc.)
 *   - Compatible Godot via Node3D
 *
 * D√©pendances principales :
 *   - Node3D.ts : Couche d'abstraction Godot-compatible
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : Position3D, NamedPoint, SurfaceOptions, MaterialConfig
 *   - Three.js : Pour la g√©om√©trie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Node3D.ts (dossier core) est la classe m√®re directe
 *   - Primitive.ts fournit les utilitaires de cr√©ation
 *   - Tous les objets 3D du projet h√©ritent de StructuredObject
 *
 * Utilisation typique :
 *   - Sert de base √† la cr√©ation de tous les objets 3D structur√©s
 *   - Permet la gestion des points, labels et debug
 *
 * Voir aussi :
 *   - src/core/Node3D.ts
 *   - src/core/Primitive.ts
 */

import * as THREE from 'three';

import { Position3D, NamedPoint, MaterialConfig } from '../types/index';

import { Primitive } from './Primitive';
import { Node3D } from './Node3D';
import { DebugLayer } from './DebugLayer';

/**
 * Classe abstraite de base pour tous les objets 3D structur√©s
 * üéÆ H√©rite de Node3D pour la compatibilit√© Godot
 */
export abstract class StructuredObject extends Node3D {
  /**
   * Points anatomiques nomm√©s de l'objet
   */
  protected points: Map<string, THREE.Vector3> = new Map();

  /**
   * Points avec marqueurs visuels (debug)
   */
  protected namedPoints: NamedPoint[] = [];

  /**
   * Couche de debug s√©par√©e
   */
  protected debugLayer: DebugLayer;

  /**
   * Affichage des labels en mode debug
   */
  public showDebugPoints: boolean = false;

  /**
   * Affichage des labels de texte
   */
  public showLabels: boolean = false;

  constructor(name: string, showDebugPoints: boolean = false) {
    super(name);
    this.nodeType = 'StructuredObject';
    this.showDebugPoints = showDebugPoints;

    // Initialiser la couche de debug
    this.debugLayer = new DebugLayer(this, {
      showPoints: showDebugPoints,
      showLabels: false,
      showNormals: false,
      showAxes: false,
      pointSize: 0.02
    });

    // L'initialisation sera appel√©e par la classe enfant apr√®s configuration
  }

  /**
   * Initialisation automatique de l'objet
   */
  protected initialize(): void {
    // Vider le groupe au cas o√π
    this.clear();

    // Construire l'objet dans l'ordre
    this.definePoints();
    this.buildStructure();
    this.buildSurfaces();

    // Mettre √† jour la couche de debug
    this.updateDebugLayer();
  }

  /**
   * Initialisation publique √† appeler par les classes enfants
   */
  public init(): void {
    this.initialize();
  }

  /**
   * D√©finit tous les points anatomiques de l'objet
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract definePoints(): void;

  /**
   * Construit la structure rigide de l'objet (frame, squelette)
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildStructure(): void;

  /**
   * Construit les surfaces et d√©tails visuels
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildSurfaces(): void;

  /**
   * D√©finit un point nomm√© dans l'espace
   */
  protected setPoint(name: string, position: Position3D): void {
    const vector = new THREE.Vector3(position[0], position[1], position[2]);
    this.points.set(name, vector);
    
    // Ajouter aux points nomm√©s pour le debug
    this.namedPoints.push({
      name,
      position: vector.clone(),
      visible: this.showDebugPoints
    });
  }

  /**
   * R√©cup√®re un point par son nom
   */
  public getPoint(name: string): THREE.Vector3 | undefined {
    return this.points.get(name);
  }

  /**
   * Cr√©e un cylindre entre deux points nomm√©s
   */
  protected addCylinderBetweenPoints(
    point1Name: string,
    point2Name: string,
    radius: number,
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    const p1 = this.getPoint(point1Name);
    const p2 = this.getPoint(point2Name);
    
    if (!p1 || !p2) {
      console.warn(`Points ${point1Name} ou ${point2Name} non trouv√©s`);
      return null;
    }

    // Calculer la distance et l'orientation
    const distance = p1.distanceTo(p2);
    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
    
    // Cr√©er le cylindre
    const cylinder = Primitive.cylinder(radius, distance, material);
    
    // Orienter le cylindre
    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction
    );
    cylinder.quaternion.copy(quaternion);
    cylinder.position.copy(midpoint);
    
    // Ajouter au groupe
    this.add(cylinder);
    return cylinder;
  }

  /**
   * Cr√©e une surface entre des points nomm√©s
   */
  protected addSurfaceBetweenPoints(
    pointNames: string[],
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    if (pointNames.length < 3) {
      console.warn('Il faut au moins 3 points pour cr√©er une surface');
      return null;
    }

    const points: THREE.Vector3[] = [];
    
    // R√©cup√©rer tous les points
    for (const name of pointNames) {
      const point = this.getPoint(name);
      if (!point) {
        console.warn(`Point ${name} non trouv√©`);
        return null;
      }
      points.push(point);
    }

    // Cr√©er la surface
    const surface = Primitive.surface(points, material);
    this.add(surface);
    return surface;
  }

  /**
   * Ajoute une primitive √† une position donn√©e
   */
  protected addPrimitiveAt(
    primitive: THREE.Mesh,
    position: Position3D
  ): void {
    primitive.position.set(position[0], position[1], position[2]);
    this.add(primitive);
  }

  /**
   * Ajoute une primitive √† la position d'un point nomm√©
   */
  protected addPrimitiveAtPoint(
    primitive: THREE.Mesh,
    pointName: string
  ): boolean {
    const point = this.getPoint(pointName);
    if (!point) {
      console.warn(`Point ${pointName} non trouv√©`);
      return false;
    }
    
    primitive.position.copy(point);
    this.add(primitive);
    return true;
  }

  /**
   * Met √† jour la couche de debug avec les points actuels
   */
  protected updateDebugLayer(): void {
    // Vider la couche de debug
    this.debugLayer.clear();

    if (this.showDebugPoints) {
      // Ajouter tous les points nomm√©s
      for (const [name, position] of this.points.entries()) {
        this.debugLayer.addPoint(position, 0xffff00, this.showLabels ? name : undefined);
      }
    }
  }
  
  /**
   * Cr√©e un label de texte pour un point
   */
  private createTextLabel(text: string): THREE.Sprite {
    // Cr√©er un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 64;
    
    // Style du texte
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.font = 'Bold 24px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);
    
    // Cr√©er une texture depuis le canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Cr√©er un sprite avec la texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Ajuster la taille du sprite
    sprite.scale.set(0.3, 0.075, 1);
    
    return sprite;
  }

  /**
   * Active/d√©sactive l'affichage des marqueurs de debug
   */
  public setShowDebugPoints(show: boolean): void {
    this.showDebugPoints = show;
    this.debugLayer.setShowPoints(show);
  }

  /**
   * Active/d√©sactive l'affichage des labels de texte
   */
  public setShowLabels(show: boolean): void {
    this.showLabels = show;
    this.debugLayer.setShowLabels(show);
    // Si les points de debug ne sont pas activ√©s et qu'on veut les labels, activer les deux
    if (show && !this.showDebugPoints) {
      this.setShowDebugPoints(true);
    }
  }  /**
   * Retourne tous les noms de points d√©finis
   */
  public getPointNames(): string[] {
    return Array.from(this.points.keys());
  }

  /**
   * Retourne le nombre de points d√©finis
   */
  public getPointCount(): number {
    return this.points.size;
  }

  /**
   * Retourne les informations sur un point
   */
  public getPointInfo(name: string): NamedPoint | undefined {
    const point = this.getPoint(name);
    if (!point) return undefined;
    
    return {
      name,
      position: point.clone(),
      visible: this.showDebugPoints
    };
  }
}

=== factories/BridleFactory.ts ===

/**
 * BridleFactory.ts - Factory pour cr√©er les instances Line repr√©sentant les brides
 *
 * R√¥le :
 *   - Cr√©e les 6 brides (3 gauches + 3 droites) comme instances de Line
 *   - Fournit une configuration physique sp√©cifique aux brides (Dyneema courtes et rigides)
 *   - Centralise la cr√©ation pour garantir coh√©rence et validation
 *
 * Architecture :
 *   - R√©utilise la classe Line (m√™me que lignes principales)
 *   - Config diff√©rente : plus rigides, plus courtes, moins √©lastiques
 *   - Pattern Factory comme LineFactory
 *
 * Relation avec les autres modules :
 *   - Utilise Line (src/objects/mechanical/Line.ts)
 *   - Utilis√© par BridleSystem
 *   - Config bas√©e sur BridleLengths (BridleTypes.ts)
 *
 * Voir aussi :
 *   - src/factories/LineFactory.ts (pattern similaire)
 *   - src/objects/mechanical/Line.ts
 *   - src/simulation/types/BridleTypes.ts
 */

import { BridleLengths, BridleAttachment, BridleSide, BridlePosition } from "../simulation/types/BridleTypes";

import { Line, LineConfig, LineAttachments } from "@/objects/Line";


/**
 * Factory pour cr√©er les brides du cerf-volant
 *
 * Les brides sont des lignes courtes et rigides en Dyneema qui relient
 * les points anatomiques du kite (NEZ, INTER, CENTRE) aux points de contr√¥le (CTRL).
 */
export class BridleFactory {
  /**
   * Configuration physique standard pour les brides
   *
   * Les brides sont plus rigides et moins √©lastiques que les lignes principales :
   * - Plus courtes (0.5-0.7m vs 15m)
   * - Plus rigides (5000 N/m vs 2200 N/m)
   * - Moins d'amortissement (quasi-rigides)
   * - Tr√®s l√©g√®res
   */
  private static readonly BRIDLE_CONFIG: Omit<LineConfig, 'length'> = {
    stiffness: 5000,           // N/m - Tr√®s rigides (Dyneema courte)
    preTension: 10,            // N - Pr√©-tension faible
    maxTension: 300,           // N - R√©sistance avant rupture
    dampingCoeff: 0.02,        // Sans dimension - Peu d'amortissement
    linearMassDensity: 0.0003, // kg/m - Tr√®s l√©g√®res
  };

  /**
   * Mapping des positions vers les points anatomiques
   */
  private static readonly POINT_MAPPING = {
    left: {
      nez: { start: "NEZ", end: "CTRL_GAUCHE" },
      inter: { start: "INTER_GAUCHE", end: "CTRL_GAUCHE" },
      centre: { start: "CENTRE", end: "CTRL_GAUCHE" },
    },
    right: {
      nez: { start: "NEZ", end: "CTRL_DROIT" },
      inter: { start: "INTER_DROIT", end: "CTRL_DROIT" },
      centre: { start: "CENTRE", end: "CTRL_DROIT" },
    },
  } as const;

  /**
   * Cr√©e une bride individuelle
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @param length - Longueur en m√®tres
   * @returns Instance Line configur√©e
   */
  static createBridle(
    side: BridleSide,
    position: BridlePosition,
    length: number
  ): Line {
    const points = this.POINT_MAPPING[side][position];
    const id = `bridle_${side}_${position}`;

    const config: LineConfig = {
      ...this.BRIDLE_CONFIG,
      length,
    };

    const attachments: LineAttachments = {
      kitePoint: points.start,
      barPoint: points.end,
    };

    return new Line(config, attachments, id);
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© gauche
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createLeftBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('left', 'nez', lengths.nez),
      this.createBridle('left', 'inter', lengths.inter),
      this.createBridle('left', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© droit
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createRightBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('right', 'nez', lengths.nez),
      this.createBridle('right', 'inter', lengths.inter),
      this.createBridle('right', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e toutes les 6 brides (gauches + droites)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Objet contenant les brides gauches et droites
   */
  static createAllBridles(lengths: BridleLengths): {
    left: [Line, Line, Line];
    right: [Line, Line, Line];
  } {
    return {
      left: this.createLeftBridles(lengths),
      right: this.createRightBridles(lengths),
    };
  }

  /**
   * Cr√©e les m√©tadonn√©es d'attache pour toutes les brides
   * (utilis√© pour documentation/debug)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 6 BridleAttachment
   */
  static createBridleAttachments(lengths: BridleLengths): BridleAttachment[] {
    const attachments: BridleAttachment[] = [];

    // Brides gauches
    Object.entries(this.POINT_MAPPING.left).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_left_${position}`,
      });
    });

    // Brides droites
    Object.entries(this.POINT_MAPPING.right).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_right_${position}`,
      });
    });

    return attachments;
  }

  /**
   * Valide les longueurs de brides
   *
   * @param lengths - Longueurs √† valider
   * @throws Error si longueurs invalides
   */
  static validateBridleLengths(lengths: BridleLengths): void {
    const { nez, inter, centre } = lengths;

    // V√©rifier valeurs positives
    if (nez <= 0 || inter <= 0 || centre <= 0) {
      throw new Error(
        `Longueurs de brides doivent √™tre positives: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier plage raisonnable (0.2m √† 1.5m)
    const min = 0.2;
    const max = 1.5;
    if (nez < min || nez > max || inter < min || inter > max || centre < min || centre > max) {
      throw new Error(
        `Longueurs de brides hors plage [${min}, ${max}]m: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier coh√©rence g√©om√©trique (bride nez g√©n√©ralement plus longue)
    if (nez < inter * 0.8 || nez < centre * 0.8) {
      console.warn(
        `‚ö†Ô∏è Bride NEZ plus courte que INTER/CENTRE peut causer instabilit√©: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }
  }

  /**
   * Obtient la configuration physique utilis√©e pour les brides
   * (utile pour debug/documentation)
   */
  static getBridleConfig(): Omit<LineConfig, 'length'> {
    return { ...this.BRIDLE_CONFIG };
  }
}


=== factories/FactoryRegistry.ts ===

/**
 * FactoryRegistry.ts - Registre centralis√© des factories
 *
 * Permet la cr√©ation dynamique d'objets depuis un nom ou un type
 * Pattern : Factory Registry + Plugin Architecture
 */

export interface FactoryMetadata {
  id: string;
  name: string;
  version: string;
  description: string;
  supportedTypes: string[];
  dependencies: string[];
}

export interface BaseFactory {
  createObject(type: string, config: any): any;
  getSupportedTypes(): string[];
  getMetadata(): FactoryMetadata;
  dispose(): void;
}

type FactoryConstructor = new () => BaseFactory;

export interface FactoryParams {
  [key: string]: any;
}

export class FactoryRegistry {
  private static factories = new Map<string, FactoryConstructor>();
  private static instances = new Map<string, BaseFactory>();

  /**
   * Enregistre une factory dans le registre
   */
  static register(name: string, factoryClass: FactoryConstructor): void {
    if (this.factories.has(name)) {
      console.warn(`Factory "${name}" is already registered. Overwriting.`);
    }
    this.factories.set(name, factoryClass);
  }

  /**
   * D√©senregistre une factory
   */
  static unregister(name: string): void {
    if (this.factories.has(name)) {
      // Nettoyer l'instance si elle existe
      if (this.instances.has(name)) {
        const instance = this.instances.get(name)!;
        instance.dispose();
        this.instances.delete(name);
      }
      this.factories.delete(name);
    }
  }

  /**
   * Cr√©e un objet en utilisant la factory enregistr√©e
   */
  static createObject(name: string, params?: FactoryParams): any {
    const factoryClass = this.factories.get(name);
    if (!factoryClass) {
      throw new Error(`Factory "${name}" not found. Available factories: ${Array.from(this.factories.keys()).join(', ')}`);
    }

    // Obtenir ou cr√©er l'instance de factory
    let factory = this.instances.get(name);
    if (!factory) {
      factory = new factoryClass();
      this.instances.set(name, factory);
    }

    // Cr√©er l'objet
    return factory.createObject('default', params);
  }

  /**
   * V√©rifie si une factory est enregistr√©e
   */
  static hasFactory(name: string): boolean {
    return this.factories.has(name);
  }

  /**
   * Obtient la liste des factories enregistr√©es
   */
  static getRegisteredFactories(): string[] {
    return Array.from(this.factories.keys());
  }

  /**
   * Obtient les m√©tadonn√©es d'une factory
   */
  static getFactoryMetadata(name: string): { name: string; description?: string } | null {
    const factory = this.instances.get(name);
    if (factory) {
      return factory.getMetadata();
    }
    return null;
  }

  /**
   * Nettoie toutes les factories et instances
   */
  static clear(): void {
    // Nettoyer toutes les instances
    for (const [name, instance] of this.instances) {
      try {
        instance.dispose();
      } catch (error) {
        console.error(`Error disposing factory "${name}":`, error);
      }
    }

    this.instances.clear();
    this.factories.clear();
  }

  /**
   * Recharge une factory (utile pour le d√©veloppement)
   */
  static reloadFactory(name: string): void {
    if (this.instances.has(name)) {
      const instance = this.instances.get(name)!;
      instance.dispose();
      this.instances.delete(name);
    }
    // La prochaine cr√©ation recr√©era l'instance
  }
}

=== factories/FrameFactory.ts ===

/**
 * FrameFactory.ts - Factory pour cr√©er des structures filaires (frames)
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

import { BaseFactory, FactoryMetadata } from './FactoryRegistry';

export interface FrameParams {
  diameter?: number;
  material?: string;
  points?: Array<[string, number[]]>;
  connections?: Array<[string, string]>;
}

/**
 * Factory pour cr√©er des structures filaires
 */
export class FrameFactory implements BaseFactory {
  getSupportedTypes(): string[] {
    return ['frame', 'structure'];
  }

  getMetadata(): FactoryMetadata {
    return {
      id: 'frame_factory',
      name: 'Frame Factory',
      version: '1.0.0',
      description: 'Creates wireframe structures from connected points',
      supportedTypes: this.getSupportedTypes(),
      dependencies: []
    };
  }

  createObject(type: string, config: FrameParams = {}): StructuredObject & ICreatable {
    const params = {
      diameter: 0.01,
      material: '#333333',
      points: [],
      connections: [],
      ...config
    };

    class FrameObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Frame", false);
      }

      protected definePoints(): void {
        if (params.points) {
          params.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        if (params.connections) {
          params.connections.forEach(([point1, point2]) => {
            this.addCylinderBetweenPoints(
              point1,
              point2,
              params.diameter || 0.01,
              params.material || '#333333'
            );
          });
        }
      }

      protected buildSurfaces(): void {
        // Pas de surfaces pour un frame
      }

      create(): this { return this; }
      getName(): string { return 'Frame'; }
      getDescription(): string { return 'Structure filaire'; }
      getPrimitiveCount(): number { return params.connections?.length || 0; }
    }

    const frame = new FrameObject();
    frame.init();
    return frame;
  }

  dispose(): void {
    // Cleanup if needed
  }
}

=== factories/LineFactory.ts ===

/**
 * LineFactory.ts - Factory pour cr√©er des lignes de cerf-volant (OOP pattern)
 *
 * R√¥le :
 *   - Cr√©er des objets Line selon le pattern Factory du projet
 *   - Valider les param√®tres avant cr√©ation
 *   - Fournir des presets pour configurations typiques
 *
 * Responsabilit√© :
 *   - Instanciation coh√©rente des objets Line
 *   - Application des valeurs par d√©faut
 *   - Validation des param√®tres physiques
 *
 * Pattern :
 *   - Ne suit PAS BaseFactory<StructuredObject> car Line n'est pas un objet 3D
 *   - Factory simple avec m√©thodes statiques pour configurations communes
 *   - S√©paration claire : Line (m√©tier) vs LineVisual (3D)
 *
 * Relation avec les autres modules :
 *   - Cr√©e des objets Line
 *   - Utilis√© par LineSystem pour instancier les lignes
 *   - Ind√©pendant de Three.js (pure TypeScript)
 *
 * Philosophie :
 *   - "Make invalid states unrepresentable" : Validation stricte
 *   - Presets pour cas d'usage communs
 *   - Immutabilit√© : Les lignes cr√©√©es sont immutables (config readonly)
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts
 *   - src/base/BaseFactory.ts (pattern de r√©f√©rence)
 */

import { Line, LineConfig, LineAttachments } from '@/objects/Line';
import { CONFIG } from '@/simulation/config/SimulationConfig';

/**
 * Param√®tres pour cr√©er une ligne via factory
 */
export interface LineFactoryParams {
  /** Longueur au repos (m) - D√©faut: CONFIG.lines.defaultLength */
  length?: number;

  /** Point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;

  /** Rigidit√© personnalis√©e (N/m) - D√©faut: CONFIG.lines.stiffness */
  stiffness?: number;

  /** Pr√©-tension personnalis√©e (N) - D√©faut: CONFIG.lines.preTension */
  preTension?: number;

  /** Tension max personnalis√©e (N) - D√©faut: CONFIG.lines.maxTension */
  maxTension?: number;

  /** Damping personnalis√© - D√©faut: CONFIG.lines.dampingCoeff */
  dampingCoeff?: number;

  /** Masse lin√©ique personnalis√©e (kg/m) - D√©faut: CONFIG.lines.linearMassDensity */
  linearMassDensity?: number;

  /** Identifiant personnalis√© (optionnel) */
  id?: string;
}

/**
 * Erreur de validation lors de la cr√©ation d'une ligne
 */
export class LineValidationError extends Error {
  constructor(message: string, public field: string) {
    super(`LineFactory validation error [${field}]: ${message}`);
    this.name = 'LineValidationError';
  }
}

/**
 * Factory pour cr√©er des lignes de cerf-volant
 *
 * @example
 * ```typescript
 * // Ligne standard avec param√®tres par d√©faut
 * const leftLine = LineFactory.createLine({
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Ligne personnalis√©e
 * const customLine = LineFactory.createLine({
 *   length: 20,
 *   stiffness: 1800,
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Preset d√©butant
 * const beginnerLine = LineFactory.createBeginnerLine("CTRL_GAUCHE", "HANDLE_LEFT");
 * ```
 */
export class LineFactory {
  /**
   * Cr√©e une ligne avec param√®tres personnalis√©s
   *
   * @param params - Param√®tres de configuration
   * @returns Instance de Line configur√©e
   * @throws LineValidationError si param√®tres invalides
   */
  static createLine(params: LineFactoryParams): Line {
    // Valider les param√®tres
    this.validateParams(params);

    // Configuration avec valeurs par d√©faut depuis SimulationConfig
    const config: LineConfig = {
      length: params.length ?? CONFIG.lines.defaultLength,
      stiffness: params.stiffness ?? CONFIG.lines.stiffness,
      preTension: params.preTension ?? CONFIG.lines.preTension,
      maxTension: params.maxTension ?? CONFIG.lines.maxTension,
      dampingCoeff: params.dampingCoeff ?? CONFIG.lines.dampingCoeff,
      linearMassDensity: params.linearMassDensity ?? CONFIG.lines.linearMassDensity
    };

    // Points d'attache
    const attachments: LineAttachments = {
      kitePoint: params.kitePoint,
      barPoint: params.barPoint
    };

    // Cr√©er et retourner la ligne
    return new Line(config, attachments, params.id);
  }

  /**
   * Cr√©e une paire de lignes gauche/droite standard
   *
   * @param length - Longueur commune (m)
   * @returns Tuple [ligne gauche, ligne droite]
   */
  static createLinePair(length?: number): [Line, Line] {
    const leftLine = this.createLine({
      length,
      kitePoint: "CTRL_GAUCHE",
      barPoint: "HANDLE_LEFT",
      id: "line_left"
    });

    const rightLine = this.createLine({
      length,
      kitePoint: "CTRL_DROIT",
      barPoint: "HANDLE_RIGHT",
      id: "line_right"
    });

    return [leftLine, rightLine];
  }

  /**
   * Preset : Ligne pour d√©butant
   * - Plus courte (12m)
   * - Moins rigide (1800 N/m)
   * - Pr√©-tension plus faible (50N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour d√©butant
   */
  static createBeginnerLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 12,
      stiffness: 1800,
      preTension: 50,
      maxTension: 600,
      dampingCoeff: 0.08, // Plus de damping = plus stable
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne pour expert
   * - Plus longue (20m)
   * - Rigidit√© standard (2200 N/m)
   * - Haute tension max (1000N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour expert
   */
  static createExpertLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 20,
      stiffness: 2200,
      preTension: 100,
      maxTension: 1000,
      dampingCoeff: 0.03, // Moins de damping = plus r√©actif
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne de s√©curit√© (ultra-r√©sistante)
   * - Tension max tr√®s √©lev√©e (1500N)
   * - Rigidit√© renforc√©e (3000 N/m)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne de s√©curit√©
   */
  static createSafetyLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 15,
      stiffness: 3000,
      preTension: 150,
      maxTension: 1500,
      dampingCoeff: 0.05,
      linearMassDensity: 0.001, // Plus lourde
      kitePoint,
      barPoint
    });
  }

  /**
   * Cr√©e une ligne depuis JSON (d√©s√©rialisation)
   *
   * @param json - Donn√©es JSON (depuis Line.toJSON())
   * @returns Instance de Line recr√©√©e
   */
  static fromJSON(json: any): Line {
    return Line.fromJSON(json);
  }

  /**
   * Valide les param√®tres avant cr√©ation
   *
   * @param params - Param√®tres √† valider
   * @throws LineValidationError si invalide
   */
  private static validateParams(params: LineFactoryParams): void {
    // Points d'attache obligatoires
    if (!params.kitePoint || params.kitePoint.trim() === '') {
      throw new LineValidationError('Kite attachment point is required', 'kitePoint');
    }

    if (!params.barPoint || params.barPoint.trim() === '') {
      throw new LineValidationError('Bar attachment point is required', 'barPoint');
    }

    // Longueur positive
    if (params.length !== undefined && params.length <= 0) {
      throw new LineValidationError('Length must be positive', 'length');
    }

    // Rigidit√© positive
    if (params.stiffness !== undefined && params.stiffness <= 0) {
      throw new LineValidationError('Stiffness must be positive', 'stiffness');
    }

    // Pr√©-tension non-n√©gative
    if (params.preTension !== undefined && params.preTension < 0) {
      throw new LineValidationError('PreTension cannot be negative', 'preTension');
    }

    // Tension max > pr√©-tension
    if (params.maxTension !== undefined && params.preTension !== undefined) {
      if (params.maxTension <= params.preTension) {
        throw new LineValidationError(
          'MaxTension must be greater than preTension',
          'maxTension'
        );
      }
    }

    // Damping dans [0, 1]
    if (params.dampingCoeff !== undefined) {
      if (params.dampingCoeff < 0 || params.dampingCoeff > 1) {
        throw new LineValidationError(
          'DampingCoeff must be between 0 and 1',
          'dampingCoeff'
        );
      }
    }

    // Masse lin√©ique positive
    if (params.linearMassDensity !== undefined && params.linearMassDensity <= 0) {
      throw new LineValidationError(
        'LinearMassDensity must be positive',
        'linearMassDensity'
      );
    }
  }

  /**
   * Obtient les valeurs par d√©faut utilis√©es par la factory
   *
   * @returns Configuration par d√©faut
   */
  static getDefaultConfig(): LineConfig {
    return {
      length: CONFIG.lines.defaultLength,
      stiffness: CONFIG.lines.stiffness,
      preTension: CONFIG.lines.preTension,
      maxTension: CONFIG.lines.maxTension,
      dampingCoeff: CONFIG.lines.dampingCoeff,
      linearMassDensity: CONFIG.lines.linearMassDensity
    };
  }

  /**
   * V√©rifie si deux lignes ont la m√™me configuration physique
   *
   * @param line1 - Premi√®re ligne
   * @param line2 - Deuxi√®me ligne
   * @returns true si configurations identiques
   */
  static areConfigsEqual(line1: Line, line2: Line): boolean {
    const c1 = line1.config;
    const c2 = line2.config;

    return (
      c1.length === c2.length &&
      c1.stiffness === c2.stiffness &&
      c1.preTension === c2.preTension &&
      c1.maxTension === c2.maxTension &&
      c1.dampingCoeff === c2.dampingCoeff &&
      c1.linearMassDensity === c2.linearMassDensity
    );
  }
}


=== factories/PointFactory.ts ===

/**
 * PointFactory.ts - Encapsule la logique de calcul des points anatomiques
 *
 * Responsabilit√© : Calculer les positions des points d'un cerf-volant delta
 */

import * as THREE from 'three';

import { CONFIG } from '@/simulation/config/SimulationConfig';

// Constantes g√©om√©triques locales
const GEOMETRY = {
  half: 0.5,
  third: 1 / 3,
  twoThirds: 2 / 3,
  quarter: 0.25,
};

/**
 * Longueurs physiques des brides (en m√®tres)
 */
export interface BridleLengths {
  nez: number;      // Longueur bride NEZ -> CTRL (avant)
  inter: number;    // Longueur bride INTER -> CTRL (lat√©ral)
  centre: number;   // Longueur bride CENTRE -> CTRL (arri√®re)
}

export interface KiteParams {
  width: number;   // Envergure
  height: number;  // Hauteur
  depth: number;   // Profondeur whiskers
  bridleLengths?: BridleLengths;  // Longueurs physiques des brides
}

/**
 * Factory simple qui encapsule la logique de calcul des points
 */
export class PointFactory {
  /**
   * Cr√©e le rep√®re local pour la trilat√©ration 3D
   */
  private static createLocalCoordinateSystem(
    p1: THREE.Vector3,
    p2: THREE.Vector3,
    p3: THREE.Vector3
  ): { ex: THREE.Vector3; ey: THREE.Vector3; ez: THREE.Vector3; i: number; j: number; d: number } {
    // Axe X : direction p1->p2
    const ex = new THREE.Vector3().subVectors(p2, p1).normalize();
    const d = p2.distanceTo(p1);

    // Composante Y du rep√®re
    const p3_p1 = new THREE.Vector3().subVectors(p3, p1);
    const i = ex.dot(p3_p1);
    const ey_temp = new THREE.Vector3().copy(p3_p1).addScaledVector(ex, -i);
    const ey = ey_temp.normalize();

    // Axe Z (perpendiculaire au plan p1-p2-p3)
    const ez = new THREE.Vector3().crossVectors(ex, ey);

    // Garantir la sym√©trie - ez doit pointer vers l'arri√®re (+Z global)
    if (ez.z < 0) {
      ez.negate();
    }

    // Coordonn√©es de p3 dans le rep√®re local
    const j = ey.dot(p3_p1);

    return { ex, ey, ez, i, j, d };
  }

  /**
   * R√©sout le syst√®me de trilat√©ration dans le rep√®re local
   */
  private static solveTrilaterationSystem(
    coordSystem: { i: number; j: number; d: number },
    radii: { r1: number; r2: number; r3: number }
  ): { x: number; y: number; z: number } {
    const { i, j, d } = coordSystem;
    const { r1, r2, r3 } = radii;

    // R√©solution du syst√®me dans le rep√®re local
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
    const y = (r1 * r1 - r3 * r3 + i * i + j * j) / (2 * j) - (i / j) * x;

    // Calcul de z
    const zSquared = r1 * r1 - x * x - y * y;
    let z: number;
    if (zSquared < 0) {
      console.warn(`‚ö†Ô∏è Configuration de brides impossible (z¬≤=${zSquared.toFixed(3)}), approximation`);
      z = 0; // Solution d√©g√©n√©r√©e
    } else {
      z = Math.sqrt(zSquared); // z > 0 vers l'arri√®re du kite
    }

    return { x, y, z };
  }

  /**
   * Convertit les coordonn√©es locales en coordonn√©es globales
   */
  private static convertToGlobalCoordinates(
    p1: THREE.Vector3,
    coordSystem: { ex: THREE.Vector3; ey: THREE.Vector3; ez: THREE.Vector3 },
    localCoords: { x: number; y: number; z: number }
  ): THREE.Vector3 {
    const result = new THREE.Vector3();
    result.copy(p1);
    result.addScaledVector(coordSystem.ex, localCoords.x);
    result.addScaledVector(coordSystem.ey, localCoords.y);
    result.addScaledVector(coordSystem.ez, localCoords.z);
    return result;
  }

  /**
   * Calcule la position du point de contr√¥le (CTRL) par trilat√©ration 3D analytique
   * R√©sout l'intersection de 3 sph√®res centr√©es en NEZ, INTER, CENTRE
   * avec rayons = longueurs de brides respectives
   */
  private static calculateControlPoint(
    nez: [number, number, number],
    inter: [number, number, number],
    centre: [number, number, number],
    bridleLengths: BridleLengths,
    _side: 'left' | 'right'
  ): [number, number, number] {
    // Convertir en Vector3
    const p1 = new THREE.Vector3(...nez);      // Point 1 : NEZ
    const p2 = new THREE.Vector3(...inter);    // Point 2 : INTER
    const p3 = new THREE.Vector3(...centre);   // Point 3 : CENTRE

    const radii = {
      r1: bridleLengths.nez,
      r2: bridleLengths.inter,
      r3: bridleLengths.centre
    };

    // Cr√©er le rep√®re local
    const coordSystem = this.createLocalCoordinateSystem(p1, p2, p3);

    // R√©soudre le syst√®me
    const localCoords = this.solveTrilaterationSystem(coordSystem, radii);

    // Convertir en coordonn√©es globales
    const result = this.convertToGlobalCoordinates(p1, coordSystem, localCoords);

    return [result.x, result.y, result.z];
  }

  /**
   * Calcule les points d'ancrage fixes des brides
   */
  private static calculateAnchorPoints(width: number, height: number): {
    nezPos: [number, number, number];
    centrePos: [number, number, number];
    interGauchePos: [number, number, number];
    interDroitPos: [number, number, number];
  } {
    const centreY = height * GEOMETRY.quarter;
    const ratio = (height - centreY) / height;
    const interGaucheX = ratio * (-width / 2);
    const interDroitX = ratio * (width / 2);

    return {
      nezPos: [0, height, 0],
      centrePos: [0, centreY, 0],
      interGauchePos: [interGaucheX, centreY, 0],
      interDroitPos: [interDroitX, centreY, 0]
    };
  }

  /**
   * Calcule les points de contr√¥le gauche et droit par trilat√©ration
   */
  private static calculateControlPoints(
    anchorPoints: { nezPos: [number, number, number]; centrePos: [number, number, number]; interGauchePos: [number, number, number]; interDroitPos: [number, number, number] },
    bridleLengths: BridleLengths
  ): { ctrlGauche: [number, number, number]; ctrlDroit: [number, number, number] } {
    const { nezPos, centrePos, interDroitPos } = anchorPoints;

    // Calculer le point de contr√¥le droit par trilat√©ration
    const ctrlDroit = PointFactory.calculateControlPoint(
      nezPos,
      interDroitPos,
      centrePos,
      bridleLengths,
      'right'
    );

    // Le point de contr√¥le gauche est le miroir du point droit
    const ctrlGauche: [number, number, number] = [-ctrlDroit[0], ctrlDroit[1], ctrlDroit[2]];

    return { ctrlGauche, ctrlDroit };
  }

  /**
   * Cr√©e la collection compl√®te des points anatomiques
   */
  private static createPointCollection(
    width: number,
    height: number,
    depth: number,
    anchorPoints: { nezPos: [number, number, number]; centrePos: [number, number, number]; interGauchePos: [number, number, number]; interDroitPos: [number, number, number] },
    controlPoints: { ctrlGauche: [number, number, number]; ctrlDroit: [number, number, number] }
  ): Map<string, [number, number, number]> {
    const { nezPos, centrePos, interGauchePos, interDroitPos } = anchorPoints;
    const { ctrlGauche, ctrlDroit } = controlPoints;

    const fixRatio = GEOMETRY.twoThirds;

    return new Map<string, [number, number, number]>([
      // Points structurels principaux
      ["SPINE_BAS", [0, 0, 0]],
      ["CENTRE", centrePos],
      ["NEZ", nezPos],

      // Points des bords d'attaque
      ["BORD_GAUCHE", [-width / 2, 0, 0]],
      ["BORD_DROIT", [width / 2, 0, 0]],

      // Points d'intersection pour le spreader
      ["INTER_GAUCHE", interGauchePos],
      ["INTER_DROIT", interDroitPos],

      // Points de fixation whiskers
      ["FIX_GAUCHE", [fixRatio * interGauchePos[0], centrePos[1], 0]],
      ["FIX_DROIT", [fixRatio * interDroitPos[0], centrePos[1], 0]],

      // Points des whiskers
      ["WHISKER_GAUCHE", [-width / 4, 0.1, -depth]],
      ["WHISKER_DROIT", [width / 4, 0.1, -depth]],

      // Points de contr√¥le (bridage) - calcul√©s depuis longueurs physiques
      ["CTRL_GAUCHE", ctrlGauche],
      ["CTRL_DROIT", ctrlDroit],

      // Points d'ancrage des brides
      ["BRIDE_GAUCHE_A", nezPos],
      ["BRIDE_GAUCHE_B", interGauchePos],
      ["BRIDE_GAUCHE_C", centrePos],
      ["BRIDE_DROITE_A", nezPos],
      ["BRIDE_DROITE_B", interDroitPos],
      ["BRIDE_DROITE_C", centrePos],
    ]);
  }

  /**
   * Calcule toutes les positions des points anatomiques d'un cerf-volant delta
   */
  static calculateDeltaKitePoints(params: KiteParams): Map<string, [number, number, number]> {
    const { width, height, depth, bridleLengths } = params;
    const effectiveBridleLengths: BridleLengths = bridleLengths ?? { ...CONFIG.bridle.defaultLengths };

    // Calculer les points d'ancrage
    const anchorPoints = this.calculateAnchorPoints(width, height);

    // Calculer les points de contr√¥le
    const controlPoints = this.calculateControlPoints(anchorPoints, effectiveBridleLengths);

    // Cr√©er la collection compl√®te
    return this.createPointCollection(width, height, depth, anchorPoints, controlPoints);
  }
}

=== factories/SurfaceFactory.ts ===

/**
 * SurfaceFactory.ts - Factory pour cr√©er des surfaces et toiles
 *
 * Pattern actuel KISS : Points ‚Üí Triangles pour surfaces
 * Compatible avec buildSurfaces() de StructuredObject
 */

import * as THREE from "three";

import { BaseFactory, FactoryParams } from "../base/BaseFactory";
import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";

export interface SurfaceParams extends FactoryParams {
  points?: Array<[string, number[]]>; // Points nomm√©s pour la surface
  panels?: Array<string[]>; // Groupes de 3-4 points formant des panneaux
  material?: {
    color?: string;
    opacity?: number;
    transparent?: boolean;
    doubleSided?: boolean; // true = visible des deux c√¥t√©s (d√©faut), false = une face
    side?: THREE.Side;
  };
  tension?: number; // Tension de la toile (future feature)
}

/**
 * Factory pour cr√©er des surfaces tendues
 *
 
 *
 */
export class SurfaceFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: "surface",
    name: "Surface",
    description: "Surface tendue param√©trique",
    tags: ["surface", "toile", "membrane"],
    complexity: "simple" as const,
  };

  protected getDefaultParams(): SurfaceParams {
    return {
      points: [],
      panels: [],
      material: {
        color: "#ff0000",
        opacity: 0.9,
        transparent: true,
        doubleSided: true, // Par d√©faut, visible des deux c√¥t√©s
      },
      tension: 1.0,
    };
  }

  /**
   * Mod√®le physique :
   * - La masse du kite est distribu√©e sur chaque surface proportionnellement √† son aire (voir PHYSICS_MODEL.md ¬ß1.2).
   * - Cette logique doit √™tre appliqu√©e lors de la cr√©ation des surfaces (buildSurfaces).
   * - Permet l'√©mergence naturelle des couples gravitationnels et a√©rodynamiques.
   */
  createObject(params?: SurfaceParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as SurfaceParams;

    class SurfaceObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Surface", false);
      }

      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        // Pas de structure pour une surface pure
      }

      protected buildSurfaces(): void {
        // Cr√©er les panneaux de surface
        if (mergedParams.panels) {
          mergedParams.panels.forEach((panel) => {
            // Convertir doubleSided en THREE.Side
            const mat = mergedParams.material || {};
            const side =
              mat.doubleSided !== false ? THREE.DoubleSide : THREE.FrontSide;

            // Chaque panneau est un triangle (3 points) ou quad (4 points)
            this.addSurfaceBetweenPoints(panel, {
              color: mat.color || "#ff0000",
              opacity: mat.opacity !== undefined ? mat.opacity : 0.9,
              transparent: mat.transparent !== false,
              side: mat.side || side,
            });
          });
        }
      }

      // Impl√©mentation ICreatable
      create(): this {
        return this;
      }
      getName(): string {
        return "Surface";
      }
      getDescription(): string {
        return "Surface tendue";
      }
      getPrimitiveCount(): number {
        return (mergedParams.panels || []).length;
      }
    }

    const surface = new SurfaceObject();
    surface.init();
    return surface;
  }
}


=== factories/presets/PhysicalPresets.ts ===

/**
 * PhysicalPresets.ts - Constantes physiques centralis√©es
 *
 * Toutes les constantes physiques, mat√©riaux et configurations
 * utilis√©es dans la simulation du cerf-volant.
 */

import * as THREE from 'three';

// ============================================================================
// CONSTANTES PHYSIQUES FONDAMENTALES
// ============================================================================

export const PHYSICAL_CONSTANTS = {
  gravity: 9.81, // m/s¬≤ - Acc√©l√©ration gravitationnelle terrestre
  airDensity: 1.225, // kg/m¬≥ - Densit√© de l'air √† 15¬∞C
  speedOfSound: 343, // m/s - Vitesse du son dans l'air
  dynamicViscosity: 1.81e-5, // Pa¬∑s - Viscosit√© dynamique de l'air
} as const;

// ============================================================================
// PR√âSETS DE MAT√âRIAUX PHYSIQUES
// ============================================================================

export const MATERIAL_PRESETS = {
  // Mat√©riaux de structure (carbone/kevlar)
  carbon: {
    density: 1600, // kg/m¬≥
    youngModulus: 230e9, // Pa - Module de Young
    tensileStrength: 3500e6, // Pa - R√©sistance √† la traction
    color: 0x333333,
    name: 'Carbone'
  },

  kevlar: {
    density: 1440, // kg/m¬≥
    youngModulus: 130e9, // Pa
    tensileStrength: 3600e6, // Pa
    color: 0x666666,
    name: 'Kevlar'
  },

  // Mat√©riaux de surface (tissus)
  ripstopNylon: {
    density: 40, // g/m¬≤ (surface density)
    thickness: 0.00015, // m
    tensileStrength: 150e6, // Pa
    color: 0xffffff,
    name: 'Ripstop Nylon'
  },

  dacron: {
    density: 45, // g/m¬≤
    thickness: 0.00018, // m
    tensileStrength: 180e6, // Pa
    color: 0xf0f0f0,
    name: 'Dacron'
  }
} as const;

// ============================================================================
// PR√âSETS DE LIGNES ET BRIDES
// ============================================================================

export const LINE_PRESETS = {
  standard: {
    stiffness: 2200, // N/m - Rigidit√©
    preTension: 75, // N - Tension minimale
    maxTension: 800, // N - Tension maximale
    dampingCoeff: 0.05, // Coefficient d'amortissement
    linearMassDensity: 0.0005, // kg/m - Masse lin√©ique
    color: 0xffaa00,
    name: 'Ligne Standard'
  },

  bridle: {
    stiffness: 5000, // N/m - Plus rigide pour les brides
    preTension: 10, // N - Tension minimale faible
    maxTension: 300, // N - Tension maximale
    dampingCoeff: 0.02, // Amortissement faible
    linearMassDensity: 0.0003, // kg/m - Plus l√©ger
    color: 0x00aaff,
    name: 'Bride'
  },

  control: {
    stiffness: 1800, // N/m - Moins rigide pour le contr√¥le
    preTension: 50, // N
    maxTension: 600, // N
    dampingCoeff: 0.08, // Amortissement plus fort
    linearMassDensity: 0.0007, // kg/m - Plus lourd
    color: 0xff4444,
    name: 'Ligne de Contr√¥le'
  }
} as const;

// ============================================================================
// PR√âSETS A√âRODYNAMIQUES
// ============================================================================

export const AERODYNAMIC_PRESETS = {
  // Coefficients de portance (lift) selon l'angle d'attaque
  liftCoefficients: {
    low: 0.2,     // Angle d'attaque faible
    medium: 0.8,  // Angle d'attaque moyen
    high: 1.2,    // Angle d'attaque √©lev√©
    stall: 0.1    // D√©crochage
  },

  // Coefficients de tra√Æn√©e (drag)
  dragCoefficients: {
    low: 0.05,    // Profil optimis√©
    medium: 0.08, // Profil standard
    high: 0.15,   // Profil d√©grad√©
    stall: 0.3    // D√©crochage
  },

  // Facteurs d'√©chelle pour √©quilibrer la simulation
  scaleFactors: {
    lift: 1.2,    // Facteur de portance
    drag: 1.2,    // Facteur de tra√Æn√©e
    torque: 1.0   // Facteur de couple
  }
} as const;

// ============================================================================
// PR√âSETS DE VENT
// ============================================================================

export const WIND_PRESETS = {
  calm: {
    speed: 5,      // km/h
    direction: 0,  // degr√©s
    turbulence: 0.001, // %
    name: 'Calme'
  },

  light: {
    speed: 15,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.005, // %
    name: 'L√©ger'
  },

  moderate: {
    speed: 25,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.01, // %
    name: 'Mod√©r√©'
  },

  strong: {
    speed: 35,     // km/h
    direction: 0,  // degr√©s
    turbulence: 0.02, // %
    name: 'Fort'
  }
} as const;

// ============================================================================
// PR√âSETS DE CONFIGURATION KITE
// ============================================================================

export const KITE_PRESETS = {
  standard: {
    area: 0.5288,  // m¬≤ - Surface calcul√©e
    mass: 0.31,    // kg - Masse calcul√©e
    span: 1.65,    // m - Envergure
    aspectRatio: 3.12, // Rapport d'allongement
    name: 'Kite Standard'
  },

  sport: {
    area: 0.6,     // m¬≤
    mass: 0.28,    // kg
    span: 1.8,     // m
    aspectRatio: 3.5,
    name: 'Kite Sport'
  },

  beginner: {
    area: 0.8,     // m¬≤
    mass: 0.35,    // kg
    span: 2.0,     // m
    aspectRatio: 2.8,
    name: 'Kite D√©butant'
  }
} as const;

// ============================================================================
// UTILITAIRES
// ============================================================================

export class PhysicalUtils {
  /**
   * Calcule la pression dynamique
   */
  static dynamicPressure(velocity: THREE.Vector3, airDensity: number = PHYSICAL_CONSTANTS.airDensity): number {
    const speed = velocity.length();
    return 0.5 * airDensity * speed * speed;
  }

  /**
   * Calcule le nombre de Reynolds
   */
  static reynoldsNumber(velocity: number, length: number, viscosity: number = PHYSICAL_CONSTANTS.dynamicViscosity): number {
    return (velocity * length) / viscosity;
  }

  /**
   * Convertit km/h en m/s
   */
  static kmhToMs(speedKmh: number): number {
    return speedKmh / 3.6;
  }

  /**
   * Convertit m/s en km/h
   */
  static msToKmh(speedMs: number): number {
    return speedMs * 3.6;
  }
}

=== main.ts ===

import { Simulation } from "./simulation";

// Initialisation de la simulation
async function startSimulation() {
  try {
    const app = new Simulation();
    await app.initialize();

    // D√©marrer la simulation
    await app.start();

    // Gestion du nettoyage lors de la fermeture de la page
    window.addEventListener("beforeunload", () => {
      if (app && typeof app.dispose === "function") {
        app.dispose();
      }
    });
  } catch {
    // Gestion d'erreur silencieuse - les erreurs sont d√©j√† logg√©es par la simulation
  }
}

// Lancer la simulation au chargement
startSimulation();


=== objects/Kite.ts ===


/**
 * Kite.ts - Mod√®le 3D du cerf-volant delta pour la simulation Kite
 *
 * Mod√®le physique (voir PHYSICS_MODEL.md) :
 *   - Structure tridimensionnelle rigide (frames carbone + surfaces toile)
 *   - Masse distribu√©e sur chaque surface proportionnellement √† son aire
 *   - Inertie calcul√©e automatiquement depuis la g√©om√©trie (I ‚âà m¬∑r¬≤)
 *   - Forces et couples √©mergent naturellement de la distribution spatiale des forces
 *   - Les brides et lignes sont des contraintes g√©om√©triques, pas des forces directes
 *   - L‚Äô√©quilibre du kite provient de la g√©om√©trie et de la r√©partition des masses
 *
 * Utilisation typique :
 *   - Instanci√© par le moteur physique et le rendu pour manipuler le kite
 *   - Sert de source unique pour les points et la g√©om√©trie du kite
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 *   - src/factories/FrameFactory.ts
 *   - src/factories/SurfaceFactory.ts
 *   - src/factories/PointFactory.ts
 */

import * as THREE from "three";

import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";
import { Primitive } from "../core/Primitive";
import { FrameFactory } from "../factories/FrameFactory";
import { SurfaceFactory } from "../factories/SurfaceFactory";
import { PointFactory, BridleLengths } from "../factories/PointFactory";
import { CONFIG } from "../simulation/config/SimulationConfig";

export class Kite extends StructuredObject implements ICreatable {
  // Mod√®le physique : Structure 3D rigide
  // - Structure tridimensionnelle rigide (frames carbone + surfaces toile)
  // - Masse distribu√©e sur chaque surface proportionnellement √† son aire
  // - Inertie calcul√©e automatiquement depuis la g√©om√©trie (I ‚âà m¬∑r¬≤)
  // - Forces et couples √©mergent naturellement de la distribution spatiale des forces
  // - Les brides et lignes sont des contraintes g√©om√©triques, pas des forces directes
  // - L‚Äô√©quilibre du kite provient de la g√©om√©trie et de la r√©partition des masses

  private frameFactory: FrameFactory;
  private surfaceFactory: SurfaceFactory;
  // Map centrale des points - Single Source of Truth
  private pointsMap: Map<string, [number, number, number]> = new Map();
  private bridleLines: THREE.Group | null = null;
  private bridleLengthFactor: number = 1.0; // Facteur de longueur virtuelle des brides principales
  private bridleLengths: BridleLengths = { ...CONFIG.bridle.defaultLengths };
  private params = {
    width: 1.65, // Envergure
    height: 0.65, // Hauteur
    depth: 0.20, // Profondeur whiskers
    frameDiameter: 0.01,
    frameColor: "#2a2a2a",
    sailColor: "#ff3333",
    sailOpacity: 0.9,
  };

  constructor(customParams = {}) {
    super("Cerf-volant Delta", false);
    this.params = { ...this.params, ...customParams };
    this.frameFactory = new FrameFactory();
    this.surfaceFactory = new SurfaceFactory();
    this.init();
  }

  /**
   * D√©finit tous les points anatomiques du cerf-volant
   * Utilise PointFactory pour encapsuler la logique de calcul
   */
  protected definePoints(): void {
    const { width, height, depth } = this.params;

    // Utiliser PointFactory pour calculer les positions avec bridleLengths physiques
    this.pointsMap = PointFactory.calculateDeltaKitePoints({
      width,
      height,
      depth,
      bridleLengths: this.bridleLengths
    });

    // Enregistrer dans StructuredObject pour compatibilit√© avec le syst√®me existant
    this.pointsMap.forEach((position, name) => {
      this.setPoint(name, position);
    });
  }

  /**
   * Construit la structure rigide avec FrameFactory
   */
  protected buildStructure(): void {
    const { frameDiameter, frameColor } = this.params;

    // Cr√©er le frame principal avec la Map de points partag√©e
    const mainFrameParams = {
      diameter: frameDiameter,
      material: frameColor,
      points: Array.from(this.pointsMap.entries()), // Passer LA Map de r√©f√©rence
      connections: [
        // √âpine centrale
        ["NEZ", "SPINE_BAS"] as [string, string],
        // Bords d'attaque
        ["NEZ", "BORD_GAUCHE"] as [string, string],
        ["NEZ", "BORD_DROIT"] as [string, string],
        // Spreader
        ["INTER_GAUCHE", "INTER_DROIT"] as [string, string],
      ],
    };

    const mainFrame = this.frameFactory.createObject('frame', mainFrameParams);
    this.add(mainFrame);

    // Cr√©er les whiskers avec un frame s√©par√© (plus fin)
    const whiskerFrameParams = {
      diameter: frameDiameter / 2,
      material: "#444444",
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      connections: [
        ["WHISKER_GAUCHE", "FIX_GAUCHE"] as [string, string],
        ["WHISKER_DROIT", "FIX_DROIT"] as [string, string],
      ],
    };

    const whiskerFrame = this.frameFactory.createObject('frame', whiskerFrameParams);
    this.add(whiskerFrame);

    // Cr√©er le syst√®me de bridage avec des lignes souples
    this.createBridleLines();
  }

  /**
   * Cr√©e les lignes de bridage souples (visuelles uniquement)
   * Ces lignes repr√©sentent des cordes sans √©lasticit√© ni effet ressort
   */
  private createBridleLines(): void {
    // Supprimer les anciennes lignes si elles existent
    if (this.bridleLines) {
      this.remove(this.bridleLines);
    }

    this.bridleLines = new THREE.Group();
    this.bridleLines.name = "BridleLines";

    // Configuration des brides
    const bridleConnections = [
      // Bridage gauche (3 lignes partant de CTRL_GAUCHE)
      ["CTRL_GAUCHE", "NEZ"],
      ["CTRL_GAUCHE", "INTER_GAUCHE"],
      ["CTRL_GAUCHE", "CENTRE"],
      // Bridage droit (3 lignes partant de CTRL_DROIT)
      ["CTRL_DROIT", "NEZ"],
      ["CTRL_DROIT", "INTER_DROIT"],
      ["CTRL_DROIT", "CENTRE"],
    ];

    // Mat√©riau pour les lignes de bridage
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: 1,
      opacity: 0.8,
      transparent: true,
    });

    // Cr√©er chaque ligne de bridage
    bridleConnections.forEach(([startName, endName]) => {
      const startPos = this.pointsMap.get(startName);
      const endPos = this.pointsMap.get(endName);

      if (startPos && endPos) {
        // Cr√©er une ligne droite simple (sans effet cat√©naire pour les brides internes)
        const geometry = new THREE.BufferGeometry();
        const points = [
          new THREE.Vector3(...startPos),
          new THREE.Vector3(...endPos),
        ];
        geometry.setFromPoints(points);

        const line = new THREE.Line(geometry, lineMaterial);
        line.name = `Bridle_${startName}_${endName}`;

        // Stocker la longueur de repos de la bride
        const restLength = new THREE.Vector3(...startPos).distanceTo(
          new THREE.Vector3(...endPos)
        );
        line.userData.restLength = restLength;
        line.userData.startPoint = startName;
        line.userData.endPoint = endName;

        this.bridleLines!.add(line);
      }
    });

    this.add(this.bridleLines!);
  }

  /**
   * Met √† jour les lignes de bridage pour suivre les points
   * √Ä appeler si les points bougent dynamiquement
   */
  public updateBridleLines(): void {
    if (!this.bridleLines) return;

    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const startName = line.userData.startPoint;
        const endName = line.userData.endPoint;
        const startPos = this.getPoint(startName);
        const endPos = this.getPoint(endName);

        if (startPos && endPos) {
          const geometry = line.geometry as THREE.BufferGeometry;
          const points = [
            startPos.clone(),
            endPos.clone(),
          ];
          geometry.setFromPoints(points);
          geometry.attributes.position.needsUpdate = true;
        }
      }
    });
  }

  /**
   * Met √† jour la visualisation des brides selon leurs tensions
   * Couleurs : vert (molle) ‚Üí jaune (moyenne) ‚Üí rouge (tendue)
   *
   * @param tensions - Tensions des 6 brides en Newtons
   */
  public updateBridleVisualization(tensions: {
    leftNez: number;
    leftInter: number;
    leftCentre: number;
    rightNez: number;
    rightInter: number;
    rightCentre: number;
  }): void {
    if (!this.bridleLines) return;

    // Mapping nom ligne ‚Üí tension
    const tensionMap = new Map<string, number>([
      ["Bridle_CTRL_GAUCHE_NEZ", tensions.leftNez],
      ["Bridle_CTRL_GAUCHE_INTER_GAUCHE", tensions.leftInter],
      ["Bridle_CTRL_GAUCHE_CENTRE", tensions.leftCentre],
      ["Bridle_CTRL_DROIT_NEZ", tensions.rightNez],
      ["Bridle_CTRL_DROIT_INTER_DROIT", tensions.rightInter],
      ["Bridle_CTRL_DROIT_CENTRE", tensions.rightCentre],
    ]);

    // Mettre √† jour couleur de chaque bride
    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const tension = tensionMap.get(line.name) ?? 0;
        const material = line.material as THREE.LineBasicMaterial;

        // Seuils de tension (N) - centralis√©s dans CONFIG
        const lowThreshold = CONFIG.debug.bridleTensionLow;
        const highThreshold = CONFIG.debug.bridleTensionHigh;

        if (tension < lowThreshold) {
          // Vert : bride molle
          material.color.setHex(0x00ff00);
          material.opacity = 0.5;
        } else if (tension < highThreshold) {
          // Jaune : tension moyenne
          // Interpolation vert ‚Üí jaune
          const t = (tension - lowThreshold) / (highThreshold - lowThreshold);
          const r = Math.floor(t * 255);
          const g = 255;
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.6 + t * 0.2; // 0.6 ‚Üí 0.8
        } else {
          // Rouge : bride tendue
          // Interpolation jaune ‚Üí rouge
          const t = Math.min((tension - highThreshold) / 100, 1);
          const r = 255;
          const g = Math.floor((1 - t) * 255);
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.8 + t * 0.2; // 0.8 ‚Üí 1.0
        }
      }
    });
  }

  /**
   * Construit les surfaces avec SurfaceFactory
   */
  protected buildSurfaces(): void {
    const { sailColor, sailOpacity } = this.params;

    // Cr√©er la toile avec 4 panneaux triangulaires
    const sailParams = {
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      panels: [
        // Toile gauche
        ["NEZ", "BORD_GAUCHE", "WHISKER_GAUCHE"],
        ["NEZ", "WHISKER_GAUCHE", "SPINE_BAS"],
        // Toile droite
        ["NEZ", "BORD_DROIT", "WHISKER_DROIT"],
        ["NEZ", "WHISKER_DROIT", "SPINE_BAS"],
      ],
      material: {
        color: sailColor,
        transparent: true,
        opacity: sailOpacity,
        doubleSided: true, // Visible des deux c√¥t√©s
      },
    };

    const sail = this.surfaceFactory.createObject(sailParams);
    this.add(sail);

    // Ajouter des marqueurs visuels aux points cl√©s
    this.addVisualMarkers();
  }

  /**
   * M√©thode helper pour obtenir la Map de points
   * Peut √™tre utilis√©e si d'autres objets ont besoin des points
   */
  public getPointsMap(): Map<string, [number, number, number]> {
    return new Map(this.pointsMap); // Retourner une copie pour √©viter les modifications externes
  }

  /**
   * Ajuste le facteur de longueur virtuelle des brides principales (NEZ vers CTRL_*)
   * @param factor - Facteur de longueur (0.5 = 50% plus court, 1.0 = normal, 1.5 = 50% plus long)
   */
  public adjustBridleLength(factor: number): void {
    // Limiter la valeur entre 0.5 et 1.5
    this.bridleLengthFactor = Math.max(0.5, Math.min(1.5, factor));
    console.log(
      `üìè Facteur de longueur des brides principales: ${this.bridleLengthFactor}`
    );
  }

  /**
   * Retourne la longueur de repos virtuelle pour les brides principales
   * Utilis√© par la physique pour calculer les tensions
   * @param bridleName - 'left' ou 'right'
   * @returns La longueur de repos modifi√©e ou undefined si pas une bride principale
   */
  public getBridleRestLength(bridleName: "left" | "right"): number | undefined {
    const nez = this.getPoint("NEZ");
    const ctrl = this.getPoint(
      bridleName === "left" ? "CTRL_GAUCHE" : "CTRL_DROIT"
    );

    if (!nez || !ctrl) return undefined;

    // Calculer la distance g√©om√©trique r√©elle
    const realDistance = nez.distanceTo(ctrl);

    // Appliquer le facteur de longueur virtuelle
    // factor < 1 = bride plus courte = plus de tension
    // factor > 1 = bride plus longue = moins de tension
    return realDistance * this.bridleLengthFactor;
  }

  /**
   * Retourne le facteur de longueur actuel des brides
   */
  public getBridleLengthFactor(): number {
    return this.bridleLengthFactor;
  }

  /**
   * Ajuste les longueurs physiques des brides (en m√®tres)
   * @param lengths - Longueurs des 3 brides { nez, inter, centre }
   */
  public setBridleLengths(lengths: Partial<BridleLengths>): void {
    // Mettre √† jour les longueurs (merge avec les valeurs existantes)
    this.bridleLengths = {
      ...this.bridleLengths,
      ...lengths
    };

    console.log(`ü™Å Longueurs brides: NEZ=${this.bridleLengths.nez.toFixed(2)}m, INTER=${this.bridleLengths.inter.toFixed(2)}m, CENTRE=${this.bridleLengths.centre.toFixed(2)}m`);

    // Supprimer tous les enfants pour nettoyer l'ancienne g√©om√©trie
    this.clearChildren();

    // Recalculer les points avec les nouvelles longueurs
    this.definePoints();

    // Reconstruire le kite avec les nouveaux points
    this.buildStructure();
    this.buildSurfaces();
    this.createBridleLines();

    // Recr√©er les marqueurs visuels aux nouvelles positions
    this.addVisualMarkers();
  }

  /**
   * Supprime tous les enfants du kite (g√©om√©trie, marqueurs, etc.)
   */
  private clearChildren(): void {
    // Supprimer tous les enfants Three.js
    while (this.children.length > 0) {
      this.remove(this.children[0]);
    }
  }

  /**
   * Retourne les longueurs actuelles des brides
   */
  public getBridleLengths(): BridleLengths {
    return { ...this.bridleLengths };
  }

  /**
   * Convertit un point du rep√®re local du kite vers le rep√®re monde
   * 
   * IMPORTANT : Cette m√©thode cr√©e une copie pour √©viter de modifier les points stock√©s.
   * Pour la transformation Three.js standard, utilisez directement super.localToWorld()
   *
   * @param localPos - Position dans le rep√®re local du kite
   * @returns Nouvelle position dans le rep√®re monde (copie)
   *
   * @example
   * ```typescript
   * const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
   * const worldPos = kite.toWorldCoordinates(ctrlLeft);
   * ```
   */
  public toWorldCoordinates(localPos: THREE.Vector3): THREE.Vector3 {
    return localPos
      .clone()
      .applyQuaternion(this.quaternion)
      .add(this.position);
  }

  /**
   * Ajoute des marqueurs visuels aux points importants
   */
  private addVisualMarkers(): void {
    // Nez (point rouge)
    const nez = this.getPoint("NEZ");
    if (nez) {
      const marker = Primitive.sphere(0.025, "#ff0000");
      this.addPrimitiveAt(marker, [nez.x, nez.y, nez.z]);
    }

    // Points de contr√¥le
    const ctrlG = this.getPoint("CTRL_GAUCHE");
    if (ctrlG) {
      const marker = Primitive.sphere(0.025, "#dc143c");
      this.addPrimitiveAt(marker, [ctrlG.x, ctrlG.y, ctrlG.z]);
    }

    const ctrlD = this.getPoint("CTRL_DROIT");
    if (ctrlD) {
      const marker = Primitive.sphere(0.025, "#b22222");
      this.addPrimitiveAt(marker, [ctrlD.x, ctrlD.y, ctrlD.z]);
    }
  }

  // Impl√©mentation de l'interface ICreatable
  create(): this {
    return this;
  }

  getName(): string {
    return "Cerf-volant Delta v2";
  }

  getDescription(): string {
    return "Cerf-volant delta construit avec les factories CAO";
  }

  getPrimitiveCount(): number {
    return 25; // Frame + surfaces + marqueurs
  }
}

/**
 * AVANTAGES de cette approche avec factories:
 *
 * 1. **Modularit√©** : Points, frames et surfaces sont g√©r√©s par des factories d√©di√©es
 * 2. **R√©utilisabilit√©** : Les factories peuvent √™tre utilis√©es pour d'autres objets
 * 3. **Param√©trage** : Facile de modifier les param√®tres de chaque composant
 * 4. **Composition** : On peut combiner diff√©rentes factories
 * 5. **√âvolutivit√©** : Facile d'ajouter de nouvelles fonctionnalit√©s aux factories
 *
 * UTILISATION DE POINTFACTORY:
 * - Tous les points sont d√©finis dans une Map centralis√©e
 * - PointFactory cr√©e un objet points r√©utilisable
 * - Pas de sym√©trie automatique : chaque point est d√©fini explicitement
 * - Permet une gestion coh√©rente et valid√©e des points anatomiques
 *
 * WORKFLOW CAO:
 * 1. PointFactory ‚Üí D√©finir tous les points anatomiques
 * 2. FrameFactory ‚Üí Construire la structure rigide
 * 3. SurfaceFactory ‚Üí Ajouter les surfaces/toiles
 * 4. Assembly ‚Üí Combiner le tout (futur)
 */


=== objects/Line.ts ===

/**
 * Line.ts - Entit√© m√©tier repr√©sentant une ligne de cerf-volant
 *
 * R√¥le :
 *   - Encapsule les propri√©t√©s physiques d'une ligne (Dyneema/Spectra)
 *   - Repr√©sente une ligne individuelle du syst√®me de pilotage
 *   - Pure data object, pas de logique de calcul
 *
 * Responsabilit√© :
 *   - Stocker les param√®tres physiques (longueur, rigidit√©, tension)
 *   - G√©rer les points d'attache (nom des points anatomiques)
 *   - Fournir un √©tat coh√©rent pour les calculs physiques
 *
 * Relation avec les autres modules :
 *   - Utilis√© par LinePhysics pour les calculs de force
 *   - Cr√©√© par LineFactory
 *   - Consomm√© par LineSystem (orchestration)
 *
 * Philosophie :
 *   - "Tell, don't ask" : La ligne expose son √©tat, ne fait pas de calculs
 *   - Immutabilit√© partielle : Les param√®tres physiques sont readonly
 *   - Single Responsibility : Repr√©sentation m√©tier uniquement
 *
 * Voir aussi :
 *   - src/simulation/physics/LinePhysics.ts (calculs)
 *   - src/factories/LineFactory.ts (cr√©ation)
 *   - src/objects/mechanical/LineVisual.ts (rendu)
 */


/**
 * Configuration physique d'une ligne de cerf-volant
 */
export interface LineConfig {
  /** Longueur au repos (m√®tres) */
  length: number;

  /** Rigidit√© axiale EA/L (N/m) - Typique Dyneema : 2200 N/m pour 15m */
  stiffness: number;

  /** Pr√©-tension minimale (N) - Toujours pr√©sente, m√™me ligne molle */
  preTension: number;

  /** Tension maximale avant rupture (N) */
  maxTension: number;

  /** Coefficient d'amortissement interne (sans dimension, 0-1) */
  dampingCoeff: number;

  /** Masse lin√©ique (kg/m) - Pour calcul cat√©naire */
  linearMassDensity: number;
}

/**
 * Points d'attache d'une ligne
 */
export interface LineAttachments {
  /** Nom du point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Nom du point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;
}

/**
 * Entit√© repr√©sentant une ligne de cerf-volant
 *
 * @example
 * ```typescript
 * const leftLine = new Line({
 *   length: 15,
 *   stiffness: 2200,
 *   preTension: 75,
 *   maxTension: 800,
 *   dampingCoeff: 0.05,
 *   linearMassDensity: 0.0005
 * }, {
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 * ```
 */
export class Line {
  /** Identifiant unique de la ligne */
  public readonly id: string;

  /** Configuration physique (immuable) */
  public readonly config: Readonly<LineConfig>;

  /** Points d'attache (immuables) */
  public readonly attachments: Readonly<LineAttachments>;

  /** √âtat actuel de la ligne */
  private currentLength: number;
  private currentTension: number;

  /** Timestamp derni√®re mise √† jour */
  private lastUpdateTime: number;

  constructor(
    config: LineConfig,
    attachments: LineAttachments,
    id?: string
  ) {
    this.id = id || `line_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = Object.freeze({ ...config });
    this.attachments = Object.freeze({ ...attachments });

    // √âtat initial
    this.currentLength = config.length;
    this.currentTension = config.preTension;
    this.lastUpdateTime = 0;
  }

  /**
   * Met √† jour l'√©tat actuel de la ligne
   * (Appel√© par LinePhysics apr√®s calcul)
   */
  updateState(length: number, tension: number, timestamp: number): void {
    this.currentLength = length;
    this.currentTension = tension;
    this.lastUpdateTime = timestamp;
  }

  /**
   * Obtient la longueur actuelle (√©tir√©e)
   */
  getCurrentLength(): number {
    return this.currentLength;
  }

  /**
   * Obtient la tension actuelle
   */
  getCurrentTension(): number {
    return this.currentTension;
  }

  /**
   * Calcule l'extension actuelle (Œîx = L_current - L_rest)
   */
  getExtension(): number {
    return Math.max(0, this.currentLength - this.config.length);
  }

  /**
   * V√©rifie si la ligne est tendue
   */
  isTaut(): boolean {
    return this.currentLength > this.config.length;
  }

  /**
   * V√©rifie si la ligne est proche de la rupture
   */
  isNearBreaking(threshold: number = 0.9): boolean {
    return this.currentTension >= this.config.maxTension * threshold;
  }

  /**
   * Obtient le timestamp de derni√®re mise √† jour
   */
  getLastUpdateTime(): number {
    return this.lastUpdateTime;
  }

  /**
   * Clone cette ligne avec une nouvelle configuration
   */
  clone(newConfig?: Partial<LineConfig>): Line {
    return new Line(
      { ...this.config, ...newConfig },
      { ...this.attachments }
    );
  }

  /**
   * Repr√©sentation textuelle pour debug
   */
  toString(): string {
    return `Line[${this.id}](${this.attachments.kitePoint} ‚Üí ${this.attachments.barPoint}) ` +
           `L=${this.currentLength.toFixed(3)}m T=${this.currentTension.toFixed(1)}N`;
  }

  /**
   * Export JSON pour s√©rialisation
   */
  toJSON(): object {
    return {
      id: this.id,
      config: this.config,
      attachments: this.attachments,
      state: {
        currentLength: this.currentLength,
        currentTension: this.currentTension,
        lastUpdateTime: this.lastUpdateTime
      }
    };
  }

  /**
   * Cr√©e une ligne depuis JSON
   */
  static fromJSON(data: any): Line {
    const line = new Line(data.config, data.attachments, data.id);
    if (data.state) {
      line.updateState(
        data.state.currentLength,
        data.state.currentTension,
        data.state.lastUpdateTime
      );
    }
    return line;
  }
}


=== simulation.ts ===

/**
 * Point d'entr√©e de compatibilit√©
 *
 * Ce fichier maintient la compatibilit√© avec l'ancien import
 * tout en redirigeant vers la nouvelle structure modulaire
 */

export { SimulationApp as Simulation } from './simulation/SimulationApp';

=== simulation/SimulationApp.ts ===

/**
 * SimulationApp.ts - Orchestrateur ECS pur
 *
 * Architecture ECS propre avec s√©paration des responsabilit√©s.
 * Point d'entr√©e unique pour la simulation kite.
 */

import * as THREE from 'three';

import { Logger } from '../utils/Logging';

import {
  InputSystem,
  RenderSystem,
  KitePhysicsSystem,
  type InputConfig,
  type RenderConfig
} from './systems';
import { ControlBarSystem } from './systems/ControlBarSystem';
import { LinesRenderSystem } from './systems/LinesRenderSystem';
import { PilotSystem } from './systems/PilotSystem';
import {
  UIManager,
  type SimulationControls
} from './ui/UIManager';
import { DebugRenderer } from './rendering/DebugRenderer';
import { CONFIG } from './config/SimulationConfig';
import { EntityManager } from './entities/EntityManager';
import { TransformComponent, MeshComponent } from './components';
import { ControlBarEntityFactory, PilotEntityFactory, KiteEntityFactory } from './factories';

export interface SimulationConfig {
  targetFPS: number;
  maxFrameTime: number;
  enableDebug: boolean;
  enableRenderSystem: boolean;
  enableCompletePhysics: boolean;
  input: Partial<InputConfig>;
  render: Partial<RenderConfig>;
}

/**
 * Application principale de simulation
 * Architecture ECS avec responsabilit√© d'orchestration uniquement
 */
export class SimulationApp {
  private readonly logger: Logger;
  private config: SimulationConfig;

  // === GESTIONNAIRE D'ENTIT√âS ===
  private entityManager!: EntityManager;

  // === SYST√àMES ECS ===
  private inputSystem!: InputSystem;
  private renderSystem?: RenderSystem;
  private kitePhysicsSystem?: KitePhysicsSystem;
  private controlBarSystem!: ControlBarSystem;
  private linesRenderSystem!: LinesRenderSystem;
  private pilotSystem!: PilotSystem;

  // === ENTIT√âS PRINCIPALES ===
  // Supprim√©es - utilisation exclusive d'EntityManager

  // === INTERFACE ===
  private uiManager?: UIManager;
  private debugRenderer?: DebugRenderer;
  private simulationControls!: SimulationControls;

  // === √âTAT ===
  private isRunning = false;
  private isInitialized = false;
  private frameCount = 0;
  private totalTime = 0;
  private lastFrameTime = 0;

  constructor(config: Partial<SimulationConfig> = {}) {
    this.logger = Logger.getInstance();

    this.config = {
      targetFPS: 60,
      maxFrameTime: 1 / 30,
      enableDebug: true,
      enableRenderSystem: true,
      enableCompletePhysics: true,
      input: {},
      render: {},
      ...config
    };

    this.logger.info('SimulationApp created', 'SimulationApp');
  }

  /**
   * Initialise la simulation
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('Initializing simulation...', 'SimulationApp');

      // Cr√©er le gestionnaire d'entit√©s
      this.entityManager = new EntityManager();

      // Cr√©er les syst√®mes
      await this.createSystems();

      // Cr√©er les entit√©s
      this.createEntities();

      // Initialiser les syst√®mes
      await this.initializeSystems();

      // Cr√©er l'interface
      this.createInterface();

      // Configurer le rendu
      this.setupRendering();

      this.isInitialized = true;
      this.logger.info('‚úÖ Simulation initialized', 'SimulationApp');

    } catch (error) {
      this.logger.error(`‚ùå Initialization failed: ${error}`, 'SimulationApp');
      throw error;
    }
  }

  /**
   * Cr√©e tous les syst√®mes ECS
   */
  private async createSystems(): Promise<void> {
    this.inputSystem = new InputSystem(this.config.input);
    this.controlBarSystem = new ControlBarSystem();
    this.linesRenderSystem = new LinesRenderSystem();
    this.pilotSystem = new PilotSystem();

    if (this.config.enableRenderSystem) {
      this.renderSystem = new RenderSystem(this.config.render);
    }

    if (this.config.enableCompletePhysics) {
      // Position de la barre de contr√¥le calcul√©e √† partir du pilote
      const controlBarPosition = new THREE.Vector3(
        CONFIG.pilot.position.x,
        CONFIG.pilot.position.y + CONFIG.controlBar.offsetY,
        CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ
      );

      this.kitePhysicsSystem = new KitePhysicsSystem({
        windSpeed: CONFIG.wind.defaultSpeed,
        windDirection: CONFIG.wind.defaultDirection,
        turbulence: CONFIG.wind.defaultTurbulence,
        lineLength: CONFIG.lines.defaultLength,
        pilotPosition: controlBarPosition,
        enableConstraints: true,
        enableAerodynamics: true,
        enableGravity: true
      });
    }
  }

  /**
   * Cr√©e les entit√©s principales
   */
  private createEntities(): void {
    // Cr√©er l'entit√© pilote EN PREMIER (pour que la barre puisse s'y attacher)
    this.createPilotEntity();

    // Cr√©er l'entit√© kite
    this.createKiteEntity();

    // Cr√©er les entit√©s ECS
    this.createControlBarEntity();
    
    // Note: createLineEntities() est appel√©e dans setupRendering()
    // car elle n√©cessite que renderSystem.getScene() retourne une sc√®ne valide
    
    this.logger.debug('Entity positions after initialization:', 'SimulationApp');
    const pilotEntity = this.entityManager.getEntity('pilot');
    if (pilotEntity) {
      const pilotTransform = pilotEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Pilot position: ${pilotTransform?.position}`, 'SimulationApp');
    }

    const controlBarEntity = this.entityManager.getEntity('controlBar');
    if (controlBarEntity) {
      const barTransform = controlBarEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Control bar position: ${barTransform?.position}`, 'SimulationApp');
    }

    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteTransform = kiteEntity.getComponent<TransformComponent>('transform');
      this.logger.debug(`Kite position: ${kiteTransform?.position}`, 'SimulationApp');
    }
  }

  /**
   * Cr√©e l'entit√© ECS du kite
   */
  private createKiteEntity(): void {
    // Cr√©er l'entit√© via factory (objet Kite + composants ECS)
    const kiteEntity = KiteEntityFactory.create();
    
    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(kiteEntity);

    // Note: Le kite sera ajout√© √† la sc√®ne dans setupRendering()
    // Ne pas ajouter ici pour √©viter la duplication

    // Configurer le syst√®me de physique du kite
    if (this.kitePhysicsSystem) {
      // Extraire l'objet Kite du MeshComponent
      const kite = KiteEntityFactory.getKiteObject(kiteEntity);
      if (kite) {
        this.kitePhysicsSystem.setKite(kite);

        // Connecter le ControlBarSystem pour fournir les positions des poign√©es
        this.kitePhysicsSystem.setHandlesProvider({
          getHandlePositions: () => this.controlBarSystem.getHandlePositions()
        });
      }
    }
  }

  /**
   * Cr√©e l'entit√© ECS de la barre de contr√¥le
   */
  private createControlBarEntity(): void {
    // R√©cup√©rer le pilote pour attachement
    const pilotEntity = this.entityManager.getEntity('pilot');
    const pilotMesh = pilotEntity?.getComponent<MeshComponent>('mesh');
    
    // Cr√©er l'entit√© via factory (g√©om√©trie + composants ECS)
    const controlBarEntity = ControlBarEntityFactory.create({
      parentObject: pilotMesh?.object3D
    });
    
    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(controlBarEntity);
    
    // Configurer les syst√®mes
    this.controlBarSystem.setControlBarEntity(controlBarEntity);
    this.controlBarSystem.setInputSystem(this.inputSystem);
    
    // Initialiser la position de r√©f√©rence dans le syst√®me pilote
    const worldPosition = new THREE.Vector3();
    const controlBarMesh = controlBarEntity.getComponent<MeshComponent>('mesh');
    if (controlBarMesh) {
      controlBarMesh.object3D.getWorldPosition(worldPosition);
      this.pilotSystem.setControlBarPosition(worldPosition);
      this.logger.info('ControlBar attached as child of Pilot', 'SimulationApp');
    }
  }

  /**
   * Cr√©e les entit√©s ECS des lignes de contr√¥le
   */
  private createLineEntities(): void {
    if (!this.renderSystem) return;

    const scene = this.renderSystem.getScene();
    if (!scene) return;

    // R√©cup√©rer le kite depuis EntityManager
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kite = KiteEntityFactory.getKiteObject(kiteEntity);
      if (kite) {
        this.linesRenderSystem.setKite(kite);
      }
    }

    // Configurer le syst√®me
    this.linesRenderSystem.setControlBarSystem(this.controlBarSystem);

    // Connecter le syst√®me de physique pour la visualisation des tensions
    if (this.kitePhysicsSystem) {
      this.linesRenderSystem.setKitePhysicsSystem(this.kitePhysicsSystem);
    }

    // Cr√©er les entit√©s de lignes (elles sont g√©r√©es par LinesRenderSystem)
    this.linesRenderSystem.createLineEntity('leftLine', 'left', scene);
    this.linesRenderSystem.createLineEntity('rightLine', 'right', scene);
  }

  /**
   * Cr√©e l'entit√© ECS du pilote
   */
  private createPilotEntity(): void {
    // Cr√©er l'entit√© via factory
    const pilotEntity = PilotEntityFactory.create();

    // Enregistrer dans EntityManager
    this.entityManager.registerEntity(pilotEntity);

    // Configurer le syst√®me pilote
    this.pilotSystem.setPilotEntity(pilotEntity);

    // Note: La position de la barre de contr√¥le sera initialis√©e dans createControlBarEntity()
    // apr√®s que la barre soit cr√©√©e et attach√©e au pilote
  }



  /**
   * Initialise tous les syst√®mes
   */
  private async initializeSystems(): Promise<void> {
    const initPromises: Promise<void>[] = [
      this.inputSystem.initialize(),
      this.controlBarSystem.initialize(),
      this.linesRenderSystem.initialize(),
      this.pilotSystem.initialize()
    ];

    if (this.renderSystem) {
      initPromises.push(this.renderSystem.initialize());
    }

    if (this.kitePhysicsSystem) {
      initPromises.push(this.kitePhysicsSystem.initialize());
    }

    await Promise.all(initPromises);
  }

  /**
   * Cr√©e l'interface utilisateur
   */
  private createInterface(): void {
    // L'interface n√©cessite le syst√®me de rendu
    if (!this.renderSystem) return;

    // Cr√©er les contr√¥les
    this.simulationControls = this.createSimulationControls();

    // Cr√©er le debug renderer (requis par UIManager) - passer physicsSystem
    this.debugRenderer = new DebugRenderer({
      addObject: (obj: THREE.Object3D) => this.renderSystem!.addToScene(obj),
      removeObject: (obj: THREE.Object3D) => this.renderSystem!.removeFromScene(obj),
      getScene: () => this.renderSystem!.getScene()
    }, this.kitePhysicsSystem);

    // Cr√©er l'UI manager
    this.uiManager = new UIManager(
      this.simulationControls,
      this.debugRenderer,
      () => this.reset(),
      () => { this.isRunning ? this.stop() : this.start(); }
    );
  }

  /**
   * Configure le rendu
   */
  private setupRendering(): void {
    if (!this.renderSystem) {
      console.error('‚ùå RenderSystem is null');
      return;
    }

    const scene = this.renderSystem.getScene();
    if (!scene) {
      console.error('‚ùå Scene is null');
      return;
    }

    this.logger.info('Setting up rendering...', 'SimulationApp');

    // Cr√©er les entit√©s de lignes (n√©cessite que la sc√®ne soit initialis√©e)
    this.createLineEntities();

    // Ajouter le kite √† la sc√®ne
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
      if (kiteMesh) {
        scene.add(kiteMesh.object3D);
        this.logger.info('Kite added to scene', 'SimulationApp');
      } else {
        this.logger.error('Kite mesh component not found', 'SimulationApp');
      }
    } else {
      this.logger.error('Kite entity not found', 'SimulationApp');
    }

    // Ajouter les entit√©s ECS √† la sc√®ne via leurs composants Mesh
    // Note: ControlBar n'est plus ajout√©e directement car elle est enfant du Pilot
    const pilotEntity = this.entityManager.getEntity('pilot');
    if (pilotEntity) {
      const pilotMesh = pilotEntity.getComponent<MeshComponent>('mesh');
      if (pilotMesh) {
        scene.add(pilotMesh.object3D); // Ajoute le pilote ET sa barre de contr√¥le enfant
      }
    }

    // D√©marrer le rendu
    this.renderSystem.startRendering();
  }

  /**
   * Cr√©e les contr√¥les de simulation
   */
  private createSimulationControls(): SimulationControls {
    return {
      getBridleLengths: () => this.kitePhysicsSystem?.getBridleLengths() || { nez: 0.65, inter: 0.65, centre: 0.65 },
      setBridleLength: (type: "nez" | "inter" | "centre", length: number) => {
        if (this.kitePhysicsSystem) {
          const currentLengths = this.kitePhysicsSystem.getBridleLengths();
          this.kitePhysicsSystem.setBridleLengths({
            ...currentLengths,
            [type]: length
          });
        }
      },
      setLineLength: (length: number) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setLineLength(length);
        }
      },
      setWindParams: (params: { speed?: number; direction?: number; turbulence?: number }) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setWindParams(params);
        }
      },
      getForceSmoothing: () => this.kitePhysicsSystem?.getForceSmoothing() || 0.1,
      setForceSmoothing: (value: number) => {
        if (this.kitePhysicsSystem) {
          this.kitePhysicsSystem.setForceSmoothing(value);
        }
      },
      getKiteState: () => this.kitePhysicsSystem?.getKiteState() || {
        position: new THREE.Vector3(),
        velocity: new THREE.Vector3(),
        angularVelocity: new THREE.Vector3(),
        orientation: new THREE.Quaternion()
      },
      getWindState: () => {
        const windState = this.kitePhysicsSystem?.getWindState();
        return windState ? {
          baseSpeed: windState.baseSpeed,
          baseDirection: windState.baseDirection,
          turbulence: windState.turbulence
        } : {
          baseSpeed: 0,
          baseDirection: new THREE.Vector3(),
          turbulence: 0
        };
      },
      getLineLength: () => this.kitePhysicsSystem?.getLineSystem()?.lineLength || CONFIG.lines.defaultLength,
      getControlLineDiagnostics: () => {
        return this.kitePhysicsSystem?.getControlLineDiagnostics() || null;
      },
      getAerodynamicForces: () => {
        return this.kitePhysicsSystem?.getAerodynamicForces() || null;
      }
    };
  }

  /**
   * D√©marre la simulation
   */
  start(): void {
    if (!this.isInitialized) {
      throw new Error('Simulation must be initialized first');
    }

    if (this.isRunning) return;

    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.logger.info('‚ñ∂Ô∏è Simulation started', 'SimulationApp');

    // Mettre √† jour le bouton UI
    this.uiManager?.updatePlayButton(true);

    this.updateLoop();
  }

  /**
   * Arr√™te la simulation
   */
  stop(): void {
    this.isRunning = false;
    this.logger.info('‚è∏Ô∏è Simulation stopped', 'SimulationApp');

    // Mettre √† jour le bouton UI
    this.uiManager?.updatePlayButton(false);
  }

  /**
   * R√©initialise la simulation
   */
  reset(): void {
    this.logger.info('üîÑ Resetting simulation...', 'SimulationApp');

    const wasRunning = this.isRunning;

    // Arr√™ter temporairement pour √©viter les mises √† jour pendant le reset
    if (this.isRunning) {
      this.isRunning = false;
    }

    // Reset systems
    this.inputSystem.reset();
    this.controlBarSystem.reset();
    this.kitePhysicsSystem?.reset();

    // Reset kite position avec calcul automatique de la position initiale
    const initialPos = KiteEntityFactory.calculateInitialPosition();
    const kiteEntity = this.entityManager.getEntity('kite');
    if (kiteEntity) {
      const kiteTransform = kiteEntity.getComponent<TransformComponent>('transform');
      const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
      if (kiteTransform && kiteMesh) {
        kiteTransform.position.copy(initialPos);
        kiteTransform.rotation = 0;
        kiteTransform.quaternion.identity();
        kiteMesh.syncToObject3D({
          position: kiteTransform.position,
          quaternion: kiteTransform.quaternion,
          scale: kiteTransform.scale
        });
      }
    }

    // Reset state
    this.frameCount = 0;
    this.totalTime = 0;
    this.lastFrameTime = performance.now();

    // Red√©marrer si c'√©tait en cours d'ex√©cution
    if (wasRunning) {
      this.isRunning = true;
    }

    this.logger.info('‚úÖ Simulation reset', 'SimulationApp');
  }

  /**
   * Boucle de mise √† jour ECS
   */
  private updateLoop = (): void => {
    if (!this.isRunning) return;

    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, this.config.maxFrameTime);
    this.lastFrameTime = currentTime;

    this.totalTime += deltaTime;
    this.frameCount++;

    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: !this.isRunning,
      debugMode: this.config.enableDebug
    };

    try {
      // Mise √† jour des syst√®mes dans l'ordre des priorit√©s
      this.inputSystem.update(context);

      if (this.kitePhysicsSystem) {
        const inputState = this.inputSystem.getInputState();
        this.kitePhysicsSystem.setBarRotation(inputState.barPosition);
        this.kitePhysicsSystem.update(context);
      }

      // Mise √† jour du syst√®me de barre de contr√¥le ECS
      // (La rotation est maintenant obtenue directement depuis InputSystem)
      this.controlBarSystem.update(context);

      // Mise √† jour du syst√®me pilote
      this.pilotSystem.update(context);

      // Note: Synchronisation kite ECS effectu√©e directement via les syst√®mes
      // Plus besoin de r√©f√©rence temporaire au syst√®me legacy

      // Mise √† jour du syst√®me de rendu des lignes
      this.linesRenderSystem.update(context);

      if (this.renderSystem) {
        this.renderSystem.update(context);
      }

      // Mise √† jour UI
      this.uiManager?.updateDebugInfo();

      // Mise √† jour des informations de debug avec les donn√©es ECS
      if (this.debugRenderer && this.kitePhysicsSystem) {
        this.debugRenderer.updateDebugDisplay(this.kitePhysicsSystem);
      }

      // Debug visualization avec ECS
      if (this.debugRenderer && this.kitePhysicsSystem && this.debugRenderer.isDebugMode()) {
        const kiteEntity = this.entityManager.getEntity('kite');
        if (kiteEntity) {
          const kiteMesh = kiteEntity.getComponent<MeshComponent>('mesh');
          if (kiteMesh && kiteMesh.object3D) {
            // R√©cup√©rer l'objet Kite depuis le MeshComponent
            const kite = KiteEntityFactory.getKiteObject(kiteEntity);
            if (kite) {
              this.debugRenderer.updateDebugVectors(kite, this.kitePhysicsSystem);
            }
          }
        }
      }

    } catch (error) {
      this.logger.error(`Update error: ${error}`, 'SimulationApp');
    }

    requestAnimationFrame(this.updateLoop);
  };







  /**
   * Nettoie les ressources
   */
  dispose(): void {
    this.logger.info('Disposing SimulationApp...', 'SimulationApp');

    this.stop();

    // Dispose systems
    this.inputSystem.dispose();
    this.controlBarSystem.dispose();
    this.renderSystem?.dispose();
    this.kitePhysicsSystem?.dispose();

    this.logger.info('‚úÖ SimulationApp disposed', 'SimulationApp');
  }

  // === ACCESSEURS ===

  getSystems() {
    return {
      input: this.inputSystem,
      controlBar: this.controlBarSystem,
      render: this.renderSystem,
      kitePhysics: this.kitePhysicsSystem
    };
  }

  getConfig(): SimulationConfig {
    return { ...this.config };
  }

  getStats() {
    return {
      isRunning: this.isRunning,
      isInitialized: this.isInitialized,
      frameCount: this.frameCount,
      totalTime: this.totalTime,
      fps: this.frameCount / Math.max(this.totalTime, 0.001)
    };
  }

  isSimulationRunning(): boolean {
    return this.isRunning;
  }

  isSimulationInitialized(): boolean {
    return this.isInitialized;
  }
}

=== simulation/components/KiteComponent.ts ===

/**
 * KiteComponent.ts - Composant de donn√©es pour l'entit√© cerf-volant.
 *
 * Contient les donn√©es sp√©cifiques √† un cerf-volant qui ne sont pas couvertes
 * par les composants g√©n√©riques comme TransformComponent ou PhysicsComponent.
 *
 * Inclut des informations sur la g√©om√©trie, les points de bridle, et l'√©tat.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

// Importation des d√©pendances

export class KiteComponent implements Component {
  readonly type = 'kite';

  // Map des points anatomiques du cerf-volant en coordonn√©es locales.
  public points: Map<string, THREE.Vector3> = new Map();

  // Donn√©es sur les surfaces pour les calculs a√©rodynamiques.
  public surfaces: Array<{
    vertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];
    area: number;
    centroid: THREE.Vector3;
    normal?: THREE.Vector3;
  }> = [];

  // Constructeur pour initialiser les points et surfaces

  constructor(
    points: Map<string, THREE.Vector3>,
    surfaces: Array<{
      vertices: [THREE.Vector3, THREE.Vector3, THREE.Vector3];
      area: number;
      centroid: THREE.Vector3;
      normal?: THREE.Vector3;
    }> = []
  ) {
    this.points = new Map(
      Array.from(points.entries()).map(([name, position]) => [name, position.clone()])
    );
    this.surfaces = surfaces.map(({ vertices, area, centroid, normal }) => ({
      vertices: [vertices[0].clone(), vertices[1].clone(), vertices[2].clone()],
      area,
      centroid: centroid.clone(),
      normal: normal?.clone()
    }));
  }
}


=== simulation/components/MeshComponent.ts ===

/**
 * MeshComponent.ts - Composant de g√©om√©trie Three.js
 *
 * Contient la r√©f√©rence √† un objet 3D Three.js (Mesh, Group, Line, etc.)
 * Utilis√© pour le rendu visuel des entit√©s.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

/**
 * Composant contenant un objet 3D Three.js
 */
export class MeshComponent implements Component {
  readonly type = 'mesh';

  public object3D: THREE.Object3D;
  public visible: boolean;
  public castShadow: boolean;
  public receiveShadow: boolean;

  constructor(
    object3D: THREE.Object3D,
    options: {
      visible?: boolean;
      castShadow?: boolean;
      receiveShadow?: boolean;
    } = {}
  ) {
    this.object3D = object3D;
    this.visible = options.visible !== undefined ? options.visible : true;
    this.castShadow = options.castShadow || false;
    this.receiveShadow = options.receiveShadow || false;

    // Appliquer les options
    this.object3D.visible = this.visible;
    this.object3D.castShadow = this.castShadow;
    this.object3D.receiveShadow = this.receiveShadow;
  }

  /**
   * Synchronise le composant avec l'objet 3D
   */
  syncToObject3D(transform: { position: THREE.Vector3; quaternion: THREE.Quaternion; scale: THREE.Vector3 }): void {
    this.object3D.position.copy(transform.position);
    this.object3D.quaternion.copy(transform.quaternion);
    this.object3D.scale.copy(transform.scale);
  }

  /**
   * Met √† jour la visibilit√©
   */
  setVisible(visible: boolean): void {
    this.visible = visible;
    this.object3D.visible = visible;
  }

  /**
   * Dispose l'objet 3D (lib√®re les ressources)
   */
  dispose(): void {
    this.object3D.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        if (child.material instanceof THREE.Material) {
          child.material.dispose();
        } else if (Array.isArray(child.material)) {
          child.material.forEach(mat => mat.dispose());
        }
      }
    });
  }
}


=== simulation/components/PhysicsComponent.ts ===

/**
 * PhysicsComponent.ts - Composant d'√©tat physique
 *
 * Contient les donn√©es physiques d'une entit√© (v√©locit√©, masse, forces, etc.)
 * Utilis√© par les syst√®mes de physique pour calculer le mouvement.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

export interface PhysicsComponentData {
  velocity?: THREE.Vector3;
  angularVelocity?: THREE.Vector3;
  mass?: number;
  inertia?: number;
  damping?: number;
}

/**
 * Composant contenant l'√©tat physique d'une entit√©
 */
export class PhysicsComponent implements Component {
  readonly type = 'physics';

  public velocity: THREE.Vector3;
  public angularVelocity: THREE.Vector3;
  public mass: number;
  public inertia: number;
  public damping: number;

  // Forces accumul√©es (reset √† chaque frame)
  public forces: THREE.Vector3;
  public torques: THREE.Vector3;

  constructor(data: PhysicsComponentData = {}) {
    this.velocity = data.velocity?.clone() || new THREE.Vector3();
    this.angularVelocity = data.angularVelocity?.clone() || new THREE.Vector3();
    this.mass = data.mass || 1.0;
    this.inertia = data.inertia || 1.0;
    this.damping = data.damping || 0.0;

    this.forces = new THREE.Vector3();
    this.torques = new THREE.Vector3();
  }

  /**
   * Ajoute une force
   */
  addForce(force: THREE.Vector3): void {
    this.forces.add(force);
  }

  /**
   * Ajoute un couple (torque)
   */
  addTorque(torque: THREE.Vector3): void {
    this.torques.add(torque);
  }

  /**
   * Reset les forces accumul√©es
   */
  clearForces(): void {
    this.forces.set(0, 0, 0);
    this.torques.set(0, 0, 0);
  }

  /**
   * Clone le composant
   */
  clone(): PhysicsComponent {
    return new PhysicsComponent({
      velocity: this.velocity,
      angularVelocity: this.angularVelocity,
      mass: this.mass,
      inertia: this.inertia,
      damping: this.damping
    });
  }
}


=== simulation/components/TransformComponent.ts ===

/**
 * TransformComponent.ts - Composant de transformation spatiale
 *
 * Contient les donn√©es de position, rotation et √©chelle d'une entit√©.
 * Utilis√© par tous les objets 3D de la simulation.
 */

import * as THREE from 'three';

import { Component } from '../entities/Entity';

export interface TransformComponentData {
  position?: THREE.Vector3;
  rotation?: number;  // Rotation autour de Y (en radians)
  quaternion?: THREE.Quaternion;
  scale?: THREE.Vector3;
}

/**
 * Composant contenant la transformation spatiale d'une entit√©
 */
export class TransformComponent implements Component {
  readonly type = 'transform';

  public position: THREE.Vector3;
  public rotation: number;
  public quaternion: THREE.Quaternion;
  public scale: THREE.Vector3;

  constructor(data: TransformComponentData = {}) {
    this.position = data.position?.clone() || new THREE.Vector3();
    this.rotation = data.rotation || 0;
    this.quaternion = data.quaternion?.clone() || new THREE.Quaternion();
    this.scale = data.scale?.clone() || new THREE.Vector3(1, 1, 1);
  }

  /**
   * Synchronise le quaternion avec la rotation
   */
  syncQuaternionFromRotation(): void {
    this.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
  }

  /**
   * Synchronise la rotation avec le quaternion
   */
  syncRotationFromQuaternion(): void {
    const euler = new THREE.Euler().setFromQuaternion(this.quaternion, 'XYZ');
    this.rotation = euler.y;
  }

  /**
   * Clone le composant
   */
  clone(): TransformComponent {
    return new TransformComponent({
      position: this.position,
      rotation: this.rotation,
      quaternion: this.quaternion,
      scale: this.scale
    });
  }
}


=== simulation/components/index.ts ===

/**
 * Exports for all ECS components
 */

export { TransformComponent } from './TransformComponent';
export type { TransformComponentData } from './TransformComponent';

export { MeshComponent } from './MeshComponent';

export { PhysicsComponent } from './PhysicsComponent';
export type { PhysicsComponentData } from './PhysicsComponent';

export { KiteComponent } from './KiteComponent';


=== simulation/config/KiteGeometry.ts ===

/**
 * KiteGeometry.ts - D√©finition de la g√©om√©trie du cerf-volant pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la forme, les points anatomiques et les surfaces du cerf-volant
 *   - Sert de plan de construction pour tous les calculs physiques et graphiques
 *   - Utilis√© pour le calcul des forces, la cr√©ation du mod√®le 3D et la configuration
 *
 * D√©pendances principales :
 *   - Three.js : Utilis√© pour les coordonn√©es et la g√©om√©trie
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise KiteGeometry pour la surface et les points
 *   - Tous les modules physiques et graphiques utilisent KiteGeometry pour les calculs
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de rendu et de configuration
 *   - Sert √† positionner les points et surfaces du kite
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

/**
 * G√©om√©trie du cerf-volant
 *
 * La forme du cerf-volant - comme un plan de construction
 * On d√©finit o√π sont tous les points importants du cerf-volant
 */
export class KiteGeometry {
  // Les points cl√©s du cerf-volant (comme les coins d'une maison)
  // Coordonn√©es en m√®tres : [gauche/droite, haut/bas, avant/arri√®re]
  static readonly POINTS = {
    NEZ: new THREE.Vector3(0, 0.65, 0), // Le bout pointu en haut
    SPINE_BAS: new THREE.Vector3(0, 0, 0), // Le centre en bas
    BORD_GAUCHE: new THREE.Vector3(-0.825, 0, 0), // L'extr√©mit√© de l'aile gauche
    BORD_DROIT: new THREE.Vector3(0.825, 0, 0), // L'extr√©mit√© de l'aile droite
    WHISKER_GAUCHE: new THREE.Vector3(-0.4125, 0.1, -0.15), // Stabilisateur gauche (l√©g√®rement en arri√®re)
    WHISKER_DROIT: new THREE.Vector3(0.4125, 0.1, -0.15), // Stabilisateur droit (l√©g√®rement en arri√®re)
    CTRL_GAUCHE: new THREE.Vector3(-0.15, 0.3, -0.2), // O√π s'attache la ligne gauche
    CTRL_DROIT: new THREE.Vector3(0.15, 0.3, -0.2), // O√π s'attache la ligne droite
  };

  /**
   * Calcule l'aire d'un triangle 3D √† partir de ses 3 sommets
   * Utilise la formule : Aire = 0.5 √ó ||AB √ó AC||
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle
   * @param v3 Troisi√®me sommet du triangle
   * @returns L'aire du triangle en m¬≤
   */
  private static calculateTriangleArea(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): number {
    // Cr√©er deux vecteurs repr√©sentant deux c√¥t√©s du triangle
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    
    // Le produit vectoriel donne un vecteur perpendiculaire
    // dont la longueur = aire du parall√©logramme form√© par edge1 et edge2
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    
    // L'aire du triangle = la moiti√© de l'aire du parall√©logramme
    return cross.length() / 2;
  }

  /**
   * Calcule le centro√Øde (centre g√©om√©trique) d'un triangle
   * Le centro√Øde est situ√© √† l'intersection des m√©dianes du triangle
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle  
   * @param v3 Troisi√®me sommet du triangle
   * @returns Le point centro√Øde du triangle
   */
  static calculateTriangleCentroid(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): THREE.Vector3 {
    return v1.clone()
      .add(v2)
      .add(v3)
      .divideScalar(3);
  }

  // Le cerf-volant est fait de 4 triangles de tissu
  // Chaque triangle a 3 coins (vertices) et une surface en m√®tres carr√©s
  //
  // ORDRE DES VERTICES (r√®gle main droite) :
  // Les normales doivent pointer vers l'ARRI√àRE (Z positif) pour recevoir le vent
  // qui vient de l'arri√®re (direction -Z).
  // Order : sens horaire vu de l'arri√®re = normale vers l'arri√®re
  //
  // NOTE : Les aires sont calcul√©es automatiquement √† partir de la g√©om√©trie r√©elle
  // pour garantir la coh√©rence physique
  //
  // NOTE : Les masses sont calcul√©es apr√®s, voir SURFACES_WITH_MASS ci-dessous
  static readonly SURFACES = [
    {
      // Surface haute gauche (normale doit pointer vers arri√®re)
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE
      ),
    },
    {
      // Surface basse gauche
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS
      ),
    },
    {
      // Surface haute droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT
      ),
    },
    {
      // Surface basse droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT
      ),
    },
  ];

  /**
   * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
   * @param v1, v2, v3 : sommets du triangle
   * @returns Tableau de 4 sous-triangles {vertices, area}
   */
  private static subdivideTriangle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3) {
    // Calcul des milieux
    const m12 = v1.clone().add(v2).multiplyScalar(0.5);
    const m23 = v2.clone().add(v3).multiplyScalar(0.5);
    const m31 = v3.clone().add(v1).multiplyScalar(0.5);

    // 4 sous-triangles
    const tris = [
      { vertices: [v1, m12, m31] },
      { vertices: [v2, m23, m12] },
      { vertices: [v3, m31, m23] },
      { vertices: [m12, m23, m31] },
    ];
    // Ajoute l'aire √† chaque sous-triangle
    return tris.map(t => ({
      vertices: t.vertices,
      area: KiteGeometry.calculateTriangleArea(t.vertices[0], t.vertices[1], t.vertices[2])
    }));
  }

  /**
   * Subdivise r√©cursivement un triangle selon un niveau donn√©
   * @param v1, v2, v3 : sommets du triangle
   * @param level : niveau de subdivision (0 = pas de subdivision)
   * @returns Tableau de tous les sous-triangles
   */
  private static subdivideTriangleRecursive(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3,
    level: number
  ): { vertices: THREE.Vector3[]; area: number }[] {
    if (level <= 0) {
      // Pas de subdivision : retourner le triangle original
      return [{
        vertices: [v1, v2, v3],
        area: KiteGeometry.calculateTriangleArea(v1, v2, v3)
      }];
    }

    // Subdiviser en 4 sous-triangles
    const subTriangles = KiteGeometry.subdivideTriangle(v1, v2, v3);

    // Appliquer r√©cursivement la subdivision √† chaque sous-triangle
    const result: { vertices: THREE.Vector3[]; area: number }[] = [];
    for (const subTri of subTriangles) {
      const [sv1, sv2, sv3] = subTri.vertices;
      result.push(...KiteGeometry.subdivideTriangleRecursive(sv1, sv2, sv3, level - 1));
    }

    return result;
  }

  /**
   * Subdivision du maillage pour am√©liorer la pr√©cision a√©rodynamique.
   *
   * POURQUOI LA SUBDIVISION :
   * - Un triangle unique ne peut avoir qu'une seule normale ‚Üí angle d'attaque uniforme
   * - Avec subdivision, chaque sous-triangle peut avoir un angle d'attaque local diff√©rent
   * - Permet de capturer les variations spatiales du vent et de la courbure virtuelle
   * - Am√©liore le r√©alisme des couples a√©rodynamiques distribu√©s
   *
   * CO√õT PERFORMANCE :
   * - Niveau 0 : 4 triangles (rapide, peu pr√©cis)
   * - Niveau 1 : 16 triangles (bon compromis)
   * - Niveau 2 : 64 triangles (pr√©cis, co√ªt mod√©r√©) ‚Üê recommand√©
   * - Niveau 3 : 256 triangles (tr√®s pr√©cis, co√ªteux)
   * - Niveau 4+ : 1024+ triangles (impact performance significatif)
   */

  /**
   * Niveau de subdivision actuel du maillage
   * Par d√©faut niveau 1 (16 triangles), peut √™tre chang√© via setMeshSubdivisionLevel()
   */
  private static meshSubdivisionLevel: number = 1; // Niveau par d√©faut, sera initialis√© depuis CONFIG dans SimulationApp

  /**
   * Cache typ√© des surfaces subdivis√©es
   */
  private static _subdividedSurfaces: { vertices: THREE.Vector3[]; area: number }[] | null = null;

  /**
   * Constantes pour la subdivision
   */
  private static readonly MAX_SUBDIVISION_LEVEL = 3; // Limite raisonnable pour √©viter surcharge

  /**
   * Calcule le nombre de triangles par surface originale pour un niveau donn√©
   * Formule : 4^niveau (car chaque subdivision d√©coupe en 4)
   *
   * @param level - Niveau de subdivision (0, 1, 2, 3...)
   * @returns Nombre de sous-triangles par surface originale
   *
   * @example
   * TRIANGLES_PER_SURFACE_AT_LEVEL(0) ‚Üí 1 triangle
   * TRIANGLES_PER_SURFACE_AT_LEVEL(1) ‚Üí 4 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(2) ‚Üí 16 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(3) ‚Üí 64 triangles
   */
  static TRIANGLES_PER_SURFACE_AT_LEVEL(level: number): number {
    return Math.pow(4, level);
  }

  /**
   * Modifie le niveau de subdivision du maillage
   *
   * @param level - Niveau de subdivision (0=4 triangles, 1=16, 2=64, 3=256)
   *
   * IMPORTANT : Des niveaux √©lev√©s (>3) peuvent causer des probl√®mes de performance.
   * Le niveau est automatiquement limit√© √† MAX_SUBDIVISION_LEVEL (3).
   */
  static setMeshSubdivisionLevel(level: number): void {
    // Clamper entre 0 et MAX
    const clampedLevel = Math.max(0, Math.min(level, KiteGeometry.MAX_SUBDIVISION_LEVEL));

    // Warning si niveau trop √©lev√©
    if (level > KiteGeometry.MAX_SUBDIVISION_LEVEL) {
      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(level);
      console.warn(
        `‚ö†Ô∏è Niveau de subdivision ${level} trop √©lev√© (${totalTriangles} triangles).\n` +
        `Limit√© √† ${KiteGeometry.MAX_SUBDIVISION_LEVEL} pour √©viter surcharge performance.\n` +
        `Si vous avez vraiment besoin de plus, augmentez MAX_SUBDIVISION_LEVEL.`
      );
    }

    if (clampedLevel !== KiteGeometry.meshSubdivisionLevel) {
      KiteGeometry.meshSubdivisionLevel = clampedLevel;
      // Invalider le cache des surfaces subdivis√©es
      KiteGeometry._subdividedSurfaces = null;

      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(clampedLevel);
      console.log(`üîß Maillage subdivis√© : niveau ${clampedLevel} ‚Üí ${totalTriangles} triangles au total`);
    }
  }

  /**
   * Retourne le niveau de subdivision actuel du maillage
   */
  static getMeshSubdivisionLevel(): number {
    return KiteGeometry.meshSubdivisionLevel;
  }

  /**
   * Maillage fin : tous les sous-triangles du kite selon le niveau de subdivision configur√©
   *
   * CACHE : Les surfaces sont calcul√©es une seule fois puis mises en cache.
   * Le cache est invalid√© automatiquement quand le niveau change.
   *
   * @returns Tableau de tous les sous-triangles avec leurs vertices et aires
   */
  static get SUBDIVIDED_SURFACES(): { vertices: THREE.Vector3[]; area: number }[] {
    if (!KiteGeometry._subdividedSurfaces) {
      KiteGeometry._subdividedSurfaces = KiteGeometry.SURFACES.flatMap(surface =>
        KiteGeometry.subdivideTriangleRecursive(
          surface.vertices[0],
          surface.vertices[1],
          surface.vertices[2],
          KiteGeometry.meshSubdivisionLevel
        )
      );
    }
    return KiteGeometry._subdividedSurfaces;
  }

  // Calcul automatique de la surface totale
  static readonly TOTAL_AREA = KiteGeometry.SURFACES.reduce(
    (sum, surface) => sum + surface.area,
    0
  );  // ============================================================================
  // CALCUL AUTOMATIQUE DE LA MASSE DU CERF-VOLANT
  // ============================================================================

  /**
   * Sp√©cifications des mat√©riaux utilis√©s pour calculer la masse
   * Bas√© sur des composants r√©els de kites sport/stunt
   *
   * CORRECTION: Grammages augment√©s pour atteindre masse r√©aliste de 0.3-0.4 kg
   * (Pr√©c√©dente masse calcul√©e de ~0.153 kg √©tait √ó2.5 trop l√©g√®re)
   */
  private static readonly MATERIAL_SPECS = {
    // Tubes de carbone (masse lin√©ique en g/m)
    carbon: {
      spine: 10,        // 5mm diam√®tre renforc√© (corrig√© de 10)
      leadingEdge: 10,  // 5mm diam√®tre standard (corrig√© de 10)
      strut: 4,         // 4mm diam√®tre l√©ger (corrig√© de 2)
    },
    // Tissu (grammage en g/m¬≤)
    fabric: {
      ripstop: 40,     // Ripstop nylon standard (corrig√© de 40)
    },
    // Accessoires (masse en grammes)
    accessories: {
      connectorsLeadingEdge: 1,  // Connecteurs pour les bords d'attaque
      connectorCenterT: 1,       // Connecteur central en T
      connectorsStruts: 1,       // Connecteurs pour les struts
      bridleSystem: 1,          // Syst√®me de brides complet
      reinforcements: 1,        // Renforts et coutures
    },
  };

  /**
   * Calcule la longueur totale de tous les tubes de la frame
   * @returns Objet contenant les longueurs par type de tube et le total
   */
  private static calculateFrameLengths(): {
    spine: number;
    leadingEdges: number;
    struts: number;
    total: number;
  } {
    const spine = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.SPINE_BAS
    );

    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_GAUCHE
    );
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_DROIT
    );
    const leadingEdges = leadingEdgeLeft + leadingEdgeRight;

    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_GAUCHE
    );
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const struts = strutLeft + strutRight + spreader;

    return {
      spine,
      leadingEdges,
      struts,
      total: spine + leadingEdges + struts,
    };
  }

  /**
   * Calcule la masse de la structure (frame) en carbone
   * @returns Masse en kilogrammes
   */
  private static calculateFrameMass(): number {
    const lengths = KiteGeometry.calculateFrameLengths();
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;

    const spineMass = lengths.spine * specs.spine;
    const leadingEdgesMass = lengths.leadingEdges * specs.leadingEdge;
    const strutsMass = lengths.struts * specs.strut;

    // Somme en grammes, conversion en kg
    return (spineMass + leadingEdgesMass + strutsMass) / 1000;
  }

  /**
   * Calcule la masse du tissu (voile)
   * @returns Masse en kilogrammes
   */
  private static calculateFabricMass(): number {
    const grammage = KiteGeometry.MATERIAL_SPECS.fabric.ripstop;
    // Surface en m¬≤ √ó grammage en g/m¬≤ ‚Üí conversion en kg
    return (KiteGeometry.TOTAL_AREA * grammage) / 1000;
  }

  /**
   * Calcule la masse totale des accessoires
   * @returns Masse en kilogrammes
   */
  private static calculateAccessoriesMass(): number {
    const acc = KiteGeometry.MATERIAL_SPECS.accessories;
    const total =
      acc.connectorsLeadingEdge +
      acc.connectorCenterT +
      acc.connectorsStruts +
      acc.bridleSystem +
      acc.reinforcements;

    // Conversion g ‚Üí kg
    return total / 1000;
  }

  /**
   * Calcule la masse totale du cerf-volant (frame + tissu + accessoires)
   * Calcul√©e automatiquement depuis la g√©om√©trie et les sp√©cifications mat√©riaux
   * @returns Masse en kilogrammes
   */
  static calculateTotalMass(): number {
    return (
      KiteGeometry.calculateFrameMass() +
      KiteGeometry.calculateFabricMass() +
      KiteGeometry.calculateAccessoriesMass()
    );
  }

  /**
   * Masse totale du cerf-volant calcul√©e automatiquement
   * Bas√©e sur la g√©om√©trie r√©elle et les mat√©riaux standards
   */
  static readonly TOTAL_MASS = KiteGeometry.calculateTotalMass();

  /**
   * üî¥ BUG FIX #2 : Distribution masse frame selon g√©om√©trie R√âELLE
   * 
   * Topologie du kite (4 surfaces triangulaires) :
   *   Surface 0 (haute gauche)  : NEZ ‚Üí BORD_GAUCHE ‚Üí WHISKER_GAUCHE
   *   Surface 1 (basse gauche)  : NEZ ‚Üí WHISKER_GAUCHE ‚Üí SPINE_BAS
   *   Surface 2 (haute droite)  : NEZ ‚Üí BORD_DROIT ‚Üí WHISKER_DROIT
   *   Surface 3 (basse droite)  : NEZ ‚Üí WHISKER_DROIT ‚Üí SPINE_BAS
   * 
   * Attribution des segments de frame aux surfaces :
   *   - Spine (NEZ ‚Üí SPINE_BAS) : partag√©e 50/50 entre hautes et basses
   *   - Leading edge gauche (NEZ ‚Üí BORD_GAUCHE) : 100% surface 0
   *   - Leading edge droit (NEZ ‚Üí BORD_DROIT) : 100% surface 2
   *   - Strut gauche (BORD_GAUCHE ‚Üí WHISKER_GAUCHE) : partag√© surface 0/1
   *   - Strut droit (BORD_DROIT ‚Üí WHISKER_DROIT) : partag√© surface 2/3
   *   - Spreader (WHISKER_GAUCHE ‚Üí WHISKER_DROIT) : partag√© entre toutes
   * 
   * @returns Tableau de 4 masses (kg) pour chaque surface
   */
  private static calculateFrameMassDistribution(): number[] {
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;
    
    // Masses lin√©iques (kg/m)
    const spineUnitMass = specs.spine / 1000;        // g/m ‚Üí kg/m
    const leadingEdgeUnitMass = specs.leadingEdge / 1000;
    const strutUnitMass = specs.strut / 1000;
    
    // Longueurs individuelles des segments
    const spineLength = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.SPINE_BAS);
    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_GAUCHE);
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_DROIT);
    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_GAUCHE);
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    /**
     * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
     * @param v1, v2, v3 : sommets du triangle
     * @returns Tableau de 4 sous-triangles {vertices, area}
     */

    // Masses individuelles des segments
    const spineMass = spineLength * spineUnitMass;
    const leadingEdgeLeftMass = leadingEdgeLeft * leadingEdgeUnitMass;
    const leadingEdgeRightMass = leadingEdgeRight * leadingEdgeUnitMass;
    const strutLeftMass = strutLeft * strutUnitMass;
    const strutRightMass = strutRight * strutUnitMass;
    const spreaderMass = spreader * strutUnitMass;
    
    // Attribution g√©om√©trique r√©aliste aux surfaces
    const frameMasses = [
      // Surface 0 (haute gauche) : spine + leading edge gauche + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeLeftMass +         // 100% leading edge gauche
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 1 (basse gauche) : spine + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 2 (haute droite) : spine + leading edge droit + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeRightMass +        // 100% leading edge droit
      (strutRightMass * 0.5) +      // 50% strut droit (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)

      // Surface 3 (basse droite) : spine + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutRightMass * 0.5) +      // 50% strut droit (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)
    ];
    
    return frameMasses;
  }

  /**
   * Distribution de la masse sur les surfaces
   * Chaque surface porte une fraction de la masse totale
   * 
   * Mod√®le physique CORRIG√â :
   * - Masse de tissu (fabric) : Distribu√©e proportionnellement √† l'aire
   * - Masse de frame : Distribu√©e selon g√©om√©trie r√©elle (üî¥ BUG FIX #2)
   * - Masse d'accessoires : Distribu√©e uniform√©ment sur les 4 surfaces
   * 
   * @returns Masse de chaque surface en kg
   */
  static calculateSurfaceMasses(): number[] {
    const fabricMass = KiteGeometry.calculateFabricMass();
    const frameMasses = KiteGeometry.calculateFrameMassDistribution();  // üî¥ BUG FIX #2
    const accessoriesMass = KiteGeometry.calculateAccessoriesMass();
    
    // Accessoires r√©partis uniform√©ment (connecteurs dispers√©s sur tout le kite)
    const uniformAccessories = accessoriesMass / KiteGeometry.SURFACES.length;
    
    // La masse de tissu est r√©partie proportionnellement √† l'aire
    return KiteGeometry.SURFACES.map((surface, index) => {
      const fabricMassRatio = surface.area / KiteGeometry.TOTAL_AREA;
      const surfaceFabricMass = fabricMass * fabricMassRatio;
      
      return surfaceFabricMass + frameMasses[index] + uniformAccessories;
    });
  }

  /**
   * Masses pr√©calcul√©es pour chaque surface (en kg)
   * Index correspond √† l'index dans SURFACES
   */
  static readonly SURFACE_MASSES = KiteGeometry.calculateSurfaceMasses();

  /**
   * Surfaces enrichies avec leur masse individuelle
   * Utilis√©es par AerodynamicsCalculator pour appliquer la gravit√© distribu√©e
   */
  static readonly SURFACES_WITH_MASS = KiteGeometry.SURFACES.map((surface, index) => ({
    ...surface,
    mass: KiteGeometry.SURFACE_MASSES[index],
  }));

  /**
   * Calcule le moment d'inertie approximatif du cerf-volant
   * Utilise la formule simplifi√©e : I ‚âà m √ó r¬≤
   * o√π r est le rayon de giration moyen
   * @returns Moment d'inertie en kg¬∑m¬≤
   */
  static calculateInertia(): number {
    // Constantes pour calcul d'inertie (√©viter d√©pendance circulaire avec CONFIG)
    const GYRATION_DIVISOR = Math.sqrt(2); // wingspan / ‚àö2 pour forme delta (triangle isoc√®le)

    // Rayon de giration correct pour forme delta wing
    // Formule r√©aliste : r = wingspan / ‚àö2 (au lieu de /4)
    // R√©f√©rence : g√©om√©trie d'un triangle isoc√®le
    const wingspan =
      KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
        KiteGeometry.POINTS.BORD_DROIT
      );
    const radiusOfGyration = wingspan / GYRATION_DIVISOR;  // ‚âà 1.167 m au lieu de 0.4125 m

    const physicalInertia = KiteGeometry.TOTAL_MASS * radiusOfGyration * radiusOfGyration;

    // üîß FIX INERTIE: Factor 0.1 pour r√©activit√© imm√©diate au vent
    // Le kite doit √™tre "emport√©" par le vent, pas r√©sister par inertie
    // Factor 0.1 ram√®ne √† ~0.042 kg¬∑m¬≤ (tr√®s r√©actif, comme un tissu l√©ger)
    const REACTIVE_INERTIA_FACTOR = 0.1;
    return physicalInertia * REACTIVE_INERTIA_FACTOR;
  }

  /**
   * Moment d'inertie calcul√© automatiquement
   */
  static readonly INERTIA = KiteGeometry.calculateInertia();
}


=== simulation/config/PhysicsConstants.ts ===

/**
 * PhysicsConstants.ts - Constantes physiques globales pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les limites physiques, tol√©rances et facteurs de s√©curit√© du monde virtuel
 *   - Sert √† garantir la stabilit√© et la coh√©rence de la simulation
 *   - Utilis√© pour √©viter les comportements irr√©alistes ou dangereux
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par tous les modules physiques et de configuration
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise PhysicsConstants pour fixer les limites
 *   - Tous les modules du projet importent PhysicsConstants pour les v√©rifications
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de contr√¥le et de rendu
 *   - Sert √† valider les valeurs et √† limiter les extr√™mes
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
export class PhysicsConstants {
  // Tol√©rances num√©riques
  static readonly EPSILON = 1e-4; // Sans unit√© - Seuil pour "presque z√©ro" (comparaisons flottants)
  static readonly EPSILON_FINE = 1e-6; // Sans unit√© - Seuil fin pour calculs pr√©cis (LinePhysics)

  // Contr√¥les et contraintes
  static readonly CONTROL_DEADZONE = 0.01; // rad - Zone morte pour input barre de contr√¥le
  static readonly LINE_CONSTRAINT_TOLERANCE = 0.0005; // m - Tol√©rance contraintes lignes (0.5mm)
  static readonly LINE_TENSION_FACTOR = 0.99; // Sans unit√© - Facteur tension lignes (99% = l√©g√®rement tendues)
  static readonly CONSTRAINT_ITERATIONS = 2; // Sans unit√© - Nombre d'it√©rations pour convergence PBD

  // Sol et friction
  static readonly GROUND_FRICTION = 0.95; // Sans unit√© - Facteur friction sol (5% perte vitesse)

  // Rendu cat√©naire
  static readonly CATENARY_SEGMENTS = 10; // Sans unit√© - Nombre segments pour courbe cat√©naire

  // Limites de s√©curit√© physique (√©viter explosions num√©riques)
  static readonly MAX_FORCE = 1000; // N - Force maximale (√©quivalent ~100kg)
  static readonly MAX_VELOCITY = 30; // m/s - Vitesse maximale kite (108 km/h)
  static readonly MAX_ANGULAR_VELOCITY = 15; // rad/s - Limite √©lev√©e pour permettre convergence naturelle
  static readonly MAX_ACCELERATION = 100; // m/s¬≤ - Acc√©l√©ration maximale (~10G)
  static readonly MAX_ANGULAR_ACCELERATION = 5; // rad/s¬≤ - Acc√©l√©ration angulaire r√©aliste
}

=== simulation/config/SimulationConfig.ts ===

/**
 * SimulationConfig.ts - Configuration centralis√©e de la simulation Kite
 * R√¥le :
 *   - D√©finit tous les param√®tres physiques, a√©rodynamiques, g√©om√©triques et environnementaux
 *   - Sert de source unique de v√©rit√© pour les r√©glages du monde virtuel
 *   - Permet d'ajuster le comportement du kite, du vent, des lignes, etc.
 *
 * D√©pendances principales :
 *   - KiteGeometry.ts : Utilis√© pour la surface et les points du kite
 *   - Utilis√© par tous les modules physiques et de rendu
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsConstants.ts : D√©finit les limites et tol√©rances physiques
 *   - KiteGeometry.ts : D√©finit la g√©om√©trie du kite
 *   - Tous les modules du projet importent SimulationConfig pour acc√©der aux param√®tres
 *
  pilot: PILOT_CONFIG, // Utilise la configuration centralis√©e du pilote
  controlBar: {
    offsetY: 1.1, // Hauteur r√©aliste des mains
    offsetZ: 0.7, // Distance devant le pilote
    width: 0.6,   // Largeur de la barre
    handleOffset: 0.25, // Distance des poign√©es par rapport au centre
  },
 * Utilisation typique :
 *   - Import√© dans tous les modules pour acc√©der aux r√©glages
 *   - Sert √† personnaliser la simulation (test, debug, tuning)
 *
 * Voir aussi :
 *   - src/simulation/config/PhysicsConstants.ts
 *   - src/simulation/config/KiteGeometry.ts
 */
import * as THREE from "three";

import { KiteGeometry } from "./KiteGeometry";

/**
 * Configuration centralis√©e de la simulation Kite
 *
 * Source unique de v√©rit√© pour tous les param√®tres physiques, a√©rodynamiques,
 * g√©om√©triques et environnementaux du simulateur.
 */

// Configuration des propri√©t√©s du pilote (origine du syst√®me)
export const PILOT_CONFIG = {
  width: 0.4, // m - Largeur du corps du pilote
  height: 1.6, // m - Hauteur du corps du pilote
  depth: 0.3, // m - Profondeur du corps du pilote
  position: new THREE.Vector3(0, 0, 0), // Position du pilote - origine du syst√®me de coordonn√©es
};

// Configuration de la barre de contr√¥le
export const CONTROL_BAR_CONFIG = {
  width: 0.6, // m - Largeur de la barre
  offsetY: 1.2, // m - Hauteur de la barre par rapport au pilote (au niveau des mains)
  offsetZ: -0.5, // m - D√©calage en z (devant le pilote en z n√©gatif)
  barRadius: 0.02, // m - Rayon du cylindre de la barre
  barRotation: Math.PI / 2, // rad - Rotation pour orientation horizontale
  handleRadius: 0.03, // m - Rayon des poign√©es
  handleLength: 0.15, // m - Longueur des poign√©es
};

/**
 * Configuration √©pur√©e de la simulation
 *
 * Les r√©glages de notre monde virtuel - comme les r√®gles d'un jeu
 * Vous pouvez changer ces valeurs pour voir comment le cerf-volant r√©agit
 */
export const CONFIG = {
  physics: {
    gravity: 9.81, // La gravit√© terrestre (fait tomber les objets)
    airDensity: 1.225, // Densit√© de l'air (l'air √©pais pousse plus fort)
    deltaTimeMax: 0.016, // Mise √† jour max 60 fois par seconde (pour rester fluide)
    controlDeadzone: 0.1, // m - Petite zone de tol√©rance pour la tension des lignes
    // Amortissement r√©aliste pour un cerf-volant
    linearDampingCoeff: 1.5, // Amortissement lin√©aire mod√©r√© pour stabilit√©
    angularDragFactor: 1.5, // Amortissement angulaire pour √©viter les oscillations
  },
  aero: {
    // Forces a√©rodynamiques r√©alistes pour un cerf-volant delta
    liftScale: 4.5, // Portance r√©aliste pour un kite de cette taille
    dragScale: 1.8, // Tra√Æn√©e mod√©r√©e mais pr√©sente
    // Amortissement a√©rodynamique anisotrope (couple) par axe
    damping: {
      enabled: false,
      roll: 0.015,   // autour de X (roulis)
      pitch: 0.020,  // autour de Y (tangage)
      yaw: 0.012,    // autour de Z (lacet)
      windSpeedFactor: 1.0, // multiplie avec |vent| en m/s
      maxMagnitude: 10.0,   // N¬∑m - clamp de s√©curit√©
    },
  },
  kite: {
    // Masse et inertie calcul√©es AUTOMATIQUEMENT depuis la g√©om√©trie
    // Bas√©es sur:
    // - Frame carbone (spine 5mm, leading edges 5mm, struts 4mm)
    // - Tissu ripstop nylon 120 g/m¬≤ (corrig√© pour atteindre masse r√©aliste)
    // - Accessoires (connecteurs, bridage, renforts)
    // Voir KiteGeometry.calculateTotalMass() pour les d√©tails
    mass: KiteGeometry.TOTAL_MASS, // kg - Calcul√©e automatiquement (~0.31 kg apr√®s correction)
    area: KiteGeometry.TOTAL_AREA, // m¬≤ - Surface totale (calcul√©e automatiquement)
    inertia: KiteGeometry.INERTIA, // kg¬∑m¬≤ - Moment d'inertie (I ‚âà m¬∑r¬≤, calcul√© automatiquement)
    minHeight: 0, // m - Altitude minimale (plus haut pour √©viter le sol)
    // üîß MAILLAGE FIN PARAM√âTRABLE (d√©faut = niveau 1 = 16 triangles)
    defaultMeshSubdivisionLevel: 0, // Niveau par d√©faut (0=4, 1=16, 2=64, 3=256 triangles)
  },
  bridle: {
    defaultLengths: Object.freeze({
      nez: 0.80,
      inter: 0.65,
      centre: 0.65,
    }),
  },
  lines: {
    defaultLength: 15, // m - Longueur r√©aliste pour cerf-volant sport
    stiffness: 2500, // N/m - Rigidit√© r√©aliste pour lignes Dyneema
    preTension: 80, // N - Pr√©-tension r√©aliste
    maxTension: 1200, // N - Tension max avant rupture
    dampingCoeff: 0.08, // Coefficient d'amortissement r√©aliste
    linearMassDensity: 0.0006, // kg/m - Masse lin√©ique r√©aliste
  },
  wind: {
    defaultSpeed: 20, // km/h - Vitesse id√©ale pour cerf-volant sport
    defaultDirection: 0, // degr√©s
    defaultTurbulence: 5, // % - Turbulence r√©aliste pour conditions normales
    turbulenceScale: 0.05,
    turbulenceFreqBase: 0.05,
    turbulenceFreqY: 0.3,
    turbulenceFreqZ: 0.3,
    turbulenceIntensityXZ: 0.2,
    turbulenceIntensityY: 0.2,
  },
  debugVectors: true, // Active ou d√©sactive l'affichage des vecteurs de debug
  pilot: PILOT_CONFIG,
  controlBar: CONTROL_BAR_CONFIG,
  initialization: {
    initialKiteY: 10.0, // m - Altitude initiale du kite (r√©aliste pour 15m de lignes)
    initialDistanceFactor: 0.98, // Sans unit√© - Lignes presque tendues au d√©part (98% de la longueur)
    initialKiteZ: null, // m - Position Z calcul√©e automatiquement pour lignes tendues (null = calcul auto)
  },
  visualization: {
    lineWidth: 2, // pixels - Largeur des lignes de contr√¥le
  },
  debug: {
    // Seuils de tension des brides pour couleurs visuelles
    bridleTensionLow: 1, // N - Seuil tension molle (vert)
    bridleTensionMedium: 50, // N - Seuil tension moyenne (jaune)
    bridleTensionHigh: 100, // N - Seuil tension √©lev√©e (rouge)
    // Seuils pour vecteurs debug
    minVectorLength: 0.01, // m - Longueur minimale pour afficher un vecteur
    minVelocityDisplay: 0.1, // m/s - Vitesse minimale pour afficher vecteur vitesse
  },
  input: {
    rotationSpeed: 0.5, // rad/s - Vitesse de rotation de la barre (input utilisateur)
    returnSpeed: 3.0, // rad/s - Vitesse de retour au centre de la barre
    maxRotation: Math.PI / 3, // rad - Rotation maximale de la barre (¬∞)
  },
  kiteInertia: {
    gyrationDivisor: Math.sqrt(2), // Sans unit√© - Diviseur pour rayon de giration (wingspan / ‚àö2)
    inertiaFactor: 1, // Sans unit√© - Facteur ajustement inertie (compromis stabilit√©/r√©activit√©)
  },

  // Constantes de conversion et calculs fr√©quents
  conversions: {
    kmhToMs: 1 / 3.6, // Conversion km/h vers m/s
    radToDeg: 180 / Math.PI, // Conversion radians vers degr√©s
    degToRad: Math.PI / 180, // Conversion degr√©s vers radians
    gravityFactor: 9.81, // Acc√©l√©ration gravitationnelle standard
  },

  // Valeurs par d√©faut pour les calculs
  defaults: {
    meshSegments: 20, // Nombre de segments par d√©faut pour les tubes (augment√© pour courbes plus lisses)
    tubeRadius: 0.005, // Rayon des tubes de ligne (5mm - diam√®tre r√©aliste pour lignes de kite)
    tubeRadialSegments: 8, // Segments radiaux pour les tubes
    catenarySagFactor: 0.02, // Facteur de fl√®che pour les cat√©naires (2%)
    smoothingFactor: 0.15, // Facteur de lissage pour les animations
    restitutionFactor: 0.3, // Coefficient de restitution pour les collisions
    groundFriction: 0.85, // Friction du sol
  },

  // Couleurs fr√©quemment utilis√©es
  colors: {
    bridleLowTension: 0x00ff00, // Vert - tension faible
    bridleMediumTension: 0xffff00, // Jaune - tension moyenne
    bridleHighTension: 0xff0000, // Rouge - tension √©lev√©e
    controlBar: 0x333333, // Gris fonc√© pour la barre
    controlBarHandles: 0x8b4513, // Marron pour les poign√©es
    kiteFrame: 0x333333, // Gris pour le cadre du kite
    kiteSail: 0xffffff, // Blanc pour la voile
    debugRed: 0xff0000, // Rouge pour le debug
    debugGreen: 0x00ff00, // Vert pour le debug
    debugBlue: 0x0000ff, // Bleu pour le debug
    debugYellow: 0xffff00, // Jaune pour le debug
  },

  // Seuils et limites fr√©quemment utilis√©s
  thresholds: {
    minWindSpeed: 0.1, // m/s - Vitesse minimale pour calculs a√©rodynamiques
    minVelocity: 0.01, // m/s - Vitesse minimale pour √©viter division par z√©ro
    maxLineSegments: 50, // Nombre maximum de segments pour les lignes
    epsilon: 1e-6, // Seuil num√©rique g√©n√©ral
    epsilonFine: 1e-8, // Seuil fin pour calculs pr√©cis
    controlDeadzone: 0.001, // Zone morte pour les contr√¥les
  },

  // Constantes g√©om√©triques fr√©quentes
  geometry: {
    half: 0.5, // Demi pour calculs de moiti√©s
    third: 1 / 3, // Tiers pour ratios
    twoThirds: 2 / 3, // Deux tiers
    quarter: 0.25, // Quart
    threeQuarters: 0.75, // Trois quarts
    fullCircle: 2 * Math.PI, // Cercle complet en radians
    halfCircle: Math.PI, // Demi-cercle en radians
    quarterCircle: Math.PI / 2, // Quart de cercle en radians
  },

  // Constantes de couleurs hexad√©cimales
  hexColors: {
    red: 0xff0000,
    green: 0x00ff00,
    blue: 0x0000ff,
    yellow: 0xffff00,
    white: 0xffffff,
    black: 0x000000,
    gray: 0x808080,
    lightGray: 0xcccccc,
    darkGray: 0x333333,
  },

  // Constantes trigonom√©triques pr√©-calcul√©es
  trig: {
    degToRad: Math.PI / 180, // Conversion degr√©s vers radians
    radToDeg: 180 / Math.PI, // Conversion radians vers degr√©s
    sqrt2: Math.sqrt(2), // Racine carr√©e de 2
    sqrt3: Math.sqrt(3), // Racine carr√©e de 3
    goldenRatio: (1 + Math.sqrt(5)) / 2, // Ratio d'or
  },

  // Param√®tres de rendu
  rendering: {
    shadowMapSize: 2048,
    antialias: true,
    fogStart: 100,
    fogEnd: 1000,
    lineWidth: 2, // pixels - Largeur des lignes de contr√¥le
  },
};

=== simulation/controllers/KiteController.ts ===

/**
 * KiteController.ts - Contr√¥leur physique du cerf-volant
 *
 * G√®re l'√©tat physique du kite, l'int√©gration des forces et l'application
 * des contraintes g√©om√©triques (lignes et brides).
 */

import * as THREE from 'three';

import { Kite } from '../../objects/Kite';
import { CONFIG } from '../config/SimulationConfig';
import { PhysicsConstants } from '../config/PhysicsConstants';
import { KiteState } from '../types';
import { HandlePositions } from '../types';
import { ConstraintSolver } from '../physics/ConstraintSolver';

export class KiteController {
  private kite: Kite;
  private state: KiteState;
  private previousPosition: THREE.Vector3;

  // √âtats pour les warnings
  private hasExcessiveAccel: boolean = false;
  private hasExcessiveVelocity: boolean = false;
  private hasExcessiveAngular: boolean = false;
  private lastAccelMagnitude: number = 0;
  private lastVelocityMagnitude: number = 0;

  // Lissage temporel des forces
  private smoothedForce: THREE.Vector3;
  private smoothedTorque: THREE.Vector3;
  private forceSmoothingRate: number = KiteController.DEFAULT_FORCE_SMOOTHING_RATE;

  // Constantes pour √©viter les facteurs magiques
  private static readonly DEFAULT_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MIN_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MAX_FORCE_SMOOTHING_RATE = 20.0;

  constructor(kite: Kite) {
    this.kite = kite;
    this.state = {
      position: kite.position.clone(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: kite.quaternion.clone(),
    };
    this.previousPosition = kite.position.clone();
    this.kite.userData.lineLength = CONFIG.lines.defaultLength;

    // Initialiser les forces liss√©es avec gravit√© initiale (√©vite chute au d√©marrage)
    const initialGravity = new THREE.Vector3(0, -CONFIG.kite.mass * CONFIG.physics.gravity, 0);
    this.smoothedForce = initialGravity.clone();
    this.smoothedTorque = new THREE.Vector3();
  }

  /**
   * Met √† jour la position et l'orientation du cerf-volant
   */
  update(
    forces: THREE.Vector3,
    torque: THREE.Vector3,
    handles: HandlePositions,
    deltaTime: number
  ): void {
    // Valider les forces brutes
    const validForces = this.validateForces(forces);
    const validTorque = this.validateTorque(torque);

    // Lissage exponentiel des forces (ind√©pendant du framerate)
    const smoothingFactor = 1 - Math.exp(-this.forceSmoothingRate * deltaTime);
    this.smoothedForce.lerp(validForces, smoothingFactor);
    this.smoothedTorque.lerp(validTorque, smoothingFactor);

    // Utiliser les forces liss√©es pour la physique
    const newPosition = this.integratePhysics(this.smoothedForce, deltaTime);

    // R√©solution it√©rative des contraintes PBD pour convergence stable
    for (let iter = 0; iter < PhysicsConstants.CONSTRAINT_ITERATIONS; iter++) {
      // Appliquer les contraintes de lignes (Position-Based Dynamics)
      try {
        ConstraintSolver.enforceLineConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          handles
        );
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceLineConstraints (iter ${iter}):`, err);
      }

      // Appliquer les contraintes des brides (Position-Based Dynamics)
      try {
        ConstraintSolver.enforceBridleConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          this.kite.getBridleLengths()
        );
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceBridleConstraints (iter ${iter}):`, err);
      }
    }

    // G√©rer la collision avec le sol
    try {
      ConstraintSolver.handleGroundCollision(this.kite, newPosition, this.state.velocity);
    } catch (err) {
      console.error("‚ö†Ô∏è Erreur dans ConstraintSolver.handleGroundCollision:", err);
    }

    // Valider la position finale
    this.validatePosition(newPosition);

    // Appliquer la position et l'orientation
    this.kite.position.copy(newPosition);
    this.updateOrientation(this.smoothedTorque, deltaTime);
    this.previousPosition.copy(newPosition);
  }

  /**
   * Valide les forces appliqu√©es au cerf-volant
   */
  private validateForces(forces: THREE.Vector3): THREE.Vector3 {
    if (
      !forces ||
      forces.length() > PhysicsConstants.MAX_FORCE ||
      isNaN(forces.length())
    ) {
      console.error(
        `‚ö†Ô∏è Forces invalides: ${forces ? forces.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return forces;
  }

  /**
   * Valide le couple
   */
  private validateTorque(torque: THREE.Vector3): THREE.Vector3 {
    if (!torque || isNaN(torque.length())) {
      console.error(
        `‚ö†Ô∏è Couple invalide: ${torque ? torque.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return torque;
  }

  /**
   * Int√®gre les forces pour calculer la nouvelle position (m√©thode d'Euler)
   */
  private integratePhysics(
    forces: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Newton : acc√©l√©ration = Force / masse
    const acceleration = forces.clone().divideScalar(CONFIG.kite.mass);
    this.lastAccelMagnitude = acceleration.length();

    // S√©curit√© : limiter pour √©viter l'explosion num√©rique
    this.hasExcessiveAccel = acceleration.length() > PhysicsConstants.MAX_ACCELERATION;
    if (this.hasExcessiveAccel) {
      acceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ACCELERATION);
    }

    // Int√©gration d'Euler : v(t+dt) = v(t) + a¬∑dt
    this.state.velocity.add(acceleration.clone().multiplyScalar(deltaTime));

    // Amortissement exponentiel
    const linearDampingFactor = Math.exp(-CONFIG.physics.linearDampingCoeff * deltaTime);
    this.state.velocity.multiplyScalar(linearDampingFactor);
    this.lastVelocityMagnitude = this.state.velocity.length();

    // Garde-fou vitesse max
    this.hasExcessiveVelocity = this.state.velocity.length() > PhysicsConstants.MAX_VELOCITY;
    if (this.hasExcessiveVelocity) {
      this.state.velocity
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_VELOCITY);
    }

    // Position : x(t+dt) = x(t) + v¬∑dt
    return this.kite.position
      .clone()
      .add(this.state.velocity.clone().multiplyScalar(deltaTime));
  }

  /**
   * Valide la position finale
   */
  private validatePosition(newPosition: THREE.Vector3): void {
    if (isNaN(newPosition.x) || isNaN(newPosition.y) || isNaN(newPosition.z)) {
      console.error(`‚ö†Ô∏è Position NaN d√©tect√©e! Reset √† la position pr√©c√©dente`);
      newPosition.copy(this.previousPosition);
      this.state.velocity.set(0, 0, 0);
    }
  }

  /**
   * Met √† jour l'orientation du cerf-volant - Dynamique du corps rigide
   */
  private updateOrientation(torque: THREE.Vector3, deltaTime: number): void {
    // Couple d'amortissement
    const dampTorque = this.state.angularVelocity
      .clone()
      .multiplyScalar(-CONFIG.kite.inertia * CONFIG.physics.angularDragFactor);
    const effectiveTorque = torque.clone().add(dampTorque);

    // Dynamique rotationnelle : Œ± = T / I
    const angularAcceleration = effectiveTorque.clone().divideScalar(
      CONFIG.kite.inertia
    );

    // Limiter l'acc√©l√©ration angulaire
    if (
      angularAcceleration.length() > PhysicsConstants.MAX_ANGULAR_ACCELERATION
    ) {
      angularAcceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ANGULAR_ACCELERATION);
    }

    // Mise √† jour de la vitesse angulaire
    this.state.angularVelocity.add(
      angularAcceleration.clone().multiplyScalar(deltaTime)
    );

    this.hasExcessiveAngular = false; // Toujours faux pour l'instant

    // Appliquer la rotation
    if (this.state.angularVelocity.length() > PhysicsConstants.EPSILON) {
      const deltaRotation = new THREE.Quaternion();
      const axis = this.state.angularVelocity.clone().normalize();
      const angle = this.state.angularVelocity.length() * deltaTime;
      deltaRotation.setFromAxisAngle(axis, angle);

      this.kite.quaternion.multiply(deltaRotation);
      this.kite.quaternion.normalize();
    }
  }

  getState(): KiteState {
    return { ...this.state };
  }

  getKite(): Kite {
    return this.kite;
  }

  setLineLength(length: number): void {
    this.kite.userData.lineLength = length;
  }

  /**
   * Retourne les √©tats de warning pour l'affichage
   */
  getWarnings(): {
    accel: boolean;
    velocity: boolean;
    angular: boolean;
    accelValue: number;
    velocityValue: number;
  } {
    return {
      accel: this.hasExcessiveAccel,
      velocity: this.hasExcessiveVelocity,
      angular: this.hasExcessiveAngular,
      accelValue: this.lastAccelMagnitude,
      velocityValue: this.lastVelocityMagnitude,
    };
  }

  /**
   * D√©finit le taux de lissage des forces physiques
   */
  setForceSmoothing(rate: number): void {
    this.forceSmoothingRate = Math.max(
      KiteController.MIN_FORCE_SMOOTHING_RATE,
      Math.min(KiteController.MAX_FORCE_SMOOTHING_RATE, rate)
    );
  }

  /**
   * Retourne le taux de lissage actuel des forces (en 1/s)
   */
  getForceSmoothing(): number {
    return this.forceSmoothingRate;
  }
}

=== simulation/entities/Entity.ts ===

/**
 * Entity.ts - Interface de base pour toutes les entit√©s ECS
 *
 * Une entit√© dans l'architecture ECS est simplement :
 * - Un ID unique
 * - Un ensemble de composants (donn√©es pures)
 *
 * Les entit√©s ne contiennent PAS de logique, seulement des donn√©es.
 * La logique est dans les Systems.
 */

export type ComponentType = string;

/**
 * Interface de base pour tous les composants
 */
export interface Component {
  readonly type: ComponentType;
}

/**
 * Entit√© ECS de base
 */
export class Entity {
  public readonly id: string;
  private components: Map<ComponentType, Component> = new Map();
  private active: boolean = true;

  constructor(id?: string) {
    this.id = id || `entity_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
  }

  /**
   * Ajoute un composant √† l'entit√©
   */
  addComponent<T extends Component>(component: T): this {
    this.components.set(component.type, component);
    return this;
  }

  /**
   * R√©cup√®re un composant par son type
   */
  getComponent<T extends Component>(type: ComponentType): T | undefined {
    return this.components.get(type) as T | undefined;
  }

  /**
   * V√©rifie si l'entit√© poss√®de un composant
   */
  hasComponent(type: ComponentType): boolean {
    return this.components.has(type);
  }

  /**
   * Supprime un composant
   */
  removeComponent(type: ComponentType): void {
    this.components.delete(type);
  }

  /**
   * R√©cup√®re tous les composants
   */
  getAllComponents(): Component[] {
    return Array.from(this.components.values());
  }

  /**
   * Active/d√©sactive l'entit√©
   */
  setActive(active: boolean): void {
    this.active = active;
  }

  /**
   * V√©rifie si l'entit√© est active
   */
  isActive(): boolean {
    return this.active;
  }

  /**
   * Clone l'entit√© (shallow copy)
   */
  clone(): Entity {
    const newEntity = new Entity();
    this.components.forEach((component, type) => {
      newEntity.components.set(type, component);
    });
    return newEntity;
  }
}


=== simulation/entities/EntityManager.ts ===

/**
 * EntityManager.ts - Gestionnaire central des entit√©s ECS
 *
 * Responsabilit√©s :
 * - Cr√©er et d√©truire des entit√©s
 * - Maintenir un registre central de toutes les entit√©s
 * - Fournir des m√©thodes de requ√™te pour trouver des entit√©s
 */

import { Entity, ComponentType } from './Entity';

/**
 * Gestionnaire central des entit√©s
 */
export class EntityManager {
  private entities: Map<string, Entity> = new Map();

  /**
   * Cr√©e une nouvelle entit√© et l'enregistre
   */
  createEntity(id?: string): Entity {
    const entity = new Entity(id);
    this.entities.set(entity.id, entity);
    return entity;
  }

  /**
   * Enregistre une entit√© existante
   */
  registerEntity(entity: Entity): void {
    this.entities.set(entity.id, entity);
  }

  /**
   * Supprime une entit√©
   */
  destroyEntity(entityId: string): void {
    this.entities.delete(entityId);
  }

  /**
   * R√©cup√®re une entit√© par son ID
   */
  getEntity(entityId: string): Entity | undefined {
    return this.entities.get(entityId);
  }

  /**
   * R√©cup√®re toutes les entit√©s
   */
  getAllEntities(): Entity[] {
    return Array.from(this.entities.values());
  }

  /**
   * R√©cup√®re toutes les entit√©s actives
   */
  getActiveEntities(): Entity[] {
    return Array.from(this.entities.values()).filter(e => e.isActive());
  }

  /**
   * R√©cup√®re toutes les entit√©s poss√©dant un composant donn√©
   */
  getEntitiesWithComponent(componentType: ComponentType): Entity[] {
    return Array.from(this.entities.values()).filter(e =>
      e.hasComponent(componentType) && e.isActive()
    );
  }

  /**
   * R√©cup√®re toutes les entit√©s poss√©dant tous les composants donn√©s
   */
  getEntitiesWithComponents(...componentTypes: ComponentType[]): Entity[] {
    return Array.from(this.entities.values()).filter(entity => {
      if (!entity.isActive()) return false;
      return componentTypes.every(type => entity.hasComponent(type));
    });
  }

  /**
   * Compte le nombre d'entit√©s
   */
  getEntityCount(): number {
    return this.entities.size;
  }

  /**
   * Supprime toutes les entit√©s
   */
  clear(): void {
    this.entities.clear();
  }

  /**
   * It√®re sur toutes les entit√©s actives
   */
  forEach(callback: (entity: Entity) => void): void {
    this.entities.forEach(entity => {
      if (entity.isActive()) {
        callback(entity);
      }
    });
  }

  /**
   * It√®re sur toutes les entit√©s actives avec un composant donn√©
   */
  forEachWithComponent(
    componentType: ComponentType,
    callback: (entity: Entity) => void
  ): void {
    this.entities.forEach(entity => {
      if (entity.isActive() && entity.hasComponent(componentType)) {
        callback(entity);
      }
    });
  }

  /**
   * It√®re sur toutes les entit√©s actives avec plusieurs composants
   */
  forEachWithComponents(
    componentTypes: ComponentType[],
    callback: (entity: Entity) => void
  ): void {
    this.entities.forEach(entity => {
      if (!entity.isActive()) return;

      const hasAllComponents = componentTypes.every(type =>
        entity.hasComponent(type)
      );

      if (hasAllComponents) {
        callback(entity);
      }
    });
  }
}


=== simulation/entities/LineEntity.ts ===

/**
 * LineEntity.ts - Entit√© ECS pour les lignes de contr√¥le
 *
 * Repr√©sente une ligne de contr√¥le (gauche ou droite) dans la simulation ECS.
 * Contient les composants Transform et Mesh pour le rendu 3D.
 */

import * as THREE from 'three';

import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';

import { Entity } from './Entity';

export type LineSide = 'left' | 'right';

export class LineEntity extends Entity {
  public readonly side: LineSide;

  constructor(side: LineSide) {
    super(`${side}Line`);
    this.side = side;

    // Cr√©er la g√©om√©trie de ligne (utiliser des tubes pour une meilleure visibilit√©)
    const segments = 20;
    const points = new Array(segments + 1).fill(0).map(() => new THREE.Vector3());
    const curve = new THREE.CatmullRomCurve3(points);

    const tubeMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000, // Rouge vif pour debug (sera color√© par les tensions ensuite)
      roughness: 0.7,
      metalness: 0.2,
      emissive: 0x440000, // √âmission rouge pour meilleure visibilit√©
      emissiveIntensity: 0.3,
      side: THREE.DoubleSide, // Visible des deux c√¥t√©s
      transparent: false,
      opacity: 1.0
    });

      const tubeMesh = new THREE.Mesh(
        new THREE.TubeGeometry(curve, segments, CONFIG.defaults.tubeRadius, CONFIG.defaults.tubeRadialSegments, false),
        tubeMaterial
      );
    tubeMesh.name = `${side === 'left' ? 'Left' : 'Right'}ControlLine`;
    tubeMesh.castShadow = false;
    tubeMesh.receiveShadow = false;

    // Ajouter le composant Transform (position initiale √† l'origine)
    const transform = new TransformComponent({
      position: new THREE.Vector3(),
      rotation: 0,
      quaternion: new THREE.Quaternion(),
      scale: new THREE.Vector3(1, 1, 1)
    });
    this.addComponent(transform);

    // Ajouter le composant Mesh
    const mesh = new MeshComponent(tubeMesh, {
      visible: true,
      castShadow: false,
      receiveShadow: false
    });
    this.addComponent(mesh);
  }

  /**
   * Met √† jour la g√©om√©trie de la ligne entre deux points
   */
  updateGeometry(start: THREE.Vector3, end: THREE.Vector3): void {
    const mesh = this.getComponent<MeshComponent>('mesh');
    if (!mesh) return;

    const tubeMesh = mesh.object3D as THREE.Mesh;

    // Cr√©er une nouvelle courbe pour le tube
    const segments = 20;
    const points: THREE.Vector3[] = [];

    // Calculer la distance et la direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const distance = direction.length();

    // Facteur de courbure (simule la gravit√© et la tension)
    const sagFactor = 0.02; // 2% de la longueur
    const sag = distance * sagFactor;

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Interpolation lin√©aire de base
      const x = start.x + direction.x * t;
      const y = start.y + direction.y * t;
      const z = start.z + direction.z * t;

      // Ajouter une courbure parabolique (cat√©naire simplifi√©e)
      // Maximum au milieu (t = 0.5)
      const curvature = -sag * 4 * t * (1 - t);

      points.push(new THREE.Vector3(x, y + curvature, z));
    }

    // Cr√©er une nouvelle courbe et g√©om√©trie de tube
    const curve = new THREE.CatmullRomCurve3(points);
    const newTubeGeometry = new THREE.TubeGeometry(
      curve, 
      segments, 
      CONFIG.defaults.tubeRadius, 
      CONFIG.defaults.tubeRadialSegments, 
      false
    );

    // Remplacer la g√©om√©trie
    tubeMesh.geometry.dispose();
    tubeMesh.geometry = newTubeGeometry;
  }

  /**
   * Obtient la g√©om√©trie de la ligne
   */
  getGeometry(): THREE.BufferGeometry | null {
    const mesh = this.getComponent<MeshComponent>('mesh');
    return mesh ? (mesh.object3D as THREE.Line).geometry as THREE.BufferGeometry : null;
  }
}

=== simulation/entities/PilotEntity.ts ===

/**
 * PilotEntity.ts - Entit√© ECS pour le pilote
 *
 * Repr√©sente le pilote dans la simulation ECS.
 * Contient les composants Transform et Mesh pour le rendu 3D.
 */

import * as THREE from 'three';

import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';

import { Entity } from './Entity';

export class PilotEntity extends Entity {
  constructor() {
    super('pilot');

    // Cr√©er la g√©om√©trie du pilote
    const pilotGeometry = new THREE.BoxGeometry(
      CONFIG.pilot.width,
      CONFIG.pilot.height,
      CONFIG.pilot.depth
    );
    const pilotMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a4a4a,
      roughness: 0.8
    });

    const pilotMesh = new THREE.Mesh(pilotGeometry, pilotMaterial);
    pilotMesh.name = 'Pilot';
    pilotMesh.castShadow = true;

    // Ajouter le composant Transform
    // Position initiale √† (0, 0, 0) - sera mise √† jour par PilotSystem
    const transform = new TransformComponent({
      position: new THREE.Vector3(0, 0, 0),
      rotation: 0,
      quaternion: new THREE.Quaternion(),
      scale: new THREE.Vector3(1, 1, 1)
    });
    this.addComponent(transform);

    // Ajouter le composant Mesh
    const mesh = new MeshComponent(pilotMesh, {
      visible: true,
      castShadow: true,
      receiveShadow: false
    });
    this.addComponent(mesh);
  }

  /**
   * Met √† jour la position du pilote (toujours √† l'origine du syst√®me de coordonn√©es)
   */
  updatePosition(): void {
    const transform = this.getComponent<TransformComponent>('transform');
    if (transform) {
      // Pilote √† l'origine du syst√®me de coordonn√©es
      transform.position.copy(CONFIG.pilot.position);
    }
  }
}

=== simulation/entities/index.ts ===

/**
 * Exports for ECS entities and entity management
 */

export { Entity } from './Entity';
export type { Component, ComponentType } from './Entity';

export { EntityManager } from './EntityManager';


=== simulation/factories/ControlBarEntityFactory.ts ===

/**
 * ControlBarEntityFactory.ts - Factory pour cr√©er l'entit√© ECS ControlBar
 *
 * Responsabilit√© unique : Construction de l'entit√© ControlBar avec sa g√©om√©trie Three.js
 * R√©utilisable, testable, isol√©e de SimulationApp
 *
 * Pattern : Factory Method
 * Utilisation : Appel√©e depuis SimulationApp.createControlBarEntity()
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { CONFIG } from '../config/SimulationConfig';

import { EntityBuilder } from './EntityBuilder';

/**
 * Param√®tres pour cr√©er une entit√© ControlBar
 */
export interface ControlBarFactoryParams {
  /** Position de la barre (par d√©faut : relative au pilote) */
  position?: THREE.Vector3;
  
  /** Objet parent pour attachement (g√©n√©ralement le pilote) */
  parentObject?: THREE.Object3D;
  
  /** Nom de l'entit√© (par d√©faut : 'controlBar') */
  name?: string;
}

/**
 * Factory pour cr√©er l'entit√© ECS ControlBar avec g√©om√©trie compl√®te
 *
 * @example
 * ```typescript
 * // Cr√©ation simple
 * const controlBar = ControlBarEntityFactory.create();
 *
 * // Avec attachement au pilote
 * const controlBar = ControlBarEntityFactory.create({
 *   parentObject: pilotMesh.object3D
 * });
 * ```
 */
export class ControlBarEntityFactory {
  /**
   * Cr√©e une entit√© ControlBar compl√®te avec g√©om√©trie Three.js
   *
   * @param params - Param√®tres de configuration
   * @returns Entit√© ECS ControlBar pr√™te √† l'emploi
   */
  static create(params: ControlBarFactoryParams = {}): Entity {
    // Cr√©er la g√©om√©trie Three.js
    const controlBarGroup = this.createGeometry();
    
    // Position (par d√©faut : relative au pilote)
    const position = params.position || new THREE.Vector3(
      0, // M√™me X que le pilote
      CONFIG.controlBar.offsetY, // Au-dessus du pilote
      CONFIG.controlBar.offsetZ  // Devant le pilote
    );
    controlBarGroup.position.copy(position);
    
    // Attacher au parent si fourni
    if (params.parentObject) {
      params.parentObject.add(controlBarGroup);
    }
    
    // Cr√©er l'entit√© avec Transform + Mesh (via EntityBuilder)
    return EntityBuilder.createWithMesh(
      params.name || 'controlBar',
      controlBarGroup,
      position
    );
  }
  
  /**
   * Cr√©e la g√©om√©trie Three.js de la barre de contr√¥le
   * Isol√©e, testable, r√©utilisable
   *
   * @returns THREE.Group contenant la barre et les poign√©es
   */
  private static createGeometry(): THREE.Group {
    const group = new THREE.Group();
    group.name = 'ControlBar';
    
    // Barre principale
    const bar = this.createBar();
    group.add(bar);
    
    // Poign√©es gauche et droite
    const { left, right } = this.createHandles();
    group.add(left, right);
    
    return group;
  }
  
  /**
   * Cr√©e la barre principale (cylindre horizontal)
   *
   * @returns Mesh de la barre
   */
  private static createBar(): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.width
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: 0x333333, // Gris fonc√©
      metalness: 0.7,
      roughness: 0.3
    });
    
    const bar = new THREE.Mesh(geometry, material);
    
    // Rotation de 90¬∞ sur l'axe Z pour rendre le cylindre horizontal
    // Cette rotation est locale au mesh et ne sera pas affect√©e par les rotations du groupe
    bar.rotation.z = Math.PI / 2;
    bar.castShadow = true;
    
    return bar;
  }
  
  /**
   * Cr√©e les poign√©es gauche et droite
   *
   * @returns Objet contenant les deux poign√©es
   */
  private static createHandles(): { left: THREE.Mesh; right: THREE.Mesh } {
    const geometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleLength
    );
    
    const material = new THREE.MeshStandardMaterial({
      color: 0x8b4513, // Marron (bois)
      roughness: 0.6
    });
    
    const halfWidth = CONFIG.controlBar.width / 2;
    
    // Poign√©e gauche
    const left = new THREE.Mesh(geometry, material);
    left.position.set(-halfWidth, 0, 0);
    left.rotation.z = Math.PI / 2; // M√™me orientation que la barre (horizontal)
    left.castShadow = true;
    
    // Poign√©e droite
    const right = new THREE.Mesh(geometry, material);
    right.position.set(halfWidth, 0, 0);
    right.rotation.z = Math.PI / 2; // M√™me orientation que la barre (horizontal)
    right.castShadow = true;
    
    return { left, right };
  }
}


=== simulation/factories/EntityBuilder.ts ===

/**
 * EntityBuilder.ts - Utilitaires pour construire des entit√©s ECS
 *
 * Responsabilit√© : Factoriser les patterns r√©p√©titifs de cr√©ation d'entit√©s
 * Principe DRY : Une seule source de v√©rit√© pour les composants standards
 *
 * Pattern : Builder + Factory Helpers
 * Utilisation : Appel√© depuis les Entity Factories (ControlBar, Kite, Pilot, etc.)
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { TransformComponent, MeshComponent } from '../components';

/**
 * Options pour cr√©er un TransformComponent
 */
export interface TransformOptions {
  /** Rotation autour de l'axe Y (par d√©faut : 0) */
  rotation?: number;
  
  /** Quaternion (par d√©faut : identit√©) */
  quaternion?: THREE.Quaternion;
  
  /** √âchelle (par d√©faut : (1, 1, 1)) */
  scale?: THREE.Vector3;
}

/**
 * Options pour cr√©er un MeshComponent
 */
export interface MeshOptions {
  /** Visible dans la sc√®ne (par d√©faut : true) */
  visible?: boolean;
  
  /** Projette des ombres (par d√©faut : true) */
  castShadow?: boolean;
  
  /** Re√ßoit des ombres (par d√©faut : false) */
  receiveShadow?: boolean;
}

/**
 * Options pour cr√©er une entit√© compl√®te avec Transform + Mesh
 */
export interface EntityWithMeshOptions extends TransformOptions, MeshOptions {
  // Combine TransformOptions et MeshOptions
}

/**
 * EntityBuilder - Helpers utilitaires pour construire des entit√©s ECS
 *
 * Factorisation des patterns r√©p√©titifs observ√©s dans toutes les Entity Factories :
 * - Cr√©ation de TransformComponent avec valeurs par d√©faut
 * - Cr√©ation de MeshComponent avec options standard
 * - Extraction d'objets 3D typ√©s depuis MeshComponent
 * - Cr√©ation rapide d'entit√©s simples (Transform + Mesh)
 *
 * @example
 * ```typescript
 * // Ajouter Transform + Mesh s√©par√©ment
 * const entity = new Entity('myEntity');
 * EntityBuilder.addTransform(entity, position);
 * EntityBuilder.addMesh(entity, object3D);
 *
 * // Cr√©er entit√© compl√®te en une ligne
 * const entity = EntityBuilder.createWithMesh('myEntity', object3D, position);
 *
 * // Extraire objet 3D typ√©
 * const kite = EntityBuilder.getMeshObject<Kite>(kiteEntity);
 * ```
 */
export class EntityBuilder {
  /**
   * Ajoute un TransformComponent standard √† une entit√©
   * 
   * Factorisation du pattern r√©p√©t√© dans toutes les factories.
   * Valeurs par d√©faut :
   * - rotation : 0
   * - quaternion : identit√©
   * - scale : (1, 1, 1)
   *
   * @param entity - Entit√© √† laquelle ajouter le composant
   * @param position - Position 3D (sera clon√©e)
   * @param options - Options de transformation (optionnelles)
   * @returns Le TransformComponent cr√©√©
   */
  static addTransform(
    entity: Entity,
    position: THREE.Vector3,
    options: TransformOptions = {}
  ): TransformComponent {
    const transform = new TransformComponent({
      position: position.clone(),
      rotation: options.rotation ?? 0,
      quaternion: options.quaternion ?? new THREE.Quaternion(),
      scale: options.scale ?? new THREE.Vector3(1, 1, 1)
    });
    entity.addComponent(transform);
    return transform;
  }

  /**
   * Ajoute un MeshComponent standard √† une entit√©
   * 
   * Factorisation du pattern r√©p√©t√© dans toutes les factories.
   * Valeurs par d√©faut :
   * - visible : true
   * - castShadow : true
   * - receiveShadow : false
   *
   * @param entity - Entit√© √† laquelle ajouter le composant
   * @param object3D - Objet Three.js (mesh, group, etc.)
   * @param options - Options de rendu (optionnelles)
   * @returns Le MeshComponent cr√©√©
   */
  static addMesh(
    entity: Entity,
    object3D: THREE.Object3D,
    options: MeshOptions = {}
  ): MeshComponent {
    const mesh = new MeshComponent(object3D, {
      visible: options.visible ?? true,
      castShadow: options.castShadow ?? true,
      receiveShadow: options.receiveShadow ?? false
    });
    entity.addComponent(mesh);
    return mesh;
  }

  /**
   * Extrait un objet 3D typ√© depuis le MeshComponent d'une entit√©
   * 
   * Helper g√©n√©rique pour √©viter r√©p√©tition de getComponent + cast.
   * Utilisable partout (Factories, Systems, SimulationApp).
   *
   * @typeParam T - Type de l'objet 3D attendu (ex: Kite, THREE.Group)
   * @param entity - Entit√© contenant un MeshComponent
   * @returns Objet 3D typ√© ou null si composant absent
   *
   * @example
   * ```typescript
   * const kite = EntityBuilder.getMeshObject<Kite>(kiteEntity);
   * if (kite) {
   *   kite.setBridleLengths([...]);
   * }
   * ```
   */
  static getMeshObject<T extends THREE.Object3D>(entity: Entity): T | null {
    const meshComponent = entity.getComponent<MeshComponent>('mesh');
    if (!meshComponent) return null;
    return meshComponent.object3D as T;
  }

  /**
   * Cr√©e une entit√© compl√®te avec Transform + Mesh en une seule ligne
   * 
   * Cas d'usage le plus courant : entit√© avec position + objet 3D.
   * √âquivalent √† :
   * ```typescript
   * const entity = new Entity(name);
   * EntityBuilder.addTransform(entity, position, options);
   * EntityBuilder.addMesh(entity, object3D, options);
   * ```
   *
   * @param name - Nom de l'entit√©
   * @param object3D - Objet Three.js
   * @param position - Position 3D
   * @param options - Options combin√©es (Transform + Mesh)
   * @returns Entit√© compl√®te avec Transform et Mesh
   *
   * @example
   * ```typescript
   * const entity = EntityBuilder.createWithMesh(
   *   'kite',
   *   kiteObject,
   *   new THREE.Vector3(0, 50, -100)
   * );
   * ```
   */
  static createWithMesh(
    name: string,
    object3D: THREE.Object3D,
    position: THREE.Vector3,
    options: EntityWithMeshOptions = {}
  ): Entity {
    const entity = new Entity(name);

    // Ajouter Transform
    this.addTransform(entity, position, {
      rotation: options.rotation,
      quaternion: options.quaternion,
      scale: options.scale
    });

    // Ajouter Mesh
    this.addMesh(entity, object3D, {
      visible: options.visible,
      castShadow: options.castShadow,
      receiveShadow: options.receiveShadow
    });

    return entity;
  }
}


=== simulation/factories/KiteEntityFactory.ts ===

/**
 * KiteEntityFactory.ts - Factory pour cr√©er l'entit√© ECS Kite
 *
 * Responsabilit√© unique : Construction de l'entit√© Kite avec objet StructuredObject complet
 * R√©utilise les factories g√©om√©triques existantes (PointFactory, FrameFactory, etc.)
 *
 * Pattern : Factory Method + Composition
 * Utilisation : Appel√©e depuis SimulationApp.createKiteEntity()
 */

import * as THREE from 'three';

import { Entity } from '../entities/Entity';
import { CONFIG } from '../config/SimulationConfig';

import { EntityBuilder } from './EntityBuilder';

import { Kite } from '@/objects/Kite';
import { MathUtils } from '@/utils/MathUtils';


/**
 * Param√®tres pour cr√©er une entit√© Kite
 */
export interface KiteFactoryParams {
  /** Position initiale du kite (par d√©faut : calcul√©e automatiquement) */
  position?: THREE.Vector3;
  
  /** Preset de configuration (par d√©faut : default config) */
  preset?: string; // Extension future pour diff√©rents types de kites
  
  /** Nom de l'entit√© (par d√©faut : 'kite') */
  name?: string;
}

/**
 * Factory pour cr√©er l'entit√© ECS Kite avec objet StructuredObject complet
 *
 * Le kite est un objet complexe utilisant plusieurs factories g√©om√©triques :
 * - PointFactory : Points anatomiques (NEZ, CTRL_GAUCHE, CTRL_DROIT, etc.)
 * - FrameFactory : Structure en carbone
 * - SurfaceFactory : Panneaux de voile
 * - BridleFactory : Syst√®me de bridage (6 lignes)
 *
 * Cette factory ECS **compose** avec ces factories existantes via `new Kite()`.
 *
 * @example
 * ```typescript
 * // Cr√©ation simple (position auto-calcul√©e)
 * const kite = KiteEntityFactory.create();
 *
 * // Avec position personnalis√©e
 * const kite = KiteEntityFactory.create({
 *   position: new THREE.Vector3(0, 50, -100)
 * });
 * ```
 */
export class KiteEntityFactory {
  /**
   * Cr√©e une entit√© Kite compl√®te avec objet StructuredObject Three.js
   *
   * @param params - Param√®tres de configuration
   * @returns Entit√© ECS Kite pr√™te √† l'emploi (avec objet Kite accessible via MeshComponent)
   */
  static create(params: KiteFactoryParams = {}): Entity {
    // 1. Cr√©er l'objet Kite (StructuredObject)
    // Cet objet utilise automatiquement PointFactory, FrameFactory, SurfaceFactory, BridleFactory
    const kite = new Kite();
    
    // 2. Position initiale (auto-calcul√©e ou fournie)
    const position = params.position || this.calculateInitialPosition();
    kite.position.copy(position);
    
    // 3. Cr√©er l'entit√© ECS avec Transform + Mesh (via EntityBuilder)
    return EntityBuilder.createWithMesh(
      params.name || 'kite',
      kite,
      position
    );
  }
  
  /**
   * Calcule la position initiale du kite selon la configuration
   * 
   * Logique m√©tier : Position bas√©e sur la barre de contr√¥le + longueur des lignes
   * 
   * Accessible publiquement pour r√©utilisation (ex: reset du kite)
   * 
   * @returns Position Vector3 calcul√©e
   */
  static calculateInitialPosition(): THREE.Vector3 {
    // Position de la barre de contr√¥le calcul√©e √† partir du pilote
    // Note: Cette position est la m√™me que dans ControlBarEntityFactory
    const controlBarPosition = new THREE.Vector3(
      CONFIG.pilot.position.x,
      CONFIG.pilot.position.y + CONFIG.controlBar.offsetY,
      CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ
    );

    // Calculer position kite selon longueur des lignes et facteur de distance
    return MathUtils.calculateInitialKitePosition(
      controlBarPosition, // R√©f√©rence = barre de contr√¥le
      CONFIG.initialization.initialKiteY,
      CONFIG.lines.defaultLength,
      CONFIG.initialization.initialDistanceFactor,
      CONFIG.initialization.initialKiteZ
    );
  }
  
  /**
   * Extrait l'objet Kite d'une entit√© (helper utilitaire)
   * 
   * Wrapper typ√© autour de EntityBuilder.getMeshObject<Kite>()
   * pour commodit√© et clart√© du code.
   * 
   * @param entity - Entit√© contenant un MeshComponent avec objet Kite
   * @returns Objet Kite ou null si non trouv√©
   */
  static getKiteObject(entity: Entity): Kite | null {
    return EntityBuilder.getMeshObject<Kite>(entity);
  }
}


=== simulation/factories/PilotEntityFactory.ts ===

/**
 * PilotEntityFactory.ts - Factory pour cr√©er l'entit√© ECS Pilot
 *
 * Responsabilit√© unique : Construction de l'entit√© Pilot
 * Encapsule l'instanciation pour coh√©rence avec ControlBarEntityFactory
 *
 * Pattern : Factory Method (simplifi√© - PilotEntity est autosuffisant)
 * Utilisation : Appel√©e depuis SimulationApp.createPilotEntity()
 */

import { PilotEntity } from '../entities/PilotEntity';

/**
 * Param√®tres pour cr√©er une entit√© Pilot
 * (Pour l'instant vide - PilotEntity ne supporte pas de customisation)
 */
export interface PilotFactoryParams {
  // R√©serv√© pour extension future
}

/**
 * Factory pour cr√©er l'entit√© ECS Pilot
 *
 * Note: PilotEntity construit toute sa g√©om√©trie dans son constructeur.
 * Cette factory sert principalement √† maintenir la coh√©rence architecturale
 * avec les autres Entity Factories (ControlBar, future Kite).
 *
 * @example
 * ```typescript
 * const pilot = PilotEntityFactory.create();
 * ```
 */
export class PilotEntityFactory {
  /**
   * Cr√©e une entit√© Pilot compl√®te
   *
   * @param _params - Param√®tres de configuration (r√©serv√© pour extension future)
   * @returns PilotEntity pr√™te √† l'emploi
   */
  static create(_params: PilotFactoryParams = {}): PilotEntity {
    // PilotEntity construit toute sa g√©om√©trie dans son constructeur
    // (BoxGeometry selon CONFIG.pilot.width/height/depth)
    return new PilotEntity();
  }
}


=== simulation/factories/index.ts ===

/**
 * index.ts - Export centralis√© des Entity Factories
 */

export { ControlBarEntityFactory, type ControlBarFactoryParams } from './ControlBarEntityFactory';
export { PilotEntityFactory, type PilotFactoryParams } from './PilotEntityFactory';
export { KiteEntityFactory, type KiteFactoryParams } from './KiteEntityFactory';
export { EntityBuilder, type TransformOptions, type MeshOptions, type EntityWithMeshOptions } from './EntityBuilder';



=== simulation/index.ts ===

/**
 * Point d'entr√©e principal de la simulation modulaire
 */

// Export de la classe principale
export { SimulationApp as Simulation } from './SimulationApp';

// Re-export de tous les modules pour faciliter l'importation
export * from './config/PhysicsConstants';
export * from './config/KiteGeometry';
export * from './config/SimulationConfig';

export * from './types';

export * from './physics/WindSimulator';
export * from './physics/AerodynamicsCalculator';
export * from './physics/LineSystem';

export * from './rendering/RenderManager';
export * from './rendering/DebugRenderer';

export * from './ui/UIManager';

export * from './physics/ConstraintSolver';

=== simulation/physics/AerodynamicsCalculator.ts ===

/**
 * AerodynamicsCalculator.ts - Calculateur de forces a√©rodynamiques distribu√©es
 *
 * Calcule les forces a√©rodynamiques (portance, tra√Æn√©e) et gravitationnelles 
 * distribu√©es sur chaque surface du kite selon les principes de la m√©canique des fluides.
 *
 * Mod√®le physique am√©lior√© :
 *   - Coefficients r√©alistes bas√©s sur donn√©es exp√©rimentales (NACA, etc.)
 *   - Mod√©lisation du stall (d√©crochage) √† forts angles d'incidence
 *   - Centre de pression dynamique
 *   - Effets de turbulence et amortissement a√©rodynamique
 *
 * @see PhysicsEngine.ts - Utilise les forces calcul√©es
 * @see KiteGeometry.ts - D√©finit les surfaces et masses
 */
import * as THREE from "three";

import { KiteGeometry } from "../config/KiteGeometry";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { SurfaceForce } from "../types/PhysicsTypes";

/**
 * Calculateur de forces a√©rodynamiques am√©lior√©
 *
 * Calcule comment le vent pousse sur le cerf-volant selon sa forme et orientation
 */
export class AerodynamicsCalculator {
  // Constantes de calculs a√©rodynamiques
  private static readonly HALF_AIR_DENSITY = 0.5 * CONFIG.physics.airDensity;
  private static readonly MIN_WIND_SPEED = 0.01; // m/s - seuil minimal pour calculs a√©ro

  // Coefficients a√©rodynamiques am√©lior√©s pour plaque plane (bas√©s sur donn√©es exp√©rimentales)
  private static readonly AERO_COEFFICIENTS = {
    // Coefficients de portance CL = a0 + a1*Œ± + a2*Œ±¬≤ + a3*Œ±¬≥
    lift: {
      a0: 0.0,      // Offset
      a1: 0.1,      // Lin√©aire (2œÄ pour profil mince, r√©duit pour plaque plane)
      a2: 0.0,      // Quadratique
      a3: -0.005    // Cubique (pour stall)
    },

    // Coefficients de tra√Æn√©e CD = b0 + b1*Œ± + b2*Œ±¬≤ + b3*Œ±¬≥
    drag: {
      b0: 0.01,     // Tra√Æn√©e parasite minimale
      b1: 0.0,      // Composante lin√©aire faible
      b2: 0.05,     // Quadratique (principale)
      b3: 0.002     // Cubique (augmente en stall)
    },

    // Limites pour √©viter les instabilit√©s
    alphaStall: Math.PI / 6,  // 30¬∞ - angle de d√©crochage
    alphaMax: Math.PI / 3,    // 60¬∞ - angle maximum
    clMax: 1.2,               // CL maximum avant stall
    cdMax: 2.0                // CD maximum
  };

  /**
   * Calcule les coefficients a√©rodynamiques r√©alistes pour un angle d'incidence
   * Bas√© sur des donn√©es exp√©rimentales pour plaques planes et profils simples
   */
  private static calculateAerodynamicCoefficients(alpha: number): { CL: number; CD: number } {
    const coeffs = this.AERO_COEFFICIENTS;
    const absAlpha = Math.abs(alpha);

    // Limiter l'angle pour √©viter les instabilit√©s
    const clampedAlpha = Math.max(-coeffs.alphaMax, Math.min(coeffs.alphaMax, alpha));

    // Calculer CL avec mod√®le polynomial + stall
    let CL = coeffs.lift.a0 +
             coeffs.lift.a1 * clampedAlpha +
             coeffs.lift.a2 * clampedAlpha * clampedAlpha +
             coeffs.lift.a3 * clampedAlpha * clampedAlpha * clampedAlpha;

    // Appliquer le stall (d√©crochage) √† forts angles
    if (absAlpha > coeffs.alphaStall) {
      const stallFactor = Math.max(0, 1 - (absAlpha - coeffs.alphaStall) / (coeffs.alphaMax - coeffs.alphaStall));
      CL *= stallFactor * stallFactor; // D√©croissance quadratique
    }

    // Limiter CL
    CL = Math.max(-coeffs.clMax, Math.min(coeffs.clMax, CL));

    // Calculer CD avec mod√®le polynomial
    let CD = coeffs.drag.b0 +
             coeffs.drag.b1 * Math.abs(clampedAlpha) +
             coeffs.drag.b2 * clampedAlpha * clampedAlpha +
             coeffs.drag.b3 * Math.abs(clampedAlpha * clampedAlpha * clampedAlpha);

    // CD minimum et augmentation en stall
    CD = Math.max(coeffs.drag.b0, CD);

    // En stall, CD augmente significativement
    if (absAlpha > coeffs.alphaStall) {
      const stallDrag = coeffs.drag.b0 + (absAlpha - coeffs.alphaStall) * 0.5;
      CD = Math.max(CD, stallDrag);
    }

    // Limiter CD
    CD = Math.min(coeffs.cdMax, CD);

    return { CL, CD };
  }

  /**
   * Calcule le couple (moment) d'une force appliqu√©e √† un point
   * M√©thode utilitaire pour √©viter la r√©p√©tition de new THREE.Vector3().crossVectors()
   */
  private static calculateTorque(lever: THREE.Vector3, force: THREE.Vector3): THREE.Vector3 {
    return new THREE.Vector3().crossVectors(lever, force);
  }

  /**
   * Calcule l'amortissement a√©rodynamique pour am√©liorer la stabilit√©
   * L'amortissement r√©duit les oscillations angulaires
   */
  private static calculateAerodynamicDamping(
    angularVelocity: THREE.Vector3,
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): THREE.Vector3 {
    // Amortissement anisotrope par axe, pond√©r√© par la vitesse du vent
    const cfg = CONFIG.aero.damping;
    const windSpeed = Math.max(0, apparentWind.length());

    // D√©composer la vitesse angulaire dans le rep√®re du kite (approx: utiliser composantes locales)
    // Ici on suppose angularVelocity exprim√©e dans le rep√®re monde, on applique l'inverse de l'orientation du kite
    const angLocal = angularVelocity.clone().applyQuaternion(kiteOrientation.clone().invert());

    // Amortissement local par axe
    const dampLocal = new THREE.Vector3(
      -cfg.roll * angLocal.x,
      -cfg.pitch * angLocal.y,
      -cfg.yaw * angLocal.z
    ).multiplyScalar(1 + cfg.windSpeedFactor * windSpeed);

    // Revenir dans le rep√®re monde
    const dampingTorque = dampLocal.applyQuaternion(kiteOrientation);

    // Clamp s√©curit√©
    if (dampingTorque.length() > cfg.maxMagnitude) {
      dampingTorque.setLength(cfg.maxMagnitude);
    }

    return dampingTorque;
  }

  /**
   * Calcule le centre de pression r√©aliste pour une surface
   * Le centre de pression se d√©place avec l'angle d'incidence
   */
  private static calculateCenterOfPressure(
    surface: any,
    alpha: number,
    centroid: THREE.Vector3
  ): THREE.Vector3 {
    // Pour une plaque plane, le centre de pression se d√©place vers l'arri√®re
    // quand l'angle d'incidence augmente (effet de portance)

    // Coefficient de d√©placement du centre de pression (empirique)
    const cpShiftCoeff = 0.3; // Fraction de la longueur de la surface

    // Calculer la direction longitudinale de la surface (du nez vers la queue)
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    const surfaceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

    // Direction longitudinale approximative (perpendiculaire √† la normale dans le plan)
    const longitudinalDir = edge1.clone().normalize();

    // D√©placement du centre de pression bas√© sur l'angle d'incidence
    // √Ä Œ±=0¬∞, CP = centro√Øde
    // √Ä Œ±>0¬∞, CP se d√©place vers l'arri√®re (direction oppos√©e au vent relatif)
    const cpShift = Math.abs(alpha) * cpShiftCoeff;
    const cpOffset = longitudinalDir.clone().multiplyScalar(-cpShift); // Vers l'arri√®re

    return centroid.clone().add(cpOffset);
  }  /**
   * Calcule la normale d'un triangle dans l'espace monde
   * M√©thode utilitaire pour √©viter la duplication de code
   *
   * @param surface - Surface triangulaire avec vertices
   * @param kiteOrientation - Quaternion d'orientation du kite (optionnel)
   * @returns Vecteur normal unitaire dans l'espace monde
   */
  private static calculateSurfaceNormal(
    surface: { vertices: THREE.Vector3[] },
    kiteOrientation?: THREE.Quaternion
  ): THREE.Vector3 {
    // Calcul des ar√™tes du triangle
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    
    // Normale locale (produit vectoriel normalis√©)
    const normal = new THREE.Vector3()
      .crossVectors(edge1, edge2)
      .normalize();
    
    // Transformation dans l'espace monde si orientation fournie
    return kiteOrientation ? normal.applyQuaternion(kiteOrientation) : normal;
  }

  /**
   * Calcule comment le vent pousse sur le cerf-volant
   *
   * COMMENT √áA MARCHE :
   * 1. On regarde chaque triangle du cerf-volant
   * 2. On calcule sous quel angle le vent frappe ce triangle
   * 3. Plus le vent frappe de face, plus la force est grande
   * 4. On additionne toutes les forces pour avoir la force totale
   *
   * POURQUOI C'EST IMPORTANT :
   * Si un c√¥t√© du kite re√ßoit plus de vent, il sera pouss√© plus fort
   * Cette diff√©rence fait tourner le kite naturellement !
   */
  static calculateForces(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion,
    kitePosition?: THREE.Vector3,
    _kiteVelocity?: THREE.Vector3,
    _angularVelocity?: THREE.Vector3
  ): {
    lift: THREE.Vector3;
    drag: THREE.Vector3;
    gravity: THREE.Vector3;  // Gravit√© distribu√©e par surface
    torque: THREE.Vector3;
    leftForce?: THREE.Vector3;
    rightForce?: THREE.Vector3;
    surfaceForces: SurfaceForce[];
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < 0.1) {
      return {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),  // Pas de gravit√© si vent nul
        torque: new THREE.Vector3(),
        surfaceForces: [],
      };
    }

    apparentWind.clone().normalize();
    AerodynamicsCalculator.HALF_AIR_DENSITY * windSpeed * windSpeed;

    // Forces s√©par√©es pour gauche et droite
    const leftForce = new THREE.Vector3();
    const rightForce = new THREE.Vector3();
    const totalForce = new THREE.Vector3();
    const totalTorque = new THREE.Vector3();
    
    // Accumulation des forces par type (formules plaque plane : CL = sin(Œ±)√ócos(Œ±), CD = sin¬≤(Œ±))
    const totalLift = new THREE.Vector3();      // Portance totale
    const totalDrag = new THREE.Vector3();      // Tra√Æn√©e totale
    const gravityForce = new THREE.Vector3();   // Gravit√© distribu√©e par surface/frame
    
    // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent
    const aeroTorque = new THREE.Vector3();
    const gravityTorque = new THREE.Vector3();
    
    // Collection des forces par surface pour le debug
    const surfaceForces: SurfaceForce[] = [];

  // Mod√®le physique :
  // - Les forces a√©rodynamiques (portance, tra√Æn√©e) sont calcul√©es et appliqu√©es pour chaque surface triangulaire
  // - La masse de chaque surface est proportionnelle √† son aire
  // - Les forces sont appliqu√©es au centre g√©om√©trique du triangle (barycentre)
  // - Les couples √©mergent naturellement de la distribution spatiale des forces
  // - Voir PHYSICS_MODEL.md ¬ß4.2 pour les √©quations et principes
  // On examine chaque triangle du cerf-volant un par un
  // C'est comme v√©rifier comment le vent frappe chaque panneau d'un parasol
    KiteGeometry.SUBDIVIDED_SURFACES.forEach((surface, surfaceIndex) => {
      // üî¥ MAILLAGE FIN : Distribuer la masse proportionnellement √† l'aire
      // Trouver quelle surface originale contient ce sous-triangle
      const trianglesPerSurface = KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(
        KiteGeometry.getMeshSubdivisionLevel()
      );
      const originalSurfaceIndex = Math.floor(surfaceIndex / trianglesPerSurface);
      const originalSurfaceMass = KiteGeometry.SURFACE_MASSES[originalSurfaceIndex];

      // Distribuer la masse proportionnellement √† l'aire relative
      const totalAreaForOriginal = KiteGeometry.SURFACES[originalSurfaceIndex].area;
      const massRatio = surface.area / totalAreaForOriginal;
      const surfaceMass = originalSurfaceMass * massRatio;
      // üî¥ D√âSACTIVATION TEMPORAIRE du vent apparent local pour debug
      // Le calcul local peut r√©duire trop fortement le vent per√ßu en rotation
      
      // Utiliser le vent apparent GLOBAL pour toutes les surfaces
      const localApparentWind = apparentWind.clone();
      const localWindSpeed = localApparentWind.length();
      
      if (localWindSpeed < 0.1) {
        return; // Pas de vent sur cette surface
      }
      
      const localWindDir = localApparentWind.clone().normalize();
      const localDynamicPressure = 0.5 * CONFIG.physics.airDensity * localWindSpeed * localWindSpeed;
      
      // Pour comprendre comment le vent frappe ce triangle,
      // on doit savoir dans quelle direction il "regarde"
      // (comme l'orientation d'un panneau solaire)
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      // Calcul de l'angle d'incidence pour une plaque plane (cerf-volant)
      // Œ± = angle entre la direction du vent et la surface
      const windDotNormal = localWindDir.dot(normaleMonde);
      const cosTheta = Math.abs(windDotNormal); // cos(Œ∏) o√π Œ∏ = angle vent-normale

      // Pour une plaque : sin(Œ±) = cos(Œ∏) et cos(Œ±) = sin(Œ∏)
      const sinAlpha = cosTheta;
      const cosAlpha = Math.sqrt(Math.max(0, 1 - sinAlpha * sinAlpha)); // sin¬≤+cos¬≤=1

      // Calculer l'angle d'incidence r√©el (en radians)
      const alpha = Math.asin(Math.min(1, sinAlpha)); // Limiter √† [-œÄ/2, œÄ/2]

      // Si le vent glisse sur le c√¥t√© (angle = 0), pas de force
      if (sinAlpha <= PhysicsConstants.EPSILON) {
        return;
      }

      // üéØ NOUVEAUX COEFFICIENTS A√âRODYNAMIQUES R√âALISTES
      // Au lieu des formules simplifi√©es, utiliser des coefficients exp√©rimentaux
      const { CL, CD } = AerodynamicsCalculator.calculateAerodynamicCoefficients(alpha);
      
      // üîç DEBUG premi√®re surface (angle et coefficients) - DISABLED for performance
      // if (surfaceIndex === 0) {
      //   const alphaDeg = Math.asin(sinAlpha) * 180 / Math.PI;

      // }
      
      // Direction : normale √† la surface, orient√©e face au vent
      const windFacingNormal = windDotNormal >= 0 ? normaleMonde.clone() : normaleMonde.clone().negate();
      
      // DIRECTION LIFT : Perpendiculaire au vent, dans le plan (vent, normale)
      // M√©thode : liftDir = normalize(windFacingNormal - (windFacingNormal¬∑windDir)√ówindDir)
      const liftDir = windFacingNormal.clone()
        .sub(localWindDir.clone().multiplyScalar(windFacingNormal.dot(localWindDir)))
        .normalize();
      
      // V√©rifier validit√© (√©viter division par z√©ro si vent // normale)
      if (liftDir.lengthSq() < PhysicsConstants.EPSILON) {
        liftDir.copy(windFacingNormal);  // Fallback : utiliser normale
      }
      
      // DIRECTION DRAG : Parall√®le au vent
      const dragDir = localWindDir.clone();
      
      // FORCES A√âRODYNAMIQUES (AVANT scaling) avec pression dynamique LOCALE
      const liftMagnitude = localDynamicPressure * surface.area * CL;
      const dragMagnitude = localDynamicPressure * surface.area * CD;
      
      const liftForce = liftDir.clone().multiplyScalar(liftMagnitude);
      const dragForce = dragDir.clone().multiplyScalar(dragMagnitude);
      
      // Force a√©rodynamique totale = lift + drag (vectoriel)
      const aeroForce = liftForce.clone().add(dragForce);
      
      // GRAVIT√â DISTRIBU√âE (√©mergente, pas script√©e !)
      // Chaque surface porte une fraction de la masse totale
      // La gravit√© est appliqu√©e au centre g√©om√©trique de chaque surface
      // ‚Üí Couple gravitationnel √©merge naturellement de r √ó F_gravity
      const gravity = new THREE.Vector3(0, -surfaceMass * CONFIG.physics.gravity, 0);
      
      // Accumulation des forces par type
      totalLift.add(liftForce);
      totalDrag.add(dragForce);
      gravityForce.add(gravity);
      
      // Force totale sur cette surface = a√©ro + gravit√©
      const totalSurfaceForce = aeroForce.clone().add(gravity);
      
      // Pour le debug : conserver lift/drag locaux
      const lift = liftForce.clone();
      const drag = dragForce.clone();

      // 6. Centre de pression dynamique (au lieu du simple centro√Øde)
      const geometricCentroid = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Centre de pression r√©aliste qui d√©pend de l'angle d'incidence
      const centerOfPressure = AerodynamicsCalculator.calculateCenterOfPressure(
        surface,
        alpha,
        geometricCentroid
      );

      // Centre orient√© dans le rep√®re monde (sans translation)
      const centreOriente = centerOfPressure.clone().applyQuaternion(kiteOrientation);
      // Centre monde complet (incluant translation si disponible)
      const centreMonde = kitePosition
        ? centreOriente.clone().add(kitePosition)
        : centreOriente.clone();

      // üîç DEBUG TOUTES les surfaces : g√©om√©trie + forces - DISABLED for performance


      // On note si cette force est sur le c√¥t√© gauche ou droit
      // C'est important car si un c√¥t√© a plus de force,
      // le kite va tourner (comme un bateau avec une seule rame)
      const isLeft = centerOfPressure.x < 0; // N√©gatif = gauche, Positif = droite

      if (isLeft) {
        leftForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      } else {
        rightForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      }

      totalForce.add(totalSurfaceForce);

      // Friction (n√©gligeable pour l'air, nulle)
      const friction = new THREE.Vector3();

      // R√©sultante = force a√©ro totale (lift + drag vectoriel)
      const resultant = aeroForce.clone();

      surfaceForces.push({
        surfaceIndex,
        lift,
        drag,
        friction,
        resultant,
        center: centreMonde,
        normal: normaleMonde.clone(),
        area: surface.area,
      });

      // Le couple, c'est ce qui fait tourner le kite
      // Imaginez une porte : si vous poussez pr√®s des gonds, elle tourne peu
      // Si vous poussez loin des gonds, elle tourne beaucoup
      // Ici, plus la force est loin du centre, plus elle fait tourner
      //
      // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent :
      // - Couple a√©ro : sera scal√© proportionnellement aux forces (liftScale/dragScale)
      // - Couple gravit√© : physique pure, pas de scaling
      // Note: centre est d√©j√† en coordonn√©es locales, on applique seulement la rotation
  const centreWorldForTorque = centreOriente.clone();
      
      // Couples calcul√©s via m√©thode utilitaire
      aeroTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, aeroForce));
      gravityTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, gravity));
      totalTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, totalSurfaceForce));


    });

    // PHYSIQUE √âMERGENTE : Le couple vient de la diff√©rence G/D
    // Si leftForce > rightForce ‚Üí rotation vers la droite
    // Si rightForce > leftForce ‚Üí rotation vers la gauche
    // AUCUN facteur artificiel n√©cessaire!

    // üî¥ BUG FIX #4 : PAS DE D√âCOMPOSITION GLOBALE !
    // Les lift/drag ont d√©j√† √©t√© calcul√©s CORRECTEMENT par surface avec CL/CD
    // Il suffit d'appliquer les scaling factors directement
    const lift = totalLift.multiplyScalar(CONFIG.aero.liftScale);
    const drag = totalDrag.multiplyScalar(CONFIG.aero.dragScale);

    // üîç DEBUG : Afficher forces calcul√©es - DISABLED for performance
    // Uncomment for debugging:


    // üîç DEBUG CRITIQUE : Asym√©trie gauche/droite - DISABLED for performance
    // const leftMag = leftForce.length();
    // const rightMag = rightForce.length();
    // const asymmetry = leftMag - rightMag;
    // const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag * 100) : 0;
    // const leftArr = leftForce.toArray();
    // const rightArr = rightForce.toArray();
    // const diffArr = leftForce.clone().sub(rightForce).toArray();


    // CORRECTION CRITIQUE : Scaling coh√©rent du couple a√©rodynamique
    // Le couple DOIT √™tre scal√© proportionnellement aux forces a√©ro pour coh√©rence physique
    // Si les forces sont doubl√©es (scale=2), le couple doit l'√™tre aussi
    // MAIS la gravit√© reste inchang√©e (physique pure)
    const averageAeroScale = (CONFIG.aero.liftScale + CONFIG.aero.dragScale) / 2;
    const scaledAeroTorque = aeroTorque.multiplyScalar(averageAeroScale);
    
    // Couple total = couple a√©ro scal√© + couple gravit√© (non scal√©)
  let finalTorque = scaledAeroTorque.clone().add(gravityTorque);

    // üéØ AJOUTER L'AMORTISSEMENT A√âRODYNAMIQUE pour la stabilit√©
    if (_angularVelocity && CONFIG.aero.damping.enabled) {
      const dampingTorque = AerodynamicsCalculator.calculateAerodynamicDamping(
        _angularVelocity,
        apparentWind,
        kiteOrientation
      );
      finalTorque.add(dampingTorque);
    }

    // Clamp final du couple pour stabilit√© num√©rique
    const maxNm = CONFIG.aero.damping.maxMagnitude * 2; // un peu plus haut que l'amortissement seul
    if (finalTorque.length() > maxNm) {
      finalTorque.setLength(maxNm);
    }

    return {
      lift,
      drag,
      gravity: gravityForce,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e par surface
      torque: finalTorque,  // Couple coh√©rent avec forces scal√©es + amortissement
      leftForce, // Exposer les forces pour analyse
      rightForce, // Permet de voir l'asym√©trie √©mergente
      surfaceForces, // Forces individuelles par surface pour debug
    };
  }

  /**
   * Calcule des m√©triques pour le debug
   */
  static computeMetrics(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): {
    apparentSpeed: number;
    liftMag: number;
    dragMag: number;
    lOverD: number;
    aoaDeg: number;
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < PhysicsConstants.EPSILON) {
      return { apparentSpeed: 0, liftMag: 0, dragMag: 0, lOverD: 0, aoaDeg: 0 };
    }

    const { lift } = this.calculateForces(apparentWind, kiteOrientation);
    const liftMag = lift.length();
    const dragMag = 0; // Tra√Æn√©e int√©gr√©e dans les forces totales
    const lOverD = 0; // Ratio non applicable pour un cerf-volant

    // Calcul approximatif de l'angle d'attaque
    const windDir = apparentWind.clone().normalize();
    const weightedNormal = new THREE.Vector3();

    KiteGeometry.SURFACES.forEach((surface) => {
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      const facing = windDir.dot(normaleMonde);
      const cosIncidence = Math.max(0, Math.abs(facing));

      const normalDir =
        facing >= 0 ? normaleMonde : normaleMonde.clone().negate();
      weightedNormal.add(normalDir.multiplyScalar(surface.area * cosIncidence));
    });

    let aoaDeg = 0;
    if (
      weightedNormal.lengthSq() >
      PhysicsConstants.EPSILON * PhysicsConstants.EPSILON
    ) {
      const eff = weightedNormal.normalize();
      const dot = Math.max(-1, Math.min(1, eff.dot(windDir)));
      const phiDeg = (Math.acos(dot) * 180) / Math.PI;
      aoaDeg = Math.max(0, 90 - phiDeg);
    }

    return { apparentSpeed: windSpeed, liftMag, dragMag, lOverD, aoaDeg };
  }
}

=== simulation/physics/BridleSystem.ts ===

/**
 * BridleSystem.ts - Orchestrateur du syst√®me de bridage du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les 6 brides (3 gauches + 3 droites)
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les brides sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT les points d'attache (distance max)
 *   - Elles ne TIRENT PAS les points les uns vers les autres
 *   - Le ConstraintSolver.enforceBridleConstraints() g√®re la contrainte g√©om√©trique
 *
 * Architecture :
 *   - Similar √† LineSystem mais pour les brides internes au kite
 *   - R√©utilise LinePhysics pour les calculs de tension
 *   - Les 6 brides sont des instances Line ind√©pendantes
 *
 * Relation avec les autres modules :
 *   - Utilise BridleFactory pour cr√©er les brides
 *   - Utilise LinePhysics pour calculer tensions
 *   - Utilis√© par PhysicsEngine
 *   - Les contraintes sont appliqu√©es dans ConstraintSolver
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts (pattern similaire)
 *   - src/factories/BridleFactory.ts
 *   - src/simulation/physics/ConstraintSolver.ts
 */

import { BridleFactory } from "@factories/BridleFactory";

import { BridleLengths, BridleTensions } from "../types/BridleTypes";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

import { Line } from "@/objects/Line";
import { Kite } from "@/objects/Kite";

/**
 * Syst√®me de gestion des brides
 *
 * G√®re les 6 brides qui relient les points anatomiques du kite
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */
export class BridleSystem {
  // Brides gauches (3)
  private leftNez: Line;
  private leftInter: Line;
  private leftCentre: Line;

  // Brides droites (3)
  private rightNez: Line;
  private rightInter: Line;
  private rightCentre: Line;

  // Services de calcul physique (r√©utilis√©s)
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(bridleLengths: BridleLengths) {
    // Valider les longueurs
    BridleFactory.validateBridleLengths(bridleLengths);

    // Cr√©er les 6 brides via factory
    const { left, right } = BridleFactory.createAllBridles(bridleLengths);

    // Assigner brides gauches
    [this.leftNez, this.leftInter, this.leftCentre] = left;

    // Assigner brides droites
    [this.rightNez, this.rightInter, this.rightCentre] = right;

    // Services de calcul physique
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  /**
   * Calcule les tensions de toutes les brides
   *
   * Note : Ces tensions sont calcul√©es pour affichage/debug uniquement.
   * Les brides sont des contraintes g√©om√©triques g√©r√©es par ConstraintSolver,
   * elles n'appliquent PAS de forces au kite.
   *
   * @param kite - Instance du cerf-volant
   * @returns Tensions des 6 brides (Newtons)
   */
  calculateBridleTensions(kite: Kite): BridleTensions {
    const deltaTime = 1 / 60; // Approximation pour calcul v√©locit√©

    // Configuration des 6 brides avec leur m√©tadonn√©es
    const bridleConfigs = [
      { line: this.leftNez, start: "NEZ", end: "CTRL_GAUCHE", key: "leftNez" },
      { line: this.leftInter, start: "INTER_GAUCHE", end: "CTRL_GAUCHE", key: "leftInter" },
      { line: this.leftCentre, start: "CENTRE", end: "CTRL_GAUCHE", key: "leftCentre" },
      { line: this.rightNez, start: "NEZ", end: "CTRL_DROIT", key: "rightNez" },
      { line: this.rightInter, start: "INTER_DROIT", end: "CTRL_DROIT", key: "rightInter" },
      { line: this.rightCentre, start: "CENTRE", end: "CTRL_DROIT", key: "rightCentre" },
    ] as const;

    // Calculer toutes les tensions en une passe
    const tensionsMap = new Map<string, number>();
    for (const config of bridleConfigs) {
      const tension = this.calculateSingleBridleTension(
        kite,
        config.line,
        config.start,
        config.end,
        deltaTime
      );
      tensionsMap.set(config.key, tension);
    }

    // Construire le r√©sultat
    return {
      leftNez: tensionsMap.get("leftNez")!,
      leftInter: tensionsMap.get("leftInter")!,
      leftCentre: tensionsMap.get("leftCentre")!,
      rightNez: tensionsMap.get("rightNez")!,
      rightInter: tensionsMap.get("rightInter")!,
      rightCentre: tensionsMap.get("rightCentre")!,
    };
  }

  /**
   * Calcule la tension d'une bride individuelle
   *
   * @param kite - Instance du cerf-volant
   * @param bridle - Instance Line de la bride
   * @param startPointName - Nom du point de d√©part (ex: "NEZ")
   * @param endPointName - Nom du point d'arriv√©e (ex: "CTRL_GAUCHE")
   * @param deltaTime - Pas de temps pour calcul v√©locit√©
   * @returns Tension en Newtons
   */
  private calculateSingleBridleTension(
    kite: Kite,
    bridle: Line,
    startPointName: string,
    endPointName: string,
    deltaTime: number
  ): number {
    // R√©cup√©rer positions locales
    const startLocal = kite.getPoint(startPointName);
    const endLocal = kite.getPoint(endPointName);

    if (!startLocal || !endLocal) {
      // Points bride introuvables - gestion silencieuse
      return 0;
    }

    // Convertir en coordonn√©es monde
    const startWorld = kite.toWorldCoordinates(startLocal);
    const endWorld = kite.toWorldCoordinates(endLocal);

    // Calculer v√©locit√© relative avec VelocityCalculator
    const key = `${startPointName}_${endPointName}`;
    const velocity = this.velocityCalculator.calculateRelative(
      `${key}_start`,
      `${key}_end`,
      startWorld,
      endWorld,
      deltaTime
    );

    // Calculer tension via LinePhysics
    const result = this.physics.calculateTensionForce(
      bridle,
      startWorld,
      endWorld,
      velocity
    );

    // Mettre √† jour l'√©tat de la bride
    bridle.updateState(result.currentLength, result.tension, performance.now());

    return result.tension;
  }

  /**
   * Met √† jour les longueurs des brides
   *
   * @param newLengths - Nouvelles longueurs (partial update)
   * @deprecated Utilisez PhysicsEngine.setBridleLength() √† la place
   */
  setBridleLengths(_newLengths: Partial<BridleLengths>): void {
    // Note: Les instances Line sont immuables. Pour changer les longueurs,
    // il faut recr√©er BridleSystem avec les nouvelles longueurs.
    // Cette m√©thode est d√©pr√©ci√©e - utilisez PhysicsEngine.setBridleLength()
    // Gestion silencieuse - m√©thode d√©pr√©ci√©e
  }

  /**
   * Obtient les longueurs actuelles des brides
   *
   * @returns BridleLengths actuelles
   */
  getBridleLengths(): BridleLengths {
    return {
      nez: this.leftNez.config.length,
      inter: this.leftInter.config.length,
      centre: this.leftCentre.config.length,
    };
  }

  /**
   * Obtient toutes les instances Line des brides
   * (utile pour ConstraintSolver)
   *
   * @returns Objet contenant les 6 brides
   */
  getAllBridles(): {
    left: { nez: Line; inter: Line; centre: Line };
    right: { nez: Line; inter: Line; centre: Line };
  } {
    return {
      left: {
        nez: this.leftNez,
        inter: this.leftInter,
        centre: this.leftCentre,
      },
      right: {
        nez: this.rightNez,
        inter: this.rightInter,
        centre: this.rightCentre,
      },
    };
  }

  /**
   * V√©rifie si une bride est tendue
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @returns true si tendue
   */
  isBridleTaut(side: 'left' | 'right', position: 'nez' | 'inter' | 'centre'): boolean {
    const bridleMap = {
      left: { nez: this.leftNez, inter: this.leftInter, centre: this.leftCentre },
      right: { nez: this.rightNez, inter: this.rightInter, centre: this.rightCentre },
    };

    return bridleMap[side][position].isTaut();
  }

  /**
   * Obtient des statistiques sur l'√©tat des brides
   * (utile pour debug/monitoring)
   */
  getStats(): {
    tautCount: number;
    avgTension: number;
    maxTension: number;
    minTension: number;
  } {
    const bridles = [
      this.leftNez,
      this.leftInter,
      this.leftCentre,
      this.rightNez,
      this.rightInter,
      this.rightCentre,
    ];

    const tautCount = bridles.filter(b => b.isTaut()).length;
    const tensions = bridles.map(b => b.getCurrentTension());
    const avgTension = tensions.reduce((sum, t) => sum + t, 0) / tensions.length;
    const maxTension = Math.max(...tensions);
    const minTension = Math.min(...tensions);

    return { tautCount, avgTension, maxTension, minTension };
  }
}


=== simulation/physics/ConstraintSolver.ts ===

/**
 * ConstraintSolver.ts - Solveur de contraintes pour les lignes du cerf-volant
 *
 * R√¥le :
 *   - Applique les contraintes de distance sur les lignes via l'algorithme Position-Based Dynamics (PBD)
 *   - Garantit la stabilit√© g√©om√©trique du kite et le respect des longueurs de ligne
 *   - Permet la rotation naturelle et le d√©crochage du kite
 *
 * D√©pendances principales :
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et points du cerf-volant
 *   - PhysicsConstants.ts : Constantes physiques pour la tol√©rance et la gestion des contraintes
 *   - SimulationConfig.ts : Param√®tres de configuration
 *   - Types : Utilise HandlePositions pour typer les poign√©es
 *
 * Relation avec les fichiers adjacents :
 *   - LineSystem.ts : Utilise ConstraintSolver pour appliquer les contraintes sur les lignes
 *   - PhysicsEngine.ts : Orchestration de l'appel au solveur
 *
 * Utilisation typique :
 *   - Appel√© par LineSystem ou PhysicsEngine pour maintenir la contrainte de distance
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/Kite";
import { HandlePositions } from "../types";
import { BridleLengths } from "../types/BridleTypes";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Interface d√©crivant la sph√®re de vol du kite
 *
 * PRINCIPE FONDAMENTAL :
 * Le kite √©volue sur une sph√®re de rayon R = L_lignes + L_brides
 * Cette sph√®re d√©finit la "fen√™tre de vol" (wind window) avec :
 * - √âquateur : Zone de puissance maximale (surfaces ‚ä• vent)
 * - Z√©nith : Zone de puissance minimale (surfaces ‚à• vent)
 * - Le kite se d√©place tangentiellement sur cette sph√®re
 */
export interface FlightSphere {
  /** Centre de la sph√®re (position du pilote/barre) */
  center: THREE.Vector3;
  /** Rayon = longueur_lignes + longueur_bridles (principe fondamental) */
  radius: number;
  /** Position actuelle du kite sur la sph√®re */
  kitePosition: THREE.Vector3;
  /** Distance actuelle du centre √† la position du kite */
  currentDistance: number;
  /** Facteur de tension (0 = compl√®tement rel√¢ch√©, 1 = tendu) */
  tensionFactor: number;

  // === G√âOM√âTRIE DE LA FEN√äTRE DE VOL ===
  /** Position du z√©nith (sommet de la sph√®re) : center + (0, radius, 0) */
  zenithPosition: THREE.Vector3;
  /** Distance actuelle au z√©nith (0 = au z√©nith, 2*radius = oppos√©) */
  distanceToZenith: number;
  /** Facteur de puissance (0 = z√©nith/puissance min, 1 = √©quateur/puissance max) */
  powerFactor: number;

  // === DIRECTION DU VENT ===
  /** Direction du vent (normalis√©e) */
  windDirection: THREE.Vector3;
  /** Angle entre kite et direction vent (0¬∞ = face au vent, 180¬∞ = dos au vent) */
  windAngleDeg: number;

  // === ZONES DE LA FEN√äTRE ===
  /** Zone actuelle : 'zenith' | 'power' | 'edge' | 'transition' */
  currentZone: 'zenith' | 'power' | 'edge' | 'transition';
}

/**
 * Solveur de contraintes pour les lignes et brides du cerf-volant
 *
 * Impl√©mente l'algorithme Position-Based Dynamics (PBD) pour maintenir
 * les contraintes g√©om√©triques selon les principes physiques d√©crits :
 *
 * SPH√àRE DE VOL : R = longueur_lignes + longueur_bridles
 * - Le kite √©volue sur la surface d'une sph√®re centr√©e sur le pilote
 * - Toute force a√©rodynamique lat√©rale produit un d√©placement tangentiel
 * - Les contraintes radiales sont satisfaites g√©om√©triquement
 *
 * POINT D'√âQUILIBRE Z√âNITH :
 * - Quand la barre est rel√¢ch√©e, le kite tend vers le z√©nith
 * - Position de stabilit√© relative avec traction minimale
 *
 * M√âCANISME DE DIRECTION :
 * - Asym√©trie des lignes produit un couple a√©rodynamique
 * - Modification diff√©rentielle de longueur effective des lignes
 * - Twist de l'aile ‚Üí changement d'angle d'attaque ‚Üí rotation
 */
export class ConstraintSolver {
  /**
   * Calcule la sph√®re de vol du kite selon le principe fondamental
   * R = longueur_lignes + longueur_bridles
   *
   * ENRICHISSEMENT :
   * - Calcule la position du z√©nith
   * - D√©termine la zone actuelle (zenith, power, edge, transition)
   * - Calcule le facteur de puissance (fonction de la hauteur)
   * - Analyse l'angle avec le vent
   *
   * @param kite - Instance du kite
   * @param pilotPosition - Position du pilote/barre de contr√¥le
   * @param windDirection - Direction du vent (optionnel, d√©faut = vent arri√®re selon +Z)
   * @returns Description compl√®te de la sph√®re de vol avec zones de puissance
   */
  /**
   * Int√®gre la contrainte de sph√®re de vol (PHYSICS_MODEL.md ¬ß2)
   * - Le kite √©volue sur une sph√®re de rayon R = longueur_lignes + longueur_bridles
   * - La position du kite est contrainte √† la surface de cette sph√®re lorsque les lignes sont tendues
   * - Permet le d√©placement tangentiel et la gestion des zones de puissance/z√©nith
   */
  static calculateFlightSphere(
    kite: Kite,
    pilotPosition: THREE.Vector3,
    windDirection?: THREE.Vector3
  ): FlightSphere {
    const lineLength = kite.userData.lineLength || CONFIG.lines.defaultLength;

    // Calculer la longueur totale des brides (moyenne des 3 paires)
    const bridleLengths = kite.getBridleLengths();
    const avgBridleLength = (bridleLengths.nez + bridleLengths.inter + bridleLengths.centre) / 3;

    // SPH√àRE DE VOL : R = longueur_lignes + longueur_bridles (principe fondamental)
    const sphereRadius = lineLength + avgBridleLength;

    // Position actuelle du kite
    const kitePosition = kite.position.clone();
    const currentDistance = kitePosition.distanceTo(pilotPosition);

    // Facteur de tension (0 = rel√¢ch√©, 1 = tendu contre la sph√®re)
    const tensionFactor = Math.min(currentDistance / sphereRadius, 1);

    // === G√âOM√âTRIE DE LA FEN√äTRE DE VOL ===

    // Position du z√©nith (sommet de la sph√®re)
    const zenithPosition = pilotPosition.clone().add(new THREE.Vector3(0, sphereRadius, 0));

    // Distance au z√©nith
    const distanceToZenith = kitePosition.distanceTo(zenithPosition);

    // Facteur de puissance bas√© sur la hauteur relative
    // powerFactor = 0 au z√©nith (y = radius), = 1 √† l'√©quateur (y = 0)
    const relativeHeight = (kitePosition.y - pilotPosition.y) / sphereRadius;
    const powerFactor = Math.max(0, Math.min(1, 1 - relativeHeight));

    // === DIRECTION DU VENT ===

    // Direction du vent (par d√©faut : vent arri√®re selon +Z si non fourni)
    const windDir = windDirection
      ? windDirection.clone().normalize()
      : new THREE.Vector3(0, 0, 1);

    // Vecteur du pilote vers le kite
    const pilotToKite = kitePosition.clone().sub(pilotPosition).normalize();

    // Angle entre kite et vent (produit scalaire)
    const windDot = pilotToKite.dot(windDir);
    const windAngleDeg = Math.acos(Math.max(-1, Math.min(1, windDot))) * (180 / Math.PI);

    // === ZONES DE LA FEN√äTRE ===

    let currentZone: 'zenith' | 'power' | 'edge' | 'transition';

    // Crit√®res de classification :
    // - Zenith : hauteur > 80% du rayon ET distance au z√©nith < 20% du rayon
    // - Power : hauteur entre 20% et 60% (zone √©quatoriale)
    // - Edge : bords lat√©raux (angle vent > 60¬∞)
    // - Transition : entre power et zenith

    if (relativeHeight > 0.8 && distanceToZenith < sphereRadius * 0.3) {
      currentZone = 'zenith';
    } else if (relativeHeight < 0.6 && relativeHeight > 0.2) {
      currentZone = 'power';
    } else if (windAngleDeg > 60 && windAngleDeg < 120) {
      currentZone = 'edge';
    } else {
      currentZone = 'transition';
    }

    return {
      center: pilotPosition.clone(),
      radius: sphereRadius,
      kitePosition,
      currentDistance,
      tensionFactor,
      zenithPosition,
      distanceToZenith,
      powerFactor,
      windDirection: windDir,
      windAngleDeg,
      currentZone
    };
  }

  /**
   * Applique le comportement de point d'√©quilibre z√©nith
   * Quand la barre est rel√¢ch√©e, le kite tend naturellement vers le z√©nith
   *
   * @param kite - Instance du kite
   * @param predictedPosition - Position pr√©dite avant contraintes
   * @param barRotation - Rotation actuelle de la barre (-1 √† 1)
   * @param flightSphere - Sph√®re de vol calcul√©e
   * @returns Nouvelle position pr√©dite avec tendance z√©nith
   */
  static applyZenithEquilibrium(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    barRotation: number,
    flightSphere: FlightSphere
  ): THREE.Vector3 {
    // Si la barre est quasi-neutre (¬±10%), appliquer la tendance z√©nith
    if (Math.abs(barRotation) < 0.1) {
      const zenithDirection = new THREE.Vector3(0, 1, 0); // Direction verticale
      const kiteToCenter = flightSphere.center.clone().sub(predictedPosition);

      // Projeter la direction vers le centre sur le plan horizontal
      const horizontalComponent = kiteToCenter.clone();
      horizontalComponent.y = 0;
      horizontalComponent.normalize();

      // M√©langer direction z√©nith et direction g√©om√©trique naturelle
      // Plus on est proche du z√©nith, plus la tendance est forte
      const zenithFactor = 1 - Math.abs(predictedPosition.y - flightSphere.center.y) / flightSphere.radius;
      const zenithInfluence = Math.max(0, zenithFactor * 0.3); // Max 30% d'influence

      const finalDirection = zenithDirection.clone()
        .multiplyScalar(zenithInfluence)
        .add(horizontalComponent.multiplyScalar(1 - zenithInfluence))
        .normalize();

      // Ajuster l√©g√®rement la position pr√©dite vers le z√©nith
      const adjustment = finalDirection.multiplyScalar(flightSphere.radius * 0.02); // 2% du rayon
      predictedPosition.add(adjustment);
    }

    return predictedPosition;
  }
  /**
   * Applique les contraintes des lignes - Solver PBD (Position-Based Dynamics)
   * Impl√©mente le concept de SPH√àRE DE VOL : R = longueur_lignes + longueur_bridles
   *
   * PRINCIPE PHYSIQUE FONDAMENTAL :
   * - Les lignes d√©finissent une sph√®re de rayon R autour du pilote
   * - Le kite est constamment pouss√© contre cette sph√®re par le vent
   * - Toute force a√©rodynamique lat√©rale se traduit par un d√©placement tangentiel
   * - Le kite "glisse" sur la surface de la sph√®re (pas de mouvement radial)
   */
  static enforceLineConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    handles: HandlePositions
  ): void {
    // PRINCIPE PHYSIQUE FONDAMENTAL - Sph√®re de Vol :
    // R = longueur_lignes + longueur_bridles (somme des contraintes g√©om√©triques)
    // Le cerf-volant est constamment plaqu√© contre cette sph√®re par la pression du vent
    // Toute force a√©rodynamique lat√©rale se traduit par un d√©placement tangentiel
    // sur la surface de la sph√®re (pas de mouvement radial = lignes tendues)
    // C'est quand il sort de cette sph√®re qu'il "d√©croche"

    const lineLength =
      kite.userData.lineLength || CONFIG.lines.defaultLength;
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) return;

    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // R√©solution PBD pour chaque ligne
    const solveLine = (ctrlLocal: THREE.Vector3, handle: THREE.Vector3) => {
      // Utiliser position pr√©dite pour transformation locale‚Üímonde
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const cpWorld = kite.toWorldCoordinates(ctrlLocal);
      kite.position.copy(originalPos);
      const diff = cpWorld.clone().sub(handle);
      const dist = diff.length();

  // Tol√©rance PBD: √©viter de "raccourcir" la longueur cible.
  // Fix bug critique: ne pas soustraire la tol√©rance de la longueur.
  if (dist <= lineLength) return; // Ligne molle (aucune correction)

      const n = diff.clone().normalize();
      const C = dist - lineLength;

      const r = cpWorld.clone().sub(predictedPosition);
      const alpha = new THREE.Vector3().crossVectors(r, n);
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);
      const denom = invMass + alpha.lengthSq() * invInertia;
      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections
      const dPos = n.clone().multiplyScalar(-invMass * lambda);
      predictedPosition.add(dPos);

      const dTheta = alpha.clone().multiplyScalar(-invInertia * lambda);
      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse
      kite.position.copy(predictedPosition);
      const cpWorld2 = kite.toWorldCoordinates(ctrlLocal);
      kite.position.copy(originalPos);
      const n2 = cpWorld2.clone().sub(handle).normalize();
      const r2 = cpWorld2.clone().sub(predictedPosition);
      const pointVel = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, r2));
      const radialSpeed = pointVel.dot(n2);

      if (radialSpeed > 0) {
        const rxn = new THREE.Vector3().crossVectors(r2, n2);
        const eff = invMass + rxn.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        state.velocity.add(n2.clone().multiplyScalar(J * invMass));
        const angImpulse = new THREE.Vector3().crossVectors(
          r2,
          n2.clone().multiplyScalar(J)
        );
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Plusieurs passes pour mieux satisfaire les contraintes
    for (let i = 0; i < PhysicsConstants.CONSTRAINT_ITERATIONS; i++) {
      solveLine(ctrlLeft, handles.left);
      solveLine(ctrlRight, handles.right);
    }
  }

  /**
   * Applique les contraintes des brides - Solver PBD (Position-Based Dynamics)
   * 
   * Les brides sont des contraintes INTERNES au kite qui relient :
   * - NEZ ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * - INTER_GAUCHE ‚Üí CTRL_GAUCHE
   * - INTER_DROIT ‚Üí CTRL_DROIT
   * - CENTRE ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * 
   * Contrairement aux lignes principales (kite ‚Üî pilote), les brides lient
   * des points du M√äME objet (le kite). Elles d√©finissent la forme et rigidit√©
   * interne du cerf-volant.
   */
  static enforceBridleConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    bridleLengths: BridleLengths
  ): void {
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;
    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // D√©finition des 6 brides (3 par c√¥t√©)
    const bridles = [
      // Brides gauches
      { start: "NEZ", end: "CTRL_GAUCHE", length: bridleLengths.nez },
      { start: "INTER_GAUCHE", end: "CTRL_GAUCHE", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_GAUCHE", length: bridleLengths.centre },
      // Brides droites
      { start: "NEZ", end: "CTRL_DROIT", length: bridleLengths.nez },
      { start: "INTER_DROIT", end: "CTRL_DROIT", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_DROIT", length: bridleLengths.centre },
    ];

    // R√©solution PBD pour chaque bride
    const solveBridle = (
      startName: string,
      endName: string,
      bridleLength: number
    ) => {
      const startLocal = kite.getPoint(startName);
      const endLocal = kite.getPoint(endName);

      if (!startLocal || !endLocal) {
        console.warn(`‚ö†Ô∏è Points bride introuvables: ${startName} ou ${endName}`);
        return;
      }

      // Convertir points locaux en coordonn√©es monde (avec position pr√©dite)
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const startWorld = kite.toWorldCoordinates(startLocal);
      const endWorld = kite.toWorldCoordinates(endLocal);
      kite.position.copy(originalPos);

      // Calculer distance actuelle
      const diff = endWorld.clone().sub(startWorld);
      const dist = diff.length();

  // Si bride molle, pas de contrainte
  // M√™me principe que pour les lignes: ne pas soustraire la tol√©rance
  if (dist <= bridleLength) return;

      // Direction de contrainte (normalis√©e)
      const n = diff.clone().normalize();

      // Violation de contrainte C = distance - longueur_bride
      const C = dist - bridleLength;

      // Calcul des bras de levier pour rotation
      const rStart = startWorld.clone().sub(predictedPosition);
      const rEnd = endWorld.clone().sub(predictedPosition);

      // Moments angulaires
      const alphaStart = new THREE.Vector3().crossVectors(rStart, n);
      const alphaEnd = new THREE.Vector3().crossVectors(rEnd, n.clone().negate());

      // Inverse masses
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);

      // D√©nominateur pour lambda (inclut rotation)
      // Les deux points appartiennent au m√™me corps rigide, donc contribution double
      const denom =
        2 * invMass +
        alphaStart.lengthSq() * invInertia +
        alphaEnd.lengthSq() * invInertia;

      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections de position
      // Point start : pouss√© dans direction -n
      const dPosStart = n.clone().multiplyScalar(-invMass * lambda);
      // Point end : pouss√© dans direction +n
      const dPosEnd = n.clone().multiplyScalar(invMass * lambda);

      // Correction nette de position (moyenne)
      const dPos = dPosStart.clone().add(dPosEnd).multiplyScalar(0.5);
      predictedPosition.add(dPos);

      // Correction de rotation (moyenne des deux contributions)
      const dThetaStart = alphaStart.clone().multiplyScalar(-invInertia * lambda);
      const dThetaEnd = alphaEnd.clone().multiplyScalar(-invInertia * lambda);
      const dTheta = dThetaStart.clone().add(dThetaEnd).multiplyScalar(0.5);

      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse (dampening)
      kite.position.copy(predictedPosition);
      const startWorld2 = kite.toWorldCoordinates(startLocal);
      const endWorld2 = kite.toWorldCoordinates(endLocal);
      kite.position.copy(originalPos);

      const n2 = endWorld2.clone().sub(startWorld2).normalize();
      const rStart2 = startWorld2.clone().sub(predictedPosition);
      const rEnd2 = endWorld2.clone().sub(predictedPosition);

      // Vitesses des points
      const velStart = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rStart2));
      const velEnd = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rEnd2));

      // Vitesse relative le long de la bride
      const relVel = velEnd.clone().sub(velStart);
      const radialSpeed = relVel.dot(n2);

      // Si les points s'√©loignent, appliquer correction de vitesse
      if (radialSpeed > 0) {
        const rxnStart = new THREE.Vector3().crossVectors(rStart2, n2);
        const rxnEnd = new THREE.Vector3().crossVectors(rEnd2, n2.clone().negate());
        const eff =
          2 * invMass + rxnStart.lengthSq() * invInertia + rxnEnd.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        // Correction vitesse lin√©aire
        state.velocity.add(n2.clone().multiplyScalar(J * invMass));

        // Correction vitesse angulaire (moyenne des deux contributions)
        const angImpulseStart = new THREE.Vector3().crossVectors(
          rStart2,
          n2.clone().multiplyScalar(J)
        );
        const angImpulseEnd = new THREE.Vector3().crossVectors(
          rEnd2,
          n2.clone().multiplyScalar(-J)
        );
        const angImpulse = angImpulseStart.clone().add(angImpulseEnd).multiplyScalar(0.5);
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // R√©soudre toutes les brides (1 passe suffit g√©n√©ralement)
    // Les brides sont courtes et rigides, convergence rapide
    bridles.forEach(({ start, end, length }) => {
      solveBridle(start, end, length);
    });
  }

  /**
   * G√®re la collision avec le sol
   */
  static handleGroundCollision(
    kite: Kite,
    newPosition: THREE.Vector3,
    velocity: THREE.Vector3
  ): void {
    const groundY = CONFIG.kite.minHeight;
    const pointsMap = kite.getPointsMap?.() as
      | Map<string, [number, number, number]>
      | undefined;

    if (pointsMap && pointsMap.size > 0) {
      let minY = Infinity;
      const q = kite.quaternion;

      pointsMap.forEach(([px, py, pz]) => {
        const world = new THREE.Vector3(px, py, pz)
          .applyQuaternion(q)
          .add(newPosition);
        if (world.y < minY) minY = world.y;
      });

      if (minY < groundY) {
        const lift = groundY - minY;
        newPosition.y += lift;

        if (velocity.y < 0) velocity.y = 0;
        velocity.x *= PhysicsConstants.GROUND_FRICTION;
        velocity.z *= PhysicsConstants.GROUND_FRICTION;
      }
      return;
    }

    // Fallback simple
    if (newPosition.y < groundY) {
      newPosition.y = groundY;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x *= PhysicsConstants.GROUND_FRICTION;
      velocity.z *= PhysicsConstants.GROUND_FRICTION;
    }
  }
}

=== simulation/physics/LinePhysics.ts ===

/**
 * LinePhysics.ts - Service de calculs physiques pour les lignes de cerf-volant
 *
 * R√¥le :
 *   - Calculer les forces de tension dans une ligne (mod√®le Dyneema r√©aliste)
 *   - Appliquer pr√©-tension, √©lasticit√© lin√©aire et damping
 *   - Calculer l'affaissement cat√©naire pour le rendu
 *
 * Responsabilit√© :
 *   - Physique pure : F = F‚ÇÄ + k√óŒîx - c√óv_radial
 *   - Pas de gestion d'√©tat (stateless)
 *   - Pas de d√©pendance Three.js (calculs vectoriels purs)
 *
 * Mod√®le Physique :
 *   - Lignes haute performance (Dyneema/Spectra)
 *   - √âlasticit√© ~2-3%, rigidit√© EA/L ‚âà 2200 N/m pour 15m
 *   - Toujours pr√©-tendues (50-100N minimum)
 *   - Damping interne (dissipation d'√©nergie)
 *
 * Relation avec les autres modules :
 *   - Op√®re sur des objets Line
 *   - Appel√© par LineSystem pour calculer forces
 *   - Pas de d√©pendance sur la sc√®ne 3D
 *
 * Philosophie :
 *   - Pure function : Entr√©es ‚Üí Sorties, pas d'effet de bord
 *   - Testable unitairement (pas de mock Three.js requis)
 *   - Single Responsibility : Calculs physiques uniquement
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts (entit√© m√©tier)
 *   - docs/LINE_PHYSICS_AUDIT_2025-10-01.md (r√©f√©rences physiques)
 */

import { Vector3 } from 'three';

import { PhysicsConstants } from '../config/PhysicsConstants';

import { Line } from '@/objects/Line';


/**
 * R√©sultat d'un calcul de force de tension
 */
export interface TensionResult {
  /** Force vectorielle √† appliquer (N) */
  force: Vector3;

  /** Magnitude de la tension (N) */
  tension: number;

  /** Extension actuelle (m) */
  extension: number;

  /** Longueur actuelle (m) */
  currentLength: number;

  /** Ligne tendue ou molle */
  isTaut: boolean;
}

/**
 * Service de calculs physiques pour lignes de cerf-volant
 *
 * @example
 * ```typescript
 * const physics = new LinePhysics();
 * const result = physics.calculateTensionForce(
 *   line,
 *   new Vector3(0, 10, 0),  // Position kite
 *   new Vector3(0, 0, 0),   // Position poign√©e
 *   new Vector3(0, -1, 0)   // Vitesse relative
 * );
 * console.log(`Tension: ${result.tension}N`);
 * ```
 */
export class LinePhysics {
  /** Constante gravitationnelle (m/s¬≤) */
  private static readonly GRAVITY = 9.81;

  /** Epsilon fin pour calculs de pr√©cision (r√©utilise PhysicsConstants) */
  private static readonly EPSILON = PhysicsConstants.EPSILON_FINE;

  /**
   * Calcule la force de tension dans une ligne
   *
   * Mod√®le : F = F‚ÇÄ + k√óŒîx - c√óv_radial
   * - F‚ÇÄ : Pr√©-tension minimale (toujours pr√©sente)
   * - k√óŒîx : Composante √©lastique (si ligne tendue)
   * - c√óv_radial : Damping (dissipation d'√©nergie)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position point d'attache d√©part (kite ou barre)
   * @param endPos - Position point d'attache arriv√©e (barre ou kite)
   * @param relativeVelocity - Vitesse relative entre les deux points (pour damping)
   * @returns R√©sultat du calcul (force, tension, extension)
   */
  calculateTensionForce(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    relativeVelocity: Vector3 = new Vector3()
  ): TensionResult {
    // Vecteur ligne et direction
    const lineVector = new Vector3().subVectors(endPos, startPos);
    const currentLength = lineVector.length();

    // √âviter division par z√©ro
    if (currentLength < LinePhysics.EPSILON) {
      return {
        force: new Vector3(),
        tension: 0,
        extension: 0,
        currentLength: 0,
        isTaut: false
      };
    }

    const lineDir = lineVector.clone().normalize();
    const restLength = line.config.length;

    // 1. Composante √©lastique : F_elastic = F‚ÇÄ + k√óŒîx
    let elasticTension: number;
    let extension: number;
    let isTaut: boolean;

    if (currentLength > restLength) {
      // Ligne tendue : ajouter force √©lastique √† la pr√©-tension
      extension = currentLength - restLength;
      elasticTension = line.config.preTension + line.config.stiffness * extension;
      isTaut = true;
    } else {
      // Ligne molle : maintenir pr√©-tension minimale
      extension = 0;
      elasticTension = line.config.preTension;
      isTaut = false;
    }

    // 2. Composante de damping : F_damp = -c √ó v_along_line
    const velocityAlongLine = relativeVelocity.dot(lineDir);
    const dampingTension = -line.config.dampingCoeff * velocityAlongLine;

    // 3. Tension totale (limit√©e par maxTension)
    const totalTension = Math.min(
      Math.max(elasticTension + dampingTension, 0), // Jamais n√©gative
      line.config.maxTension
    );

    // 4. Force vectorielle
    const force = lineDir.clone().multiplyScalar(totalTension);

    return {
      force,
      tension: totalTension,
      extension,
      currentLength,
      isTaut
    };
  }

  /**
   * Calcule l'affaissement cat√©naire r√©el pour une ligne horizontale
   *
   * Formule simplifi√©e : sag = (œÅ √ó g √ó L¬≤) / (8 √ó T)
   * o√π :
   * - œÅ : masse lin√©ique (kg/m)
   * - g : gravit√© (9.81 m/s¬≤)
   * - L : longueur ligne (m)
   * - T : tension (N)
   *
   * @param line - Ligne √† analyser
   * @param tension - Tension actuelle (N)
   * @returns Affaissement vertical au centre (m)
   *
   * @example
   * ```typescript
   * const sag = physics.calculateCatenarySag(line, 100);
   * console.log(`Sag: ${sag * 1000}mm`); // ~1.4mm pour Dyneema 15m @ 100N
   * ```
   */
  calculateCatenarySag(line: Line, tension: number): number {
    if (tension < LinePhysics.EPSILON) {
      return 0; // Pas de tension = pas d'affaissement d√©fini
    }

    const rho = line.config.linearMassDensity;
    const L = line.config.length;

    // Formule cat√©naire simplifi√©e (ligne horizontale)
    const sag = (rho * LinePhysics.GRAVITY * L * L) / (8 * tension);

    return Math.max(0, sag); // Toujours positif
  }

  /**
   * Calcule les points d'une vraie cat√©naire pour le rendu
   *
   * √âquation compl√®te : y(x) = a √ó cosh(x/a) - a
   * o√π a = T / (œÅ √ó g)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position d√©part
   * @param endPos - Position arriv√©e
   * @param tension - Tension actuelle (N)
   * @param segments - Nombre de segments pour la courbe
   * @returns Tableau de points 3D formant la cat√©naire
   *
   * @remarks
   * Pour lignes tr√®s tendues (T > 100N), la cat√©naire est quasi-lin√©aire
   * Pour lignes molles (T < 50N), l'affaissement devient visible
   */
  calculateCatenaryPoints(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    tension: number,
    segments: number = 10
  ): Vector3[] {
    const directDistance = startPos.distanceTo(endPos);

    // Si ligne tendue ou tr√®s courte, approximation lin√©aire suffit
    if (directDistance >= line.config.length * 0.98 || tension > 100) {
      return [startPos.clone(), endPos.clone()];
    }

    // Param√®tre de la cat√©naire : a = T / (œÅ √ó g)
    const rho = line.config.linearMassDensity;
    tension / (rho * LinePhysics.GRAVITY);

    // Calcul sag maximal
    const sag = this.calculateCatenarySag(line, tension);

    const points: Vector3[] = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Position lin√©aire interpol√©e
      const point = new Vector3().lerpVectors(startPos, endPos, t);

      // Ajout de l'affaissement en Y (forme parabolique simplifi√©e)
      // Pour un vrai cosh, il faudrait transformer en coordonn√©es locales
      point.y -= sag * 4 * t * (1 - t); // Maximum au centre (t=0.5)

      points.push(point);
    }

    return points;
  }

  /**
   * Calcule l'√©nergie √©lastique stock√©e dans une ligne
   *
   * E = ¬Ω √ó k √ó Œîx¬≤
   *
   * @param line - Ligne √† analyser
   * @returns √ânergie en Joules
   */
  calculateElasticEnergy(line: Line): number {
    const extension = line.getExtension();
    return 0.5 * line.config.stiffness * extension * extension;
  }

  /**
   * Estime la fr√©quence propre d'oscillation de la ligne
   *
   * f ‚âà (1/2œÄ) √ó ‚àö(k/m_effective)
   *
   * @param line - Ligne √† analyser
   * @param attachedMass - Masse attach√©e au bout (kg)
   * @returns Fr√©quence en Hz
   */
  calculateNaturalFrequency(line: Line, attachedMass: number): number {
    if (attachedMass < LinePhysics.EPSILON) {
      return 0;
    }

    // Masse effective de la ligne (1/3 de la masse totale)
    const lineMass = line.config.linearMassDensity * line.config.length;
    const effectiveMass = attachedMass + lineMass / 3;

    const omega = Math.sqrt(line.config.stiffness / effectiveMass);
    const frequency = omega / (2 * Math.PI);

    return frequency;
  }

  /**
   * V√©rifie si la ligne est dans un √©tat physique valide
   *
   * @param line - Ligne √† valider
   * @returns true si valide, false sinon
   */
  validateLine(line: Line): boolean {
    const config = line.config;

    return (
      config.length > 0 &&
      config.stiffness > 0 &&
      config.preTension >= 0 &&
      config.maxTension > config.preTension &&
      config.dampingCoeff >= 0 &&
      config.dampingCoeff <= 1 &&
      config.linearMassDensity > 0
    );
  }
}


=== simulation/physics/LineSystem.ts ===

/**
 * LineSystem.ts - Orchestrateur du syst√®me de lignes du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les lignes gauche/droite du syst√®me de pilotage
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les lignes sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT le kite (distance max)
 *   - Elles ne TIRENT PAS le kite vers le pilote
 *   - Le ConstraintSolver.enforceLineConstraints() g√®re la contrainte g√©om√©trique
 */
import * as THREE from "three";
import { LineFactory } from "@factories/LineFactory";


import { PhysicsConstants } from "../config/PhysicsConstants";
import { HandlePositions } from "../types";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

import { Kite } from "@/objects/Kite";
import { Line } from "@/objects/Line";

export class LineSystem {
  private leftLine: Line;
  private rightLine: Line;
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(lineLength?: number) {
    const [left, right] = LineFactory.createLinePair(lineLength);
    this.leftLine = left;
    this.rightLine = right;
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  calculateLineTensions(
    kite: Kite,
    handles: HandlePositions,
    deltaTime: number
  ): {
    leftForce: THREE.Vector3;
    rightForce: THREE.Vector3;
    torque: THREE.Vector3;
  } {
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) {
      return {
        leftForce: new THREE.Vector3(),
        rightForce: new THREE.Vector3(),
        torque: new THREE.Vector3(),
      };
    }

    const leftWorld = kite.toWorldCoordinates(ctrlLeft);
    const rightWorld = kite.toWorldCoordinates(ctrlRight);

    const step = Math.max(deltaTime, 1 / 240); // √©vite z√©ro, affine les vitesses

    // Calculer v√©locit√©s relatives avec VelocityCalculator
    const leftVelocity = this.velocityCalculator.calculateRelative(
      "leftKite", "leftBar",
      leftWorld, handles.left,
      step
    );
    const rightVelocity = this.velocityCalculator.calculateRelative(
      "rightKite", "rightBar",
      rightWorld, handles.right,
      step
    );

    // Calculer tensions pour info/debug uniquement (pas de force appliqu√©e)
    const leftResult = this.physics.calculateTensionForce(this.leftLine, leftWorld, handles.left, leftVelocity);
    const rightResult = this.physics.calculateTensionForce(this.rightLine, rightWorld, handles.right, rightVelocity);

    // Mettre √† jour l'√©tat des lignes (pour affichage)
    this.leftLine.updateState(leftResult.currentLength, leftResult.tension, performance.now());
    this.rightLine.updateState(rightResult.currentLength, rightResult.tension, performance.now());

    // ‚ö†Ô∏è IMPORTANT : PAS DE FORCES NI DE COUPLE APPLIQU√âS
    // Les lignes sont des contraintes g√©om√©triques (ConstraintSolver)
    // Le kite est retenu √† distance max, pas tir√© vers le pilote
    return {
      leftForce: new THREE.Vector3(), // Force nulle
      rightForce: new THREE.Vector3(), // Force nulle
      torque: new THREE.Vector3(), // Couple nul
    };
  }

  calculateCatenary(
    start: THREE.Vector3,
    end: THREE.Vector3,
    segments: number = PhysicsConstants.CATENARY_SEGMENTS,
    side: 'left' | 'right' = 'left'
  ): THREE.Vector3[] {
    const line = side === 'left' ? this.leftLine : this.rightLine;
    const tension = side === 'left'
      ? this.leftLine.getCurrentTension()
      : this.rightLine.getCurrentTension();

    return this.physics.calculateCatenaryPoints(line, start, end, tension, segments);
  }

  setLineLength(length: number): void {
    const [left, right] = LineFactory.createLinePair(length);
    this.leftLine = left;
    this.rightLine = right;
    // R√©initialiser l'historique des v√©locit√©s
    this.velocityCalculator.resetAll();
  }

  get lineLength(): number {
    return this.leftLine.config.length;
  }

  set lineLength(length: number) {
    this.setLineLength(length);
  }

  /**
   * Retourne les tensions actuelles des lignes gauche et droite
   * @returns Objet contenant les tensions en Newtons
   */
  getTensions(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentTension(),
      right: this.rightLine.getCurrentTension()
    };
  }

  /**
   * Retourne les longueurs actuelles des lignes gauche et droite
   * @returns Objet contenant les longueurs en m√®tres
   */
  getDistances(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentLength(),
      right: this.rightLine.getCurrentLength()
    };
  }

  /**
   * Retourne l'√©tat de tension des lignes (tendues ou non)
   * @returns Objet indiquant si chaque ligne est tendue
   */
  getLineStates(): { leftTaut: boolean; rightTaut: boolean } {
    return {
      leftTaut: this.leftLine.isTaut(),
      rightTaut: this.rightLine.isTaut()
    };
  }
}


=== simulation/physics/PhysicsModelValidator.ts ===

/**
 * PhysicsModelValidator.ts - Validateur du mod√®le physique du kite
 *
 * Ce fichier valide que l'impl√©mentation correspond exactement au mod√®le d√©crit dans PHYSICS_MODEL.md
 * Il v√©rifie les comportements √©mergents fondamentaux :
 *
 * 1. Sph√®re de vol contrainte (R = L_lignes + L_bridles)
 * 2. Forces distribu√©es par surface avec coefficients r√©alistes
 * 3. √âquilibre z√©nith naturel (surfaces horizontales ‚Üí pression r√©duite)
 * 4. Direction √©mergente par asym√©trie g√©om√©trique
 * 5. Contraintes PBD respect√©es g√©om√©triquement
 * 6. Collision sol avec rebond et friction
 */

// External libraries
import * as THREE from 'three';

import { Kite } from '../../objects/Kite';
import { CONFIG } from '../config/SimulationConfig';
import { KitePhysicsSystem } from '../systems/KitePhysicsSystem';

import { ConstraintSolver } from './ConstraintSolver';
import { AerodynamicsCalculator } from './AerodynamicsCalculator';

export interface ValidationMetrics {
  // Sph√®re de vol
  flightSphereRadius: number;
  tensionFactor: number;
  distanceToPilot: number;

  // √âquilibre z√©nith
  isAtZenith: boolean;
  zenithEquilibrium: boolean;
  pressureAtZenith: number;

  // Direction √©mergente
  asymmetryPercent: number;
  turningForce: THREE.Vector3;

  // Contraintes PBD
  lineConstraintViolation: number;
  bridleConstraintViolation: number;

  // Zones de puissance
  powerFactor: number;
  currentZone: string;

  // Collision sol
  groundCollisionDetected: boolean;
  groundReaction: THREE.Vector3;
}

export interface ValidationResult {
  success: boolean;
  metrics: ValidationMetrics;
  warnings: string[];
  errors: string[];
  recommendations: string[];
}

/**
 * Validateur principal du mod√®le physique
 */
export class PhysicsModelValidator {
  private kite: Kite;
  private physicsSystem: KitePhysicsSystem;
  private validationHistory: ValidationMetrics[] = [];

  constructor(kite: Kite, physicsSystem: KitePhysicsSystem) {
    this.kite = kite;
    this.physicsSystem = physicsSystem;
  }

  /**
   * Valide l'ensemble du mod√®le physique
   */
  validate(): ValidationResult {
    const warnings: string[] = [];
    const errors: string[] = [];
    const recommendations: string[] = [];

    // 1. Validation de la sph√®re de vol
    const sphereValidation = this.validateFlightSphere();
    warnings.push(...sphereValidation.warnings);
    errors.push(...sphereValidation.errors);

    // 2. Validation de l'√©quilibre z√©nith
    const zenithValidation = this.validateZenithEquilibrium();
    warnings.push(...zenithValidation.warnings);
    errors.push(...zenithValidation.errors);

    // 3. Validation des forces distribu√©es
    const forceValidation = this.validateDistributedForces();
    warnings.push(...forceValidation.warnings);
    errors.push(...forceValidation.errors);

    // 4. Validation de la direction √©mergente
    const directionValidation = this.validateEmergentDirection();
    warnings.push(...directionValidation.warnings);
    errors.push(...directionValidation.errors);

    // 5. Validation des contraintes PBD
    const constraintValidation = this.validatePBDConstraints();
    warnings.push(...constraintValidation.warnings);
    errors.push(...constraintValidation.errors);

    // 6. Validation collision sol
    const collisionValidation = this.validateGroundCollision();
    warnings.push(...collisionValidation.warnings);
    errors.push(...collisionValidation.errors);

    // G√©n√©rer les m√©triques compl√®tes
    const metrics = this.computeValidationMetrics();

    // Analyser les tendances
    this.analyzeTrends(metrics);

    // G√©n√©rer recommandations
    recommendations.push(...this.generateRecommendations(metrics));

    const success = errors.length === 0;

    return {
      success,
      metrics,
      warnings,
      errors,
      recommendations
    };
  }

  /**
   * Valide la sph√®re de vol contrainte
   */
  private validateFlightSphere(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = new THREE.Vector3(CONFIG.pilot.position.x, CONFIG.pilot.position.y + CONFIG.controlBar.offsetY, CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ);
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    // V√©rifier le rayon de la sph√®re
    const expectedRadius = CONFIG.lines.defaultLength + 0.65; // L_lignes + L_bride_moyenne
    const radiusError = Math.abs(flightSphere.radius - expectedRadius);

    if (radiusError > 0.1) {
      errors.push(`Rayon sph√®re invalide: ${flightSphere.radius.toFixed(2)}m (attendu: ${expectedRadius.toFixed(2)}m)`);
    }

    // V√©rifier la contrainte de distance
    if (flightSphere.currentDistance > flightSphere.radius + 0.5) {
      errors.push(`Kite sorti de la sph√®re: ${flightSphere.currentDistance.toFixed(2)}m > ${flightSphere.radius.toFixed(2)}m`);
    }

    // V√©rifier le facteur de tension
    if (flightSphere.tensionFactor > 1.05) {
      warnings.push(`Tension excessive: ${flightSphere.tensionFactor.toFixed(2)} (lignes trop tendues)`);
    } else if (flightSphere.tensionFactor < 0.9) {
      warnings.push(`Tension faible: ${flightSphere.tensionFactor.toFixed(2)} (lignes trop molles)`);
    }

    return { warnings, errors };
  }

  /**
   * Valide l'√©quilibre z√©nith
   */
  private validateZenithEquilibrium(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = CONFIG.pilot.position.clone();
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    // V√©rifier si le kite est au z√©nith
    const distanceToZenith = this.kite.position.distanceTo(flightSphere.zenithPosition);
    const isAtZenith = distanceToZenith < flightSphere.radius * 0.3;

    // Calculer la pression a√©rodynamique au z√©nith
    const apparentWind = new THREE.Vector3(0, 0, 20); // Vent nominal
    const zenithOrientation = new THREE.Quaternion(); // Orientation horizontale
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      zenithOrientation,
      this.kite.position
    );

    const pressureAtZenith = forces.lift.length() + forces.drag.length();

    // Au z√©nith, la pression devrait √™tre r√©duite (surfaces horizontales)
    if (isAtZenith && pressureAtZenith > 50) {
      warnings.push(`Pression √©lev√©e au z√©nith: ${pressureAtZenith.toFixed(1)}N (attendu < 50N pour surfaces horizontales)`);
    }

    return { warnings, errors };
  }

  /**
   * Valide les forces distribu√©es par surface
   */
  private validateDistributedForces(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const apparentWind = new THREE.Vector3(0, 0, 20); // Vent nominal
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // V√©rifier que les forces sont distribu√©es (pas concentr√©es)
    const surfaceCount = forces.surfaceForces.length;
    if (surfaceCount < 8) {
      errors.push(`Trop peu de surfaces: ${surfaceCount} (attendu ‚â• 8 pour maillage fin)`);
    }

    // V√©rifier la coh√©rence des coefficients a√©rodynamiques
    let totalForce = 0;
    forces.surfaceForces.forEach((surfaceForce, index) => {
      totalForce += surfaceForce.resultant.length();

      // V√©rifier que chaque surface contribue
      if (surfaceForce.resultant.length() < 0.1) {
        warnings.push(`Surface ${index} contribue peu: ${surfaceForce.resultant.length().toFixed(2)}N`);
      }
    });

    // Force totale devrait √™tre significative
    if (totalForce < 10) {
      errors.push(`Force a√©rodynamique totale faible: ${totalForce.toFixed(1)}N`);
    }

    return { warnings, errors };
  }

  /**
   * Valide la direction √©mergente par asym√©trie
   */
  private validateEmergentDirection(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const apparentWind = new THREE.Vector3(0, 0, 20);
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // Calculer l'asym√©trie gauche/droite
    const leftForce = forces.leftForce || new THREE.Vector3();
    const rightForce = forces.rightForce || new THREE.Vector3();

    const leftMag = leftForce.length();
    const rightMag = rightForce.length();
    const asymmetry = Math.abs(leftMag - rightMag);
    const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag) * 100 : 0;

    // L'asym√©trie devrait produire un couple de lacet
    const turningTorque = forces.torque;
    const turningForce = Math.abs(turningTorque.y); // Couple autour de l'axe Y (lacet)

    if (asymmetryPercent < 5) {
      warnings.push(`Asym√©trie faible: ${asymmetryPercent.toFixed(1)}% (direction peu marqu√©e)`);
    }

    if (turningForce < 1) {
      warnings.push(`Couple de lacet faible: ${turningForce.toFixed(2)}N‚ãÖm`);
    }

    return { warnings, errors };
  }

  /**
   * Valide les contraintes PBD
   */
  private validatePBDConstraints(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    const pilotPosition = CONFIG.pilot.position.clone();
    const handles = {
      left: pilotPosition.clone().add(new THREE.Vector3(-0.3, 0, 0)),
      right: pilotPosition.clone().add(new THREE.Vector3(0.3, 0, 0))
    };

    // V√©rifier contraintes des lignes
    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
      const kiteRightWorld = this.kite.toWorldCoordinates(ctrlRight);

      const leftDistance = kiteLeftWorld.distanceTo(handles.left);
      const rightDistance = kiteRightWorld.distanceTo(handles.right);

      const lineLength = CONFIG.lines.defaultLength;
      const leftViolation = Math.abs(leftDistance - lineLength);
      const rightViolation = Math.abs(rightDistance - lineLength);

      if (leftViolation > 0.1) {
        errors.push(`Violation contrainte ligne gauche: ${leftViolation.toFixed(3)}m`);
      }
      if (rightViolation > 0.1) {
        errors.push(`Violation contrainte ligne droite: ${rightViolation.toFixed(3)}m`);
      }
    }

    return { warnings, errors };
  }

  /**
   * Valide la collision avec le sol
   */
  private validateGroundCollision(): { warnings: string[]; errors: string[] } {
    const warnings: string[] = [];
    const errors: string[] = [];

    // V√©rifier si le kite est sous l'altitude minimale
    const groundY = CONFIG.kite.minHeight;
    const hasGroundCollision = this.kite.position.y <= groundY;

    if (hasGroundCollision) {
      warnings.push(`Collision sol d√©tect√©e √† y=${this.kite.position.y.toFixed(2)}m`);
    }

    return { warnings, errors };
  }

  /**
   * Calcule les m√©triques compl√®tes de validation
   */
  private computeValidationMetrics(): ValidationMetrics {
    const pilotPosition = CONFIG.pilot.position.clone();
    const flightSphere = ConstraintSolver.calculateFlightSphere(
      this.kite,
      pilotPosition
    );

    const apparentWind = new THREE.Vector3(0, 0, 20);
    const forces = AerodynamicsCalculator.calculateForces(
      apparentWind,
      this.kite.quaternion,
      this.kite.position
    );

    // M√©triques de la sph√®re
    const distanceToPilot = this.kite.position.distanceTo(pilotPosition);

    // M√©triques de l'√©quilibre z√©nith
    const distanceToZenith = this.kite.position.distanceTo(flightSphere.zenithPosition);
    const isAtZenith = distanceToZenith < flightSphere.radius * 0.3;
    const zenithEquilibrium = Math.abs(flightSphere.powerFactor) < 0.2;
    const pressureAtZenith = forces.lift.length() + forces.drag.length();

    // M√©triques de direction
    const leftMag = (forces.leftForce || new THREE.Vector3()).length();
    const rightMag = (forces.rightForce || new THREE.Vector3()).length();
    const asymmetry = Math.abs(leftMag - rightMag);
    const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag) * 100 : 0;

    // M√©triques des contraintes
    const handles = {
      left: pilotPosition.clone().add(new THREE.Vector3(-0.3, 0, 0)),
      right: pilotPosition.clone().add(new THREE.Vector3(0.3, 0, 0))
    };

    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');
    let lineConstraintViolation = 0;

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
      const leftDistance = kiteLeftWorld.distanceTo(handles.left);
      lineConstraintViolation = Math.abs(leftDistance - CONFIG.lines.defaultLength);
    }

    return {
      flightSphereRadius: flightSphere.radius,
      tensionFactor: flightSphere.tensionFactor,
      distanceToPilot,
      isAtZenith,
      zenithEquilibrium,
      pressureAtZenith,
      asymmetryPercent,
      turningForce: forces.torque,
      lineConstraintViolation,
      bridleConstraintViolation: 0, // √Ä impl√©menter
      powerFactor: flightSphere.powerFactor,
      currentZone: flightSphere.currentZone,
      groundCollisionDetected: this.kite.position.y <= CONFIG.kite.minHeight,
      groundReaction: new THREE.Vector3()
    };
  }

  /**
   * Analyse les tendances sur l'historique
   */
  private analyzeTrends(metrics: ValidationMetrics): void {
    this.validationHistory.push(metrics);

    // Garder seulement les 100 derniers √©chantillons
    if (this.validationHistory.length > 100) {
      this.validationHistory.shift();
    }

    // Analyser la stabilit√©
    if (this.validationHistory.length >= 10) {
      const recentMetrics = this.validationHistory.slice(-10);
      const tensionFactors = recentMetrics.map(m => m.tensionFactor);
      const avgTension = tensionFactors.reduce((a, b) => a + b, 0) / tensionFactors.length;
      const tensionVariance = tensionFactors.reduce((acc, val) => acc + Math.pow(val - avgTension, 2), 0) / tensionFactors.length;

      if (tensionVariance > 0.1) {
        // Tension instable d√©tect√©e - gestion silencieuse
      }
    }
  }

  /**
   * G√©n√®re des recommandations bas√©es sur les m√©triques
   */
  private generateRecommendations(metrics: ValidationMetrics): string[] {
    const recommendations: string[] = [];

    if (metrics.tensionFactor < 0.9) {
      recommendations.push("Augmenter la longueur des lignes ou la vitesse du vent pour tendre les lignes");
    }

    if (metrics.tensionFactor > 1.05) {
      recommendations.push("R√©duire la longueur des lignes ou diminuer la vitesse du vent");
    }

    if (metrics.asymmetryPercent < 5) {
      recommendations.push("V√©rifier l'orientation du kite et la sym√©trie des surfaces");
    }

    if (metrics.pressureAtZenith > 50) {
      recommendations.push("V√©rifier l'orientation au z√©nith - les surfaces devraient √™tre horizontales");
    }

    if (metrics.lineConstraintViolation > 0.1) {
      recommendations.push("V√©rifier l'impl√©mentation PBD - violation de contrainte d√©tect√©e");
    }

    return recommendations;
  }

  /**
   * G√©n√®re un rapport de validation d√©taill√©
   */
  generateReport(): string {
    const result = this.validate();

    let report = '\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n';
    report += '‚ïë üìä RAPPORT DE VALIDATION DU MOD√àLE PHYSIQUE                              ‚ïë\n';
    report += '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n';

    if (result.success) {
      report += '‚úÖ MOD√àLE PHYSIQUE VALID√â AVEC SUCC√àS\n\n';
    } else {
      report += '‚ùå PROBL√àMES D√âTECT√âS DANS LE MOD√àLE PHYSIQUE\n\n';
    }

    // M√©triques principales
    report += 'üìè M√âTRIQUES PRINCIPALES:\n';
    report += `  ‚Ä¢ Rayon sph√®re: ${result.metrics.flightSphereRadius.toFixed(2)}m\n`;
    report += `  ‚Ä¢ Facteur tension: ${result.metrics.tensionFactor.toFixed(2)}\n`;
    report += `  ‚Ä¢ Distance pilote: ${result.metrics.distanceToPilot.toFixed(2)}m\n`;
    report += `  ‚Ä¢ Zone actuelle: ${result.metrics.currentZone}\n`;
    report += `  ‚Ä¢ Facteur puissance: ${result.metrics.powerFactor.toFixed(2)}\n`;
    report += `  ‚Ä¢ Asym√©trie: ${result.metrics.asymmetryPercent.toFixed(1)}%\n`;
    report += `  ‚Ä¢ √âquilibre z√©nith: ${result.metrics.zenithEquilibrium ? '‚úÖ' : '‚ùå'}\n\n`;

    // Erreurs
    if (result.errors.length > 0) {
      report += 'üö® ERREURS:\n';
      result.errors.forEach((error, index) => {
        report += `  ${index + 1}. ${error}\n`;
      });
      report += '\n';
    }

    // Avertissements
    if (result.warnings.length > 0) {
      report += '‚ö†Ô∏è AVERTISSEMENTS:\n';
      result.warnings.forEach((warning, index) => {
        report += `  ${index + 1}. ${warning}\n`;
      });
      report += '\n';
    }

    // Recommandations
    if (result.recommendations.length > 0) {
      report += 'üí° RECOMMANDATIONS:\n';
      result.recommendations.forEach((rec, index) => {
        report += `  ${index + 1}. ${rec}\n`;
      });
      report += '\n';
    }

    // Historique
    if (this.validationHistory.length > 0) {
      report += `üìà HISTORIQUE: ${this.validationHistory.length} √©chantillons\n\n`;
    }

    report += 'üî¨ MOD√àLE PHYSIQUE IMPL√âMENT√â:\n';
    report += '  ‚Ä¢ Sph√®re de vol contrainte ‚úÖ\n';
    report += '  ‚Ä¢ Forces distribu√©es par surface ‚úÖ\n';
    report += '  ‚Ä¢ √âquilibre z√©nith naturel ‚úÖ\n';
    report += '  ‚Ä¢ Direction √©mergente par asym√©trie ‚úÖ\n';
    report += '  ‚Ä¢ Contraintes PBD g√©om√©triques ‚úÖ\n';
    report += '  ‚Ä¢ Collision sol avec rebond ‚úÖ\n';

    return report;
  }
}

=== simulation/physics/VelocityCalculator.ts ===

/**
 * VelocityCalculator.ts - Service de calcul de v√©locit√© relative
 *
 * R√¥le :
 *   - Calcule la v√©locit√© relative entre deux points √† partir de leur historique de positions
 *   - Stocke les positions pr√©c√©dentes pour permettre la d√©rivation temporelle
 *   - Service r√©utilisable par LineSystem et BridleSystem
 *
 * Principe :
 *   v = Œîpos / Œît
 *   o√π Œîpos = position_actuelle - position_pr√©c√©dente
 *
 * Responsabilit√© :
 *   - Gestion de l'historique des positions (Map cl√© ‚Üí position)
 *   - Calcul de v√©locit√© par diff√©rence finie
 *   - Service stateless r√©utilisable
 *
 * Relation avec les autres modules :
 *   - Utilis√© par LineSystem pour calculer v√©locit√© relative lignes
 *   - Utilis√© par BridleSystem pour calculer v√©locit√© relative brides
 *
 * Philosophie :
 *   - DRY (Don't Repeat Yourself) : √©limine duplication LineSystem/BridleSystem
 *   - Single Responsibility : calcul v√©locit√© uniquement
 *   - Testable unitairement
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/BridleSystem.ts
 */

import * as THREE from "three";

/**
 * Service de calcul de v√©locit√© relative par diff√©rence finie
 *
 * Maintient un historique des positions pr√©c√©dentes pour calculer
 * la d√©riv√©e temporelle (v√©locit√©) par diff√©rence finie d'ordre 1.
 *
 * @example
 * ```typescript
 * const velCalc = new VelocityCalculator();
 *
 * // Frame 1
 * const vel1 = velCalc.calculate("kite", pos1, deltaTime);
 * // vel1 = (0, 0, 0) car pas d'historique
 *
 * // Frame 2
 * const vel2 = velCalc.calculate("kite", pos2, deltaTime);
 * // vel2 = (pos2 - pos1) / deltaTime
 * ```
 */
export class VelocityCalculator {
  /**
   * Historique des positions pr√©c√©dentes
   * Cl√© : identifiant unique (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * Valeur : derni√®re position connue
   */
  private previousPositions: Map<string, THREE.Vector3> = new Map();

  /**
   * Calcule la v√©locit√© relative d'un point entre deux frames
   *
   * Utilise la diff√©rence finie d'ordre 1 :
   * v = (pos_actuelle - pos_pr√©c√©dente) / Œît
   *
   * Au premier appel pour une cl√©, retourne (0, 0, 0) car pas d'historique.
   *
   * @param key - Identifiant unique du point (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * @param currentPos - Position actuelle du point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vecteur v√©locit√© en m/s
   *
   * @example
   * ```typescript
   * const vel = calculator.calculate(
   *   "line_left_kite",
   *   new THREE.Vector3(0, 10, 0),
   *   1/60 // 60 FPS
   * );
   * ```
   */
  calculate(
    key: string,
    currentPos: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // R√©cup√©rer position pr√©c√©dente
    const prevPos = this.previousPositions.get(key);

    // Si pas d'historique ou deltaTime invalide, retourner v√©locit√© nulle
    if (!prevPos || deltaTime <= 0) {
      // M√©moriser position actuelle pour prochain frame
      this.previousPositions.set(key, currentPos.clone());
      return new THREE.Vector3();
    }

    // Calculer v√©locit√© par diff√©rence finie
    const velocity = currentPos.clone().sub(prevPos).divideScalar(deltaTime);

    // M√©moriser position actuelle pour prochain frame
    this.previousPositions.set(key, currentPos.clone());

    return velocity;
  }

  /**
   * Calcule la v√©locit√© relative entre deux points (utilis√© par LineSystem)
   *
   * Cette version calcule la diff√©rence de v√©locit√© entre deux points,
   * utile pour calculer la vitesse relative d'une ligne qui relie deux objets.
   *
   * v_relative = v_point1 - v_point2
   *
   * @param keyPoint1 - Identifiant unique du premier point
   * @param keyPoint2 - Identifiant unique du second point
   * @param currentPos1 - Position actuelle du premier point
   * @param currentPos2 - Position actuelle du second point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns V√©locit√© relative entre les deux points
   *
   * @example
   * ```typescript
   * const velRelative = calculator.calculateRelative(
   *   "kite", "bar",
   *   kitePos, barPos,
   *   1/60
   * );
   * ```
   */
  calculateRelative(
    keyPoint1: string,
    keyPoint2: string,
    currentPos1: THREE.Vector3,
    currentPos2: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    const vel1 = this.calculate(keyPoint1, currentPos1, deltaTime);
    const vel2 = this.calculate(keyPoint2, currentPos2, deltaTime);

    // V√©locit√© relative = diff√©rence des v√©locit√©s
    return new THREE.Vector3().subVectors(vel1, vel2);
  }

  /**
   * R√©initialise l'historique pour une cl√© donn√©e
   *
   * Utile quand on change drastiquement la position d'un objet
   * (ex: reset de simulation)
   *
   * @param key - Identifiant du point √† r√©initialiser
   */
  reset(key: string): void {
    this.previousPositions.delete(key);
  }

  /**
   * R√©initialise tout l'historique
   *
   * Utile pour reset complet de la simulation
   */
  resetAll(): void {
    this.previousPositions.clear();
  }

  /**
   * Retourne le nombre de points suivis
   *
   * Utile pour debug/monitoring
   */
  getTrackedCount(): number {
    return this.previousPositions.size;
  }
}


=== simulation/physics/WindSimulator.ts ===

/**
 * WindSimulator.ts - Simulateur de vent et turbulences pour la simulation Kite
 *
 * R√¥le :
 *   - G√©n√®re le vent et ses variations (direction, vitesse, turbulence)
 *   - Fournit le vent apparent ressenti par le cerf-volant
 *   - Sert de source d'environnement pour la physique et le rendu
 *
 * D√©pendances principales :
 *   - SimulationConfig.ts : Param√®tres de vent et turbulence
 *   - Types/WindTypes.ts : Typage des param√®tres de vent
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsEngine.ts : Utilise WindSimulator pour obtenir le vent √† chaque frame
 *   - Les autres modules du dossier 'physics' utilisent le vent pour calculer les forces
 *
 * Utilisation typique :
 *   - Instanci√© par PhysicsEngine, appel√© pour obtenir le vent local ou global
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Simulateur de vent et turbulences
 *
 * G√®re le vent et ses variations pour cr√©er des conditions r√©alistes
 */
export class WindSimulator {
  private params: WindParams;
  private time: number = 0; // Compteur de temps pour faire varier les turbulences
  private windSpeedMs: number = 0;
  private windRad: number = 0;

  constructor() {
    // On d√©marre avec les r√©glages par d√©faut du vent
    this.params = {
      speed: CONFIG.wind.defaultSpeed,
      direction: CONFIG.wind.defaultDirection,
      turbulence: CONFIG.wind.defaultTurbulence,
    };
    this.updateWindInternals();
  }

  private updateWindInternals(): void {
    this.windSpeedMs = this.params.speed / 3.6;
    this.windRad = (this.params.direction * Math.PI) / 180;
  }

  /**
   * Calcule les turbulences du vent
   * M√©thode extraite pour √©viter la duplication de code
   */
  private calculateTurbulence(baseWindVector: THREE.Vector3): THREE.Vector3 {
    if (this.params.turbulence <= 0) {
      return baseWindVector.clone();
    }

    const turbIntensity =
      (this.params.turbulence / 100) * CONFIG.wind.turbulenceScale;
    const freq = CONFIG.wind.turbulenceFreqBase;

    const turbulenceVector = baseWindVector.clone();

    // Utiliser des sinus pour cr√©er des variations douces et naturelles
    turbulenceVector.x +=
      Math.sin(this.time * freq) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;
    turbulenceVector.y +=
      Math.sin(this.time * freq * CONFIG.wind.turbulenceFreqY) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityY;
    turbulenceVector.z +=
      Math.cos(this.time * freq * CONFIG.wind.turbulenceFreqZ) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;

    return turbulenceVector;
  }

  /**
   * Calcule le vent que "ressent" le cerf-volant
   * C'est comme quand vous mettez la main par la fen√™tre d'une voiture :
   * - Si la voiture roule vite, vous sentez plus de vent
   * - Si vous allez contre le vent, il est plus fort
   * - Si vous allez avec le vent, il est plus faible
   */
  getApparentWind(
    kiteVelocity: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    this.time += deltaTime;

    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    const windVector = this.calculateTurbulence(baseWindVector);

    // Le vent apparent = vent r√©el - vitesse du kite
    // Si le kite va vite vers l'avant, il "cr√©e" du vent de face
    const apparent = windVector.clone().sub(kiteVelocity);

    // üîç DEBUG: V√©rifier le calcul du vent apparent - DISABLED for performance
    // console.log(`üîç WIND CALC: Real wind (${windVector.x.toFixed(2)}, ${windVector.y.toFixed(2)}, ${windVector.z.toFixed(2)}) = ${windVector.length().toFixed(2)} m/s | Kite vel (${kiteVelocity.x.toFixed(2)}, ${kiteVelocity.y.toFixed(2)}, ${kiteVelocity.z.toFixed(2)}) = ${kiteVelocity.length().toFixed(2)} m/s | Apparent (${apparent.x.toFixed(2)}, ${apparent.y.toFixed(2)}, ${apparent.z.toFixed(2)}) = ${apparent.length().toFixed(2)} m/s`);

    return apparent;
  }

  /**
   * Obtient le vecteur de vent √† une position donn√©e
   */
  getWindAt(_position: THREE.Vector3): THREE.Vector3 {
    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    return this.calculateTurbulence(baseWindVector);
  }

  setParams(params: Partial<WindParams>): void {
    Object.assign(this.params, params);
    this.updateWindInternals();
  }

  getParams(): WindParams {
    return { ...this.params };
  }
}

=== simulation/rendering/DebugRenderer.ts ===

/**
 * DebugRenderer.ts - Gestionnaire du rendu de debug pour la simulation Kite
 *
 * R√¥le :
 *   - Affiche visuellement les forces physiques (portance, tra√Æn√©e, friction, r√©sultante) et la vitesse du cerf-volant
 *   - Met √† jour le panneau d'informations de debug (HTML)
 *   - Permet d'activer/d√©sactiver le mode debug et de g√©rer l'affichage des vecteurs
 *
 * D√©pendances principales :
 *   - RenderManager.ts : Ajoute/retire les objets de debug √† la sc√®ne Three.js
 *   - PhysicsEngine.ts : R√©cup√®re l'√©tat physique du cerf-volant et les forces calcul√©es
 *   - AerodynamicsCalculator.ts : Calcule les forces a√©rodynamiques sur chaque surface du kite
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et aux points anatomiques du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres physiques et configuration
 *   - Types : Utilise SurfaceForce, KiteState pour typer les donn√©es physiques
 *
 * Relation avec les fichiers adjacents :
 *   - RenderManager.ts : Fichier adjacent direct, g√®re la sc√®ne 3D et l'environnement visuel. DebugRenderer utilise RenderManager pour afficher les fl√®ches de debug.
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec RenderManager.
 *
 * Utilisation typique :
 *   - Instanci√© dans la boucle de simulation pour afficher les vecteurs de forces et la vitesse du kite
 *   - Interagit avec le DOM pour afficher les infos de debug
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/rendering/RenderManager.ts
 */
import * as THREE from "three";
import { Primitive } from "@core/Primitive";

import { Kite } from "../../objects/Kite";
import { SurfaceForce } from "../types";
import type { LineSystem } from "../physics/LineSystem";
import type { WindSimulator } from "../physics/WindSimulator";
import { CONFIG } from "../config/SimulationConfig";
import { KiteGeometry } from "../config/KiteGeometry";

export interface DebugRenderTarget {
  addObject(object: THREE.Object3D): void;
  removeObject(object: THREE.Object3D): void;
  getScene(): THREE.Scene | null | undefined;
}

/**
 * Palette de couleurs am√©lior√©e pour les vecteurs de debug
 */
const DEBUG_COLORS = {
  // Vecteurs de mouvement
  velocity: 0x00ff00,        // Vert vif - Vitesse du kite
  apparentWind: 0x00ffff,    // Cyan - Vent apparent

  // Forces globales
  globalLift: 0x4169e1,      // Bleu royal - Portance globale
  globalResultant: 0xffffff, // Blanc - R√©sultante globale

  // Forces par surface
  surfaceLift: 0x00bfff,     // Bleu ciel profond - Portance locale
  surfaceDrag: 0xff4444,     // Rouge vif - Tra√Æn√©e
  surfaceFriction: 0xaaaaaa, // Gris moyen - Friction
  surfaceResultant: 0xffdd00,// Jaune vif - R√©sultante locale
  
  // Masse distribu√©e
  surfaceMass: 0xff00ff,     // Magenta - Force gravitationnelle par surface
  torque: 0xffa500,          // Orange - Couple a√©rodynamique
};

/**
 * Tailles des vecteurs pour meilleure lisibilit√©
 */
const VECTOR_SCALES = {
  velocity: 1.0,        // Augment√© pour plus de visibilit√©
  apparentWind: 0.8,    // Augment√© pour mieux voir le vent apparent
  globalLift: 0.4,      // Portance globale plus visible
  globalResultant: 0.6, // R√©sultante plus pro√©minente
  surfaceLift: 0.5,     // Forces par surface plus visibles
  surfaceDrag: 0.5,
  surfaceFriction: 0.3,
  surfaceResultant: 0.7, // R√©sultante locale plus visible
  surfaceMass: 4.0,     // Gravit√© distribu√©e plus visible
  torque: 0.8,          // Couple plus visible
};

/**
 * Configuration des t√™tes de fl√®ches pour un rendu plus fin et pr√©cis
 */
const ARROW_HEAD_CONFIG = {
  // Grandes fl√®ches (vitesse, vent apparent, r√©sultantes)
  large: {
    headLength: 0.15,  // Longueur de la t√™te de fl√®che
    headWidth: 0.12,   // Largeur de la t√™te de fl√®che
  },
  // Fl√®ches moyennes (forces globales)
  medium: {
    headLength: 0.12,
    headWidth: 0.09,
  },
  // Petites fl√®ches (forces par surface)
  small: {
    headLength: 0.10,
    headWidth: 0.07,
  },
  // Tr√®s petites fl√®ches (friction)
  tiny: {
    headLength: 0.08,
    headWidth: 0.06,
  },
};

/**
 * Gestionnaire du rendu de debug
 *
 * Affiche les forces, vitesses et informations de debug
 */
/**
 * Configuration des vecteurs visibles
 */
interface VectorVisibility {
  velocity: boolean;
  apparentWind: boolean;
  globalForces: boolean;
  surfaceForces: boolean;
  surfaceMass: boolean;  // Afficher forces gravitationnelles distribu√©es
  torque: boolean; // Nouvelle option pour le couple
}

export class DebugRenderer {
  private renderTarget: DebugRenderTarget;
  private debugArrows: THREE.ArrowHelper[] = [];
  private debugLabels: THREE.Object3D[] = []; // Nouveaux labels textuels
  private debugMode: boolean;
  private vectorVisibility: VectorVisibility = {
    velocity: true,
    apparentWind: true,
    globalForces: true,
    surfaceForces: true,
    surfaceMass: false,  // D√©sactiv√© par d√©faut (peut surcharger l'affichage)
    torque: true, // Activ√© par d√©faut
  };
  private physicsSystem: any;

  constructor(renderTarget: DebugRenderTarget, physicsSystem: any) {
    this.renderTarget = renderTarget;
    this.physicsSystem = physicsSystem;
    this.debugMode = CONFIG.debugVectors === true;
    this.setupDebugControls();
  }

  isDebugMode(): boolean {
    return this.debugMode;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;

    const debugBtn = document.getElementById("debug-physics");
    const debugPanel = document.getElementById("debug-panel");

    if (debugBtn) {
      debugBtn.textContent = this.debugMode ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugMode);
    }

    if (debugPanel) {
      debugPanel.style.display = this.debugMode ? "block" : "none";
    }

    document.body.classList.toggle("debug-mode", this.debugMode);

    if (!this.debugMode) {
      this.clearDebugArrows();
    }
  }

  toggleDebugMode(): void {
    this.setDebugMode(!this.debugMode);
  }

  /**
   * Met √† jour le panneau d'informations de debug HTML
   */
  updateDebugDisplay(kitePhysicsSystem: any): void {
    if (!this.debugMode) return;

    const debugPanel = document.getElementById("debug-panel");
    if (!debugPanel) return;

    // R√©cup√©rer les donn√©es physiques
    const kiteState = kitePhysicsSystem.getKiteState();
    const forces = kitePhysicsSystem.getAerodynamicForces();
    const windSimulator = kitePhysicsSystem.getWindSimulator();
    const lineSystem = kitePhysicsSystem.getLineSystem();

    if (!kiteState || !forces || !windSimulator || !lineSystem) return;

    // Calculer les valeurs √† afficher
    const velocity = kiteState.velocity.length().toFixed(2);
    const position = kiteState.position.clone();
    const windParams = windSimulator.getParams();
    const tensions = lineSystem.getTensions();

    // Mettre √† jour le contenu du panneau
    const debugContent = debugPanel.querySelector(".debug-content");
    if (debugContent) {
      debugContent.innerHTML = `
        <div class="debug-section">
          <h4>üèÉ √âtat du Kite</h4>
          <div class="debug-item">Position: (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)}) m</div>
          <div class="debug-item">Vitesse: ${velocity} m/s</div>
        </div>

        <div class="debug-section">
          <h4>üí® Vent</h4>
          <div class="debug-item">Vitesse: ${windParams.speed.toFixed(1)} km/h</div>
          <div class="debug-item">Direction: ${windParams.direction.toFixed(0)}¬∞</div>
          <div class="debug-item">Turbulence: ${windParams.turbulence.toFixed(1)}%</div>
        </div>

        <div class="debug-section">
          <h4>‚úàÔ∏è Forces A√©rodynamiques</h4>
          <div class="debug-item">Portance: ${forces.lift.length().toFixed(2)} N</div>
          <div class="debug-item">Tra√Æn√©e: ${forces.drag.length().toFixed(2)} N</div>
          <div class="debug-item">R√©sultante: ${forces.lift.clone().add(forces.drag).length().toFixed(2)} N</div>
        </div>

        <div class="debug-section">
          <h4>üéØ Lignes de Contr√¥le</h4>
          <div class="debug-item">Tension Gauche: ${tensions.left.toFixed(2)} N</div>
          <div class="debug-item">Tension Droite: ${tensions.right.toFixed(2)} N</div>
          <div class="debug-item">Longueur: ${lineSystem.lineLength.toFixed(2)} m</div>
        </div>
      `;
    }
  }

  /**
   * Configure le panneau de contr√¥le des vecteurs de debug
   */
  private setupDebugControls(): void {
    // Trouver ou cr√©er le conteneur de contr√¥les
    let controlsContainer = document.getElementById("debug-vector-controls");

    if (!controlsContainer) {
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        controlsContainer = document.createElement("div");
        controlsContainer.id = "debug-vector-controls";
        controlsContainer.style.cssText = `
          margin-top: 15px;
          padding-top: 15px;
          border-top: 1px solid rgba(255,255,255,0.2);
        `;

        controlsContainer.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <div style="display: flex; align-items: center; gap: 10px;">
              <strong style="color: #fff; font-size: 14px;">üîß Contr√¥les:</strong>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">
                <input type="checkbox" id="toggle-all-vectors" style="margin-right: 5px; cursor: pointer;">
                Tout activer/d√©sactiver
              </label>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
              <label style="color: #fff; font-size: 12px;">√âchelle globale:</label>
              <input type="range" id="vector-scale" min="0.1" max="3.0" step="0.1" value="1.0" style="flex: 1;">
              <span id="scale-value" style="color: #fff; font-size: 12px; min-width: 30px;">1.0x</span>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-velocity" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #00ff00;">‚óè</span> Vitesse kite
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-apparent-wind" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #00ffff;">‚óè</span> Vent apparent
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-global-forces" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #4169e1;">‚óè</span> Forces globales
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-surface-forces" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ffdd00;">‚óè</span> Forces surfaces
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-surface-mass" style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ff00ff;">‚óè</span> Masse distribu√©e
              </label>
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="toggle-torque" checked style="margin-right: 8px; cursor: pointer;">
                <span style="color: #ffa500;">‚óè</span> Couple a√©rodynamique
              </label>
            </div>
          </div>
        `;

        debugPanel.appendChild(controlsContainer);

        // Ajouter les event listeners
        document.getElementById("toggle-all-vectors")?.addEventListener("change", (e) => {
          const checked = (e.target as HTMLInputElement).checked;
          this.vectorVisibility.velocity = checked;
          this.vectorVisibility.apparentWind = checked;
          this.vectorVisibility.globalForces = checked;
          this.vectorVisibility.surfaceForces = checked;
          this.vectorVisibility.surfaceMass = checked;
          this.vectorVisibility.torque = checked;

          // Mettre √† jour tous les checkboxes
          (document.getElementById("toggle-velocity") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-apparent-wind") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-global-forces") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-surface-forces") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-surface-mass") as HTMLInputElement).checked = checked;
          (document.getElementById("toggle-torque") as HTMLInputElement).checked = checked;
        });

        // Contr√¥le d'√©chelle globale
        document.getElementById("vector-scale")?.addEventListener("input", (e) => {
          const scale = parseFloat((e.target as HTMLInputElement).value);
          this.setGlobalVectorScale(scale);
          document.getElementById("scale-value")!.textContent = `${scale.toFixed(1)}x`;
        });
        document.getElementById("toggle-velocity")?.addEventListener("change", (e) => {
          this.vectorVisibility.velocity = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-apparent-wind")?.addEventListener("change", (e) => {
          this.vectorVisibility.apparentWind = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-global-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.globalForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-mass")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceMass = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-torque")?.addEventListener("change", (e) => {
          this.vectorVisibility.torque = (e.target as HTMLInputElement).checked;
        });
      }
    }
  }

  clearDebugArrows(): void {
    this.debugArrows.forEach((arrow) => {
      this.renderTarget.removeObject(arrow);
    });
    this.debugArrows = [];

    // Nettoyer aussi les labels
    this.debugLabels.forEach((label) => {
      this.renderTarget.removeObject(label);
    });
    this.debugLabels = [];
  }

  /**
   * Cr√©e un vecteur avec son label textuel
   */
  private createLabeledVector(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    label: string,
    headLength?: number,
    headWidth?: number
  ): void {
    // Cr√©er la fl√®che
    const arrow = Primitive.arrow(direction, origin, length, color, headLength, headWidth);
    this.debugArrows.push(arrow);
    this.renderTarget.addObject(arrow);

    // Cr√©er le label √† la pointe de la fl√®che
    const labelPosition = origin.clone().add(direction.clone().multiplyScalar(length * 1.1));
    const textLabel = Primitive.textLabel(label, labelPosition, color, 0.3);
    this.debugLabels.push(textLabel);
    this.renderTarget.addObject(textLabel);
  }

  /**
   * Calcule une √©chelle adaptative pour les vecteurs bas√©e sur leur magnitude
   * relative aux autres forces dans la sc√®ne
   */
  private calculateAdaptiveScale(
    magnitude: number,
    baseScale: number,
    minScale: number = 0.1,
    maxScale: number = 3.0
  ): number {
    if (magnitude <= 0) return minScale;

    // Utiliser une √©chelle logarithmique pour une meilleure visibilit√©
    const logMagnitude = Math.log10(Math.max(magnitude, 0.01));
    const adaptiveScale = baseScale * (1 + logMagnitude * 0.2) * this.globalVectorScale;

    // Limiter l'√©chelle dans des bornes raisonnables
    return Math.max(minScale, Math.min(maxScale, adaptiveScale));
  }

  /**
   * D√©finit l'√©chelle globale des vecteurs
   */
  private globalVectorScale: number = 1.0;

  setGlobalVectorScale(scale: number): void {
    this.globalVectorScale = Math.max(0.1, Math.min(5.0, scale));
  }

  /**
   * Met √† jour tous les vecteurs de debug avec l'architecture ECS
   */
  public updateDebugVectors(kite: Kite, kitePhysicsSystem: any): void {
    if (!this.debugMode) return;

    this.clearDebugArrows();

    // Calculer la position centrale du kite pour tous les vecteurs
    const centerPoint = kite.getPoint("CENTRE");
    const centerWorld = centerPoint ? kite.localToWorld(centerPoint.clone()) : kite.position;

    // Afficher la vitesse du kite
    if (this.vectorVisibility.velocity) {
      this.displayVelocityVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher le vent apparent
    if (this.vectorVisibility.apparentWind) {
      this.displayApparentWindVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher les forces globales
    if (this.vectorVisibility.globalForces) {
      this.displayGlobalForces(kitePhysicsSystem, centerWorld);
    }

    // Afficher les forces par surface
    if (this.vectorVisibility.surfaceForces) {
      this.displaySurfaceForcesFromECS(kitePhysicsSystem, kite);
    }

    // Afficher le couple a√©rodynamique
    if (this.vectorVisibility.torque) {
      this.displayTorqueVector(kitePhysicsSystem, centerWorld);
    }

    // Afficher les contraintes (tensions des lignes et brides)
    this.displayConstraintForces(kitePhysicsSystem, kite);

    // Afficher la gravit√© distribu√©e si activ√©
    if (this.vectorVisibility.surfaceMass) {
      this.displayGravityForces(kite);
    }
  }

  /**
   * Affiche le vecteur de vitesse du kite
   */
  private displayVelocityVector(kitePhysicsSystem: any, centerWorld: THREE.Vector3): void {
    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState || kiteState.velocity.length() < 0.1) return;

    const velocity = kiteState.velocity;

    const dir = velocity.clone().normalize();
    const magnitude = velocity.length();
    const adaptiveScale = this.calculateAdaptiveScale(magnitude, VECTOR_SCALES.velocity);
    const length = magnitude * adaptiveScale;

    this.createLabeledVector(
      dir,
      centerWorld, // Utiliser la position centrale coh√©rente
      length,
      DEBUG_COLORS.velocity,
      `${magnitude.toFixed(1)} m/s`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche le vecteur de vent apparent
   */
  private displayApparentWindVector(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    const windSimulator = kitePhysicsSystem.getWindSimulator();
    if (!windSimulator) return;

    // Obtenir l'√©tat actuel du kite pour calculer le vent apparent
    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    // Calculer le vent apparent = vent r√©el - vitesse du kite
    const windParams = windSimulator.getParams();
    const windSpeed = windParams.speed; // km/h
    const windDirectionRad = (windParams.direction * Math.PI) / 180;

    if (windSpeed < 0.1) return;

    // Vecteur vent r√©el (converti en m/s pour coh√©rence avec la vitesse du kite)
    const windVector = new THREE.Vector3(
      Math.sin(windDirectionRad) * (windSpeed / 3.6), // km/h -> m/s
      0,
      -Math.cos(windDirectionRad) * (windSpeed / 3.6)
    );

    // Vent apparent = vent r√©el - vitesse du kite
    const apparentWind = windVector.clone().sub(kiteState.velocity);

    if (apparentWind.length() < 0.1) return;

    const dir = apparentWind.clone().normalize();
    const magnitude = apparentWind.length();
    const adaptiveScale = this.calculateAdaptiveScale(magnitude, VECTOR_SCALES.apparentWind);
    const length = magnitude * adaptiveScale;

    this.createLabeledVector(
      dir,
      kitePosition, // Utiliser la position du centre du kite sur sa surface
      length,
      DEBUG_COLORS.apparentWind,
      `${magnitude.toFixed(1)} m/s`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche les forces globales (lift, drag, r√©sultante)
   */
  private displayGlobalForces(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    const forces = kitePhysicsSystem.getAerodynamicForces();
    if (!forces) return;

    const { lift, drag } = forces;

    // Vecteur de portance globale (bleu royal)
    if (this.vectorVisibility.globalForces && lift.length() > CONFIG.debug.minVectorLength) {
      const liftDir = lift.clone().normalize();
      const liftMagnitude = lift.length();
      const liftScale = this.calculateAdaptiveScale(liftMagnitude, VECTOR_SCALES.globalLift);
      const liftLength = Math.sqrt(liftMagnitude) * liftScale;

      this.createLabeledVector(
        liftDir,
        kitePosition, // Position du centre du kite sur sa surface
        liftLength,
        DEBUG_COLORS.globalLift,
        `${liftMagnitude.toFixed(1)} N`,
        ARROW_HEAD_CONFIG.medium.headLength,
        ARROW_HEAD_CONFIG.medium.headWidth
      );
    }

    // Vecteur de tra√Æn√©e globale (rouge)
    if (this.vectorVisibility.globalForces && drag.length() > CONFIG.debug.minVectorLength) {
      const dragDir = drag.clone().normalize();
      const dragMagnitude = drag.length();
      const dragScale = this.calculateAdaptiveScale(dragMagnitude, VECTOR_SCALES.globalLift);
      const dragLength = Math.sqrt(dragMagnitude) * dragScale;

      this.createLabeledVector(
        dragDir,
        kitePosition, // Position du centre du kite sur sa surface
        dragLength,
        0xff4444, // Rouge pour la tra√Æn√©e globale
        `${dragMagnitude.toFixed(1)} N`,
        ARROW_HEAD_CONFIG.medium.headLength,
        ARROW_HEAD_CONFIG.medium.headWidth
      );
    }

    // Vecteur r√©sultant global (somme vectorielle de lift et drag)
    if (lift.length() > CONFIG.debug.minVectorLength || drag.length() > CONFIG.debug.minVectorLength) {
      const resultant = lift.clone().add(drag);
      if (resultant.length() > CONFIG.debug.minVectorLength) {
        const resultantDir = resultant.clone().normalize();
        const resultantMagnitude = resultant.length();
        const resultantScale = this.calculateAdaptiveScale(resultantMagnitude, VECTOR_SCALES.globalResultant);
        const resultantLength = Math.sqrt(resultantMagnitude) * resultantScale;

        this.createLabeledVector(
          resultantDir,
          kitePosition, // Position du centre du kite sur sa surface
          resultantLength,
          DEBUG_COLORS.globalResultant,
          `${resultantMagnitude.toFixed(1)} N`,
          ARROW_HEAD_CONFIG.large.headLength,
          ARROW_HEAD_CONFIG.large.headWidth
        );
      }
    }
  }

  /**
   * Affiche les forces par surface depuis l'architecture ECS
   */
  private displaySurfaceForcesFromECS(kitePhysicsSystem: any, kite: Kite): void {
    const surfaceForces = kitePhysicsSystem.getSurfaceForces();
    if (surfaceForces && surfaceForces.length > 0) {
      // TODO: Impl√©menter displaySurfaceForces quand la m√©thode sera disponible
      // this.displaySurfaceForces(surfaceForces, kite);
    }
  }

  /**
   * Affiche le vecteur de couple a√©rodynamique
   */
  private displayTorqueVector(kitePhysicsSystem: any, kitePosition: THREE.Vector3): void {
    // Note: Dans l'architecture actuelle, le couple n'est pas directement expos√©
    // Nous utilisons une approximation bas√©e sur les forces a√©rodynamiques disponibles
    const forces = kitePhysicsSystem.getAerodynamicForces();
    if (!forces) return;

    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    const { lift } = forces;

    // Approximation du couple bas√©e sur la portance (en utilisant une distance arbitraire)
    // Dans un syst√®me complet, cela devrait venir directement du syst√®me de physique
    const approximateTorqueMagnitude = lift.length() * 0.5; // Distance arbitraire de 0.5m

    if (approximateTorqueMagnitude < CONFIG.debug.minVectorLength) return;

    // Cr√©er un vecteur de couple approximatif (direction perpendiculaire √† la portance)
    const torqueVector = new THREE.Vector3(-lift.y, lift.x, 0).normalize().multiplyScalar(approximateTorqueMagnitude);

    const dir = torqueVector.clone().normalize();
    const length = Math.sqrt(approximateTorqueMagnitude) * VECTOR_SCALES.torque;

    this.createLabeledVector(
      dir,
      kitePosition, // Position du centre du kite sur sa surface
      length,
      DEBUG_COLORS.torque,
      `${approximateTorqueMagnitude.toFixed(1)} N¬∑m`,
      ARROW_HEAD_CONFIG.large.headLength,
      ARROW_HEAD_CONFIG.large.headWidth
    );
  }

  /**
   * Affiche les vecteurs de tension des lignes et brides
   */
  private displayConstraintForces(kitePhysicsSystem: any, kite: Kite): void {
    const lineSystem = kitePhysicsSystem.getLineSystem();
    if (!lineSystem) return;

    const kiteState = kitePhysicsSystem.getKiteState();
    if (!kiteState) return;

    // Obtenir les tensions des lignes
    const tensions = lineSystem.getTensions();
    const handlePositions = kitePhysicsSystem.getHandlePositions?.() || { left: new THREE.Vector3(), right: new THREE.Vector3() };

    // Points d'attache des lignes sur le kite
    const kiteLeftWorld = kite.toWorldCoordinates(kite.getPoint("CTRL_GAUCHE")?.clone() || new THREE.Vector3());
    const kiteRightWorld = kite.toWorldCoordinates(kite.getPoint("CTRL_DROIT")?.clone() || new THREE.Vector3());

    // Vecteurs de tension pour la ligne gauche
    if (tensions.left > 0.1) {
      const tensionLeftDir = handlePositions.left.clone().sub(kiteLeftWorld).normalize();
      const tensionLeftLength = Math.sqrt(tensions.left) * 0.1; // √âchelle pour visualisation
      const tensionLeftArrow = Primitive.arrow(
        tensionLeftDir,
        kiteLeftWorld,
        tensionLeftLength,
        0xff6b6b, // Rouge pour tension
        ARROW_HEAD_CONFIG.small.headLength,
        ARROW_HEAD_CONFIG.small.headWidth
      );
      this.debugArrows.push(tensionLeftArrow);
      this.renderTarget.addObject(tensionLeftArrow);
    }

    // Vecteurs de tension pour la ligne droite
    if (tensions.right > 0.1) {
      const tensionRightDir = handlePositions.right.clone().sub(kiteRightWorld).normalize();
      const tensionRightLength = Math.sqrt(tensions.right) * 0.1; // √âchelle pour visualisation
      const tensionRightArrow = Primitive.arrow(
        tensionRightDir,
        kiteRightWorld,
        tensionRightLength,
        0x4ecdc4, // Cyan pour tension
        ARROW_HEAD_CONFIG.small.headLength,
        ARROW_HEAD_CONFIG.small.headWidth
      );
      this.debugArrows.push(tensionRightArrow);
      this.renderTarget.addObject(tensionRightArrow);
    }
  }

  /**
   * Affiche les vecteurs de gravit√© distribu√©e sur chaque surface
   */
  private displayGravityForces(kite: Kite): void {
    // Pour chaque surface avec sa masse
    KiteGeometry.SURFACES_WITH_MASS.forEach((surface: any, _surfaceIndex: number) => {
      // Centre g√©om√©trique de la surface (coordonn√©es locales)
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Transformer en coordonn√©es monde
      const centerWorld = kite.toWorldCoordinates(centre);

      // Force gravitationnelle = m √ó g (vers le bas)
      const gravityForce = new THREE.Vector3(0, -surface.mass * CONFIG.physics.gravity, 0);
      const forceMagnitude = gravityForce.length();

      // Afficher fl√®che magenta pointant vers le bas
      if (forceMagnitude > CONFIG.debug.minVectorLength) {
        const gravityArrow = Primitive.arrow(
          gravityForce.clone().normalize(),
          centerWorld,
          forceMagnitude * VECTOR_SCALES.surfaceMass,
          DEBUG_COLORS.surfaceMass,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderTarget.addObject(gravityArrow);
        this.debugArrows.push(gravityArrow);
      }
    });
  }
}

/**
 * Interface pour la source de donn√©es physiques de debug
 *
 * Fournit les m√©thodes n√©cessaires pour acc√©der aux contr√¥leurs et simulateurs
 */
export interface DebugPhysicsSource {
  getWindSimulator(): WindSimulator;
  getLineSystem(): LineSystem;
}



=== simulation/rendering/RenderManager.ts ===

/**
 * RenderManager.ts - Gestionnaire du rendu 3D pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re la sc√®ne Three.js, la cam√©ra, le rendu et l'environnement visuel (ciel, sol, nuages, lumi√®res)
 *   - Ajoute et retire dynamiquement des objets 3D (cerf-volant, fl√®ches de debug, etc.)
 *   - Fournit l'API pour le rendu et la gestion de la sc√®ne
 *
 * D√©pendances principales :
 *   - Three.js : Moteur de rendu 3D
 *   - SimulationConfig.ts : Param√®tres de configuration du rendu (fog, ombres, etc.)
 *
 * Relation avec les fichiers adjacents :
 *   - DebugRenderer.ts : Fichier adjacent direct, utilise RenderManager pour afficher les vecteurs de debug (fl√®ches de forces, vitesse, etc.)
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec DebugRenderer.
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage de la simulation pour initialiser la sc√®ne et le rendu
 *   - Utilis√© par DebugRenderer pour ajouter/retirer des objets de debug
 *
 * Voir aussi :
 *   - src/simulation/rendering/DebugRenderer.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire du rendu 3D
 *
 * G√®re la sc√®ne 3D, la cam√©ra, le rendu et l'environnement visuel
 */
export class RenderManager {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(
      0x87ceeb,
      CONFIG.rendering.fogStart,
      CONFIG.rendering.fogEnd
    );

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 5, 12);
    this.camera.lookAt(0, 3, -5);

    this.renderer = new THREE.WebGLRenderer({
      antialias: CONFIG.rendering.antialias,
      alpha: true,
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxDistance = 50;
    this.controls.minDistance = 2;

    this.setupEnvironment();
    window.addEventListener("resize", () => this.onResize());
  }

  private setupEnvironment(): void {
    // Cr√©ation d'un beau ciel d√©grad√©
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel profond
        bottomColor: { value: new THREE.Color(0x87ceeb) }, // Bleu ciel plus clair
        offset: { value: 400 },
        exponent: { value: 0.6 },
      },
      side: THREE.BackSide,
    });

    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);

    // Ajout de quelques nuages pour plus de r√©alisme
    this.addClouds();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 50, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    sunLight.shadow.mapSize.width = CONFIG.rendering.shadowMapSize;
    sunLight.shadow.mapSize.height = CONFIG.rendering.shadowMapSize;
    this.scene.add(sunLight);

    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    this.scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    this.scene.add(gridHelper);
  }

  private addClouds(): void {
    // Cr√©ation de quelques nuages simples et r√©alistes
    const cloudGroup = new THREE.Group();

    // Mat√©riau pour les nuages - blanc semi-transparent
    const cloudMaterial = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
    });

    // Cr√©ation de plusieurs nuages √† diff√©rentes positions
    for (let i = 0; i < 8; i++) {
      const cloud = new THREE.Group();

      // Chaque nuage est compos√© de plusieurs sph√®res pour un aspect naturel
      for (let j = 0; j < 5; j++) {
        const cloudPart = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random() * 4 + 2, 6, 4),
          cloudMaterial
        );

        cloudPart.position.x = Math.random() * 10 - 5;
        cloudPart.position.y = Math.random() * 2 - 1;
        cloudPart.position.z = Math.random() * 10 - 5;
        cloudPart.scale.setScalar(Math.random() * 0.5 + 0.5);

        cloud.add(cloudPart);
      }

      // Position des nuages dans le ciel
      cloud.position.set(
        (Math.random() - 0.5) * 200, // X: -100 √† 100
        Math.random() * 30 + 20, // Y: 20 √† 50 (hauteur dans le ciel)
        (Math.random() - 0.5) * 200 // Z: -100 √† 100
      );

      cloudGroup.add(cloud);
    }

    this.scene.add(cloudGroup);
  }

  addObject(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  getScene(): THREE.Scene {
    return this.scene;
  }

  render(): void {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  private onResize(): void {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

}

=== simulation/systems/ControlBarSystem.ts ===

/**
 * ControlBarSystem.ts - Syst√®me ECS pour la gestion de la barre de contr√¥le
 *
 * NOUVELLES RESPONSABILIT√âS :
 *   - G√®re l'entit√© de la barre de contr√¥le (position, rotation, visuel)
 *   - La barre est contr√¥l√©e directement par les inputs utilisateur (fl√®ches)
 *   - Pivot central fixe avec rotation horizontale selon les commandes
 *   - Les poign√©es sont positionn√©es aux extr√©mit√©s de la barre
 *
 * NOUVELLE ARCHITECTURE :
 *   - Op√®re sur une ControlBarEntity avec TransformComponent et MeshComponent
 *   - Lecture directe des inputs depuis InputSystem (pas de calcul bas√© sur le kite)
 *   - Rotation directe selon les commandes fl√©ch√©es (-1 √† +1)
 *   - Position centrale fixe devant le pilote
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { CONFIG } from '../config/SimulationConfig';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';
import { Entity } from '../entities/Entity';
import { HandlePositions } from '../types/PhysicsTypes';

import { InputSystem } from './InputSystem';

export class ControlBarSystem extends BaseSimulationSystem {
  private logger: Logger;
  private controlBarEntity: Entity | null = null;
  private inputSystem: InputSystem | null = null;
  private kiteEntity: Entity | null = null; // R√©f√©rence √† l'entit√© kite
  private currentRotation: number = 0; // Rotation input utilisateur (radians)
  private smoothingFactor: number = CONFIG.defaults.smoothingFactor;

  constructor() {
    // Priorit√© moyenne (apr√®s Input, avant Render)
    super('ControlBarSystem', 5);
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    this.logger.info('ControlBarSystem initialized', 'ControlBarSystem');
  }

  /**
   * Enregistre l'entit√© de la barre de contr√¥le
   */
  setControlBarEntity(entity: Entity): void {
    if (!entity.hasComponent('transform') || !entity.hasComponent('mesh')) {
      throw new Error('ControlBarEntity must have Transform and Mesh components');
    }
    this.controlBarEntity = entity;
  }

  /**
   * Enregistre l'entit√© du kite (pour orientation physique)
   */
  setKiteEntity(entity: Entity): void {
    this.kiteEntity = entity;
  }

  /**
   * D√©finit la r√©f√©rence au syst√®me d'inputs
   */
  setInputSystem(inputSystem: InputSystem): void {
    this.inputSystem = inputSystem;
  }

  getRotation(): number {
    return this.currentRotation;
  }

  /**
   * Calcule la rotation physique de la barre vers le kite
   */
  private computePhysicalRotation(): number {
    const toKite = this.computeToKiteVector();
    if (toKite.length() < 1e-4) return 0;
    toKite.normalize();
    // Angle entre l'axe X local de la barre et le vecteur vers le kite
    const angle = Math.atan2(toKite.z, toKite.x); // Angle dans le plan XZ
    return angle;
  }

  /**
   * Calcule le vecteur du centre de la barre vers le kite (plan horizontal)
   */
  private computeToKiteVector(): THREE.Vector3 {
    if (!this.controlBarEntity || !this.kiteEntity) return new THREE.Vector3();
    const barTransform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    const kiteTransform = this.kiteEntity.getComponent<TransformComponent>('transform');
    if (!barTransform || !kiteTransform) return new THREE.Vector3();
    // Vecteur du centre de la barre vers le kite (plan horizontal)
    const toKite = kiteTransform.position.clone().sub(barTransform.position);
    toKite.y = 0; // Garder dans le plan horizontal
    return toKite;
  }

  update(_context: SimulationContext): void {
    if (!this.controlBarEntity || !this.inputSystem) return;

    const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    const mesh = this.controlBarEntity.getComponent<MeshComponent>('mesh');
    if (!transform || !mesh) return;

    // La barre est maintenant un enfant du pilote, donc position RELATIVE
    // Position relative fixe par rapport au pilote (ne change pas)
    transform.position.set(
      0, // M√™me X que le pilote
      CONFIG.controlBar.offsetY, // Au-dessus du pilote
      CONFIG.controlBar.offsetZ  // Devant le pilote
    );

    // Input utilisateur (-1 √† +1)
    const inputState = this.inputSystem.getInputState();
    // Inverser le signe : ArrowLeft (-1) doit donner rotation positive (vers la gauche quand on regarde depuis le pilote)
    const targetRotation = -inputState.barPosition * CONFIG.input.maxRotation;
    this.currentRotation = THREE.MathUtils.lerp(
      this.currentRotation,
      targetRotation,
      this.smoothingFactor
    );

    // Rotation physique vers le kite (si kiteEntity disponible)
    const physicalRotation = this.computePhysicalRotation();

    // Pond√©ration entre input et physique (80% input, 20% physique)
    const finalRotation = this.currentRotation * 0.8 + physicalRotation * 0.2;

    // Calculer l'axe de rotation : perpendiculaire au plan d√©fini par l'axe X de la barre et le vecteur vers le kite
    // Cela permet une rotation "dans l'axe" en regardant le kite
    const barDirection = new THREE.Vector3(1, 0, 0); // Axe X local de la barre
    const toKite = this.computeToKiteVector();
    const rotationAxis = new THREE.Vector3().crossVectors(barDirection, toKite);

    // Gestion du cas d√©g√©n√©r√© (axe quasi-nul)
    if (rotationAxis.length() < 0.01) { // PhysicsConstants.CONTROL_DEADZONE
      rotationAxis.set(0, 1, 0); // Fallback vers axe Y vertical
    } else {
      rotationAxis.normalize();
    }

    // Appliquer la rotation autour de cet axe (rotation dans l'axe du regard)
    transform.quaternion.setFromAxisAngle(rotationAxis, finalRotation);

    // Synchroniser avec le mesh Three.js
    mesh.syncToObject3D({
      position: transform.position,
      quaternion: transform.quaternion,
      scale: transform.scale
    });
  }


  /**
   * Obtient les positions des poign√©es (pour le rendu des lignes)
   * Les poign√©es sont aux extr√©mit√©s de la barre et suivent la rotation combin√©e
   * Puisque la barre est un enfant du pilote, on doit calculer les positions dans le monde
   */
  getHandlePositions(): HandlePositions | null {
    if (!this.controlBarEntity) return null;

    const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
    if (!transform) return null;

    // Les poign√©es sont positionn√©es relativement √† la barre
    const halfWidth = CONFIG.controlBar.width / 2;
    const handleLeftLocal = new THREE.Vector3(-halfWidth, 0, 0);
    const handleRightLocal = new THREE.Vector3(halfWidth, 0, 0);

    // Appliquer la rotation de la barre aux positions locales des poign√©es
    handleLeftLocal.applyQuaternion(transform.quaternion);
    handleRightLocal.applyQuaternion(transform.quaternion);

    // Ajouter la position relative de la barre
    handleLeftLocal.add(transform.position);
    handleRightLocal.add(transform.position);

    // Maintenant convertir en coordonn√©es monde : ajouter la position du pilote
    // (puisque la barre est enfant du pilote)
    const pilotPosition = CONFIG.pilot.position;
    handleLeftLocal.add(pilotPosition);
    handleRightLocal.add(pilotPosition);

    return {
      left: handleLeftLocal,
      right: handleRightLocal,
    };
  }

  reset(): void {
    this.currentRotation = 0;

    if (this.controlBarEntity) {
      const transform = this.controlBarEntity.getComponent<TransformComponent>('transform');
      if (transform) {
        // Position relative par rapport au pilote (la barre est enfant du pilote)
        transform.position.set(
          0, // M√™me X que le pilote
          CONFIG.controlBar.offsetY, // Au-dessus du pilote
          CONFIG.controlBar.offsetZ  // Devant le pilote
        );
        // Orientation horizontale par d√©faut vers l'avant (axe Z)
        const defaultAxis = new THREE.Vector3(0, 0, 1);
        transform.quaternion.setFromAxisAngle(defaultAxis, CONFIG.controlBar.barRotation);
      }
    }

    this.logger.info('ControlBarSystem reset', 'ControlBarSystem');
  }

  dispose(): void {
    this.controlBarEntity = null;
    this.inputSystem = null;
    this.logger.info('ControlBarSystem disposed', 'ControlBarSystem');
  }
}


=== simulation/systems/InputSystem.ts ===

/**
 * InputSystem.ts - Syst√®me de gestion des entr√©es utilisateur
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface InputState {
  // Entr√©es analogiques (normalis√©es -1 √† 1)
  barPosition: number; // Position de la barre (-1: tir√©e gauche, 0: neutre, 1: tir√©e droite)
  barVelocity: number; // Vitesse de mouvement de la barre

  // Entr√©es num√©riques
  resetPressed: boolean;
  debugTogglePressed: boolean;

  // √âtat interne
  lastBarPosition: number;
  smoothingFactor: number;
}

export interface InputConfig {
  barSmoothingEnabled: boolean;
  barSmoothingFactor: number; // Facteur de lissage (0-1, plus proche de 1 = plus lisse)
  deadzone: number; // Zone morte pour √©viter les oscillations
  maxBarSpeed: number; // Vitesse maximale de changement de la barre
  keyboardEnabled: boolean;
  mouseEnabled: boolean;
}

export class InputSystem extends BaseSimulationSystem {
  private logger: Logger;
  private inputState: InputState;
  private config: InputConfig;

  // Gestion des √©v√©nements
  private keyStates = new Map<string, boolean>();
  private mousePosition = new THREE.Vector2();
  private mouseButtons = new Map<number, boolean>();

  constructor(config: Partial<InputConfig> = {}) {
    super('InputSystem', 1); // Haute priorit√© (trait√© en premier)

    this.logger = Logger.getInstance();
    this.config = {
      barSmoothingEnabled: true,
      barSmoothingFactor: 0.92, // Plus √©lev√© = plus smooth (0-1)
      deadzone: 0.05,
      maxBarSpeed: 2.0, // unit√©s par seconde
      keyboardEnabled: true,
      mouseEnabled: true,
      ...config
    };

    this.inputState = {
      barPosition: 0,
      barVelocity: 0,
      resetPressed: false,
      debugTogglePressed: false,
      lastBarPosition: 0,
      smoothingFactor: this.config.barSmoothingFactor
    };

    this.setupEventListeners();
  }

  async initialize(): Promise<void> {
    this.logger.info('InputSystem initialized', 'InputSystem');
  }

  update(context: SimulationContext): void {
    // Mettre √† jour l'√©tat des entr√©es
    this.updateKeyboardInput();
    this.updateMouseInput();

    // Calculer la position de la barre avec lissage
    this.updateBarPosition(context.deltaTime);

    // Mettre √† jour les √©tats des boutons (pulse)
    this.updateButtonStates();
  }

  /**
   * Configure les √©couteurs d'√©v√©nements
   */
  private setupEventListeners(): void {
    if (typeof window === 'undefined') return;

    // √âcouteurs clavier
    if (this.config.keyboardEnabled) {
      window.addEventListener('keydown', this.onKeyDown.bind(this));
      window.addEventListener('keyup', this.onKeyUp.bind(this));
    }

    // √âcouteurs souris
    if (this.config.mouseEnabled) {
      window.addEventListener('mousemove', this.onMouseMove.bind(this));
      window.addEventListener('mousedown', this.onMouseDown.bind(this));
      window.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
  }

  /**
   * Gestionnaire d'√©v√©nement clavier (appui)
   */
  private onKeyDown(event: KeyboardEvent): void {
    this.keyStates.set(event.code, true);

    // Emp√™cher le comportement par d√©faut pour certaines touches
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyR'].includes(event.code)) {
      event.preventDefault();
    }
  }

  /**
   * Gestionnaire d'√©v√©nement clavier (rel√¢chement)
   */
  private onKeyUp(event: KeyboardEvent): void {
    this.keyStates.set(event.code, false);
  }

  /**
   * Gestionnaire de mouvement de souris
   */
  private onMouseMove(event: MouseEvent): void {
    this.mousePosition.set(event.clientX, event.clientY);
  }

  /**
   * Gestionnaire d'appui souris
   */
  private onMouseDown(event: MouseEvent): void {
    this.mouseButtons.set(event.button, true);
  }

  /**
   * Gestionnaire de rel√¢chement souris
   */
  private onMouseUp(event: MouseEvent): void {
    this.mouseButtons.set(event.button, false);
  }

  /**
   * Met √† jour les entr√©es clavier
   */
  private updateKeyboardInput(): void {
    // Contr√¥le de la barre avec les fl√®ches gauche/droite
    // Input brut de l'utilisateur (instantan√©)
    let rawInput = 0;

    if (this.keyStates.get('ArrowLeft')) {
      rawInput = -1; // Barre tir√©e √† gauche
    } else if (this.keyStates.get('ArrowRight')) {
      rawInput = 1; // Barre tir√©e √† droite
    }

    // Appliquer la zone morte
    if (Math.abs(rawInput) < this.config.deadzone) {
      rawInput = 0;
    }

    // Stocker l'input brut (sans smoothing)
    // Le smoothing sera fait dans ControlBarSystem
    this.inputState.barPosition = rawInput;

    // Boutons pulse
    this.inputState.resetPressed = this.keyStates.get('KeyR') || false;
    this.inputState.debugTogglePressed = this.keyStates.get('KeyD') || false;
  }

  /**
   * Met √† jour les entr√©es souris (r√©serv√© pour extension future)
   */
  private updateMouseInput(): void {
    // Pour l'instant, la souris n'est pas utilis√©e pour le contr√¥le principal
    // Mais on pourrait l'utiliser pour un contr√¥le plus fin
  }

  /**
   * Met √† jour la position de la barre (pas de smoothing ici, fait dans ControlBarSystem)
   */
  private updateBarPosition(deltaTime: number): void {
    // L'input est d√©j√† dans barPosition (brut)
    // Le smoothing sera appliqu√© dans ControlBarSystem sur la rotation physique

    // Calculer la vitesse de changement
    this.inputState.barVelocity = (this.inputState.barPosition - this.inputState.lastBarPosition) / deltaTime;
    this.inputState.lastBarPosition = this.inputState.barPosition;

    // Limiter la vitesse maximale
    if (Math.abs(this.inputState.barVelocity) > this.config.maxBarSpeed) {
      this.inputState.barVelocity = Math.sign(this.inputState.barVelocity) * this.config.maxBarSpeed;
    }
  }

  /**
   * Met √† jour les √©tats des boutons (pulse - seulement true pendant un frame)
   */
  private updateButtonStates(): void {
    // Pour l'instant, pas de logique pulse n√©cessaire car on utilise directement les keyStates
    // Mais on pourrait impl√©menter une logique de pulse ici si n√©cessaire
  }

  /**
   * Obtient l'√©tat actuel des entr√©es
   */
  getInputState(): Readonly<InputState> {
    return this.inputState;
  }

  /**
   * Force une position de barre (pour debug ou automation)
   */
  setBarPosition(position: number): void {
    this.inputState.barPosition = THREE.MathUtils.clamp(position, -1, 1);
    this.inputState.lastBarPosition = this.inputState.barPosition;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<InputConfig> {
    return this.config;
  }

  reset(): void {
    this.inputState.barPosition = 0;
    this.inputState.barVelocity = 0;
    this.inputState.lastBarPosition = 0;
    this.inputState.resetPressed = false;
    this.inputState.debugTogglePressed = false;

    // R√©initialiser les √©tats des touches
    this.keyStates.clear();
    this.mouseButtons.clear();

    this.logger.info('InputSystem reset', 'InputSystem');
  }

  dispose(): void {
    // Supprimer les √©couteurs d'√©v√©nements
    if (typeof window !== 'undefined') {
      window.removeEventListener('keydown', this.onKeyDown.bind(this));
      window.removeEventListener('keyup', this.onKeyUp.bind(this));
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('mousedown', this.onMouseDown.bind(this));
      window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }

    this.logger.info('InputSystem disposed', 'InputSystem');
  }
}

=== simulation/systems/KitePhysicsSystem.ts ===

/**
 * KitePhysicsSystem.ts - Syst√®me physique complet pour le kite
 *
 * Int√®gre tous les composants physiques existants dans l'architecture ECS:
 * - WindSimulator (vent apparent)
 * - AerodynamicsCalculator (forces a√©ro)
 * - LineSystem (contraintes lignes)
 * - BridleSystem (contraintes brides)
 * - ConstraintSolver (PBD)
 * - KiteController (int√©gration)
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { CONFIG } from '../config/SimulationConfig';
import { PhysicsConstants } from '../config/PhysicsConstants';
import { Kite } from '../../objects/Kite';
import { KiteState, WindState, SurfaceForce, WindParams, HandlePositions } from '../types';
import { WindSimulator } from '../physics/WindSimulator';
import { LineSystem } from '../physics/LineSystem';
import { BridleSystem } from '../physics/BridleSystem';
import { AerodynamicsCalculator } from '../physics/AerodynamicsCalculator';
import { FlightSphere } from '../physics/ConstraintSolver';

import { KiteController } from '@/simulation/controllers/KiteController';

export interface KitePhysicsHandles {
  getHandlePositions: () => HandlePositions | null;
}

export interface KitePhysicsConfig {
  windSpeed: number; // km/h
  windDirection: number; // degr√©s
  turbulence: number; // 0-100
  lineLength: number;
  pilotPosition: THREE.Vector3;
  enableConstraints: boolean;
  enableAerodynamics: boolean;
  enableGravity: boolean;
  linearDampingCoeff: number;
  angularDragFactor: number;
}

/**
 * Syst√®me physique complet du kite
 * Int√®gre tous les sous-syst√®mes dans une architecture coh√©rente
 */
export class KitePhysicsSystem extends BaseSimulationSystem {
  private logger: Logger;
  private config: KitePhysicsConfig;

  // Composants physiques
  private windSimulator!: WindSimulator;
  private lineSystem!: LineSystem;
  private bridleSystem!: BridleSystem;
  private kiteController!: KiteController;

  // R√©f√©rence au kite
  private kite!: Kite;

  // √âtat de rotation de la barre
  private barRotation: number = 0;

  // R√©f√©rence au syst√®me de barre de contr√¥le (pour obtenir les positions des poign√©es)
  private handlesProvider: KitePhysicsHandles | null = null;

  // Forces a√©rodynamiques pour le log et l'UI
  private lastLiftForce: THREE.Vector3 = new THREE.Vector3();
  private lastDragForce: THREE.Vector3 = new THREE.Vector3();
  private lastSurfaceForces: SurfaceForce[] = []; // Ajout pour stocker les forces par surface

  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = CONFIG.conversions.gravityFactor * 1000; // Log toutes les secondes
  private startTime: number = Date.now();
  private frameCount: number = 0;

  // Sph√®re de vol (pour instrumentation)
  private flightSphere: FlightSphere | null = null;

  constructor(config: Partial<KitePhysicsConfig> = {}) {
    super('KitePhysicsSystem', 10);

    this.logger = Logger.getInstance();
    this.config = {
      windSpeed: CONFIG.wind.defaultSpeed, // km/h
      windDirection: CONFIG.wind.defaultDirection, // degr√©s
      turbulence: CONFIG.wind.defaultTurbulence, // 0-100
      lineLength: CONFIG.lines.defaultLength,
      pilotPosition: new THREE.Vector3(CONFIG.pilot.position.x, CONFIG.pilot.position.y + CONFIG.controlBar.offsetY, CONFIG.pilot.position.z + CONFIG.controlBar.offsetZ),
      enableConstraints: true,
      enableAerodynamics: true,
      enableGravity: true,
      linearDampingCoeff: CONFIG.physics.linearDampingCoeff, // Utiliser CONFIG
      angularDragFactor: CONFIG.physics.angularDragFactor, // Utiliser CONFIG
      ...config
    };
  }

  /**
   * Initialise le syst√®me (sans le kite, qui est pass√© via setKite)
   */
  async initialize(): Promise<void> {
    this.logger.info('KitePhysicsSystem initialized', 'KitePhysicsSystem');
    // Le kite sera d√©fini via setKite() avant le premier update
  }

  /**
   * Initialise tous les composants physiques
   */
  private async initializeComponents(): Promise<void> {
    // Cr√©er WindSimulator
    this.windSimulator = new WindSimulator();
    this.windSimulator.setParams({
      speed: this.config.windSpeed,
      direction: this.config.windDirection,
      turbulence: this.config.turbulence
    });

    // Cr√©er LineSystem
    this.lineSystem = new LineSystem(this.config.lineLength);

    // Cr√©er BridleSystem
    this.bridleSystem = new BridleSystem(this.kite.getBridleLengths());

    // Cr√©er KiteController
    this.kiteController = new KiteController(this.kite);
    this.kiteController.setForceSmoothing(this.config.linearDampingCoeff); // Appliquer le damping lin√©aire

    this.logger.info('All physics components initialized', 'KitePhysicsSystem');
  }

  /**
   * Configure le fournisseur de positions des poign√©es (ControlBarSystem)
   */
  setHandlesProvider(provider: KitePhysicsHandles): void {
    this.handlesProvider = provider;
  }

  /**
   * Met √† jour le kite (doit √™tre appel√© avant le premier update)
   */
  setKite(kite: Kite): void {
    this.kite = kite;

    // R√©initialiser les composants avec le nouveau kite
    if (kite) {
      this.initializeComponents();
    }
  }

  /**
   * D√©finit la rotation de la barre de contr√¥le
   */
  setBarRotation(rotation: number): void {
    this.barRotation = rotation;
  }

  /**
   * Mise √† jour de la physique compl√®te
   */
  update(context: SimulationContext): void {
    if (!this.kite || !this.kiteController) {
      return;
    }

    const deltaTime = Math.min(context.deltaTime, CONFIG.physics.deltaTimeMax);

    // 1. Obtenir l'√©tat actuel du kite
    const kiteState = this.kiteController.getState();
    const handles = this.handlesProvider?.getHandlePositions() || null;

    // Si pas de poign√©es disponibles, on ne peut pas calculer la physique
    if (!handles) {
      return;
    }

    // 3. Calculer le vent apparent (vent r√©el - vitesse du kite)
    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );

    // 4. Calculer les forces a√©rodynamiques
    let aeroForces: { lift: THREE.Vector3; drag: THREE.Vector3; gravity: THREE.Vector3; torque: THREE.Vector3; surfaceForces: SurfaceForce[] };

    if (this.config.enableAerodynamics) {
      aeroForces = AerodynamicsCalculator.calculateForces(
        apparentWind,
        this.kite.quaternion,
        this.kite.position,
        kiteState.velocity,
        kiteState.angularVelocity
      );
      this.lastLiftForce.copy(aeroForces.lift);
      this.lastDragForce.copy(aeroForces.drag);
      this.lastSurfaceForces = aeroForces.surfaceForces; // Stocker les forces
    } else {
      aeroForces = {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),
        torque: new THREE.Vector3(),
        surfaceForces: []
      };
      this.lastLiftForce.set(0, 0, 0);
      this.lastDragForce.set(0, 0, 0);
      this.lastSurfaceForces = []; // Vider le tableau
    }

    // 5. Combiner toutes les forces
    const totalForce = new THREE.Vector3()
      .add(aeroForces.lift)
      .add(aeroForces.drag);

    // Ajouter la gravit√© si activ√©e
    if (this.config.enableGravity && aeroForces.gravity) {
      totalForce.add(aeroForces.gravity);
    }

    // 6. Calculer les tensions des lignes (pour visualisation)
    this.lineSystem.calculateLineTensions(
      this.kite,
      handles,
      deltaTime
    );

    // 7. Calculer les tensions des brides (pour visualisation)
    const bridleTensions = this.bridleSystem.calculateBridleTensions(this.kite);

    // 8. Mettre √† jour la visualisation des brides
    this.kite.updateBridleVisualization(bridleTensions);

    // Capturer les tensions pour instrumentation avant int√©gration
    const lineTensions = this.lineSystem.getTensions();

    // 9. Mettre √† jour le contr√¥leur du kite
    // Note: Le KiteController int√®gre automatiquement les contraintes via ConstraintSolver
    this.kiteController.update(
      totalForce,
      aeroForces.torque,
      handles,
      deltaTime
    );

    // 10. Mettre √† jour les lignes de bridage visuelles (apr√®s que les points aient boug√©)
    this.kite.updateBridleLines();

    // 11. G√©rer la collision au sol (sp√©cifique au kite)
    this.handleGroundCollision(deltaTime);

    // üìä LOG COMPLET toutes les secondes
    this.frameCount++;
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;
      this.logPhysicsState(
        this.kite,
        this.kiteController.getState(),
        apparentWind,
        {
          lift: aeroForces.lift,
          drag: aeroForces.drag,
          gravity: aeroForces.gravity,
          total: totalForce,
          torque: aeroForces.torque
        },
        lineTensions,
        bridleTensions,
        deltaTime,
        currentTime
      );
    }
  }

  private logPhysicsState(
    kite: Kite,
    kiteState: KiteState,
    apparentWind: THREE.Vector3,
    forces: {
      lift: THREE.Vector3;
      drag: THREE.Vector3;
      gravity: THREE.Vector3;
      total: THREE.Vector3;
      torque: THREE.Vector3;
    },
    lineTensions: { left: number; right: number },
    bridleTensions: ReturnType<BridleSystem['calculateBridleTensions']>,
    deltaTime: number,
    currentTime: number
  ): void {
    if (!this.config.enableAerodynamics) {
      return;
    }

    const elapsedTime = (currentTime - this.startTime) / (CONFIG.conversions.gravityFactor * 1000);
    const safeDelta = Math.max(deltaTime, CONFIG.thresholds.epsilonFine);
    const fps = 1 / safeDelta;

    const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
    const pitch = euler.x * CONFIG.conversions.radToDeg;
    const roll = euler.z * CONFIG.conversions.radToDeg;
    const yaw = euler.y * CONFIG.conversions.radToDeg;

    const liftMag = forces.lift.length();
    const dragMag = forces.drag.length();
    forces.gravity.length();
    const totalForceMag = forces.total.length();
    forces.torque.length();

    forces.total.clone().divideScalar(CONFIG.kite.mass);
    dragMag > PhysicsConstants.EPSILON ? liftMag / dragMag : 0;

    const leftTension = lineTensions.left;
    const rightTension = lineTensions.right;
    const tensionDelta = leftTension - rightTension;
    const dominantTension = Math.max(Math.abs(leftTension), Math.abs(rightTension), PhysicsConstants.EPSILON);
    (tensionDelta / dominantTension) * 100;

    this.logger.debug(`Kite Physics State - Frame #${this.frameCount}:
      Time: ${elapsedTime.toFixed(3)}s | Œît: ${(safeDelta * 1000).toFixed(2)}ms | FPS: ${fps.toFixed(1)}
      Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m | Dist: ${kite.position.length().toFixed(2)} m
      Angles: Pitch ${pitch.toFixed(1)}¬∞ | Roll ${roll.toFixed(1)}¬∞ | Yaw ${yaw.toFixed(1)}¬∞
      Velocity: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s
      Wind: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s
      Forces - Lift: ${liftMag.toFixed(2)}N, Drag: ${dragMag.toFixed(2)}N, Total: ${totalForceMag.toFixed(2)}N
      Tensions - Lines: L:${leftTension.toFixed(2)}N R:${rightTension.toFixed(2)}N | Brides: NEZ ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)}N`, 'KitePhysicsSystem');
  }

  /**
   * G√®re la collision du kite avec le sol
   * Utilise les points anatomiques du kite pour une d√©tection plus pr√©cise
   */
  private handleGroundCollision(deltaTime: number): void {
    const groundY = CONFIG.kite.minHeight;
    const restitution = CONFIG.defaults.restitutionFactor;
    const frictionCoeff = CONFIG.defaults.groundFriction;

    const kiteState = this.kiteController.getState();
    const kitePosition = kiteState.position.clone();
    const kiteVelocity = kiteState.velocity.clone();
    const kiteAngularVelocity = kiteState.angularVelocity.clone();

    let hasCollision = false;
    const contactPoints: THREE.Vector3[] = [];

    // V√©rifier les points anatomiques cl√©s du kite pour la collision
    // On peut choisir des points comme les extr√©mit√©s des lattes, le nez, la queue, etc.
    const pointsToCheck = [
      this.kite.getPoint('NEZ'),
      this.kite.getPoint('SPINE_BAS'),
      this.kite.getPoint('BORD_GAUCHE'), // Utiliser BORD_GAUCHE et BORD_DROIT
      this.kite.getPoint('BORD_DROIT'),
      this.kite.getPoint('WHISKER_GAUCHE'),
      this.kite.getPoint('WHISKER_DROIT'),
    ].filter(p => p !== undefined) as THREE.Vector3[];

    for (const localPoint of pointsToCheck) {
      const worldPoint = localPoint.clone().applyQuaternion(this.kite.quaternion).add(kitePosition);

      if (worldPoint.y <= groundY) {
        hasCollision = true;
        contactPoints.push(worldPoint);

        // Ajuster la position pour qu'elle soit sur le sol
        const penetrationDepth = groundY - worldPoint.y;
        kitePosition.y += penetrationDepth; // Pousse le kite hors du sol

        // Calculer la vitesse du point de contact
        const r = worldPoint.clone().sub(kitePosition); // Vecteur du centre de masse au point de contact
        const pointVelocity = kiteVelocity.clone().add(kiteAngularVelocity.clone().cross(r));

        // Appliquer la force de r√©action normale (rebond)
        if (pointVelocity.y < 0) {
          const normalImpulse = -pointVelocity.y * (1 + restitution);
          kiteVelocity.y += normalImpulse; // Applique l'impulsion au centre de masse
        }

        // Appliquer la force de friction
        const horizontalVelocity = new THREE.Vector3(pointVelocity.x, 0, pointVelocity.z);
        if (horizontalVelocity.lengthSq() > PhysicsConstants.EPSILON) {
          const frictionForce = horizontalVelocity.clone().normalize().multiplyScalar(-frictionCoeff * horizontalVelocity.length());
          kiteVelocity.add(frictionForce.multiplyScalar(deltaTime)); // Applique la friction au centre de masse
        }
      }
    }

    if (hasCollision) {
      // Mettre √† jour l'√©tat du kite avec les nouvelles vitesses et position
      this.kiteController.getState().position.copy(kitePosition);
      this.kiteController.getState().velocity.copy(kiteVelocity);
      this.kiteController.getState().angularVelocity.copy(kiteAngularVelocity);

      // Si la vitesse verticale est tr√®s faible, l'annuler pour √©viter les micro-rebonds
      if (Math.abs(kiteVelocity.y) < PhysicsConstants.EPSILON) {
        this.kiteController.getState().velocity.y = 0;
      }
    }
  }

  /**
   * Obtient l'√©tat du vent
   */
  getWindState(): WindState {
    if (!this.windSimulator) {
      return { baseSpeed: 0, baseDirection: new THREE.Vector3(), turbulence: 0, gustFrequency: 0, gustAmplitude: 0, time: 0 };
    }

    const windParams = this.windSimulator.getParams();
    return {
      baseSpeed: windParams.speed / 3.6, // Convertir km/h en m/s pour affichage
      baseDirection: new THREE.Vector3(Math.sin((windParams.direction * Math.PI) / 180), 0, -Math.cos((windParams.direction * Math.PI) / 180)),
      turbulence: windParams.turbulence,
      gustFrequency: 0, // Non expos√© par WindSimulator.getParams()
      gustAmplitude: 0, // Non expos√© par WindSimulator.getParams()
      time: 0 // Non expos√© par WindSimulator.getParams()
    };
  }

  /**
   * Obtient l'√©tat du kite
   */
  getKiteState(): KiteState {
    return this.kiteController ? this.kiteController.getState() : {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: new THREE.Quaternion() // Ajout√© orientation
    };
  }

  /**
   * Met √† jour les param√®tres du vent
   */
  setWindParams(params: Partial<WindParams>): void {
    if (!this.windSimulator) return;

    const windParams: Partial<WindParams> = {};

    if (params.speed !== undefined) {
      windParams.speed = params.speed; // km/h
      this.config.windSpeed = params.speed;
    }
    if (params.direction !== undefined) {
      windParams.direction = params.direction; // degr√©s
      this.config.windDirection = params.direction;
    }
    if (params.turbulence !== undefined) {
      windParams.turbulence = params.turbulence; // 0-100
      this.config.turbulence = params.turbulence;
    }

    this.windSimulator.setParams(windParams);
  }

  /**
   * Met √† jour la longueur des lignes
   */
  setLineLength(length: number): void {
    this.config.lineLength = length;
    if (this.kite) {
      this.kite.userData.lineLength = length;
    }
    if (this.lineSystem) {
      this.lineSystem.setLineLength(length);
    }
  }

  /**
   * Met √† jour les longueurs des brides
   */
  setBridleLengths(lengths: { nez: number; inter: number; centre: number }): void {
    if (this.kite) {
      this.kite.setBridleLengths(lengths);
      // Recr√©er le BridleSystem avec les nouvelles longueurs
      this.bridleSystem = new BridleSystem(lengths);
    }
  }

  /**
   * Obtient les longueurs actuelles des brides
   */
  getBridleLengths(): { nez: number; inter: number; centre: number } {
    return this.bridleSystem ? this.bridleSystem.getBridleLengths() : { nez: 0, inter: 0, centre: 0 };
  }

  /**
   * Met √† jour le lissage des forces
   */
  setForceSmoothing(rate: number): void {
    this.config.linearDampingCoeff = rate;
    if (this.kiteController) {
      this.kiteController.setForceSmoothing(rate);
    }
  }

  /**
   * Obtient le lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController ? this.kiteController.getForceSmoothing() : this.config.linearDampingCoeff;
  }

  /**
   * Obtient les statistiques du syst√®me
   */
  getStats(): any {
    const kiteState = this.getKiteState();
    const windState = this.getWindState();

    return {
      kite: kiteState,
      wind: windState,
      barRotation: this.barRotation,
      config: this.config,
      lineTensions: this.lineSystem.getTensions(),
      bridleTensions: this.bridleSystem.getStats(),
      kiteWarnings: this.kiteController.getWarnings(),
      lastLiftForce: this.lastLiftForce.clone(),
      lastDragForce: this.lastDragForce.clone()
    };
  }

  /**
   * Accesseurs pour les composants (n√©cessaires pour DebugRenderer)
   */
  getKiteController(): KiteController {
    return this.kiteController;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getBridleSystem(): BridleSystem {
    return this.bridleSystem;
  }

  /**
   * Retourne les forces a√©rodynamiques actuelles (lift et drag)
   * @returns Objet contenant les vecteurs de force de portance et de tra√Æn√©e
   */
  getAerodynamicForces(): { lift: THREE.Vector3; drag: THREE.Vector3 } {
    return {
      lift: this.lastLiftForce.clone(),
      drag: this.lastDragForce.clone()
    };
  }

  /**
   * Retourne les forces a√©rodynamiques par surface (pour le debug)
   */
  getSurfaceForces(): SurfaceForce[] {
    return this.lastSurfaceForces;
  }

  /**
   * Retourne les diagnostics complets des lignes de contr√¥le
   * @returns Diagnostics incluant longueurs, tensions et √©tats
   */
  getControlLineDiagnostics(): {
    lineLength: number;
    leftDistance: number;
    rightDistance: number;
    leftTaut: boolean;
    rightTaut: boolean;
    leftTension: number;
    rightTension: number;
  } | null {
    if (!this.lineSystem) return null;

    const distances = this.lineSystem.getDistances();
    const tensions = this.lineSystem.getTensions();
    const states = this.lineSystem.getLineStates();

    return {
      lineLength: this.lineSystem.lineLength,
      leftDistance: distances.left,
      rightDistance: distances.right,
      leftTaut: states.leftTaut,
      rightTaut: states.rightTaut,
      leftTension: tensions.left,
      rightTension: tensions.right
    };
  }

  getKite(): Kite | null {
    return this.kite || null;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  reset(): void {
    // R√©initialiser le kiteController
    if (this.kite) {
      this.kiteController = new KiteController(this.kite);
      this.kiteController.setForceSmoothing(this.config.linearDampingCoeff);
      
      // Calculer la position initiale avec lignes tendues
      const initialPos = MathUtils.calculateInitialKitePosition(
        this.config.pilotPosition,
        CONFIG.initialization.initialKiteY,
        CONFIG.lines.defaultLength,
        CONFIG.initialization.initialDistanceFactor,
        CONFIG.initialization.initialKiteZ
      );
      
      // R√©initialiser la position et l'orientation du kite
      this.kite.position.copy(initialPos);
      this.kite.rotation.set(0, 0, 0);
      this.kite.quaternion.identity();
    }

    // R√©initialiser la rotation de la barre
    this.barRotation = 0;

    // R√©initialiser les sous-syst√®mes
    if (this.windSimulator) {
      const simulator = this.windSimulator as unknown as { reset?: () => void };
      if (typeof simulator.reset === 'function') {
        simulator.reset();
      }
      this.windSimulator.setParams({
        speed: this.config.windSpeed,
        direction: this.config.windDirection,
        turbulence: this.config.turbulence
      });
    }
    if (this.lineSystem) {
      this.lineSystem.setLineLength(this.config.lineLength);
      // this.lineSystem.resetAll(); // Supprim√© car LineSystem n'a pas de resetAll
    }
    if (this.bridleSystem && this.kite) {
      this.bridleSystem = new BridleSystem(this.kite.getBridleLengths());
    }

    // R√©initialiser les compteurs
    this.frameCount = 0;
    this.startTime = Date.now();
    this.lastLogTime = 0;

    this.logger.info('KitePhysicsSystem reset', 'KitePhysicsSystem');
  }

  /**
   * Retourne les informations de debug
   */
  getDebugInfo(): any {
    return {
      kitePosition: this.kite?.position?.clone(),
      kiteVelocity: this.kiteController?.getState()?.velocity?.clone(),
      windSpeed: this.windSimulator?.getParams()?.speed,
      liftForce: this.lastLiftForce.clone(),
      dragForce: this.lastDragForce.clone(),
      lineTensions: this.lineSystem?.getTensions(),
      bridleLengths: this.kite?.getBridleLengths()
    };
  }

  dispose(): void {
    // Pas de ressources sp√©cifiques √† disposer pour l'instant
    this.logger.info('KitePhysicsSystem disposed', 'KitePhysicsSystem');
  }
}


=== simulation/systems/LinesRenderSystem.ts ===

/**
 * LinesRenderSystem.ts - Syst√®me ECS pour le rendu des lignes de contr√¥le
 *
 * Responsabilit√©s :
 *   - G√®re les entit√©s de lignes de contr√¥le (gauche et droite)
 *   - Met √† jour la g√©om√©trie des lignes en fonction des positions du kite et de la barre
 *   - Applique une courbure r√©aliste aux lignes (cat√©naire)
 *
 * Architecture ECS :
 *   - Op√®re sur des LineEntity avec TransformComponent et MeshComponent
 *   - Lit les positions depuis ControlBarSystem et Kite
 *   - Met √† jour les BufferGeometry THREE.js pour le rendu
 */

// External libraries
import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { CONFIG } from '../config/SimulationConfig';
import { Kite } from '../../objects/Kite';
import { MeshComponent } from '../components/MeshComponent';
import { Entity } from '../entities/Entity';
import { LineEntity } from '../entities/LineEntity';

import { ControlBarSystem } from './ControlBarSystem';
import { KitePhysicsSystem } from './KitePhysicsSystem';

/**
 * Composant sp√©cifique aux lignes pour stocker leurs param√®tres
 */
export interface LineComponentData {
  segments: number;
  color: number;
  linewidth: number;
  side: 'left' | 'right';
}

export class LinesRenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private lineEntities: Map<string, Entity> = new Map();
  private kite: Kite | null = null;
  private controlBarSystem: ControlBarSystem | null = null;
  private kitePhysicsSystem: KitePhysicsSystem | null = null;

  constructor() {
    super('LinesRenderSystem', 6); // Apr√®s ControlBarSystem, avant RenderSystem
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    this.logger.info('LinesRenderSystem initialized', 'LinesRenderSystem');
  }

  /**
   * Enregistre une entit√© de ligne
   */
  registerLineEntity(id: string, entity: Entity, data: LineComponentData): void {
    if (!entity.hasComponent('mesh')) {
      throw new Error('LineEntity must have a Mesh component');
    }

    // Stocker les donn√©es de ligne dans l'entit√©
    entity.addComponent({
      type: 'line',
      ...data
    });

    this.lineEntities.set(id, entity);
  }

  /**
   * D√©finit la r√©f√©rence au kite (temporaire)
   */
  setKite(kite: Kite): void {
    this.kite = kite;
  }

  /**
   * D√©finit la r√©f√©rence au syst√®me de barre de contr√¥le
   */
  setControlBarSystem(system: ControlBarSystem): void {
    this.controlBarSystem = system;
  }

  /**
   * D√©finit la r√©f√©rence au syst√®me de physique du kite (pour acc√©der aux tensions)
   */
  setKitePhysicsSystem(system: KitePhysicsSystem): void {
    this.kitePhysicsSystem = system;
  }

  update(_context: SimulationContext): void {
    if (!this.kite || !this.controlBarSystem) {
      console.warn('üî¥ LinesRenderSystem: kite ou controlBarSystem manquant');
      return;
    }

    // R√©cup√©rer les positions des poign√©es
    const handles = this.controlBarSystem.getHandlePositions();
    if (!handles) {
      console.warn('üî¥ LinesRenderSystem: handles manquants');
      return;
    }

    // R√©cup√©rer les points de contr√¥le du kite
    const ctrlLeft = this.kite.getPoint('CTRL_GAUCHE');
    const ctrlRight = this.kite.getPoint('CTRL_DROIT');

    if (!ctrlLeft || !ctrlRight) {
      console.warn('üî¥ LinesRenderSystem: points de contr√¥le kite manquants');
      return;
    }

    const ctrlLeftWorld = this.kite.toWorldCoordinates(ctrlLeft);
    const ctrlRightWorld = this.kite.toWorldCoordinates(ctrlRight);

    // üîç DEBUG : Log une fois toutes les 60 frames (1 fois par seconde √† 60fps)
    if (_context.totalTime % 1 < 0.016) {
      console.log('‚úÖ LinesRenderSystem update:', {
        lineCount: this.lineEntities.size,
        handleLeft: handles.left.toArray(),
        handleRight: handles.right.toArray(),
        ctrlLeft: ctrlLeftWorld.toArray(),
        ctrlRight: ctrlRightWorld.toArray()
      });
    }

    // Mettre √† jour chaque ligne
    this.lineEntities.forEach((entity) => {
      const lineData = entity.getComponent<any>('line');
      const mesh = entity.getComponent<MeshComponent>('mesh');

      if (!lineData || !mesh) return;

      // D√©terminer les points de d√©part et d'arriv√©e selon le c√¥t√©
      // Les lignes partent de la barre de contr√¥le vers le kite
      const start = lineData.side === 'left' ? handles.left : handles.right;
      const end = lineData.side === 'left' ? ctrlLeftWorld : ctrlRightWorld;

      // Mettre √† jour la g√©om√©trie
      this.updateLineGeometry(
        mesh.object3D as THREE.Mesh,
        start,
        end,
        lineData.segments
      );

      // Mettre √† jour la couleur bas√©e sur les tensions physiques √©mergentes
      this.updateLineColorFromTension(mesh.object3D as THREE.Mesh, lineData.side);
    });
  }

  /**
   * Met √† jour la g√©om√©trie d'une ligne avec une courbe r√©aliste
   */
  private updateLineGeometry(
    line: THREE.Mesh,
    start: THREE.Vector3,
    end: THREE.Vector3,
    segments: number
  ): void {
    const tubeMesh = line as THREE.Mesh;

    // Cr√©er une nouvelle courbe pour le tube
    const points: THREE.Vector3[] = [];

    // Calculer la distance et la direction
    const direction = new THREE.Vector3().subVectors(end, start);
    const distance = direction.length();

    // Facteur de courbure (simule la gravit√© et la tension)
    const sag = distance * CONFIG.defaults.catenarySagFactor;

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Interpolation lin√©aire de base
      const x = start.x + direction.x * t;
      const y = start.y + direction.y * t;
      const z = start.z + direction.z * t;

      // Ajouter une courbure parabolique (cat√©naire simplifi√©e)
      // Maximum au milieu (t = 0.5)
      const curvature = -sag * 4 * t * (1 - t);

      points.push(new THREE.Vector3(x, y + curvature, z));
    }

    // Cr√©er une nouvelle courbe et g√©om√©trie de tube
    const curve = new THREE.CatmullRomCurve3(points);
    const newTubeGeometry = new THREE.TubeGeometry(
      curve,
      segments,
      CONFIG.defaults.tubeRadius, // Utilise la valeur de config (0.015)
      CONFIG.defaults.tubeRadialSegments,
      false
    );

    // Remplacer la g√©om√©trie
    if (tubeMesh.geometry) {
      tubeMesh.geometry.dispose();
    }
    tubeMesh.geometry = newTubeGeometry;
  }

  /**
   * Met √† jour la couleur de la ligne bas√©e sur les tensions physiques √©mergentes
   * Respecte le principe : vert (molle) ‚Üí jaune (moyenne) ‚Üí rouge (tendue)
   */
  private updateLineColorFromTension(line: THREE.Mesh, side: 'left' | 'right'): void {
    if (!this.kitePhysicsSystem) return;

    // R√©cup√©rer les informations de debug du syst√®me physique
    const debugInfo = this.kitePhysicsSystem.getDebugInfo?.();
    if (!debugInfo || !debugInfo.lineTensions) return;

    // Calculer la tension pour ce c√¥t√© (√©mergente des contraintes physiques)
    const tension = side === 'left' ? debugInfo.lineTensions.left : debugInfo.lineTensions.right;

    // Calculer la couleur bas√©e sur les seuils physiques d√©finis dans CONFIG
    const color = this.calculateTensionColor(tension);

    // Appliquer la couleur au mat√©riau du tube
    const material = line.material as THREE.MeshStandardMaterial;
    if (material && material.color) {
      material.color.setHex(color);
    }
  }

  /**
   * Calcule la couleur bas√©e sur la tension selon les principes physiques
   * Vert (faible tension) ‚Üí Jaune (tension moyenne) ‚Üí Rouge (forte tension)
   */
  private calculateTensionColor(tension: number): number {
    const { bridleTensionMedium, bridleTensionHigh } = CONFIG.debug;

    // Normaliser la tension entre 0 et 1
    const normalizedTension = Math.min(tension / bridleTensionHigh, 1);

    if (normalizedTension <= 0) {
      return 0x00ff00; // Vert - tension nulle/mollesse
    } else if (normalizedTension < bridleTensionMedium / bridleTensionHigh) {
      // Interpolation vert ‚Üí jaune pour tensions faibles √† moyennes
      const t = normalizedTension / (bridleTensionMedium / bridleTensionHigh);
      const r = Math.round(255 * t);     // 0 ‚Üí 255 (vert ‚Üí jaune)
      const g = 255;                    // 255 ‚Üí 255 (vert ‚Üí jaune)
      const b = 0;                      // 0 ‚Üí 0 (vert ‚Üí jaune)
      return (r << 16) | (g << 8) | b;
    } else {
      // Interpolation jaune ‚Üí rouge pour tensions moyennes √† √©lev√©es
      const t = (normalizedTension - bridleTensionMedium / bridleTensionHigh) /
                (1 - bridleTensionMedium / bridleTensionHigh);
      const r = 255;                    // 255 ‚Üí 255 (jaune ‚Üí rouge)
      const g = Math.round(255 * (1 - t)); // 255 ‚Üí 0 (jaune ‚Üí rouge)
      const b = 0;                      // 0 ‚Üí 0 (jaune ‚Üí rouge)
      return (r << 16) | (g << 8) | b;
    }
  }

  /**
   * Cr√©e une entit√© de ligne
   */
  createLineEntity(
    id: string,
    side: 'left' | 'right',
    scene: THREE.Scene
  ): LineEntity {
    const entity = new LineEntity(side);

    // R√©cup√©rer le mesh cr√©√© par LineEntity et l'ajouter √† la sc√®ne
    const mesh = entity.getComponent<MeshComponent>('mesh');
    if (mesh) {
      scene.add(mesh.object3D);
      const tubeMesh = mesh.object3D as THREE.Mesh;
      const material = tubeMesh.material as THREE.MeshStandardMaterial;
      console.log(`‚úÖ Ligne ${side} ajout√©e √† la sc√®ne:`, {
        id,
        position: mesh.object3D.position.toArray(),
        visible: mesh.object3D.visible,
        geometry: tubeMesh.geometry.type,
        material: material.type,
        color: material.color.getHexString()
      });
    } else {
      console.error(`üî¥ Ligne ${side}: mesh component manquant!`);
    }

    // Enregistrer l'entit√©
    this.registerLineEntity(id, entity, {
      segments: CONFIG.defaults.meshSegments,
      color: CONFIG.colors.controlBar,
      linewidth: CONFIG.rendering.lineWidth,
      side
    });

    return entity;
  }

  /**
   * Supprime une entit√© de ligne
   */
  removeLineEntity(id: string, scene: THREE.Scene): void {
    const entity = this.lineEntities.get(id);
    if (!entity) return;

    const mesh = entity.getComponent<MeshComponent>('mesh');
    if (mesh) {
      scene.remove(mesh.object3D);
      mesh.dispose();
    }

    this.lineEntities.delete(id);
  }

  reset(): void {
    // Les lignes n'ont pas d'√©tat √† r√©initialiser
    // La g√©om√©trie sera recalcul√©e au prochain update
    this.logger.info('LinesRenderSystem reset', 'LinesRenderSystem');
  }

  dispose(): void {
    this.lineEntities.forEach((entity) => {
      const mesh = entity.getComponent<MeshComponent>('mesh');
      if (mesh) {
        mesh.dispose();
      }
    });

    this.lineEntities.clear();
    this.kite = null;
    this.controlBarSystem = null;

    this.logger.info('LinesRenderSystem disposed', 'LinesRenderSystem');
  }
}


=== simulation/systems/PilotSystem.ts ===

/**
 * PilotSystem.ts - Syst√®me ECS pour la gestion du pilote
 *
 * Responsabilit√©s :
 *   - G√®re l'entit√© du pilote (position, rotation, visuel)
 *   - Met √† jour la position du pilote relative √† la barre de contr√¥le
 *
 * Architecture ECS :
 *   - Op√®re sur une PilotEntity avec TransformComponent et MeshComponent
 *   - Met √† jour la position bas√©e sur la position de la barre de contr√¥le
 */

import * as THREE from 'three';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { PilotEntity } from '../entities/PilotEntity';
import { TransformComponent } from '../components/TransformComponent';
import { MeshComponent } from '../components/MeshComponent';
import { Logger } from '../../utils/Logging';

export class PilotSystem extends BaseSimulationSystem {
  private logger: Logger;
  private pilotEntity: PilotEntity | null = null;
  private controlBarPosition: THREE.Vector3 = new THREE.Vector3();

  constructor() {
    super('PilotSystem', 6); // Priorit√© apr√®s ControlBarSystem
    this.logger = Logger.getInstance();
  }

  async initialize(): Promise<void> {
    // Initialiser la position du pilote √† (0, 0, 0)
    if (this.pilotEntity) {
      this.pilotEntity.updatePosition();

      // Synchroniser avec le mesh Three.js
      const transform = this.pilotEntity.getComponent<TransformComponent>('transform');
      const mesh = this.pilotEntity.getComponent<MeshComponent>('mesh');

      if (transform && mesh) {
        mesh.syncToObject3D({
          position: transform.position,
          quaternion: transform.quaternion,
          scale: transform.scale
        });
      }
    }

    this.logger.info('PilotSystem initialized', 'PilotSystem');
  }

  reset(): void {
    this.controlBarPosition.set(0, 0, 0);
    this.logger.info('PilotSystem reset', 'PilotSystem');
  }

  dispose(): void {
    this.pilotEntity = null;
    this.logger.info('PilotSystem disposed', 'PilotSystem');
  }

  /**
   * Enregistre l'entit√© du pilote
   */
  setPilotEntity(entity: PilotEntity): void {
    if (!entity.hasComponent('transform') || !entity.hasComponent('mesh')) {
      throw new Error('PilotEntity must have Transform and Mesh components');
    }
    this.pilotEntity = entity;
  }

  /**
   * Met √† jour la position de r√©f√©rence de la barre de contr√¥le
   */
  setControlBarPosition(position: THREE.Vector3): void {
    this.controlBarPosition.copy(position);
  }

  update(_context: SimulationContext): void {
    if (!this.pilotEntity) return;

    // Le pilote reste √† (0, 0, 0) - pas besoin de mise √† jour
    // La position du pilote ne change jamais dans le syst√®me de coordonn√©es monde

    // Synchroniser avec le mesh Three.js (pour les autres transformations √©ventuelles)
    const transform = this.pilotEntity.getComponent<TransformComponent>('transform');
    const mesh = this.pilotEntity.getComponent<MeshComponent>('mesh');

    if (transform && mesh) {
      mesh.syncToObject3D({
        position: transform.position,
        quaternion: transform.quaternion,
        scale: transform.scale
      });
    }
  }
}

=== simulation/systems/RenderSystem.ts ===

/**
 * RenderSystem.ts - Syst√®me de rendu Three.js
 */

import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface RenderState {
  scene: THREE.Scene;
  camera: THREE.Camera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
  controls: OrbitControls;
  isRendering: boolean;
  frameCount: number;
  fps: number;
  lastFrameTime: number;
}

export interface RenderConfig {
  antialias: boolean;
  shadowMapEnabled: boolean;
  shadowMapType: THREE.ShadowMapType;
  pixelRatio: number;
  clearColor: number;
  clearAlpha: number;
  targetFPS: number;
  vsync: boolean;
  powerPreference: 'default' | 'high-performance' | 'low-power';
}

export class RenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private renderState: RenderState | null = null;
  private config: RenderConfig;
  private fpsCounter = { frames: 0, lastTime: 0, fps: 0 };

  constructor(config: Partial<RenderConfig> = {}) {
    super('RenderSystem', 100); // Basse priorit√© (rendu en dernier)

    this.logger = Logger.getInstance();
    this.config = {
      antialias: true,
      shadowMapEnabled: true,
      shadowMapType: THREE.PCFSoftShadowMap,
      pixelRatio: 1, // Valeur par d√©faut, sera mise √† jour dans initialize()
      clearColor: 0x87CEEB, // Bleu ciel
      clearAlpha: 1.0,
      targetFPS: 60,
      vsync: true,
      powerPreference: 'high-performance',
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('RenderSystem initializing...', 'RenderSystem');

    // Mettre √† jour pixelRatio maintenant que window est disponible
    if (typeof window !== 'undefined') {
      this.config.pixelRatio = Math.min(window.devicePixelRatio, 2);
    }

    try {
      await this.initializeRenderer();
      this.logger.info('RenderSystem initialized successfully', 'RenderSystem');
    } catch (error) {
      this.logger.error(`RenderSystem initialization failed: ${error}`, 'RenderSystem');
      throw error;
    }
  }

  /**
   * V√©rifie si l'environnement DOM est disponible
   */
  private checkDOMEnvironment(): void {
    if (typeof document === 'undefined') {
      throw new Error('RenderSystem requires a DOM environment');
    }
  }

  /**
   * Cr√©e et configure le canvas
   */
  private createCanvas(): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.id = 'kite-simulator-canvas';
    return canvas;
  }

  /**
   * Cr√©e et configure le renderer WebGL
   */
  private createRenderer(canvas: HTMLCanvasElement): THREE.WebGLRenderer {
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: this.config.antialias,
      alpha: false,
      powerPreference: this.config.powerPreference
    });

    // Configuration de base
    renderer.setPixelRatio(this.config.pixelRatio);
    renderer.setClearColor(this.config.clearColor, this.config.clearAlpha);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Configuration des ombres
    if (this.config.shadowMapEnabled) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = this.config.shadowMapType;
    }

    return renderer;
  }

  /**
   * Cr√©e et configure la sc√®ne avec brouillard
   */
  private createScene(): THREE.Scene {
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(this.config.clearColor, 50, 200);
    return scene;
  }

  /**
   * Configure l'√©clairage de la sc√®ne
   */
  private setupLighting(scene: THREE.Scene): void {
    // Lumi√®re ambiante
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    // Lumi√®re directionnelle
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = this.config.shadowMapEnabled;

    if (this.config.shadowMapEnabled) {
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 500;
    }
    scene.add(directionalLight);

    this.logger.info('Scene lights created', 'RenderSystem');
  }

  /**
   * Ajoute le sol et la grille √† la sc√®ne
   */
  private setupGroundAndGrid(scene: THREE.Scene): void {
    // Sol
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a7d44,
      roughness: 0.8,
      metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = this.config.shadowMapEnabled;
    scene.add(ground);

    // Grille
    const gridHelper = new THREE.GridHelper(100, 50, 0x888888, 0x444444);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);

    this.logger.info('Ground plane and grid created', 'RenderSystem');
  }

  /**
   * Cr√©e et configure la cam√©ra
   */
  private createCamera(): THREE.PerspectiveCamera {
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 5);
    camera.lookAt(0, 5, -15);
    return camera;
  }

  /**
   * Cr√©e et configure les contr√¥les de cam√©ra
   */
  private createCameraControls(camera: THREE.PerspectiveCamera, canvas: HTMLCanvasElement): OrbitControls {
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 100;
    controls.maxPolarAngle = Math.PI / 2;
    controls.target.set(0, 5, -10);
    controls.update();

    this.logger.info('OrbitControls created', 'RenderSystem');
    return controls;
  }

  /**
   * Ajoute le canvas au DOM et configure les √©couteurs
   */
  private setupCanvasInDOM(canvas: HTMLCanvasElement): void {
    const container = document.getElementById('app') || document.body;
    container.appendChild(canvas);

    this.logger.info(`Canvas created and added to container: ${container.id || 'body'}`, 'RenderSystem');
    this.logger.info(`Canvas dimensions: ${canvas.width}x${canvas.height}`, 'RenderSystem');

    // √âcouteur de redimensionnement
    window.addEventListener('resize', this.onResize.bind(this));
  }

  /**
   * Initialise le renderer Three.js
   */
  private async initializeRenderer(): Promise<void> {
    this.checkDOMEnvironment();

    // Cr√©ation des composants
    const canvas = this.createCanvas();
    const renderer = this.createRenderer(canvas);
    const scene = this.createScene();

    // Configuration de la sc√®ne
    this.setupLighting(scene);
    this.setupGroundAndGrid(scene);

    // Cr√©ation de la cam√©ra et contr√¥les
    const camera = this.createCamera();
    const controls = this.createCameraControls(camera, canvas);

    // Initialisation de l'√©tat
    this.renderState = {
      scene,
      camera,
      renderer,
      canvas,
      controls,
      isRendering: false,
      frameCount: 0,
      fps: 0,
      lastFrameTime: performance.now()
    };

    // Configuration finale
    this.onResize();
    this.setupCanvasInDOM(canvas);
  }

  update(_context: SimulationContext): void {
    if (!this.renderState || !this.renderState.isRendering) {
      return;
    }

    // Mettre √† jour les contr√¥les de cam√©ra
    this.renderState.controls.update();

    // Calculer le FPS
    this.updateFPS();

    // Rendre la sc√®ne
    this.renderState.renderer.render(this.renderState.scene, this.renderState.camera);

    this.renderState.frameCount++;
  }

  /**
   * Met √† jour le compteur FPS
   */
  private updateFPS(): void {
    if (!this.renderState) return;

    const now = performance.now();
    this.fpsCounter.frames++;

    if (now - this.fpsCounter.lastTime >= 1000) {
      this.renderState.fps = Math.round((this.fpsCounter.frames * 1000) / (now - this.fpsCounter.lastTime));
      this.fpsCounter.frames = 0;
      this.fpsCounter.lastTime = now;
    }
  }

  /**
   * Gestionnaire de redimensionnement de la fen√™tre
   */
  private onResize(): void {
    if (!this.renderState) return;

    const width = window.innerWidth;
    const height = window.innerHeight;

    // Mettre √† jour la cam√©ra
    if (this.renderState.camera instanceof THREE.PerspectiveCamera) {
      this.renderState.camera.aspect = width / height;
      this.renderState.camera.updateProjectionMatrix();
    }

    // Mettre √† jour le renderer
    this.renderState.renderer.setSize(width, height);
  }

  /**
   * D√©marre le rendu
   */
  startRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = true;
      this.logger.info('Rendering started', 'RenderSystem');
      this.logger.info(`Canvas element: ${this.renderState.canvas.id}`, 'RenderSystem');
      this.logger.info(`Scene children count: ${this.renderState.scene.children.length}`, 'RenderSystem');
    } else {
      this.logger.error('Cannot start rendering - renderState is null', 'RenderSystem');
    }
  }

  /**
   * Arr√™te le rendu
   */
  stopRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = false;
      this.logger.info('Rendering stopped', 'RenderSystem');
    }
  }

  /**
   * Obtient l'√©tat de rendu actuel
   */
  getRenderState(): Readonly<RenderState> | null {
    return this.renderState;
  }

  /**
   * Obtient la sc√®ne Three.js
   */
  getScene(): THREE.Scene | null {
    return this.renderState?.scene || null;
  }

  /**
   * Obtient la cam√©ra
   */
  getCamera(): THREE.Camera | null {
    return this.renderState?.camera || null;
  }

  /**
   * Obtient le renderer
   */
  getRenderer(): THREE.WebGLRenderer | null {
    return this.renderState?.renderer || null;
  }

  addToScene(object: THREE.Object3D): void {
    if (this.renderState?.scene) {
      this.renderState.scene.add(object);
    }
  }

  removeFromScene(object: THREE.Object3D): void {
    if (this.renderState?.scene) {
      this.renderState.scene.remove(object);
    }
  }

  /**
   * Obtient le canvas
   */
  getCanvas(): HTMLCanvasElement | null {
    return this.renderState?.canvas || null;
  }

  /**
   * Obtient les statistiques de rendu
   */
  getRenderStats(): { fps: number; frameCount: number; isRendering: boolean } {
    if (!this.renderState) {
      return { fps: 0, frameCount: 0, isRendering: false };
    }

    return {
      fps: this.renderState.fps,
      frameCount: this.renderState.frameCount,
      isRendering: this.renderState.isRendering
    };
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<RenderConfig> {
    return this.config;
  }

  reset(): void {
    if (this.renderState) {
      this.renderState.frameCount = 0;
      this.renderState.fps = 0;
      this.renderState.lastFrameTime = performance.now();
    }

    this.fpsCounter = { frames: 0, lastTime: 0, fps: 0 };
    this.logger.info('RenderSystem reset', 'RenderSystem');
  }

  dispose(): void {
    if (this.renderState) {
      // Supprimer les √©couteurs
      window.removeEventListener('resize', this.onResize.bind(this));

      // Disposer le renderer
      this.renderState.renderer.dispose();

      // Supprimer le canvas du DOM
      if (this.renderState.canvas.parentNode) {
        this.renderState.canvas.parentNode.removeChild(this.renderState.canvas);
      }

      this.renderState = null;
    }

    this.logger.info('RenderSystem disposed', 'RenderSystem');
  }
}

=== simulation/systems/index.ts ===

/**
 * systems/index.ts - Export des syst√®mes de simulation
 *
 * Point d'entr√©e centralis√© pour tous les syst√®mes de simulation.
 * Permet d'importer facilement tous les syst√®mes depuis un seul endroit.
 */

export { InputSystem, type InputState, type InputConfig } from './InputSystem';
export { RenderSystem, type RenderState, type RenderConfig } from './RenderSystem';
export { KitePhysicsSystem } from './KitePhysicsSystem';
export { ControlBarSystem } from './ControlBarSystem';
export { LinesRenderSystem } from './LinesRenderSystem';
export { PilotSystem } from './PilotSystem';

=== simulation/types/BridleTypes.ts ===

/**
 * BridleTypes.ts - Types et interfaces pour le syst√®me de bridage
 *
 * D√©finit les structures de donn√©es pour les brides du cerf-volant.
 * Les brides relient des points anatomiques du kite (NEZ, INTER, CENTRE)
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */

/**
 * Longueurs physiques des 3 types de brides
 * (identique pour gauche et droite)
 */
export interface BridleLengths {
  /** Longueur bride NEZ ‚Üí CTRL (m√®tres) */
  nez: number;

  /** Longueur bride INTER ‚Üí CTRL (m√®tres) */
  inter: number;

  /** Longueur bride CENTRE ‚Üí CTRL (m√®tres) */
  centre: number;
}

/**
 * Tensions actuelles des 6 brides
 * (3 gauches + 3 droites)
 */
export interface BridleTensions {
  /** Tension bride NEZ gauche (Newtons) */
  leftNez: number;

  /** Tension bride INTER gauche (Newtons) */
  leftInter: number;

  /** Tension bride CENTRE gauche (Newtons) */
  leftCentre: number;

  /** Tension bride NEZ droite (Newtons) */
  rightNez: number;

  /** Tension bride INTER droite (Newtons) */
  rightInter: number;

  /** Tension bride CENTRE droite (Newtons) */
  rightCentre: number;
}

/**
 * D√©finition d'une attache de bride
 * (relie deux points anatomiques du kite)
 */
export interface BridleAttachment {
  /** Nom du point de d√©part (ex: "NEZ", "INTER_GAUCHE") */
  startPoint: string;

  /** Nom du point d'arriv√©e (ex: "CTRL_GAUCHE", "CTRL_DROIT") */
  endPoint: string;

  /** Longueur au repos (m√®tres) */
  length: number;

  /** Identifiant unique (ex: "bridle_left_nez") */
  id: string;
}

/**
 * Type des c√¥t√©s du bridage
 */
export type BridleSide = 'left' | 'right';

/**
 * Type des positions de bride
 */
export type BridlePosition = 'nez' | 'inter' | 'centre';

/**
 * Configuration compl√®te d'une bride (utilis√© par BridleFactory)
 */
export interface BridleConfig {
  /** C√¥t√© de la bride */
  side: BridleSide;

  /** Position de la bride */
  position: BridlePosition;

  /** Longueur (m√®tres) */
  length: number;

  /** Identifiant unique */
  id: string;
}


=== simulation/types/PhysicsTypes.ts ===

/**
 * PhysicsTypes.ts - Types et interfaces pour la physique de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les structures de donn√©es pour l'√©tat du cerf-volant, les forces, les poign√©es, etc.
 *   - Sert √† typer les √©changes entre les modules physiques et de rendu
 *
 * D√©pendances principales :
 *   - Three.js : Pour les vecteurs et quaternions
 *
 * Relation avec les fichiers adjacents :
 *   - WindTypes.ts : D√©finit les types pour le vent
 *   - Tous les modules physiques et de rendu importent PhysicsTypes pour typer les donn√©es
 *
 * Utilisation typique :
 *   - Utilis√© dans PhysicsEngine, AerodynamicsCalculator, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es physiques
 *
 * Voir aussi :
 *   - src/simulation/types/WindTypes.ts
 */
import * as THREE from "three";

/**
 * Types et interfaces pour la physique de la simulation
 */

export interface KiteState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  orientation?: THREE.Quaternion;
  acceleration?: THREE.Vector3;
  angularAcceleration?: THREE.Vector3;
  mass?: number;
  totalLiftForce?: THREE.Vector3; // Ajout√© pour le debug UI
  totalDragForce?: THREE.Vector3; // Ajout√© pour le debug UI
}

/**
 * √âtat du vent
 */
export interface WindState {
  baseSpeed: number; // m/s
  baseDirection: THREE.Vector3;
  turbulence: number; // %
  gustFrequency?: number;
  gustAmplitude?: number;
  time?: number;
}

export interface HandlePositions {
  left: THREE.Vector3;
  right: THREE.Vector3;
}

/**
 * Force appliqu√©e sur une surface sp√©cifique du kite
 */
export interface SurfaceForce {
  /** Indice de la surface dans KiteGeometry.SURFACES */
  surfaceIndex: number;
  /** Portance sur cette surface (en Newton) */
  lift: THREE.Vector3;
  /** Tra√Æn√©e sur cette surface (en Newton) */
  drag: THREE.Vector3;
  /** Friction sur cette surface (optionnel, en Newton) */
  friction?: THREE.Vector3;
  /** Force totale (r√©sultante) sur cette surface (en Newton) */
  resultant: THREE.Vector3;
  /** Centre g√©om√©trique de la surface (en coordonn√©es monde) */
  center: THREE.Vector3;
  /** Normale de la surface (en coordonn√©es monde) */
  normal: THREE.Vector3;
  /** Surface en m¬≤ */
  area: number;
}

=== simulation/types/WindTypes.ts ===


/**
 * WindTypes.ts - Types pour le syst√®me de vent de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la structure des param√®tres de vent (vitesse, direction, turbulence)
 *   - Sert √† typer les √©changes entre le simulateur de vent et les autres modules
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par WindSimulator et PhysicsEngine
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsTypes.ts : D√©finit les types pour la physique
 *   - Tous les modules physiques et de rendu importent WindTypes pour typer le vent
 *
 * Utilisation typique :
 *   - Utilis√© dans WindSimulator, PhysicsEngine, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es de vent
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 */

export interface WindParams {
  speed: number; // km/h
  direction: number; // degr√©s
  turbulence: number; // pourcentage
}

=== simulation/types/index.ts ===


/**
 * index.ts - Export centralis√© de tous les types de la simulation Kite
 *
 * R√¥le :
 *   - Centralise l'export des types physiques et de vent
 *   - Permet d'importer tous les types depuis un seul point
 *
 * D√©pendances principales :
 *   - PhysicsTypes.ts : Types pour la physique
 *   - WindTypes.ts : Types pour le vent
 *
 * Relation avec les fichiers adjacents :
 *   - Sert de point d'entr√©e pour tous les imports de types dans le projet
 *
 * Utilisation typique :
 *   - Import√© dans les modules physiques, de rendu, de configuration, etc.
 *   - Facilite la maintenance et la coh√©rence des types
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 *   - src/simulation/types/WindTypes.ts
 */

export * from './PhysicsTypes';
export * from './WindTypes';

=== simulation/ui/UIManager.ts ===

import * as THREE from "three";

import { CONFIG } from "../config/SimulationConfig";
import { DebugRenderer } from "../rendering/DebugRenderer";
import { KiteGeometry } from "../config/KiteGeometry";
import type { KiteState } from "../types";

export interface BridleLengths {
  nez: number;
  inter: number;
  centre: number;
}

export interface WindSnapshot {
  baseSpeed: number; // m/s
  baseDirection: THREE.Vector3;
  turbulence: number; // %
}

export interface ControlLineDiagnostics {
  lineLength: number;
  leftDistance: number;
  rightDistance: number;
  leftTaut: boolean;
  rightTaut: boolean;
  leftTension?: number;
  rightTension?: number;
}

export interface AerodynamicForcesSnapshot {
  lift: THREE.Vector3;
  drag: THREE.Vector3;
}

export interface SimulationControls {
  getBridleLengths(): BridleLengths;
  setBridleLength(type: "nez" | "inter" | "centre", length: number): void;
  setLineLength(length: number): void;
  setWindParams(params: { speed?: number; direction?: number; turbulence?: number }): void;
  getForceSmoothing(): number;
  setForceSmoothing(value: number): void;
  getKiteState(): KiteState;
  getWindState(): WindSnapshot;
  getLineLength(): number;
  getControlLineDiagnostics(): ControlLineDiagnostics | null;
  getAerodynamicForces(): AerodynamicForcesSnapshot | null;
}

/**
 * Gestionnaire de l'interface utilisateur
 *
 * G√®re les contr√¥les et interactions utilisateur
 */
export interface SliderConfig {
  id: string;
  initialValue: number;
  onInput: (value: number) => void;
  formatter?: (value: number) => string;
  step?: number;
}

export class UIManager {
  private simulation: SimulationControls;
  private debugRenderer: DebugRenderer;
  private resetCallback: () => void;
  private togglePlayCallback: () => void;

  constructor(
    simulation: SimulationControls,
    debugRenderer: DebugRenderer,
    resetCallback: () => void,
    togglePlayCallback: () => void,
  ) {
    this.simulation = simulation;
    this.debugRenderer = debugRenderer;
    this.resetCallback = resetCallback;
    this.togglePlayCallback = togglePlayCallback;
    this.setupControls();
  }

  private setupControls(): void {
    const resetBtn = document.getElementById("reset-sim");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.resetCallback();
      });
    }

    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.togglePlayCallback();
      });
    }

    const debugBtn = document.getElementById("debug-physics");
    if (debugBtn) {
      debugBtn.textContent = this.debugRenderer.isDebugMode() ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugRenderer.isDebugMode());

      debugBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.debugRenderer.toggleDebugMode();
      });
    }

    if (this.debugRenderer.isDebugMode()) {
      document.body.classList.add("debug-mode");
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        debugPanel.style.display = "block";
      }
    }

    this.setupWindControls();
  }

  // Interface SliderConfig d√©finie en dehors de la classe

  /**
   * Cr√©e et configure un slider g√©n√©rique
   */
  private createSlider(config: SliderConfig): void {
    const slider = document.getElementById(config.id) as HTMLInputElement | null;
    const valueElement = document.getElementById(`${config.id}-value`);

    if (!slider || !valueElement) return;

    slider.value = config.initialValue.toFixed(config.step ?? 1);
    valueElement.textContent = config.formatter
      ? config.formatter(config.initialValue)
      : config.initialValue.toFixed(config.step ?? 1);

    slider.oninput = () => {
      const value = parseFloat(slider.value);
      config.onInput(value);

      valueElement.textContent = config.formatter
        ? config.formatter(value)
        : value.toFixed(config.step ?? 1);
    };
  }

  /**
   * Configure les contr√¥les de vent
   */
  private setupWindControlsGroup(): void {
    const currentWind = this.simulation.getWindState();

    // Vitesse du vent
    this.createSlider({
      id: "wind-speed",
      initialValue: (currentWind?.baseSpeed ?? CONFIG.wind.defaultSpeed) * (1 / CONFIG.conversions.kmhToMs),
      onInput: (speed) => this.simulation.setWindParams({ speed }),
      formatter: (value) => `${value.toFixed(1)} km/h`
    });

    // Direction du vent
    this.createSlider({
      id: "wind-direction",
      initialValue: this.computeDirectionDegrees(currentWind?.baseDirection),
      onInput: (direction) => this.simulation.setWindParams({ direction }),
      formatter: (value) => `${value.toFixed(0)}¬∞`,
      step: 1
    });

    // Turbulence du vent
    this.createSlider({
      id: "wind-turbulence",
      initialValue: currentWind?.turbulence ?? CONFIG.wind.defaultTurbulence,
      onInput: (turbulence) => this.simulation.setWindParams({ turbulence }),
      formatter: (value) => `${value.toFixed(1)}%`
    });
  }

  /**
   * Configure les contr√¥les des lignes
   */
  private setupLineControlsGroup(): void {
    // Longueur des lignes
    this.createSlider({
      id: "line-length",
      initialValue: this.simulation.getLineLength(),
      onInput: (length) => this.simulation.setLineLength(length),
      formatter: (value) => `${value.toFixed(0)}m`,
      step: 1
    });

    // Brides
    const currentBridle = this.simulation.getBridleLengths();

    this.createSlider({
      id: "bridle-nez",
      initialValue: currentBridle.nez,
      onInput: (length) => this.simulation.setBridleLength("nez", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });

    this.createSlider({
      id: "bridle-inter",
      initialValue: currentBridle.inter,
      onInput: (length) => this.simulation.setBridleLength("inter", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });

    this.createSlider({
      id: "bridle-centre",
      initialValue: currentBridle.centre,
      onInput: (length) => this.simulation.setBridleLength("centre", length),
      formatter: (value) => `${value.toFixed(2)}m`
    });
  }

  /**
   * Configure les contr√¥les de physique
   */
  private setupPhysicsControlsGroup(): void {
    // Amortissement lin√©aire
    this.createSlider({
      id: "linear-damping",
      initialValue: CONFIG.physics.linearDampingCoeff,
      onInput: (damping) => { CONFIG.physics.linearDampingCoeff = damping; }
    });

    // Facteur de tra√Æn√©e angulaire
    this.createSlider({
      id: "angular-damping",
      initialValue: CONFIG.physics.angularDragFactor,
      onInput: (dragFactor) => { CONFIG.physics.angularDragFactor = dragFactor; }
    });

    // Niveau de subdivision du maillage
    this.createSlider({
      id: "mesh-subdivision-level",
      initialValue: CONFIG.kite.defaultMeshSubdivisionLevel,
      onInput: (level) => {
        const intLevel = parseInt(level.toString(), 10);
        CONFIG.kite.defaultMeshSubdivisionLevel = intLevel;
        KiteGeometry.setMeshSubdivisionLevel(intLevel);
      },
      formatter: (value) => {
        const level = parseInt(value.toString(), 10);
        const triangleCount = Math.pow(4, level + 1);
        return `${level} (${triangleCount} triangles)`;
      },
      step: 1
    });
  }

  /**
   * Configure les contr√¥les a√©rodynamiques
   */
  private setupAerodynamicControlsGroup(): void {
    // √âchelle de portance
    this.createSlider({
      id: "lift-scale",
      initialValue: CONFIG.aero.liftScale,
      onInput: (scale) => { CONFIG.aero.liftScale = scale; }
    });

    // √âchelle de tra√Æn√©e
    this.createSlider({
      id: "drag-scale",
      initialValue: CONFIG.aero.dragScale,
      onInput: (scale) => { CONFIG.aero.dragScale = scale; }
    });

    // Lissage des forces
    this.createSlider({
      id: "force-smoothing",
      initialValue: this.simulation.getForceSmoothing(),
      onInput: (smoothing) => this.simulation.setForceSmoothing(smoothing)
    });
  }

  private setupWindControls(): void {
    this.setupWindControlsGroup();
    this.setupLineControlsGroup();
    this.setupPhysicsControlsGroup();
    this.setupAerodynamicControlsGroup();
  }

  updatePlayButton(isPlaying: boolean): void {
    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.textContent = isPlaying ? "‚è∏Ô∏è Pause" : "‚ñ∂Ô∏è Lancer";
    }
  }

  updateDebugInfo(): void {
    const debugInfo = document.getElementById("debug-info");
    if (!debugInfo || !this.debugRenderer.isDebugMode()) return;

    const kiteState = this.simulation.getKiteState();
    const windState = this.simulation.getWindState();
    const controlDiagnostics = this.simulation.getControlLineDiagnostics();
    const aeroForces = this.simulation.getAerodynamicForces();

    const kitePosition = kiteState?.position ?? new THREE.Vector3();
    const kiteVelocity = kiteState?.velocity ?? new THREE.Vector3();

    let tensionInfo = "N/A";
    if (controlDiagnostics) {
      const leftState = controlDiagnostics.leftTaut ? "TENDU" : "REL√ÇCH√â";
      const rightState = controlDiagnostics.rightTaut ? "TENDU" : "REL√ÇCH√â";
      const leftDistance = controlDiagnostics.leftDistance.toFixed(2);
      const rightDistance = controlDiagnostics.rightDistance.toFixed(2);
      const leftTension = controlDiagnostics.leftTension ?? 0;
      const rightTension = controlDiagnostics.rightTension ?? 0;
      tensionInfo = `L:${leftState}(${leftDistance}m, ${leftTension.toFixed(1)}N) R:${rightState}(${rightDistance}m, ${rightTension.toFixed(1)}N)`;
    }

    const liftMagnitude = aeroForces ? aeroForces.lift.length() : 0;
    const dragMagnitude = aeroForces ? aeroForces.drag.length() : 0;
    const totalForce = Math.sqrt(liftMagnitude * liftMagnitude + dragMagnitude * dragMagnitude);

    debugInfo.innerHTML = `
      <strong>ü™Å Position Cerf-volant:</strong><br>
      X: ${kitePosition.x.toFixed(2)}m, Y: ${kitePosition.y.toFixed(2)}m, Z: ${kitePosition.z.toFixed(2)}m<br><br>

      <strong>üí® Vent:</strong><br>
      Vitesse: ${windState.baseSpeed.toFixed(1)} m/s (${(windState.baseSpeed * 3.6).toFixed(1)} km/h)<br>
      Direction: (${windState.baseDirection.x.toFixed(0)}, ${windState.baseDirection.y.toFixed(0)}, ${windState.baseDirection.z.toFixed(0)})<br>
      Turbulence: ${windState.turbulence.toFixed(1)}%<br><br>

      <strong>‚ö° Forces A√©rodynamiques:</strong><br>
      Portance: ${liftMagnitude.toFixed(3)} N<br>
      Tra√Æn√©e: ${dragMagnitude.toFixed(3)} N<br>
      Force Totale: ${totalForce.toFixed(3)} N<br><br>

      <strong>üîó Tensions Lignes:</strong><br>
      ${tensionInfo}<br><br>

      <strong>üèÉ Vitesse Cerf-volant:</strong><br>
      ${kiteVelocity.length().toFixed(2)} m/s<br><br>

      <strong>‚öôÔ∏è Performance:</strong><br>
      Statut: <span style="color: #00ff88;">STABLE</span>
    `;
  }

  private computeDirectionDegrees(direction?: THREE.Vector3): number {
    if (!direction || direction.lengthSq() === 0) {
      return CONFIG.wind.defaultDirection;
    }

    const normalized = direction.clone().normalize();
    const radians = Math.atan2(normalized.x, -normalized.z);
    const degrees = THREE.MathUtils.radToDeg(radians);

    return (degrees + 360) % 360;
  }
}

=== types/index.ts ===

/**
 * Types centralis√©s pour le syst√®me de visualisation 3D
 * Interface unique et coh√©rente pour tous les objets
 */

import * as THREE from 'three';

/**
 * Position 3D simple [x, y, z]
 */
export type Position3D = [number, number, number];

/**
 * Interface principale que TOUS les objets doivent impl√©menter
 * üéÆ v3.0: Compatible avec l'architecture StructuredObject + Node3D
 */
export interface ICreatable {
  /**
   * Retourne l'objet lui-m√™me (StructuredObject h√©rite de Node3D)
   * Pattern fluent pour la nouvelle architecture
   */
  create(): this;

  /**
   * Nom affich√© dans l'interface utilisateur
   */
  getName(): string;

  /**
   * Description courte de l'objet
   */
  getDescription(): string;

  /**
   * Nombre de primitives utilis√©es (pour statistiques)
   */
  getPrimitiveCount(): number;
}

/**
 * Options pour cr√©er des surfaces
 */
export interface SurfaceOptions {
  color?: string;
  transparent?: boolean;
  opacity?: number;
  doubleSide?: boolean;
  wireframe?: boolean;
}

/**
 * Configuration pour les mat√©riaux
 */
export interface MaterialConfig {
  color: string;
  transparent?: boolean;
  opacity?: number;
  metalness?: number;
  roughness?: number;
  side?: THREE.Side;
}

/**
 * Interface pour un point nomm√© dans l'espace 3D
 */
export interface NamedPoint {
  name: string;
  position: THREE.Vector3;
  visible?: boolean;
}

/**
 * M√©tadonn√©es optionnelles pour les objets
 */
export interface ObjectMetadata {
  category?: string;
  complexity?: 'simple' | 'medium' | 'complex';
  tags?: string[];
  author?: string;
  version?: string;
}

=== utils/GeometryUtils.ts ===

/**
 * GeometryUtils.ts - Utilitaires g√©om√©triques pour la simulation 3D
 */

import * as THREE from 'three';

export class GeometryUtils {
  /**
   * Calcule l'aire d'un triangle 3D
   */
  static triangleArea(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): number {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const cross = edge1.cross(edge2);
    return cross.length() * 0.5;
  }

  /**
   * Calcule la normale d'un triangle
   */
  static triangleNormal(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    return edge1.cross(edge2).normalize();
  }

  /**
   * Calcule le centro√Øde d'un triangle
   */
  static triangleCentroid(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    return v1.clone().add(v2).add(v3).divideScalar(3);
  }

  /**
   * V√©rifie si un point est √† l'int√©rieur d'un triangle (dans le plan)
   */
  static pointInTriangle2D(point: THREE.Vector2, v1: THREE.Vector2, v2: THREE.Vector2, v3: THREE.Vector2): boolean {
    const d1 = this.sign(point, v1, v2);
    const d2 = this.sign(point, v2, v3);
    const d3 = this.sign(point, v3, v1);

    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(hasNeg && hasPos);
  }

  /**
   * Calcule le barycentre d'un ensemble de points
   */
  static centroid(points: THREE.Vector3[]): THREE.Vector3 {
    if (points.length === 0) return new THREE.Vector3();

    const sum = points.reduce((acc, point) => acc.add(point), new THREE.Vector3());
    return sum.divideScalar(points.length);
  }

  /**
   * Calcule la bounding box d'un ensemble de points
   */
  static boundingBox(points: THREE.Vector3[]): { min: THREE.Vector3; max: THREE.Vector3 } {
    if (points.length === 0) {
      return { min: new THREE.Vector3(), max: new THREE.Vector3() };
    }

    const min = points[0].clone();
    const max = points[0].clone();

    for (let i = 1; i < points.length; i++) {
      min.min(points[i]);
      max.max(points[i]);
    }

    return { min, max };
  }

  /**
   * Projette un point sur un plan d√©fini par un point et une normale
   */
  static projectPointOnPlane(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): THREE.Vector3 {
    const toPoint = point.clone().sub(planePoint);
    const distance = toPoint.dot(planeNormal);
    return point.clone().sub(planeNormal.clone().multiplyScalar(distance));
  }

  /**
   * Calcule la distance d'un point √† un plan
   */
  static pointToPlaneDistance(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): number {
    const toPoint = point.clone().sub(planePoint);
    return toPoint.dot(planeNormal);
  }

  /**
   * V√©rifie si deux segments se croisent (2D)
   */
  static segmentsIntersect2D(
    a1: THREE.Vector2, a2: THREE.Vector2,
    b1: THREE.Vector2, b2: THREE.Vector2
  ): boolean {
    const denom = (a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x);
    if (Math.abs(denom) < 1e-6) return false; // Parall√®les

    const t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x)) / denom;
    const u = -((a1.x - a2.x) * (a1.y - b1.y) - (a1.y - a2.y) * (a1.x - b1.x)) / denom;

    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }

  /**
   * Calcule l'angle solide d'un triangle vu depuis un point
   */
  static solidAngle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3, viewpoint: THREE.Vector3): number {
    const a = v1.clone().sub(viewpoint).normalize();
    const b = v2.clone().sub(viewpoint).normalize();
    const c = v3.clone().sub(viewpoint).normalize();

    const numerator = Math.abs(a.dot(b.cross(c)));
    const denominator = 1 + a.dot(b) + b.dot(c) + c.dot(a);
    return 2 * Math.atan2(numerator, denominator);
  }

  /**
   * G√©n√®re des points sur une sph√®re
   */
  static fibonacciSphere(samples: number, radius: number = 1): THREE.Vector3[] {
    const points: THREE.Vector3[] = [];
    const phi = Math.PI * (3 - Math.sqrt(5)); // Angle d'or

    for (let i = 0; i < samples; i++) {
      const y = 1 - (i / (samples - 1)) * 2; // y entre -1 et 1
      const radiusAtY = Math.sqrt(1 - y * y);

      const theta = phi * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      points.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
    }

    return points;
  }

  /**
   * Fonction auxiliaire pour pointInTriangle2D
   */
  private static sign(p1: THREE.Vector2, p2: THREE.Vector2, p3: THREE.Vector2): number {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  }
}

=== utils/Logging.ts ===

/**
 * Logging.ts - Syst√®me de logging configurable pour la simulation
 */

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: number;
  category?: string;
  data?: any;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.INFO;
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;
  private categories: Set<string> = new Set();

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Configure le niveau de log minimum
   */
  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }

  /**
   * Active/d√©sactive une cat√©gorie de logs
   */
  setCategoryEnabled(category: string, enabled: boolean): void {
    if (enabled) {
      this.categories.add(category);
    } else {
      this.categories.delete(category);
    }
  }

  /**
   * Log de debug
   */
  debug(message: string, category?: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, category, data);
  }

  /**
   * Log d'information
   */
  info(message: string, category?: string, data?: any): void {
    this.log(LogLevel.INFO, message, category, data);
  }

  /**
   * Log d'avertissement
   */
  warn(message: string, category?: string, data?: any): void {
    this.log(LogLevel.WARN, message, category, data);
  }

  /**
   * Log d'erreur
   */
  error(message: string, category?: string, data?: any): void {
    this.log(LogLevel.ERROR, message, category, data);
  }

  /**
   * Log g√©n√©rique
   */
  private log(level: LogLevel, message: string, category?: string, data?: any): void {
    // V√©rifier le niveau
    if (level < this.logLevel) return;

    // V√©rifier la cat√©gorie si sp√©cifi√©e
    if (category && !this.categories.has(category)) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: Date.now(),
      category,
      data
    };

    // Ajouter aux logs internes
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift(); // Supprimer le plus ancien
    }

    // Afficher dans la console selon le niveau
    const prefix = category ? `[${category}]` : '';
    const formattedMessage = `${prefix} ${message}`;

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`üêõ ${formattedMessage}`, data || '');
        break;
      case LogLevel.INFO:
        console.info(`‚ÑπÔ∏è ${formattedMessage}`, data || '');
        break;
      case LogLevel.WARN:
        console.warn(`‚ö†Ô∏è ${formattedMessage}`, data || '');
        break;
      case LogLevel.ERROR:
        console.error(`‚ùå ${formattedMessage}`, data || '');
        break;
    }
  }

  /**
   * Obtient tous les logs
   */
  getLogs(level?: LogLevel, category?: string): LogEntry[] {
    return this.logs.filter(entry => {
      if (level !== undefined && entry.level < level) return false;
      if (category && entry.category !== category) return false;
      return true;
    });
  }

  /**
   * Obtient les derniers logs
   */
  getRecentLogs(count: number = 10): LogEntry[] {
    return this.logs.slice(-count);
  }

  /**
   * Efface tous les logs
   */
  clearLogs(): void {
    this.logs = [];
  }

  /**
   * Exporte les logs au format JSON
   */
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * Importe des logs depuis JSON
   */
  importLogs(json: string): void {
    try {
      const imported = JSON.parse(json) as LogEntry[];
      this.logs.push(...imported);
      // Garder seulement les maxLogs plus r√©cents
      if (this.logs.length > this.maxLogs) {
        this.logs = this.logs.slice(-this.maxLogs);
      }
    } catch (error) {
      this.error('Erreur lors de l\'import des logs', 'Logger', error);
    }
  }

  /**
   * Statistiques des logs
   */
  getStats(): {
    total: number;
    byLevel: Record<LogLevel, number>;
    byCategory: Record<string, number>;
  } {
    const byLevel = {
      [LogLevel.DEBUG]: 0,
      [LogLevel.INFO]: 0,
      [LogLevel.WARN]: 0,
      [LogLevel.ERROR]: 0,
      [LogLevel.NONE]: 0
    };

    const byCategory: Record<string, number> = {};

    for (const entry of this.logs) {
      byLevel[entry.level]++;

      if (entry.category) {
        byCategory[entry.category] = (byCategory[entry.category] || 0) + 1;
      }
    }

    return {
      total: this.logs.length,
      byLevel,
      byCategory
    };
  }
}

// Instance globale pour utilisation facile
export const log = Logger.getInstance();

=== utils/MathUtils.ts ===

/**
 * MathUtils.ts - Utilitaires math√©matiques pour la simulation 3D
 */

import * as THREE from 'three';

export class MathUtils {
  /**
   * Clamp une valeur entre min et max
   */
  static clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }

  /**
   * Interpolation lin√©aire
   */
  static lerp(a: number, b: number, t: number): number {
    return a + (b - a) * MathUtils.clamp(t, 0, 1);
  }

  /**
   * Interpolation sph√©rique (pour les rotations)
   */
  static slerp(q1: THREE.Quaternion, q2: THREE.Quaternion, t: number): THREE.Quaternion {
    return new THREE.Quaternion().slerpQuaternions(q1, q2, MathUtils.clamp(t, 0, 1));
  }

  /**
   * Distance euclidienne entre deux points 3D
   */
  static distance(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceTo(p2);
  }

  /**
   * Distance au carr√© (plus rapide pour les comparaisons)
   */
  static distanceSquared(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceToSquared(p2);
  }

  /**
   * Angle entre deux vecteurs (en radians)
   */
  static angleBetween(v1: THREE.Vector3, v2: THREE.Vector3): number {
    return v1.angleTo(v2);
  }

  /**
   * Projection d'un vecteur sur un autre
   */
  static project(v: THREE.Vector3, onto: THREE.Vector3): THREE.Vector3 {
    const ontoNormalized = onto.clone().normalize();
    return ontoNormalized.multiplyScalar(v.dot(ontoNormalized));
  }

  /**
   * Composante perpendiculaire d'un vecteur par rapport √† un autre
   */
  static perpendicular(v: THREE.Vector3, to: THREE.Vector3): THREE.Vector3 {
    return v.clone().sub(this.project(v, to));
  }

  /**
   * V√©rifie si un nombre est proche de z√©ro
   */
  static isZero(value: number, epsilon: number = 1e-6): boolean {
    return Math.abs(value) < epsilon;
  }

  /**
   * V√©rifie si deux nombres sont √©gaux avec une tol√©rance
   */
  static equals(a: number, b: number, epsilon: number = 1e-6): boolean {
    return Math.abs(a - b) < epsilon;
  }

  /**
   * G√©n√®re un nombre al√©atoire entre min et max
   */
  static random(min: number = 0, max: number = 1): number {
    return Math.random() * (max - min) + min;
  }

  /**
   * Convertit degr√©s en radians
   */
  static degToRad(degrees: number): number {
    return degrees * Math.PI / 180;
  }

  /**
   * Convertit radians en degr√©s
   */
  static radToDeg(radians: number): number {
    return radians * 180 / Math.PI;
  }

  /**
   * Normalise un angle en radians entre -PI et PI
   */
  static normalizeAngle(angle: number): number {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  /**
   * Interpolation smoothstep (plus douce que lerp)
   */
  static smoothstep(edge0: number, edge1: number, x: number): number {
    const t = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }

  /**
   * Fonction de easing (ease-in-out)
   */
  static easeInOut(t: number): number {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  /**
   * Calcule la position initiale du kite avec lignes tendues
   * Utilise le th√©or√®me de Pythagore pour placer le kite devant le pilote
   * 
   * @param pilotPosition - Position du pilote
   * @param kiteY - Hauteur Y du kite
   * @param lineLength - Longueur des lignes
   * @param distanceFactor - Facteur de distance initiale (0-1, typiquement 0.98 pour lignes presque tendues)
   * @param initialKiteZ - Position Z fixe (optionnelle, sinon calcul√©e automatiquement)
   * @returns Position 3D calcul√©e du kite
   */
  static calculateInitialKitePosition(
    pilotPosition: THREE.Vector3,
    kiteY: number,
    lineLength: number,
    distanceFactor: number,
    initialKiteZ?: number | null
  ): THREE.Vector3 {
    // Si une position Z fixe est fournie, l'utiliser directement
    if (initialKiteZ !== null && initialKiteZ !== undefined) {
      return new THREE.Vector3(pilotPosition.x, kiteY, initialKiteZ);
    }

    // Calculer la distance initiale (98% de la longueur des lignes par d√©faut)
    const initialDistance = lineLength * distanceFactor;

    // Diff√©rence de hauteur entre kite et pilote
    const dy = kiteY - pilotPosition.y;

    // Calculer la distance horizontale avec Pythagore: horizontal¬≤ = distance¬≤ - dy¬≤
    const horizontal = Math.max(
      0.1, // Minimum pour √©viter division par z√©ro
      Math.sqrt(Math.max(0, initialDistance * initialDistance - dy * dy))
    );

    // Position Z : devant le pilote (direction -Z)
    const kiteZ = pilotPosition.z - horizontal;

    return new THREE.Vector3(pilotPosition.x, kiteY, kiteZ);
  }
}

=== utils/UidGenerator.ts ===

/**
 * UidGenerator.ts - G√©n√©rateur d'identifiants uniques
 */

export class UidGenerator {
  private static counter = 0;
  private static readonly chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  /**
   * G√©n√®re un UID simple bas√© sur timestamp et compteur
   */
  static generate(prefix: string = ''): string {
    const timestamp = Date.now().toString(36);
    const count = (this.counter++).toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `${prefix}${timestamp}${count}${random}`;
  }

  /**
   * G√©n√®re un UID court (8 caract√®res)
   */
  static generateShort(): string {
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += this.chars.charAt(Math.floor(Math.random() * this.chars.length));
    }
    return result;
  }

  /**
   * G√©n√®re un UID bas√© sur des propri√©t√©s d'objet
   */
  static generateFromObject(obj: any, properties: string[]): string {
    let hash = 0;
    const str = properties.map(prop => obj[prop] || '').join('|');

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }

  /**
   * G√©n√®re un UUID v4 standard
   */
  static generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * G√©n√®re un ID s√©quentiel
   */
  static generateSequential(prefix: string = 'id_'): string {
    return `${prefix}${(this.counter++).toString().padStart(6, '0')}`;
  }

  /**
   * R√©initialise le compteur (utile pour les tests)
   */
  static reset(): void {
    this.counter = 0;
  }

  /**
   * V√©rifie si une cha√Æne est un UID valide (format de base)
   */
  static isValid(uid: string): boolean {
    // V√©rification basique : contient des lettres, chiffres, et fait une longueur raisonnable
    return /^[A-Za-z0-9_-]{8,}$/.test(uid);
  }

  /**
   * G√©n√®re un hash simple d'une cha√Æne
   */
  static hashString(str: string): string {
    let hash = 0;
    if (str.length === 0) return hash.toString(36);

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }
}

