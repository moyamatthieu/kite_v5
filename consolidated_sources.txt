CONSOLIDATION DES SOURCES - Thu Oct  9 13:33:30 UTC 2025
==================================

=== base/BaseComponent.ts ===

/**
 * BaseComponent.ts - Système de composants pour les objets 3D
 *
 * Pattern : Component Pattern (similaire à Unity/ECS)
 * Permet d'ajouter des fonctionnalités optionnelles aux Node3D
 * sans hériter de classes lourdes.
 */

import { Node3D } from '../core/Node3D';

export interface ComponentContext {
  deltaTime: number;
  totalTime: number;
  parent: Node3D;
}

export abstract class BaseComponent {
  protected name: string;
  protected enabled: boolean = true;
  protected parent?: Node3D;

  constructor(name: string) {
    this.name = name;
  }

  /**
   * Attache le composant à un parent
   */
  attachTo(parent: Node3D): void {
    this.parent = parent;
    this.onAttach();
  }

  /**
   * Détache le composant de son parent
   */
  detach(): void {
    this.onDetach();
    this.parent = undefined;
  }

  /**
   * Appelé quand le composant est attaché
   */
  protected onAttach(): void {
    // Override dans les sous-classes
  }

  /**
   * Appelé quand le composant est détaché
   */
  protected onDetach(): void {
    // Override dans les sous-classes
  }

  /**
   * Met à jour le composant
   */
  abstract update(context: ComponentContext): void;

  /**
   * Active/désactive le composant
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getParent(): Node3D | undefined {
    return this.parent;
  }
}

/**
 * Composant de debug visuel
 */
export class DebugComponent extends BaseComponent {
  update(context: ComponentContext): void {
    // Logique de debug visuel
  }
}

/**
 * Composant de physique
 */
export class PhysicsComponent extends BaseComponent {
  update(context: ComponentContext): void {
    // Logique de physique
  }
}

=== base/BaseFactory.ts ===

/**
 * BaseFactory.ts - Factory abstraite pour tous les objets 3D
 * 
 * Pattern Factory Method avec support des paramètres configurables
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';
import { BaseFactory as RegistryBaseFactory, FactoryMetadata } from '../factories/FactoryRegistry';

export interface FactoryParams {
  [key: string]: any;
}

export interface ObjectMetadata {
  category: string;
  name: string;
  description: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'complex';
}

/**
 * Factory abstraite pour la création d'objets 3D
 */
export abstract class BaseFactory<T extends StructuredObject & ICreatable> {
  protected abstract metadata: ObjectMetadata;

  /**
   * Créer un objet avec des paramètres optionnels
   */
  abstract createObject(params?: FactoryParams): T | Promise<T>;

  /**
   * Obtenir les métadonnées de l'objet
   */
  getMetadata(): ObjectMetadata {
    return { ...this.metadata };
  }

  /**
   * Obtenir la catégorie de l'objet
   */
  getCategory(): string {
    return this.metadata.category;
  }

  /**
   * Obtenir le nom de l'objet
   */
  getName(): string {
    return this.metadata.name;
  }

  /**
   * Valider les paramètres avant création
   */
  protected validateParams(params?: FactoryParams): void {
    // Validation de base - à surcharger dans les classes dérivées
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value === null || value === undefined) {
          throw new Error(`Paramètre '${key}' ne peut pas être null ou undefined`);
        }
      });
    }
  }

  /**
   * Paramètres par défaut - à surcharger dans les classes dérivées
   */
  protected getDefaultParams(): FactoryParams {
    return {};
  }

  /**
   * Fusionner les paramètres par défaut avec les paramètres fournis
   */
  protected mergeParams(params?: FactoryParams): FactoryParams {
    return {
      ...this.getDefaultParams(),
      ...params
    };
  }

  /**
   * Nettoyer les ressources de la factory
   */
  dispose(): void {
    // À surcharger dans les classes dérivées si nécessaire
  }
}


=== base/BaseSimulationSystem.ts ===

/**
 * BaseSimulationSystem.ts - Interface de base pour tous les systèmes de simulation
 *
 * Pattern : Template Method pour les systèmes de simulation
 * Chaque système (Physics, Wind, Input, etc.) hérite de cette classe
 * et implémente ses méthodes spécifiques.
 */

export interface SimulationContext {
  deltaTime: number;
  totalTime: number;
  isPaused: boolean;
  debugMode: boolean;
}

export abstract class BaseSimulationSystem {
  protected name: string;
  protected enabled: boolean = true;
  protected priority: number = 0; // Ordre d'exécution (plus petit = plus prioritaire)

  constructor(name: string, priority: number = 0) {
    this.name = name;
    this.priority = priority;
  }

  /**
   * Initialise le système (appelé une fois au démarrage)
   */
  abstract initialize(): void;

  /**
   * Met à jour le système (appelé chaque frame)
   */
  abstract update(context: SimulationContext): void;

  /**
   * Réinitialise le système à son état initial
   */
  abstract reset(): void;

  /**
   * Nettoie les ressources du système
   */
  abstract dispose(): void;

  /**
   * Active/désactive le système
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  isEnabled(): boolean {
    return this.enabled;
  }

  getName(): string {
    return this.name;
  }

  getPriority(): number {
    return this.priority;
  }

  /**
   * Validation interne du système
   */
  validate(): boolean {
    return true; // Override dans les sous-classes si nécessaire
  }
}

=== core/DebugLayer.ts ===

/**
 * DebugLayer.ts - Couche de debug visuel pour les objets 3D
 *
 * Rôle : Gestion centralisée de tous les éléments de debug visuel
 * Sépare complètement la logique de debug du mesh principal
 */

import * as THREE from 'three';
import { Node3D } from './Node3D';

export interface DebugOptions {
  showPoints?: boolean;
  showLabels?: boolean;
  showAxes?: boolean;
  showNormals?: boolean;
  pointSize?: number;
  labelSize?: number;
  axisLength?: number;
}

export class DebugLayer {
  public group: THREE.Group;
  private parent: Node3D;
  private options: DebugOptions;
  private pointsGroup: THREE.Group;
  private labelsGroup: THREE.Group;
  private axesGroup: THREE.Group;
  private normalsGroup: THREE.Group;

  constructor(parent: Node3D, options: DebugOptions = {}) {
    this.parent = parent;
    this.options = {
      showPoints: false,
      showLabels: false,
      showAxes: false,
      showNormals: false,
      pointSize: 0.05,
      labelSize: 0.1,
      axisLength: 1.0,
      ...options
    };

    this.group = new THREE.Group();
    this.group.name = `${parent.name}_debug`;

    this.pointsGroup = new THREE.Group();
    this.pointsGroup.name = 'points';
    this.group.add(this.pointsGroup);

    this.labelsGroup = new THREE.Group();
    this.labelsGroup.name = 'labels';
    this.group.add(this.labelsGroup);

    this.axesGroup = new THREE.Group();
    this.axesGroup.name = 'axes';
    this.group.add(this.axesGroup);

    this.normalsGroup = new THREE.Group();
    this.normalsGroup.name = 'normals';
    this.group.add(this.normalsGroup);

    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des points
   */
  setShowPoints(show: boolean): void {
    this.options.showPoints = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des labels
   */
  setShowLabels(show: boolean): void {
    this.options.showLabels = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des axes
   */
  setShowAxes(show: boolean): void {
    this.options.showAxes = show;
    this.updateVisibility();
  }

  /**
   * Active/désactive l'affichage des normales
   */
  setShowNormals(show: boolean): void {
    this.options.showNormals = show;
    this.updateVisibility();
  }

  /**
   * Ajoute un point de debug
   */
  addPoint(position: THREE.Vector3, color: number = 0xff0000, name?: string): void {
    const geometry = new THREE.SphereGeometry(this.options.pointSize, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const point = new THREE.Mesh(geometry, material);

    point.position.copy(position);
    if (name) point.name = name;

    this.pointsGroup.add(point);
  }

  /**
   * Ajoute une étiquette de debug
   */
  addLabel(position: THREE.Vector3, text: string, color: number = 0xffffff): void {
    // Note: Pour une vraie implémentation, il faudrait une bibliothèque de texte 3D
    // Pour l'instant, on utilise un point coloré avec le nom
    const geometry = new THREE.SphereGeometry(this.options.labelSize! * 0.5, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color });
    const label = new THREE.Mesh(geometry, material);

    label.position.copy(position);
    label.name = text;

    this.labelsGroup.add(label);
  }

  /**
   * Dessine les axes XYZ
   */
  drawAxes(length: number = this.options.axisLength!): void {
    this.clearAxes();

    // Axe X (rouge)
    const xAxis = this.createAxis(new THREE.Vector3(length, 0, 0), 0xff0000);
    this.axesGroup.add(xAxis);

    // Axe Y (vert)
    const yAxis = this.createAxis(new THREE.Vector3(0, length, 0), 0x00ff00);
    this.axesGroup.add(yAxis);

    // Axe Z (bleu)
    const zAxis = this.createAxis(new THREE.Vector3(0, 0, length), 0x0000ff);
    this.axesGroup.add(zAxis);
  }

  /**
   * Nettoie tous les éléments de debug
   */
  clear(): void {
    this.clearPoints();
    this.clearLabels();
    this.clearAxes();
    this.clearNormals();
  }

  /**
   * Met à jour la visibilité selon les options
   */
  private updateVisibility(): void {
    this.pointsGroup.visible = this.options.showPoints!;
    this.labelsGroup.visible = this.options.showLabels!;
    this.axesGroup.visible = this.options.showAxes!;
    this.normalsGroup.visible = this.options.showNormals!;
  }

  private createAxis(direction: THREE.Vector3, color: number): THREE.Group {
    const group = new THREE.Group();

    // Ligne de l'axe
    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      direction
    ]);
    const material = new THREE.LineBasicMaterial({ color });
    const line = new THREE.Line(geometry, material);
    group.add(line);

    // Flèche à l'extrémité
    const arrowGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
    const arrowMaterial = new THREE.MeshBasicMaterial({ color });
    const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    arrow.position.copy(direction);
    arrow.lookAt(direction);
    group.add(arrow);

    return group;
  }

  private clearPoints(): void {
    while (this.pointsGroup.children.length > 0) {
      const child = this.pointsGroup.children[0];
      this.pointsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearLabels(): void {
    while (this.labelsGroup.children.length > 0) {
      const child = this.labelsGroup.children[0];
      this.labelsGroup.remove(child);
      if (child instanceof THREE.Mesh) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }

  private clearAxes(): void {
    while (this.axesGroup.children.length > 0) {
      const child = this.axesGroup.children[0];
      this.axesGroup.remove(child);
      // Nettoyer récursivement les géométries et matériaux
      child.traverse((obj) => {
        if (obj instanceof THREE.Mesh) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        } else if (obj instanceof THREE.Line) {
          obj.geometry.dispose();
          (obj.material as THREE.Material).dispose();
        }
      });
    }
  }

  private clearNormals(): void {
    while (this.normalsGroup.children.length > 0) {
      const child = this.normalsGroup.children[0];
      this.normalsGroup.remove(child);
      if (child instanceof THREE.Line) {
        child.geometry.dispose();
        (child.material as THREE.Material).dispose();
      }
    }
  }
}

=== core/Node3D.ts ===


/**
 * Node3D.ts - Couche d'abstraction Godot-compatible pour la simulation Kite
 *
 * Rôle :
 *   - Encapsule THREE.Group avec une API similaire à Godot
 *   - Fournit des propriétés et méthodes compatibles avec le moteur Godot
 *   - Sert de base à StructuredObject et à tous les objets 3D du projet
 *
 * Dépendances principales :
 *   - Three.js : Pour la gestion des groupes et transformations 3D
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) hérite de Node3D
 *   - Tous les objets 3D du projet héritent indirectement de Node3D
 *
 * Utilisation typique :
 *   - Sert de base à la hiérarchie d'objets 3D
 *   - Permet la compatibilité avec Godot pour la portabilité
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';
import { SceneManager } from './SceneManager';

/**
 * Transform3D compatible Godot
 */
export interface Transform3D {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    scale: THREE.Vector3;
}

/**
 * Signal basique pour la communication entre nodes
 */
export interface Signal {
    name: string;
    callbacks: Array<{ target: Node3D; method: string }>;
}

/**
 * Node3D - Équivalent du Node3D de Godot
 * Hérite de THREE.Group pour la compatibilité
 */
export class Node3D extends THREE.Group {
    // 🎮 Propriétés Godot-like
    public transform: Transform3D;
    public signals: Map<string, Signal> = new Map();
    
    // 🏷️ Métadonnées
    public readonly nodeId: string;
    public nodeType: string = 'Node3D';
    
    // 🔧 État interne
    protected isReady: boolean = false;
    protected active: boolean = true;

    constructor(name: string = 'Node3D') {
        super();
        this.name = name;
        this.nodeId = this.generateNodeId();

        // Transform3D unifié
        this.transform = {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale
        };

        // Auto-enregistrement dans SceneManager
        SceneManager.getInstance().register(this);

        // Auto-initialisation
        this.callReady();
    }
    
    /**
     * Génère un ID unique pour le node (compatible Godot)
     */
    private generateNodeId(): string {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `node_${timestamp}_${random}`;
    }
    
    // === 🎮 Méthodes Cycle de Vie Godot ===
    
    /**
     * _ready() - Appelé une seule fois quand le node est ajouté à la scène
     */
    protected _ready(): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * _process() - Appelé à chaque frame
     */
    protected _process(delta: number): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * _physics_process() - Appelé à chaque frame physique
     */
    protected _physics_process(delta: number): void {
        // À overrider dans les classes dérivées
    }
    
    /**
     * Appel automatique de _ready()
     */
    private callReady(): void {
        if (!this.isReady) {
            this.isReady = true;
            this._ready();
        }
    }
    
    // === 🔗 Gestion des Signaux ===
    
    /**
     * Définit un signal (équivalent signal en GDScript)
     */
    public define_signal(name: string): void {
        if (!this.signals.has(name)) {
            this.signals.set(name, {
                name,
                callbacks: []
            });
        }
    }
    
    /**
     * Émet un signal
     */
    public emit_signal(name: string, ...args: any[]): void {
        const signal = this.signals.get(name);
        if (signal) {
            signal.callbacks.forEach(callback => {
                const method = (callback.target as any)[callback.method];
                if (typeof method === 'function') {
                    method.call(callback.target, ...args);
                }
            });
        }
    }
    
    /**
     * Connecte un signal à une méthode
     */
    public connect(signal: string, target: Node3D, method: string): void {
        if (!this.signals.has(signal)) {
            this.define_signal(signal);
        }
        
        const signalObj = this.signals.get(signal)!;
        signalObj.callbacks.push({ target, method });
    }
    
    // === 🌳 Gestion de l'Arbre de Nodes ===
    
    /**
     * Ajoute un enfant (compatible Godot)
     */
    public add_child(child: Node3D): void {
        this.add(child);
        child.callReady();
    }
    
    /**
     * Retire un enfant
     */
    public remove_child(child: Node3D): void {
        this.remove(child);
    }
    
    /**
     * Trouve un enfant par nom
     */
    public get_node(path: string): Node3D | null {
        return this.getObjectByName(path) as Node3D || null;
    }
    
    /**
     * Trouve tous les enfants d'un type donné
     */
    public get_children_of_type<T extends Node3D>(type: new (...args: any[]) => T): T[] {
        const result: T[] = [];
        this.traverse((obj) => {
            if (obj instanceof type) {
                result.push(obj);
            }
        });
        return result;
    }
    
    // === 🔄 Mise à Jour du Cycle de Vie ===
    
    /**
     * Met à jour le node et tous ses enfants
     */
    public update(delta: number): void {
        if (this.isReady) {
            this._process(delta);
            this._physics_process(delta);
            
            // Mettre à jour les enfants Node3D
            this.children.forEach(child => {
                if (child instanceof Node3D) {
                    child.update(delta);
                }
            });
        }
    }
    
    /**
     * Active/désactive le node
     */
    public setActive(active: boolean): void {
        this.active = active;
    }

    /**
     * Vérifie si le node est actif
     */
    public isActive(): boolean {
        return this.active;
    }

    /**
     * Obtient le nom du node
     */
    public getName(): string {
        return this.name;
    }

    /**
     * Appelé quand le node est enregistré dans SceneManager
     */
    public onRegister(): void {
        // À overrider dans les sous-classes
    }

    /**
     * Appelé quand le node est désenregistré de SceneManager
     */
    public onUnregister(): void {
        // À overrider dans les sous-classes
    }

    /**
     * Détruit le node et nettoie les ressources
     */
    public destroy(): void {
        // Désenregistrer du SceneManager
        SceneManager.getInstance().unregister(this);

        // Nettoyer les signaux
        this.signals.clear();

        // Nettoyer les enfants
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.destroy();
            }
        });

        // Nettoyer Three.js
        this.clear();
    }
    
    // === 🏷️ Métadonnées et Debug ===
    
    /**
     * Retourne une description du node
     */
    public get_description(): string {
        return `${this.nodeType}:${this.name} (${this.nodeId})`;
    }
    
    /**
     * Affiche l'arbre des nodes (debug)
     */
    public print_tree(indent: number = 0): void {
        const spaces = '  '.repeat(indent);
        console.log(`${spaces}${this.get_description()}`);
        
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.print_tree(indent + 1);
            }
        });
    }
    
    // === 🎯 Compatibilité Three.js ===
    
    /**
     * Accès direct au transform Three.js
     */
    public get three_transform() {
        return {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale,
            matrix: this.matrix,
            matrixWorld: this.matrixWorld
        };
    }
}


=== core/Primitive.ts ===


/**
 * Primitive.ts - Générateurs de primitives Three.js pour la simulation Kite
 *
 * Rôle :
 *   - Fournit des utilitaires pour créer les formes de base (cube, sphère, cylindre, etc.)
 *   - Permet de générer des matériaux cohérents pour les objets 3D
 *   - Sert à la construction des objets structurés (cerf-volant, barre, etc.)
 *
 * Dépendances principales :
 *   - Three.js : Pour la géométrie et les matériaux
 *   - Types : MaterialConfig pour la configuration des matériaux
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) utilise Primitive pour créer les éléments 3D
 *   - Tous les objets 3D du projet peuvent utiliser Primitive pour générer leurs formes
 *
 * Utilisation typique :
 *   - Appelé par les factories et objets structurés pour générer la géométrie
 *   - Sert à la création rapide et cohérente des primitives
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { MaterialConfig } from '../types/index';

/**
 * Classe statique pour générer les primitives de base
 */
export class Primitive {
  /**
   * Créer un matériau standardisé
   */
  private static createMaterial(config: string | MaterialConfig): THREE.MeshStandardMaterial {
    if (typeof config === 'string') {
      return new THREE.MeshStandardMaterial({ color: config });
    }

    return new THREE.MeshStandardMaterial({
      color: config.color,
      transparent: config.transparent || false,
      opacity: config.opacity || 1,
      metalness: config.metalness || 0,
      roughness: config.roughness || 0.5,
      side: config.side || THREE.FrontSide
    });
  }

  /**
   * Créer une boîte (cube ou parallélépipède)
   */
  static box(
    width: number,
    height: number,
    depth: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BoxGeometry(width, height, depth);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une sphère
   */
  static sphere(
    radius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un cylindre
   */
  static cylinder(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un cône
   */
  static cone(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un plan (surface plate)
   */
  static plane(
    width: number,
    height: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(width, height);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer un tore (anneau)
   */
  static torus(
    radius: number,
    tubeRadius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.TorusGeometry(radius, tubeRadius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une surface à partir de points (triangulation simple)
   */
  static surface(
    points: THREE.Vector3[],
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BufferGeometry();
    const vertices: number[] = [];

    // Ajouter les points
    points.forEach(point => {
      vertices.push(point.x, point.y, point.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    // Triangulation améliorée pour les quads (faces du cube)
    const indices: number[] = [];
    if (points.length === 3) {
      // Triangle simple
      indices.push(0, 1, 2);
    }

    if (points.length === 4) {
      // Quad - utiliser une triangulation qui préserve la manifold
      // Pour un cube, on utilise toujours la même diagonale (0,2)
      // Cela garantit que l'arête diagonale n'est pas partagée avec d'autres faces
      indices.push(0, 1, 2);  // Premier triangle
      indices.push(0, 2, 3);  // Deuxième triangle
    }

    if (points.length > 4) {
      // Fan triangulation pour plus de points
      for (let i = 1; i < points.length - 1; i++) {
        indices.push(0, i, i + 1);
      }
    }

    geometry.setIndex(indices);

    // Calculer les normales de manière cohérente
    geometry.computeVertexNormals();

    // S'assurer que les normales pointent vers l'extérieur pour un cube
    // En inversant si nécessaire
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Créer une flèche de debug (ArrowHelper)
   *
   * @param direction - Direction normalisée de la flèche
   * @param origin - Point d'origine de la flèche
   * @param length - Longueur de la flèche
   * @param color - Couleur (hex) de la flèche
   * @param headLength - Longueur de la tête de flèche (optionnel)
   * @param headWidth - Largeur de la tête de flèche (optionnel)
   * @returns THREE.ArrowHelper configuré
   */
  static arrow(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    headLength?: number,
    headWidth?: number
  ): THREE.ArrowHelper {
    return new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      headLength,
      headWidth
    );
  }
}

=== core/SceneManager.ts ===

/**
 * SceneManager.ts - Gestionnaire central de la scène 3D
 *
 * Rôle : Orchestrateur principal de tous les objets 3D
 * Gère le cycle de vie, les updates et la hiérarchie des Node3D
 */

import { Node3D } from './Node3D';
import * as THREE from 'three';

export class SceneManager {
  private static instance: SceneManager;
  private nodes: Set<Node3D> = new Set();
  private rootScene: THREE.Scene;
  private totalTime: number = 0;

  private constructor() {
    this.rootScene = new THREE.Scene();
  }

  static getInstance(): SceneManager {
    if (!SceneManager.instance) {
      SceneManager.instance = new SceneManager();
    }
    return SceneManager.instance;
  }

  /**
   * Enregistre un nouveau nœud dans la scène
   */
  register(node: Node3D): void {
    if (!this.nodes.has(node)) {
      this.nodes.add(node);
      node.onRegister();
    }
  }

  /**
   * Désenregistre un nœud de la scène
   */
  unregister(node: Node3D): void {
    if (this.nodes.has(node)) {
      node.onUnregister();
      this.nodes.delete(node);
    }
  }

  /**
   * Met à jour tous les nœuds enregistrés
   */
  update(deltaTime: number): void {
    this.totalTime += deltaTime;

    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: false,
      debugMode: false
    };

    // Mise à jour de tous les nœuds
    for (const node of this.nodes) {
      if (node.isActive()) {
        node.update(deltaTime);
      }
    }
  }

  /**
   * Ajoute un objet à la scène Three.js racine
   */
  addToScene(object: THREE.Object3D): void {
    this.rootScene.add(object);
  }

  /**
   * Retire un objet de la scène Three.js racine
   */
  removeFromScene(object: THREE.Object3D): void {
    this.rootScene.remove(object);
  }

  /**
   * Obtient la scène Three.js racine
   */
  getScene(): THREE.Scene {
    return this.rootScene;
  }

  /**
   * Recherche un nœud par nom
   */
  findNodeByName(name: string): Node3D | undefined {
    for (const node of this.nodes) {
      if (node.getName() === name) {
        return node;
      }
    }
    return undefined;
  }

  /**
   * Obtient tous les nœuds d'un certain type
   */
  getNodesOfType<T extends Node3D>(type: new (...args: any[]) => T): T[] {
    const result: T[] = [];
    for (const node of this.nodes) {
      if (node instanceof type) {
        result.push(node as T);
      }
    }
    return result;
  }

  /**
   * Nettoie tous les nœuds
   */
  clear(): void {
    for (const node of this.nodes) {
      node.destroy();
    }
    this.nodes.clear();
    this.rootScene.clear();
    this.totalTime = 0;
  }

  /**
   * Statistiques de la scène
   */
  getStats(): { nodeCount: number; totalTime: number } {
    return {
      nodeCount: this.nodes.size,
      totalTime: this.totalTime
    };
  }
}

=== core/StructuredObject.ts ===


/**
 * StructuredObject.ts - Classe de base unifiée pour tous les objets 3D structurés du projet Kite
 *
 * Rôle :
 *   - Fournit une architecture orientée objet avec points anatomiques nommés
 *   - Sert de classe mère pour tous les objets 3D complexes (cerf-volant, barre, etc.)
 *   - Compatible Godot via Node3D
 *
 * Dépendances principales :
 *   - Node3D.ts : Couche d'abstraction Godot-compatible
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : Position3D, NamedPoint, SurfaceOptions, MaterialConfig
 *   - Three.js : Pour la géométrie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Node3D.ts (dossier core) est la classe mère directe
 *   - Primitive.ts fournit les utilitaires de création
 *   - Tous les objets 3D du projet héritent de StructuredObject
 *
 * Utilisation typique :
 *   - Sert de base à la création de tous les objets 3D structurés
 *   - Permet la gestion des points, labels et debug
 *
 * Voir aussi :
 *   - src/core/Node3D.ts
 *   - src/core/Primitive.ts
 */

import * as THREE from 'three';

import { Position3D, NamedPoint, SurfaceOptions, MaterialConfig } from '../types/index';

import { Primitive } from './Primitive';
import { Node3D } from './Node3D';
import { DebugLayer } from './DebugLayer';

/**
 * Classe abstraite de base pour tous les objets 3D structurés
 * 🎮 Hérite de Node3D pour la compatibilité Godot
 */
export abstract class StructuredObject extends Node3D {
  /**
   * Points anatomiques nommés de l'objet
   */
  protected points: Map<string, THREE.Vector3> = new Map();

  /**
   * Points avec marqueurs visuels (debug)
   */
  protected namedPoints: NamedPoint[] = [];

  /**
   * Couche de debug séparée
   */
  protected debugLayer: DebugLayer;

  /**
   * Affichage des labels en mode debug
   */
  public showDebugPoints: boolean = false;

  /**
   * Affichage des labels de texte
   */
  public showLabels: boolean = false;

  constructor(name: string, showDebugPoints: boolean = false) {
    super(name);
    this.nodeType = 'StructuredObject';
    this.showDebugPoints = showDebugPoints;

    // Initialiser la couche de debug
    this.debugLayer = new DebugLayer(this, {
      showPoints: showDebugPoints,
      showLabels: false,
      showNormals: false,
      showAxes: false,
      pointSize: 0.02
    });

    // L'initialisation sera appelée par la classe enfant après configuration
  }

  /**
   * Initialisation automatique de l'objet
   */
  protected initialize(): void {
    // Vider le groupe au cas où
    this.clear();

    // Construire l'objet dans l'ordre
    this.definePoints();
    this.buildStructure();
    this.buildSurfaces();

    // Mettre à jour la couche de debug
    this.updateDebugLayer();
  }

  /**
   * Initialisation publique à appeler par les classes enfants
   */
  public init(): void {
    this.initialize();
  }

  /**
   * Définit tous les points anatomiques de l'objet
   * À implémenter dans chaque classe dérivée
   */
  protected abstract definePoints(): void;

  /**
   * Construit la structure rigide de l'objet (frame, squelette)
   * À implémenter dans chaque classe dérivée
   */
  protected abstract buildStructure(): void;

  /**
   * Construit les surfaces et détails visuels
   * À implémenter dans chaque classe dérivée
   */
  protected abstract buildSurfaces(): void;

  /**
   * Définit un point nommé dans l'espace
   */
  protected setPoint(name: string, position: Position3D): void {
    const vector = new THREE.Vector3(position[0], position[1], position[2]);
    this.points.set(name, vector);
    
    // Ajouter aux points nommés pour le debug
    this.namedPoints.push({
      name,
      position: vector.clone(),
      visible: this.showDebugPoints
    });
  }

  /**
   * Récupère un point par son nom
   */
  public getPoint(name: string): THREE.Vector3 | undefined {
    return this.points.get(name);
  }

  /**
   * Crée un cylindre entre deux points nommés
   */
  protected addCylinderBetweenPoints(
    point1Name: string,
    point2Name: string,
    radius: number,
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    const p1 = this.getPoint(point1Name);
    const p2 = this.getPoint(point2Name);
    
    if (!p1 || !p2) {
      console.warn(`Points ${point1Name} ou ${point2Name} non trouvés`);
      return null;
    }

    // Calculer la distance et l'orientation
    const distance = p1.distanceTo(p2);
    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
    
    // Créer le cylindre
    const cylinder = Primitive.cylinder(radius, distance, material);
    
    // Orienter le cylindre
    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction
    );
    cylinder.quaternion.copy(quaternion);
    cylinder.position.copy(midpoint);
    
    // Ajouter au groupe
    this.add(cylinder);
    return cylinder;
  }

  /**
   * Crée une surface entre des points nommés
   */
  protected addSurfaceBetweenPoints(
    pointNames: string[],
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    if (pointNames.length < 3) {
      console.warn('Il faut au moins 3 points pour créer une surface');
      return null;
    }

    const points: THREE.Vector3[] = [];
    
    // Récupérer tous les points
    for (const name of pointNames) {
      const point = this.getPoint(name);
      if (!point) {
        console.warn(`Point ${name} non trouvé`);
        return null;
      }
      points.push(point);
    }

    // Créer la surface
    const surface = Primitive.surface(points, material);
    this.add(surface);
    return surface;
  }

  /**
   * Ajoute une primitive à une position donnée
   */
  protected addPrimitiveAt(
    primitive: THREE.Mesh,
    position: Position3D
  ): void {
    primitive.position.set(position[0], position[1], position[2]);
    this.add(primitive);
  }

  /**
   * Ajoute une primitive à la position d'un point nommé
   */
  protected addPrimitiveAtPoint(
    primitive: THREE.Mesh,
    pointName: string
  ): boolean {
    const point = this.getPoint(pointName);
    if (!point) {
      console.warn(`Point ${pointName} non trouvé`);
      return false;
    }
    
    primitive.position.copy(point);
    this.add(primitive);
    return true;
  }

  /**
   * Met à jour la couche de debug avec les points actuels
   */
  protected updateDebugLayer(): void {
    // Vider la couche de debug
    this.debugLayer.clear();

    if (this.showDebugPoints) {
      // Ajouter tous les points nommés
      for (const [name, position] of this.points.entries()) {
        this.debugLayer.addPoint(position, 0xffff00, this.showLabels ? name : undefined);
      }
    }
  }
  
  /**
   * Crée un label de texte pour un point
   */
  private createTextLabel(text: string): THREE.Sprite {
    // Créer un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 64;
    
    // Style du texte
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.font = 'Bold 24px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);
    
    // Créer une texture depuis le canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Créer un sprite avec la texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Ajuster la taille du sprite
    sprite.scale.set(0.3, 0.075, 1);
    
    return sprite;
  }

  /**
   * Active/désactive l'affichage des marqueurs de debug
   */
  public setShowDebugPoints(show: boolean): void {
    this.showDebugPoints = show;
    this.debugLayer.setShowPoints(show);
  }

  /**
   * Active/désactive l'affichage des labels de texte
   */
  public setShowLabels(show: boolean): void {
    this.showLabels = show;
    this.debugLayer.setShowLabels(show);
    // Si les points de debug ne sont pas activés et qu'on veut les labels, activer les deux
    if (show && !this.showDebugPoints) {
      this.setShowDebugPoints(true);
    }
  }  /**
   * Retourne tous les noms de points définis
   */
  public getPointNames(): string[] {
    return Array.from(this.points.keys());
  }

  /**
   * Retourne le nombre de points définis
   */
  public getPointCount(): number {
    return this.points.size;
  }

  /**
   * Retourne les informations sur un point
   */
  public getPointInfo(name: string): NamedPoint | undefined {
    const point = this.getPoint(name);
    if (!point) return undefined;
    
    return {
      name,
      position: point.clone(),
      visible: this.showDebugPoints
    };
  }
}

=== factories/BridleFactory.ts ===

/**
 * BridleFactory.ts - Factory pour créer les instances Line représentant les brides
 *
 * Rôle :
 *   - Crée les 6 brides (3 gauches + 3 droites) comme instances de Line
 *   - Fournit une configuration physique spécifique aux brides (Dyneema courtes et rigides)
 *   - Centralise la création pour garantir cohérence et validation
 *
 * Architecture :
 *   - Réutilise la classe Line (même que lignes principales)
 *   - Config différente : plus rigides, plus courtes, moins élastiques
 *   - Pattern Factory comme LineFactory
 *
 * Relation avec les autres modules :
 *   - Utilise Line (src/objects/mechanical/Line.ts)
 *   - Utilisé par BridleSystem
 *   - Config basée sur BridleLengths (BridleTypes.ts)
 *
 * Voir aussi :
 *   - src/factories/LineFactory.ts (pattern similaire)
 *   - src/objects/mechanical/Line.ts
 *   - src/simulation/types/BridleTypes.ts
 */

import { Line, LineConfig, LineAttachments } from "@objects/mechanical/Line";

import { BridleLengths, BridleAttachment, BridleSide, BridlePosition } from "../simulation/types/BridleTypes";

/**
 * Factory pour créer les brides du cerf-volant
 *
 * Les brides sont des lignes courtes et rigides en Dyneema qui relient
 * les points anatomiques du kite (NEZ, INTER, CENTRE) aux points de contrôle (CTRL).
 */
export class BridleFactory {
  /**
   * Configuration physique standard pour les brides
   *
   * Les brides sont plus rigides et moins élastiques que les lignes principales :
   * - Plus courtes (0.5-0.7m vs 15m)
   * - Plus rigides (5000 N/m vs 2200 N/m)
   * - Moins d'amortissement (quasi-rigides)
   * - Très légères
   */
  private static readonly BRIDLE_CONFIG: Omit<LineConfig, 'length'> = {
    stiffness: 5000,           // N/m - Très rigides (Dyneema courte)
    preTension: 10,            // N - Pré-tension faible
    maxTension: 300,           // N - Résistance avant rupture
    dampingCoeff: 0.02,        // Sans dimension - Peu d'amortissement
    linearMassDensity: 0.0003, // kg/m - Très légères
  };

  /**
   * Mapping des positions vers les points anatomiques
   */
  private static readonly POINT_MAPPING = {
    left: {
      nez: { start: "NEZ", end: "CTRL_GAUCHE" },
      inter: { start: "INTER_GAUCHE", end: "CTRL_GAUCHE" },
      centre: { start: "CENTRE", end: "CTRL_GAUCHE" },
    },
    right: {
      nez: { start: "NEZ", end: "CTRL_DROIT" },
      inter: { start: "INTER_DROIT", end: "CTRL_DROIT" },
      centre: { start: "CENTRE", end: "CTRL_DROIT" },
    },
  } as const;

  /**
   * Crée une bride individuelle
   *
   * @param side - Côté (left/right)
   * @param position - Position (nez/inter/centre)
   * @param length - Longueur en mètres
   * @returns Instance Line configurée
   */
  static createBridle(
    side: BridleSide,
    position: BridlePosition,
    length: number
  ): Line {
    const points = this.POINT_MAPPING[side][position];
    const id = `bridle_${side}_${position}`;

    const config: LineConfig = {
      ...this.BRIDLE_CONFIG,
      length,
    };

    const attachments: LineAttachments = {
      kitePoint: points.start,
      barPoint: points.end,
    };

    return new Line(config, attachments, id);
  }

  /**
   * Crée les 3 brides du côté gauche
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createLeftBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('left', 'nez', lengths.nez),
      this.createBridle('left', 'inter', lengths.inter),
      this.createBridle('left', 'centre', lengths.centre),
    ];
  }

  /**
   * Crée les 3 brides du côté droit
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createRightBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('right', 'nez', lengths.nez),
      this.createBridle('right', 'inter', lengths.inter),
      this.createBridle('right', 'centre', lengths.centre),
    ];
  }

  /**
   * Crée toutes les 6 brides (gauches + droites)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Objet contenant les brides gauches et droites
   */
  static createAllBridles(lengths: BridleLengths): {
    left: [Line, Line, Line];
    right: [Line, Line, Line];
  } {
    return {
      left: this.createLeftBridles(lengths),
      right: this.createRightBridles(lengths),
    };
  }

  /**
   * Crée les métadonnées d'attache pour toutes les brides
   * (utilisé pour documentation/debug)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 6 BridleAttachment
   */
  static createBridleAttachments(lengths: BridleLengths): BridleAttachment[] {
    const attachments: BridleAttachment[] = [];

    // Brides gauches
    Object.entries(this.POINT_MAPPING.left).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_left_${position}`,
      });
    });

    // Brides droites
    Object.entries(this.POINT_MAPPING.right).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_right_${position}`,
      });
    });

    return attachments;
  }

  /**
   * Valide les longueurs de brides
   *
   * @param lengths - Longueurs à valider
   * @throws Error si longueurs invalides
   */
  static validateBridleLengths(lengths: BridleLengths): void {
    const { nez, inter, centre } = lengths;

    // Vérifier valeurs positives
    if (nez <= 0 || inter <= 0 || centre <= 0) {
      throw new Error(
        `Longueurs de brides doivent être positives: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // Vérifier plage raisonnable (0.2m à 1.5m)
    const min = 0.2;
    const max = 1.5;
    if (nez < min || nez > max || inter < min || inter > max || centre < min || centre > max) {
      throw new Error(
        `Longueurs de brides hors plage [${min}, ${max}]m: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // Vérifier cohérence géométrique (bride nez généralement plus longue)
    if (nez < inter * 0.8 || nez < centre * 0.8) {
      console.warn(
        `⚠️ Bride NEZ plus courte que INTER/CENTRE peut causer instabilité: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }
  }

  /**
   * Obtient la configuration physique utilisée pour les brides
   * (utile pour debug/documentation)
   */
  static getBridleConfig(): Omit<LineConfig, 'length'> {
    return { ...this.BRIDLE_CONFIG };
  }
}


=== factories/FactoryRegistry.ts ===

/**
 * FactoryRegistry.ts - Registre centralisé des factories
 *
 * Permet la création dynamique d'objets depuis un nom ou un type
 * Pattern : Factory Registry + Plugin Architecture
 */

export interface FactoryMetadata {
  id: string;
  name: string;
  version: string;
  description: string;
  supportedTypes: string[];
  dependencies: string[];
}

export interface BaseFactory {
  createObject(type: string, config: any): any;
  getSupportedTypes(): string[];
  getMetadata(): FactoryMetadata;
  dispose(): void;
}

type FactoryConstructor = new () => BaseFactory;

export interface FactoryParams {
  [key: string]: any;
}

export class FactoryRegistry {
  private static factories = new Map<string, FactoryConstructor>();
  private static instances = new Map<string, BaseFactory>();

  /**
   * Enregistre une factory dans le registre
   */
  static register(name: string, factoryClass: FactoryConstructor): void {
    if (this.factories.has(name)) {
      console.warn(`Factory "${name}" is already registered. Overwriting.`);
    }
    this.factories.set(name, factoryClass);
  }

  /**
   * Désenregistre une factory
   */
  static unregister(name: string): void {
    if (this.factories.has(name)) {
      // Nettoyer l'instance si elle existe
      if (this.instances.has(name)) {
        const instance = this.instances.get(name)!;
        instance.dispose();
        this.instances.delete(name);
      }
      this.factories.delete(name);
    }
  }

  /**
   * Crée un objet en utilisant la factory enregistrée
   */
  static createObject(name: string, params?: FactoryParams): any {
    const factoryClass = this.factories.get(name);
    if (!factoryClass) {
      throw new Error(`Factory "${name}" not found. Available factories: ${Array.from(this.factories.keys()).join(', ')}`);
    }

    // Obtenir ou créer l'instance de factory
    let factory = this.instances.get(name);
    if (!factory) {
      factory = new factoryClass();
      this.instances.set(name, factory);
    }

    // Créer l'objet
    return factory.createObject('default', params);
  }

  /**
   * Vérifie si une factory est enregistrée
   */
  static hasFactory(name: string): boolean {
    return this.factories.has(name);
  }

  /**
   * Obtient la liste des factories enregistrées
   */
  static getRegisteredFactories(): string[] {
    return Array.from(this.factories.keys());
  }

  /**
   * Obtient les métadonnées d'une factory
   */
  static getFactoryMetadata(name: string): { name: string; description?: string } | null {
    const factory = this.instances.get(name);
    if (factory) {
      return factory.getMetadata();
    }
    return null;
  }

  /**
   * Nettoie toutes les factories et instances
   */
  static clear(): void {
    // Nettoyer toutes les instances
    for (const [name, instance] of this.instances) {
      try {
        instance.dispose();
      } catch (error) {
        console.error(`Error disposing factory "${name}":`, error);
      }
    }

    this.instances.clear();
    this.factories.clear();
  }

  /**
   * Recharge une factory (utile pour le développement)
   */
  static reloadFactory(name: string): void {
    if (this.instances.has(name)) {
      const instance = this.instances.get(name)!;
      instance.dispose();
      this.instances.delete(name);
    }
    // La prochaine création recréera l'instance
  }
}

=== factories/FrameFactory.ts ===

/**
 * FrameFactory.ts - Factory pour créer des structures filaires (frames)
 */

import { BaseFactory, FactoryMetadata } from './FactoryRegistry';
import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export interface FrameParams {
  diameter?: number;
  material?: string;
  points?: Array<[string, number[]]>;
  connections?: Array<[string, string]>;
}

/**
 * Factory pour créer des structures filaires
 */
export class FrameFactory implements BaseFactory {
  getSupportedTypes(): string[] {
    return ['frame', 'structure'];
  }

  getMetadata(): FactoryMetadata {
    return {
      id: 'frame_factory',
      name: 'Frame Factory',
      version: '1.0.0',
      description: 'Creates wireframe structures from connected points',
      supportedTypes: this.getSupportedTypes(),
      dependencies: []
    };
  }

  createObject(type: string, config: FrameParams = {}): StructuredObject & ICreatable {
    const params = {
      diameter: 0.01,
      material: '#333333',
      points: [],
      connections: [],
      ...config
    };

    class FrameObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Frame", false);
      }

      protected definePoints(): void {
        if (params.points) {
          params.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        if (params.connections) {
          params.connections.forEach(([point1, point2]) => {
            this.addCylinderBetweenPoints(
              point1,
              point2,
              params.diameter || 0.01,
              params.material || '#333333'
            );
          });
        }
      }

      protected buildSurfaces(): void {
        // Pas de surfaces pour un frame
      }

      create(): this { return this; }
      getName(): string { return 'Frame'; }
      getDescription(): string { return 'Structure filaire'; }
      getPrimitiveCount(): number { return params.connections?.length || 0; }
    }

    const frame = new FrameObject();
    frame.init();
    return frame;
  }

  dispose(): void {
    // Cleanup if needed
  }
}

=== factories/LineFactory.ts ===

/**
 * LineFactory.ts - Factory pour créer des lignes de cerf-volant (OOP pattern)
 *
 * Rôle :
 *   - Créer des objets Line selon le pattern Factory du projet
 *   - Valider les paramètres avant création
 *   - Fournir des presets pour configurations typiques
 *
 * Responsabilité :
 *   - Instanciation cohérente des objets Line
 *   - Application des valeurs par défaut
 *   - Validation des paramètres physiques
 *
 * Pattern :
 *   - Ne suit PAS BaseFactory<StructuredObject> car Line n'est pas un objet 3D
 *   - Factory simple avec méthodes statiques pour configurations communes
 *   - Séparation claire : Line (métier) vs LineVisual (3D)
 *
 * Relation avec les autres modules :
 *   - Crée des objets Line
 *   - Utilisé par LineSystem pour instancier les lignes
 *   - Indépendant de Three.js (pure TypeScript)
 *
 * Philosophie :
 *   - "Make invalid states unrepresentable" : Validation stricte
 *   - Presets pour cas d'usage communs
 *   - Immutabilité : Les lignes créées sont immutables (config readonly)
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts
 *   - src/base/BaseFactory.ts (pattern de référence)
 */

import { Line, LineConfig, LineAttachments } from '@objects/mechanical/Line';

import { CONFIG } from '@/simulation/config/SimulationConfig';

/**
 * Paramètres pour créer une ligne via factory
 */
export interface LineFactoryParams {
  /** Longueur au repos (m) - Défaut: CONFIG.lines.defaultLength */
  length?: number;

  /** Point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;

  /** Rigidité personnalisée (N/m) - Défaut: CONFIG.lines.stiffness */
  stiffness?: number;

  /** Pré-tension personnalisée (N) - Défaut: CONFIG.lines.preTension */
  preTension?: number;

  /** Tension max personnalisée (N) - Défaut: CONFIG.lines.maxTension */
  maxTension?: number;

  /** Damping personnalisé - Défaut: CONFIG.lines.dampingCoeff */
  dampingCoeff?: number;

  /** Masse linéique personnalisée (kg/m) - Défaut: CONFIG.lines.linearMassDensity */
  linearMassDensity?: number;

  /** Identifiant personnalisé (optionnel) */
  id?: string;
}

/**
 * Erreur de validation lors de la création d'une ligne
 */
export class LineValidationError extends Error {
  constructor(message: string, public field: string) {
    super(`LineFactory validation error [${field}]: ${message}`);
    this.name = 'LineValidationError';
  }
}

/**
 * Factory pour créer des lignes de cerf-volant
 *
 * @example
 * ```typescript
 * // Ligne standard avec paramètres par défaut
 * const leftLine = LineFactory.createLine({
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Ligne personnalisée
 * const customLine = LineFactory.createLine({
 *   length: 20,
 *   stiffness: 1800,
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Preset débutant
 * const beginnerLine = LineFactory.createBeginnerLine("CTRL_GAUCHE", "HANDLE_LEFT");
 * ```
 */
export class LineFactory {
  /**
   * Crée une ligne avec paramètres personnalisés
   *
   * @param params - Paramètres de configuration
   * @returns Instance de Line configurée
   * @throws LineValidationError si paramètres invalides
   */
  static createLine(params: LineFactoryParams): Line {
    // Valider les paramètres
    this.validateParams(params);

    // Configuration avec valeurs par défaut depuis SimulationConfig
    const config: LineConfig = {
      length: params.length ?? CONFIG.lines.defaultLength,
      stiffness: params.stiffness ?? CONFIG.lines.stiffness,
      preTension: params.preTension ?? CONFIG.lines.preTension,
      maxTension: params.maxTension ?? CONFIG.lines.maxTension,
      dampingCoeff: params.dampingCoeff ?? CONFIG.lines.dampingCoeff,
      linearMassDensity: params.linearMassDensity ?? CONFIG.lines.linearMassDensity
    };

    // Points d'attache
    const attachments: LineAttachments = {
      kitePoint: params.kitePoint,
      barPoint: params.barPoint
    };

    // Créer et retourner la ligne
    return new Line(config, attachments, params.id);
  }

  /**
   * Crée une paire de lignes gauche/droite standard
   *
   * @param length - Longueur commune (m)
   * @returns Tuple [ligne gauche, ligne droite]
   */
  static createLinePair(length?: number): [Line, Line] {
    const leftLine = this.createLine({
      length,
      kitePoint: "CTRL_GAUCHE",
      barPoint: "HANDLE_LEFT",
      id: "line_left"
    });

    const rightLine = this.createLine({
      length,
      kitePoint: "CTRL_DROIT",
      barPoint: "HANDLE_RIGHT",
      id: "line_right"
    });

    return [leftLine, rightLine];
  }

  /**
   * Preset : Ligne pour débutant
   * - Plus courte (12m)
   * - Moins rigide (1800 N/m)
   * - Pré-tension plus faible (50N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configurée pour débutant
   */
  static createBeginnerLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 12,
      stiffness: 1800,
      preTension: 50,
      maxTension: 600,
      dampingCoeff: 0.08, // Plus de damping = plus stable
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne pour expert
   * - Plus longue (20m)
   * - Rigidité standard (2200 N/m)
   * - Haute tension max (1000N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configurée pour expert
   */
  static createExpertLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 20,
      stiffness: 2200,
      preTension: 100,
      maxTension: 1000,
      dampingCoeff: 0.03, // Moins de damping = plus réactif
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne de sécurité (ultra-résistante)
   * - Tension max très élevée (1500N)
   * - Rigidité renforcée (3000 N/m)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne de sécurité
   */
  static createSafetyLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 15,
      stiffness: 3000,
      preTension: 150,
      maxTension: 1500,
      dampingCoeff: 0.05,
      linearMassDensity: 0.001, // Plus lourde
      kitePoint,
      barPoint
    });
  }

  /**
   * Crée une ligne depuis JSON (désérialisation)
   *
   * @param json - Données JSON (depuis Line.toJSON())
   * @returns Instance de Line recréée
   */
  static fromJSON(json: any): Line {
    return Line.fromJSON(json);
  }

  /**
   * Valide les paramètres avant création
   *
   * @param params - Paramètres à valider
   * @throws LineValidationError si invalide
   */
  private static validateParams(params: LineFactoryParams): void {
    // Points d'attache obligatoires
    if (!params.kitePoint || params.kitePoint.trim() === '') {
      throw new LineValidationError('Kite attachment point is required', 'kitePoint');
    }

    if (!params.barPoint || params.barPoint.trim() === '') {
      throw new LineValidationError('Bar attachment point is required', 'barPoint');
    }

    // Longueur positive
    if (params.length !== undefined && params.length <= 0) {
      throw new LineValidationError('Length must be positive', 'length');
    }

    // Rigidité positive
    if (params.stiffness !== undefined && params.stiffness <= 0) {
      throw new LineValidationError('Stiffness must be positive', 'stiffness');
    }

    // Pré-tension non-négative
    if (params.preTension !== undefined && params.preTension < 0) {
      throw new LineValidationError('PreTension cannot be negative', 'preTension');
    }

    // Tension max > pré-tension
    if (params.maxTension !== undefined && params.preTension !== undefined) {
      if (params.maxTension <= params.preTension) {
        throw new LineValidationError(
          'MaxTension must be greater than preTension',
          'maxTension'
        );
      }
    }

    // Damping dans [0, 1]
    if (params.dampingCoeff !== undefined) {
      if (params.dampingCoeff < 0 || params.dampingCoeff > 1) {
        throw new LineValidationError(
          'DampingCoeff must be between 0 and 1',
          'dampingCoeff'
        );
      }
    }

    // Masse linéique positive
    if (params.linearMassDensity !== undefined && params.linearMassDensity <= 0) {
      throw new LineValidationError(
        'LinearMassDensity must be positive',
        'linearMassDensity'
      );
    }
  }

  /**
   * Obtient les valeurs par défaut utilisées par la factory
   *
   * @returns Configuration par défaut
   */
  static getDefaultConfig(): LineConfig {
    return {
      length: CONFIG.lines.defaultLength,
      stiffness: CONFIG.lines.stiffness,
      preTension: CONFIG.lines.preTension,
      maxTension: CONFIG.lines.maxTension,
      dampingCoeff: CONFIG.lines.dampingCoeff,
      linearMassDensity: CONFIG.lines.linearMassDensity
    };
  }

  /**
   * Vérifie si deux lignes ont la même configuration physique
   *
   * @param line1 - Première ligne
   * @param line2 - Deuxième ligne
   * @returns true si configurations identiques
   */
  static areConfigsEqual(line1: Line, line2: Line): boolean {
    const c1 = line1.config;
    const c2 = line2.config;

    return (
      c1.length === c2.length &&
      c1.stiffness === c2.stiffness &&
      c1.preTension === c2.preTension &&
      c1.maxTension === c2.maxTension &&
      c1.dampingCoeff === c2.dampingCoeff &&
      c1.linearMassDensity === c2.linearMassDensity
    );
  }
}


=== factories/PointFactory.ts ===

/**
 * PointFactory.ts - Encapsule la logique de calcul des points anatomiques
 *
 * Responsabilité : Calculer les positions des points d'un cerf-volant delta
 */

import * as THREE from 'three';

/**
 * Longueurs physiques des brides (en mètres)
 */
export interface BridleLengths {
  nez: number;      // Longueur bride NEZ -> CTRL (avant)
  inter: number;    // Longueur bride INTER -> CTRL (latéral)
  centre: number;   // Longueur bride CENTRE -> CTRL (arrière)
}

export interface KiteParams {
  width: number;   // Envergure
  height: number;  // Hauteur
  depth: number;   // Profondeur whiskers
  bridleLengths?: BridleLengths;  // Longueurs physiques des brides
}

/**
 * Factory simple qui encapsule la logique de calcul des points
 */
export class PointFactory {
  /**
   * Longueurs de brides par défaut (en mètres)
   * LONGUEURS IDENTIQUES : L'équilibre géométrique vient de la structure, pas des brides
   */
  private static readonly DEFAULT_BRIDLE_LENGTHS: BridleLengths = {
    nez: 0.65,     // 65cm - identique pour toutes les brides
    inter: 0.65,   // 65cm - identique pour toutes les brides
    centre: 0.65,  // 65cm - identique pour toutes les brides
  };

  /**
   * Calcule la position du point de contrôle (CTRL) par trilatération 3D analytique
   * Résout l'intersection de 3 sphères centrées en NEZ, INTER, CENTRE
   * avec rayons = longueurs de brides respectives
   */
  private static calculateControlPoint(
    nez: [number, number, number],
    inter: [number, number, number],
    centre: [number, number, number],
    bridleLengths: BridleLengths,
    side: 'left' | 'right'
  ): [number, number, number] {
    // Convertir en Vector3
    const p1 = new THREE.Vector3(...nez);      // Point 1 : NEZ
    const p2 = new THREE.Vector3(...inter);    // Point 2 : INTER
    const p3 = new THREE.Vector3(...centre);   // Point 3 : CENTRE

    const r1 = bridleLengths.nez;     // Rayon sphère 1
    const r2 = bridleLengths.inter;   // Rayon sphère 2
    const r3 = bridleLengths.centre;  // Rayon sphère 3

    // Trilatération 3D analytique
    // Étape 1 : Créer un repère local avec p1 à l'origine
    const ex = new THREE.Vector3().subVectors(p2, p1).normalize(); // axe X : direction p1->p2
    const d = p2.distanceTo(p1); // distance entre p1 et p2

    // Étape 2 : Calculer composante Y du repère
    const p3_p1 = new THREE.Vector3().subVectors(p3, p1);
    const i = ex.dot(p3_p1); // projection de p3-p1 sur ex
    const ey_temp = new THREE.Vector3().copy(p3_p1).addScaledVector(ex, -i);
    const ey = ey_temp.normalize(); // axe Y : perpendiculaire à ex dans le plan

    // Étape 3 : Axe Z (perpendiculaire au plan p1-p2-p3)
    const ez = new THREE.Vector3().crossVectors(ex, ey);

    // IMPORTANT : Pour garantir la symétrie, ez doit toujours pointer vers l'arrière (+Z global)
    // Si ez.z < 0, on inverse la direction
    if (ez.z < 0) {
      ez.negate();
    }

    // Étape 4 : Coordonnées de p3 dans le repère local
    const j = ey.dot(p3_p1);

    // Étape 5 : Résolution du système dans le repère local
    // x = (r1² - r2² + d²) / (2d)
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);

    // y = (r1² - r3² + i² + j²) / (2j) - (i/j) * x
    const y = (r1 * r1 - r3 * r3 + i * i + j * j) / (2 * j) - (i / j) * x;

    // z² = r1² - x² - y²
    const zSquared = r1 * r1 - x * x - y * y;

    // Si z² < 0, les sphères ne se croisent pas (configuration impossible)
    let z: number;
    if (zSquared < 0) {
      console.warn(`⚠️ Configuration de brides impossible (z²=${zSquared.toFixed(3)}), approximation`);
      z = 0; // Solution dégénérée : CTRL dans le plan des 3 points
    } else {
      // Deux solutions possibles (devant/derrière le plan)
      // On prend z > 0 (vers l'arrière du kite, direction +Z)
      // Pour garantir la SYMÉTRIE, les deux côtés doivent avoir le même Z
      z = Math.sqrt(zSquared);
    }

    // Étape 6 : Convertir les coordonnées locales en coordonnées globales
    const result = new THREE.Vector3();
    result.copy(p1); // Partir de p1
    result.addScaledVector(ex, x); // Ajouter x * ex
    result.addScaledVector(ey, y); // Ajouter y * ey
    result.addScaledVector(ez, z); // Ajouter z * ez

    return [result.x, result.y, result.z];
  }

  /**
   * Calcule toutes les positions des points anatomiques d'un cerf-volant delta
   */
  static calculateDeltaKitePoints(params: KiteParams): Map<string, [number, number, number]> {
    const { width, height, depth, bridleLengths = PointFactory.DEFAULT_BRIDLE_LENGTHS } = params;

    // Logique métier extraite de Kite.ts
    const centreY = height / 4;
    const ratio = (height - centreY) / height;
    const interGaucheX = ratio * (-width / 2);
    const interDroitX = ratio * (width / 2);
    const fixRatio = 2 / 3;

    // Points d'ancrage fixes des brides
    const nezPos: [number, number, number] = [0, height, 0];
    const centrePos: [number, number, number] = [0, height / 4, 0];
    const interGauchePos: [number, number, number] = [interGaucheX, centreY, 0];
    const interDroitPos: [number, number, number] = [interDroitX, centreY, 0];

    // Calculer la position du point de contrôle DROIT par trilatération.
    // Le point GAUCHE sera déduit par symétrie pour garantir une géométrie parfaite.
    const ctrlDroit = PointFactory.calculateControlPoint(
      nezPos,
      interDroitPos, // Utilise le point d'ancrage droit
      centrePos,
      bridleLengths,
      'right'
    );

    // Le point de contrôle GAUCHE est le miroir du point droit par rapport à l'axe YZ.
    // On prend la position du point droit et on inverse simplement sa coordonnée X.
    const ctrlGauche: [number, number, number] = [-ctrlDroit[0], ctrlDroit[1], ctrlDroit[2]];

    // Retourner la Map exactement comme dans le code original
    return new Map<string, [number, number, number]>([
      // Points structurels principaux
      ["SPINE_BAS", [0, 0, 0]],
      ["CENTRE", centrePos],
      ["NEZ", nezPos],

      // Points des bords d'attaque
      ["BORD_GAUCHE", [-width / 2, 0, 0]],
      ["BORD_DROIT", [width / 2, 0, 0]],

      // Points d'intersection pour le spreader
      ["INTER_GAUCHE", interGauchePos],
      ["INTER_DROIT", interDroitPos],

      // Points de fixation whiskers
      ["FIX_GAUCHE", [fixRatio * interGaucheX, centreY, 0]],
      ["FIX_DROIT", [fixRatio * interDroitX, centreY, 0]],

      // Points des whiskers
      ["WHISKER_GAUCHE", [-width / 4, 0.1, -depth]],
      ["WHISKER_DROIT", [width / 4, 0.1, -depth]],

      // Points de contrôle (bridage) - CALCULÉS depuis longueurs physiques
      ["CTRL_GAUCHE", ctrlGauche],
      ["CTRL_DROIT", ctrlDroit],

      // Points d'ancrage des brides
      ["BRIDE_GAUCHE_A", nezPos],
      ["BRIDE_GAUCHE_B", interGauchePos],
      ["BRIDE_GAUCHE_C", centrePos],
      ["BRIDE_DROITE_A", nezPos],
      ["BRIDE_DROITE_B", interDroitPos],
      ["BRIDE_DROITE_C", centrePos],
    ]);
  }
}

=== factories/SurfaceFactory.ts ===

/**
 * SurfaceFactory.ts - Factory pour créer des surfaces et toiles
 *
 * Pattern actuel KISS : Points → Triangles pour surfaces
 * Compatible avec buildSurfaces() de StructuredObject
 */

import * as THREE from "three";

import { BaseFactory, FactoryParams } from "../base/BaseFactory";
import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";

export interface SurfaceParams extends FactoryParams {
  points?: Array<[string, number[]]>; // Points nommés pour la surface
  panels?: Array<string[]>; // Groupes de 3-4 points formant des panneaux
  material?: {
    color?: string;
    opacity?: number;
    transparent?: boolean;
    doubleSided?: boolean; // true = visible des deux côtés (défaut), false = une face
    side?: THREE.Side;
  };
  tension?: number; // Tension de la toile (future feature)
}

/**
 * Factory pour créer des surfaces tendues
 *
 * TODO: Questions pour évolution future
 * - [ ] Implémenter subdivision de surfaces pour plus de détail ? non
 * - [ ] Ajouter simulation de tension/déformation ? non
 * - [ ] Supporter surfaces courbes (NURBS simplifiées) ? non
 * - [ ] Calculer automatiquement la triangulation optimale ? non
 * - [ ] Ajouter textures procédurales (tissage, ripstop) ? non
 * - [ ] Gérer les plis et déformations ? non
 *
 */
export class SurfaceFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: "surface",
    name: "Surface",
    description: "Surface tendue paramétrique",
    tags: ["surface", "toile", "membrane"],
    complexity: "simple" as const,
  };

  protected getDefaultParams(): SurfaceParams {
    return {
      points: [],
      panels: [],
      material: {
        color: "#ff0000",
        opacity: 0.9,
        transparent: true,
        doubleSided: true, // Par défaut, visible des deux côtés
      },
      tension: 1.0,
    };
  }

  createObject(params?: SurfaceParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as SurfaceParams;

    class SurfaceObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Surface", false);
      }

      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        // Pas de structure pour une surface pure
      }

      protected buildSurfaces(): void {
        // Créer les panneaux de surface
        if (mergedParams.panels) {
          mergedParams.panels.forEach((panel) => {
            // Convertir doubleSided en THREE.Side
            const mat = mergedParams.material || {};
            const side =
              mat.doubleSided !== false ? THREE.DoubleSide : THREE.FrontSide;

            // Chaque panneau est un triangle (3 points) ou quad (4 points)
            this.addSurfaceBetweenPoints(panel, {
              color: mat.color || "#ff0000",
              opacity: mat.opacity !== undefined ? mat.opacity : 0.9,
              transparent: mat.transparent !== false,
              side: mat.side || side,
            });
          });
        }
      }

      // Implémentation ICreatable
      create(): this {
        return this;
      }
      getName(): string {
        return "Surface";
      }
      getDescription(): string {
        return "Surface tendue";
      }
      getPrimitiveCount(): number {
        return (mergedParams.panels || []).length;
      }
    }

    const surface = new SurfaceObject();
    surface.init();
    return surface;
  }
}


=== factories/presets/PhysicalPresets.ts ===

/**
 * PhysicalPresets.ts - Constantes physiques centralisées
 *
 * Toutes les constantes physiques, matériaux et configurations
 * utilisées dans la simulation du cerf-volant.
 */

import * as THREE from 'three';

// ============================================================================
// CONSTANTES PHYSIQUES FONDAMENTALES
// ============================================================================

export const PHYSICAL_CONSTANTS = {
  gravity: 9.81, // m/s² - Accélération gravitationnelle terrestre
  airDensity: 1.225, // kg/m³ - Densité de l'air à 15°C
  speedOfSound: 343, // m/s - Vitesse du son dans l'air
  dynamicViscosity: 1.81e-5, // Pa·s - Viscosité dynamique de l'air
} as const;

// ============================================================================
// PRÉSETS DE MATÉRIAUX PHYSIQUES
// ============================================================================

export const MATERIAL_PRESETS = {
  // Matériaux de structure (carbone/kevlar)
  carbon: {
    density: 1600, // kg/m³
    youngModulus: 230e9, // Pa - Module de Young
    tensileStrength: 3500e6, // Pa - Résistance à la traction
    color: 0x333333,
    name: 'Carbone'
  },

  kevlar: {
    density: 1440, // kg/m³
    youngModulus: 130e9, // Pa
    tensileStrength: 3600e6, // Pa
    color: 0x666666,
    name: 'Kevlar'
  },

  // Matériaux de surface (tissus)
  ripstopNylon: {
    density: 40, // g/m² (surface density)
    thickness: 0.00015, // m
    tensileStrength: 150e6, // Pa
    color: 0xffffff,
    name: 'Ripstop Nylon'
  },

  dacron: {
    density: 45, // g/m²
    thickness: 0.00018, // m
    tensileStrength: 180e6, // Pa
    color: 0xf0f0f0,
    name: 'Dacron'
  }
} as const;

// ============================================================================
// PRÉSETS DE LIGNES ET BRIDES
// ============================================================================

export const LINE_PRESETS = {
  standard: {
    stiffness: 2200, // N/m - Rigidité
    preTension: 75, // N - Tension minimale
    maxTension: 800, // N - Tension maximale
    dampingCoeff: 0.05, // Coefficient d'amortissement
    linearMassDensity: 0.0005, // kg/m - Masse linéique
    color: 0xffaa00,
    name: 'Ligne Standard'
  },

  bridle: {
    stiffness: 5000, // N/m - Plus rigide pour les brides
    preTension: 10, // N - Tension minimale faible
    maxTension: 300, // N - Tension maximale
    dampingCoeff: 0.02, // Amortissement faible
    linearMassDensity: 0.0003, // kg/m - Plus léger
    color: 0x00aaff,
    name: 'Bride'
  },

  control: {
    stiffness: 1800, // N/m - Moins rigide pour le contrôle
    preTension: 50, // N
    maxTension: 600, // N
    dampingCoeff: 0.08, // Amortissement plus fort
    linearMassDensity: 0.0007, // kg/m - Plus lourd
    color: 0xff4444,
    name: 'Ligne de Contrôle'
  }
} as const;

// ============================================================================
// PRÉSETS AÉRODYNAMIQUES
// ============================================================================

export const AERODYNAMIC_PRESETS = {
  // Coefficients de portance (lift) selon l'angle d'attaque
  liftCoefficients: {
    low: 0.2,     // Angle d'attaque faible
    medium: 0.8,  // Angle d'attaque moyen
    high: 1.2,    // Angle d'attaque élevé
    stall: 0.1    // Décrochage
  },

  // Coefficients de traînée (drag)
  dragCoefficients: {
    low: 0.05,    // Profil optimisé
    medium: 0.08, // Profil standard
    high: 0.15,   // Profil dégradé
    stall: 0.3    // Décrochage
  },

  // Facteurs d'échelle pour équilibrer la simulation
  scaleFactors: {
    lift: 1.2,    // Facteur de portance
    drag: 1.2,    // Facteur de traînée
    torque: 1.0   // Facteur de couple
  }
} as const;

// ============================================================================
// PRÉSETS DE VENT
// ============================================================================

export const WIND_PRESETS = {
  calm: {
    speed: 5,      // km/h
    direction: 0,  // degrés
    turbulence: 0.001, // %
    name: 'Calme'
  },

  light: {
    speed: 15,     // km/h
    direction: 0,  // degrés
    turbulence: 0.005, // %
    name: 'Léger'
  },

  moderate: {
    speed: 25,     // km/h
    direction: 0,  // degrés
    turbulence: 0.01, // %
    name: 'Modéré'
  },

  strong: {
    speed: 35,     // km/h
    direction: 0,  // degrés
    turbulence: 0.02, // %
    name: 'Fort'
  }
} as const;

// ============================================================================
// PRÉSETS DE CONFIGURATION KITE
// ============================================================================

export const KITE_PRESETS = {
  standard: {
    area: 0.5288,  // m² - Surface calculée
    mass: 0.31,    // kg - Masse calculée
    span: 1.65,    // m - Envergure
    aspectRatio: 3.12, // Rapport d'allongement
    name: 'Kite Standard'
  },

  sport: {
    area: 0.6,     // m²
    mass: 0.28,    // kg
    span: 1.8,     // m
    aspectRatio: 3.5,
    name: 'Kite Sport'
  },

  beginner: {
    area: 0.8,     // m²
    mass: 0.35,    // kg
    span: 2.0,     // m
    aspectRatio: 2.8,
    name: 'Kite Débutant'
  }
} as const;

// ============================================================================
// UTILITAIRES
// ============================================================================

export class PhysicalUtils {
  /**
   * Calcule la pression dynamique
   */
  static dynamicPressure(velocity: THREE.Vector3, airDensity: number = PHYSICAL_CONSTANTS.airDensity): number {
    const speed = velocity.length();
    return 0.5 * airDensity * speed * speed;
  }

  /**
   * Calcule le nombre de Reynolds
   */
  static reynoldsNumber(velocity: number, length: number, viscosity: number = PHYSICAL_CONSTANTS.dynamicViscosity): number {
    return (velocity * length) / viscosity;
  }

  /**
   * Convertit km/h en m/s
   */
  static kmhToMs(speedKmh: number): number {
    return speedKmh / 3.6;
  }

  /**
   * Convertit m/s en km/h
   */
  static msToKmh(speedMs: number): number {
    return speedMs * 3.6;
  }
}

=== main.ts ===

import { Simulation } from "./simulation";

// Initialisation de la simulation
console.log("🚀 Démarrage de la simulation ...");

async function startSimulation() {
  try {
    const app = new Simulation();
    await app.initialize();
    console.log("✅ Simulation initialisée avec succès");
    
    // Démarrer la simulation
    await app.start();
    console.log("▶️ Simulation démarrée");

    // Gestion du nettoyage lors de la fermeture de la page
    window.addEventListener("beforeunload", () => {
      if (app && typeof app.cleanup === "function") {
        app.cleanup();
      }
    });
  } catch (error) {
    console.error("❌ Erreur lors de l'initialisation de la simulation:", error);
  }
}

// Lancer la simulation au chargement
startSimulation();


=== objects/mechanical/Line.ts ===

/**
 * Line.ts - Entité métier représentant une ligne de cerf-volant
 *
 * Rôle :
 *   - Encapsule les propriétés physiques d'une ligne (Dyneema/Spectra)
 *   - Représente une ligne individuelle du système de pilotage
 *   - Pure data object, pas de logique de calcul
 *
 * Responsabilité :
 *   - Stocker les paramètres physiques (longueur, rigidité, tension)
 *   - Gérer les points d'attache (nom des points anatomiques)
 *   - Fournir un état cohérent pour les calculs physiques
 *
 * Relation avec les autres modules :
 *   - Utilisé par LinePhysics pour les calculs de force
 *   - Créé par LineFactory
 *   - Consommé par LineSystem (orchestration)
 *
 * Philosophie :
 *   - "Tell, don't ask" : La ligne expose son état, ne fait pas de calculs
 *   - Immutabilité partielle : Les paramètres physiques sont readonly
 *   - Single Responsibility : Représentation métier uniquement
 *
 * Voir aussi :
 *   - src/simulation/physics/LinePhysics.ts (calculs)
 *   - src/factories/LineFactory.ts (création)
 *   - src/objects/mechanical/LineVisual.ts (rendu)
 */

import * as THREE from "three";

/**
 * Configuration physique d'une ligne de cerf-volant
 */
export interface LineConfig {
  /** Longueur au repos (mètres) */
  length: number;

  /** Rigidité axiale EA/L (N/m) - Typique Dyneema : 2200 N/m pour 15m */
  stiffness: number;

  /** Pré-tension minimale (N) - Toujours présente, même ligne molle */
  preTension: number;

  /** Tension maximale avant rupture (N) */
  maxTension: number;

  /** Coefficient d'amortissement interne (sans dimension, 0-1) */
  dampingCoeff: number;

  /** Masse linéique (kg/m) - Pour calcul caténaire */
  linearMassDensity: number;
}

/**
 * Points d'attache d'une ligne
 */
export interface LineAttachments {
  /** Nom du point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Nom du point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;
}

/**
 * Entité représentant une ligne de cerf-volant
 *
 * @example
 * ```typescript
 * const leftLine = new Line({
 *   length: 15,
 *   stiffness: 2200,
 *   preTension: 75,
 *   maxTension: 800,
 *   dampingCoeff: 0.05,
 *   linearMassDensity: 0.0005
 * }, {
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 * ```
 */
export class Line {
  /** Identifiant unique de la ligne */
  public readonly id: string;

  /** Configuration physique (immuable) */
  public readonly config: Readonly<LineConfig>;

  /** Points d'attache (immuables) */
  public readonly attachments: Readonly<LineAttachments>;

  /** État actuel de la ligne */
  private currentLength: number;
  private currentTension: number;

  /** Timestamp dernière mise à jour */
  private lastUpdateTime: number;

  constructor(
    config: LineConfig,
    attachments: LineAttachments,
    id?: string
  ) {
    this.id = id || `line_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = Object.freeze({ ...config });
    this.attachments = Object.freeze({ ...attachments });

    // État initial
    this.currentLength = config.length;
    this.currentTension = config.preTension;
    this.lastUpdateTime = 0;
  }

  /**
   * Met à jour l'état actuel de la ligne
   * (Appelé par LinePhysics après calcul)
   */
  updateState(length: number, tension: number, timestamp: number): void {
    this.currentLength = length;
    this.currentTension = tension;
    this.lastUpdateTime = timestamp;
  }

  /**
   * Obtient la longueur actuelle (étirée)
   */
  getCurrentLength(): number {
    return this.currentLength;
  }

  /**
   * Obtient la tension actuelle
   */
  getCurrentTension(): number {
    return this.currentTension;
  }

  /**
   * Calcule l'extension actuelle (Δx = L_current - L_rest)
   */
  getExtension(): number {
    return Math.max(0, this.currentLength - this.config.length);
  }

  /**
   * Vérifie si la ligne est tendue
   */
  isTaut(): boolean {
    return this.currentLength > this.config.length;
  }

  /**
   * Vérifie si la ligne est proche de la rupture
   */
  isNearBreaking(threshold: number = 0.9): boolean {
    return this.currentTension >= this.config.maxTension * threshold;
  }

  /**
   * Obtient le timestamp de dernière mise à jour
   */
  getLastUpdateTime(): number {
    return this.lastUpdateTime;
  }

  /**
   * Clone cette ligne avec une nouvelle configuration
   */
  clone(newConfig?: Partial<LineConfig>): Line {
    return new Line(
      { ...this.config, ...newConfig },
      { ...this.attachments }
    );
  }

  /**
   * Représentation textuelle pour debug
   */
  toString(): string {
    return `Line[${this.id}](${this.attachments.kitePoint} → ${this.attachments.barPoint}) ` +
           `L=${this.currentLength.toFixed(3)}m T=${this.currentTension.toFixed(1)}N`;
  }

  /**
   * Export JSON pour sérialisation
   */
  toJSON(): object {
    return {
      id: this.id,
      config: this.config,
      attachments: this.attachments,
      state: {
        currentLength: this.currentLength,
        currentTension: this.currentTension,
        lastUpdateTime: this.lastUpdateTime
      }
    };
  }

  /**
   * Crée une ligne depuis JSON
   */
  static fromJSON(data: any): Line {
    const line = new Line(data.config, data.attachments, data.id);
    if (data.state) {
      line.updateState(
        data.state.currentLength,
        data.state.currentTension,
        data.state.lastUpdateTime
      );
    }
    return line;
  }
}


=== objects/organic/Kite.ts ===


/**
 * Kite.ts - Modèle 3D du cerf-volant delta pour la simulation Kite
 *
 * Rôle :
 *   - Définit la structure, les points anatomiques et les surfaces du cerf-volant
 *   - Utilise les factories pour générer la géométrie, la structure et la toile
 *   - Sert de base à tous les calculs physiques et au rendu
 *
 * Dépendances principales :
 *   - StructuredObject.ts : Classe de base pour tous les objets 3D structurés
 *   - FrameFactory.ts, SurfaceFactory.ts, PointFactory.ts : Factories pour la création des éléments du kite
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : ICreatable pour l'interface de création
 *   - Three.js : Pour la géométrie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Les factories (FrameFactory, SurfaceFactory, PointFactory) sont utilisées pour générer la structure et la toile
 *   - StructuredObject.ts (dossier core) est la classe mère
 *
 * Utilisation typique :
 *   - Instancié par le moteur physique et le rendu pour manipuler le kite
 *   - Sert de source unique pour les points et la géométrie du kite
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 *   - src/factories/FrameFactory.ts
 *   - src/factories/SurfaceFactory.ts
 *   - src/factories/PointFactory.ts
 */

import * as THREE from "three";

import { StructuredObject } from "../../core/StructuredObject";
import { ICreatable } from "../../types/index";
import { Primitive } from "../../core/Primitive";
import { FrameFactory } from "../../factories/FrameFactory";
import { SurfaceFactory } from "../../factories/SurfaceFactory";
import { PointFactory, BridleLengths } from "../../factories/PointFactory";
import { FactoryRegistry } from "../../factories/FactoryRegistry";
import { CONFIG } from "../../simulation/config/SimulationConfig";

export class Kite extends StructuredObject implements ICreatable {
  private frameFactory: FrameFactory;
  private surfaceFactory: SurfaceFactory;
  // Map centrale des points - Single Source of Truth
  private pointsMap: Map<string, [number, number, number]> = new Map();
  private bridleLines: THREE.Group | null = null;
  private bridleLengthFactor: number = 1.0; // Facteur de longueur virtuelle des brides principales

  // Longueurs physiques des brides (en mètres)
  // LONGUEURS IDENTIQUES : L'équilibre vient de la géométrie, pas des brides
  // Principe: Kite suspendu par CTRL_GAUCHE et CTRL_DROIT sera horizontal
  // si le centre de masse se trouve entre ces deux points (axe X)
  private bridleLengths: BridleLengths = {
    nez: 0.65,     // 65cm - longueur standard
    inter: 0.65,   // 65cm - longueur standard
    centre: 0.65,  // 65cm - longueur standard
  };

  // Paramètres du cerf-volant
  private params = {
    width: 1.65, // Envergure
    height: 0.65, // Hauteur
    depth: 0.20, // Profondeur whiskers
    frameDiameter: 0.01,
    frameColor: "#2a2a2a",
    sailColor: "#ff3333",
    sailOpacity: 0.9,
  };

  constructor(customParams = {}) {
    super("Cerf-volant Delta", false);
    this.params = { ...this.params, ...customParams };
    this.frameFactory = new FrameFactory();
    this.surfaceFactory = new SurfaceFactory();
    this.init();
  }

  /**
   * Définit tous les points anatomiques du cerf-volant
   * Utilise PointFactory pour encapsuler la logique de calcul
   */
  protected definePoints(): void {
    const { width, height, depth } = this.params;

    // Utiliser PointFactory pour calculer les positions avec bridleLengths physiques
    this.pointsMap = PointFactory.calculateDeltaKitePoints({
      width,
      height,
      depth,
      bridleLengths: this.bridleLengths
    });

    // Enregistrer dans StructuredObject pour compatibilité avec le système existant
    this.pointsMap.forEach((position, name) => {
      this.setPoint(name, position);
    });
  }

  /**
   * Construit la structure rigide avec FrameFactory
   */
  protected buildStructure(): void {
    const { frameDiameter, frameColor } = this.params;

    // Créer le frame principal avec la Map de points partagée
    const mainFrameParams = {
      diameter: frameDiameter,
      material: frameColor,
      points: Array.from(this.pointsMap.entries()), // Passer LA Map de référence
      connections: [
        // Épine centrale
        ["NEZ", "SPINE_BAS"] as [string, string],
        // Bords d'attaque
        ["NEZ", "BORD_GAUCHE"] as [string, string],
        ["NEZ", "BORD_DROIT"] as [string, string],
        // Spreader
        ["INTER_GAUCHE", "INTER_DROIT"] as [string, string],
      ],
    };

    const mainFrame = this.frameFactory.createObject('frame', mainFrameParams);
    this.add(mainFrame);

    // Créer les whiskers avec un frame séparé (plus fin)
    const whiskerFrameParams = {
      diameter: frameDiameter / 2,
      material: "#444444",
      points: Array.from(this.pointsMap.entries()), // Même Map de référence
      connections: [
        ["WHISKER_GAUCHE", "FIX_GAUCHE"] as [string, string],
        ["WHISKER_DROIT", "FIX_DROIT"] as [string, string],
      ],
    };

    const whiskerFrame = this.frameFactory.createObject('frame', whiskerFrameParams);
    this.add(whiskerFrame);

    // Créer le système de bridage avec des lignes souples
    this.createBridleLines();
  }

  /**
   * Crée les lignes de bridage souples (visuelles uniquement)
   * Ces lignes représentent des cordes sans élasticité ni effet ressort
   */
  private createBridleLines(): void {
    // Supprimer les anciennes lignes si elles existent
    if (this.bridleLines) {
      this.remove(this.bridleLines);
    }

    this.bridleLines = new THREE.Group();
    this.bridleLines.name = "BridleLines";

    // Configuration des brides
    const bridleConnections = [
      // Bridage gauche (3 lignes partant de CTRL_GAUCHE)
      ["CTRL_GAUCHE", "NEZ"],
      ["CTRL_GAUCHE", "INTER_GAUCHE"],
      ["CTRL_GAUCHE", "CENTRE"],
      // Bridage droit (3 lignes partant de CTRL_DROIT)
      ["CTRL_DROIT", "NEZ"],
      ["CTRL_DROIT", "INTER_DROIT"],
      ["CTRL_DROIT", "CENTRE"],
    ];

    // Matériau pour les lignes de bridage
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: 1,
      opacity: 0.8,
      transparent: true,
    });

    // Créer chaque ligne de bridage
    bridleConnections.forEach(([startName, endName]) => {
      const startPos = this.pointsMap.get(startName);
      const endPos = this.pointsMap.get(endName);

      if (startPos && endPos) {
        // Créer une ligne droite simple (sans effet caténaire pour les brides internes)
        const geometry = new THREE.BufferGeometry();
        const points = [
          new THREE.Vector3(...startPos),
          new THREE.Vector3(...endPos),
        ];
        geometry.setFromPoints(points);

        const line = new THREE.Line(geometry, lineMaterial);
        line.name = `Bridle_${startName}_${endName}`;

        // Stocker la longueur de repos de la bride
        const restLength = new THREE.Vector3(...startPos).distanceTo(
          new THREE.Vector3(...endPos)
        );
        line.userData.restLength = restLength;
        line.userData.startPoint = startName;
        line.userData.endPoint = endName;

        this.bridleLines!.add(line);
      }
    });

    this.add(this.bridleLines!);
  }

  /**
   * Met à jour les lignes de bridage pour suivre les points
   * À appeler si les points bougent dynamiquement
   */
  public updateBridleLines(): void {
    if (!this.bridleLines) return;

    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const startName = line.userData.startPoint;
        const endName = line.userData.endPoint;
        const startPos = this.pointsMap.get(startName);
        const endPos = this.pointsMap.get(endName);

        if (startPos && endPos) {
          const geometry = line.geometry as THREE.BufferGeometry;
          const points = [
            new THREE.Vector3(...startPos),
            new THREE.Vector3(...endPos),
          ];
          geometry.setFromPoints(points);
          geometry.attributes.position.needsUpdate = true;
        }
      }
    });
  }

  /**
   * Met à jour la visualisation des brides selon leurs tensions
   * Couleurs : vert (molle) → jaune (moyenne) → rouge (tendue)
   *
   * @param tensions - Tensions des 6 brides en Newtons
   */
  public updateBridleVisualization(tensions: {
    leftNez: number;
    leftInter: number;
    leftCentre: number;
    rightNez: number;
    rightInter: number;
    rightCentre: number;
  }): void {
    if (!this.bridleLines) return;

    // Mapping nom ligne → tension
    const tensionMap = new Map<string, number>([
      ["Bridle_CTRL_GAUCHE_NEZ", tensions.leftNez],
      ["Bridle_CTRL_GAUCHE_INTER_GAUCHE", tensions.leftInter],
      ["Bridle_CTRL_GAUCHE_CENTRE", tensions.leftCentre],
      ["Bridle_CTRL_DROIT_NEZ", tensions.rightNez],
      ["Bridle_CTRL_DROIT_INTER_DROIT", tensions.rightInter],
      ["Bridle_CTRL_DROIT_CENTRE", tensions.rightCentre],
    ]);

    // Mettre à jour couleur de chaque bride
    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const tension = tensionMap.get(line.name) ?? 0;
        const material = line.material as THREE.LineBasicMaterial;

        // Seuils de tension (N) - centralisés dans CONFIG
        const lowThreshold = CONFIG.debug.bridleTensionLow;
        const highThreshold = CONFIG.debug.bridleTensionHigh;

        if (tension < lowThreshold) {
          // Vert : bride molle
          material.color.setHex(0x00ff00);
          material.opacity = 0.5;
        } else if (tension < highThreshold) {
          // Jaune : tension moyenne
          // Interpolation vert → jaune
          const t = (tension - lowThreshold) / (highThreshold - lowThreshold);
          const r = Math.floor(t * 255);
          const g = 255;
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.6 + t * 0.2; // 0.6 → 0.8
        } else {
          // Rouge : bride tendue
          // Interpolation jaune → rouge
          const t = Math.min((tension - highThreshold) / 100, 1);
          const r = 255;
          const g = Math.floor((1 - t) * 255);
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.8 + t * 0.2; // 0.8 → 1.0
        }
      }
    });
  }

  /**
   * Construit les surfaces avec SurfaceFactory
   */
  protected buildSurfaces(): void {
    const { sailColor, sailOpacity } = this.params;

    // Créer la toile avec 4 panneaux triangulaires
    const sailParams = {
      points: Array.from(this.pointsMap.entries()), // Même Map de référence
      panels: [
        // Toile gauche
        ["NEZ", "BORD_GAUCHE", "WHISKER_GAUCHE"],
        ["NEZ", "WHISKER_GAUCHE", "SPINE_BAS"],
        // Toile droite
        ["NEZ", "BORD_DROIT", "WHISKER_DROIT"],
        ["NEZ", "WHISKER_DROIT", "SPINE_BAS"],
      ],
      material: {
        color: sailColor,
        transparent: true,
        opacity: sailOpacity,
        doubleSided: true, // Visible des deux côtés
      },
    };

    const sail = this.surfaceFactory.createObject(sailParams);
    this.add(sail);

    // Ajouter des marqueurs visuels aux points clés
    this.addVisualMarkers();
  }

  /**
   * Méthode helper pour obtenir la Map de points
   * Peut être utilisée si d'autres objets ont besoin des points
   */
  public getPointsMap(): Map<string, [number, number, number]> {
    return new Map(this.pointsMap); // Retourner une copie pour éviter les modifications externes
  }

  /**
   * Ajuste le facteur de longueur virtuelle des brides principales (NEZ vers CTRL_*)
   * @param factor - Facteur de longueur (0.5 = 50% plus court, 1.0 = normal, 1.5 = 50% plus long)
   */
  public adjustBridleLength(factor: number): void {
    // Limiter la valeur entre 0.5 et 1.5
    this.bridleLengthFactor = Math.max(0.5, Math.min(1.5, factor));
    console.log(
      `📏 Facteur de longueur des brides principales: ${this.bridleLengthFactor}`
    );
  }

  /**
   * Retourne la longueur de repos virtuelle pour les brides principales
   * Utilisé par la physique pour calculer les tensions
   * @param bridleName - 'left' ou 'right'
   * @returns La longueur de repos modifiée ou undefined si pas une bride principale
   */
  public getBridleRestLength(bridleName: "left" | "right"): number | undefined {
    const nez = this.getPoint("NEZ");
    const ctrl = this.getPoint(
      bridleName === "left" ? "CTRL_GAUCHE" : "CTRL_DROIT"
    );

    if (!nez || !ctrl) return undefined;

    // Calculer la distance géométrique réelle
    const realDistance = nez.distanceTo(ctrl);

    // Appliquer le facteur de longueur virtuelle
    // factor < 1 = bride plus courte = plus de tension
    // factor > 1 = bride plus longue = moins de tension
    return realDistance * this.bridleLengthFactor;
  }

  /**
   * Retourne le facteur de longueur actuel des brides
   */
  public getBridleLengthFactor(): number {
    return this.bridleLengthFactor;
  }

  /**
   * Ajuste les longueurs physiques des brides (en mètres)
   * @param lengths - Longueurs des 3 brides { nez, inter, centre }
   */
  public setBridleLengths(lengths: Partial<BridleLengths>): void {
    // Mettre à jour les longueurs (merge avec les valeurs existantes)
    this.bridleLengths = {
      ...this.bridleLengths,
      ...lengths
    };

    console.log(`🪁 Longueurs brides: NEZ=${this.bridleLengths.nez.toFixed(2)}m, INTER=${this.bridleLengths.inter.toFixed(2)}m, CENTRE=${this.bridleLengths.centre.toFixed(2)}m`);

    // Supprimer tous les enfants pour nettoyer l'ancienne géométrie
    this.clearChildren();

    // Recalculer les points avec les nouvelles longueurs
    this.definePoints();

    // Reconstruire le kite avec les nouveaux points
    this.buildStructure();
    this.buildSurfaces();
    this.createBridleLines();

    // Recréer les marqueurs visuels aux nouvelles positions
    this.addVisualMarkers();
  }

  /**
   * Supprime tous les enfants du kite (géométrie, marqueurs, etc.)
   */
  private clearChildren(): void {
    // Supprimer tous les enfants Three.js
    while (this.children.length > 0) {
      this.remove(this.children[0]);
    }
  }

  /**
   * Retourne les longueurs actuelles des brides
   */
  public getBridleLengths(): BridleLengths {
    return { ...this.bridleLengths };
  }

  /**
   * Transforme un point local en coordonnées monde
   *
   * Cette méthode utilitaire évite la duplication du pattern:
   * `localPos.clone().applyQuaternion(kite.quaternion).add(kite.position)`
   *
   * @param localPos - Position dans le repère local du kite
   * @returns Position dans le repère monde
   *
   * @example
   * ```typescript
   * const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
   * const worldPos = kite.localToWorld(ctrlLeft);
   * ```
   */
  public localToWorld(localPos: THREE.Vector3): THREE.Vector3 {
    return localPos
      .clone()
      .applyQuaternion(this.quaternion)
      .add(this.position);
  }

  /**
   * Ajoute des marqueurs visuels aux points importants
   */
  private addVisualMarkers(): void {
    // Nez (point rouge)
    const nez = this.getPoint("NEZ");
    if (nez) {
      const marker = Primitive.sphere(0.025, "#ff0000");
      this.addPrimitiveAt(marker, [nez.x, nez.y, nez.z]);
    }

    // Points de contrôle
    const ctrlG = this.getPoint("CTRL_GAUCHE");
    if (ctrlG) {
      const marker = Primitive.sphere(0.025, "#dc143c");
      this.addPrimitiveAt(marker, [ctrlG.x, ctrlG.y, ctrlG.z]);
    }

    const ctrlD = this.getPoint("CTRL_DROIT");
    if (ctrlD) {
      const marker = Primitive.sphere(0.025, "#b22222");
      this.addPrimitiveAt(marker, [ctrlD.x, ctrlD.y, ctrlD.z]);
    }
  }

  // Implémentation de l'interface ICreatable
  create(): this {
    return this;
  }

  getName(): string {
    return "Cerf-volant Delta v2";
  }

  getDescription(): string {
    return "Cerf-volant delta construit avec les factories CAO";
  }

  getPrimitiveCount(): number {
    return 25; // Frame + surfaces + marqueurs
  }
}

/**
 * AVANTAGES de cette approche avec factories:
 *
 * 1. **Modularité** : Points, frames et surfaces sont gérés par des factories dédiées
 * 2. **Réutilisabilité** : Les factories peuvent être utilisées pour d'autres objets
 * 3. **Paramétrage** : Facile de modifier les paramètres de chaque composant
 * 4. **Composition** : On peut combiner différentes factories
 * 5. **Évolutivité** : Facile d'ajouter de nouvelles fonctionnalités aux factories
 *
 * UTILISATION DE POINTFACTORY:
 * - Tous les points sont définis dans une Map centralisée
 * - PointFactory crée un objet points réutilisable
 * - Pas de symétrie automatique : chaque point est défini explicitement
 * - Permet une gestion cohérente et validée des points anatomiques
 *
 * WORKFLOW CAO:
 * 1. PointFactory → Définir tous les points anatomiques
 * 2. FrameFactory → Construire la structure rigide
 * 3. SurfaceFactory → Ajouter les surfaces/toiles
 * 4. Assembly → Combiner le tout (futur)
 */


=== simulation.ts ===

/**
 * Point d'entrée de compatibilité
 *
 * Ce fichier maintient la compatibilité avec l'ancien import
 * tout en redirigeant vers la nouvelle structure modulaire
 */

export { SimulationApp as Simulation } from './simulation/SimulationApp';

=== simulation/SimulationApp.ts ===

/**
 * SimulationApp.ts - Application principale de simulation (Architecture ECS-inspired)
 *
 * Nouvelle architecture modulaire avec systèmes de simulation séparés.
 * Chaque système (Physics, Wind, Input, Render) fonctionne indépendamment
 * et communique via un contexte partagé.
 */

import * as THREE from 'three';
import { Logger } from '../utils/Logging';
import { UidGenerator } from '../utils/UidGenerator';

// Import des systèmes modulaires
import {
  PhysicsSystem,
  WindSystem,
  InputSystem,
  RenderSystem,
  type PhysicsState,
  type PhysicsConfig,
  type WindConfig,
  type InputConfig,
  type RenderConfig
} from './systems';

// Import des composants existants (temporairement pour compatibilité)
import { Kite } from '../objects/organic/Kite';
import { UIManager } from './ui/UIManager';
import { CONFIG } from './config/SimulationConfig';
import { KiteGeometry } from './config/KiteGeometry';

export interface SimulationConfig {
  targetFPS: number;
  maxFrameTime: number;
  enableDebug: boolean;
  enableRenderSystem: boolean;
  enableLegacyComponents: boolean; // Nouveau flag pour contrôler les composants legacy
  physics: Partial<PhysicsConfig>;
  wind: Partial<WindConfig>;
  input: Partial<InputConfig>;
  render: Partial<RenderConfig>;
}

export class SimulationApp {
  private logger: Logger;
  private config: SimulationConfig;

  // Systèmes ECS-inspired
  private physicsSystem!: PhysicsSystem;
  private windSystem!: WindSystem;
  private inputSystem!: InputSystem;
  private renderSystem!: RenderSystem;

  // Composants existants (pour compatibilité)
  private kite!: Kite;
  private uiManager!: UIManager;
  private controlBar!: THREE.Group;

  // État de simulation
  private isRunning: boolean = false;
  private isInitialized: boolean = false;
  private clock: THREE.Clock;
  private frameCount: number = 0;
  private totalTime: number = 0;
  private lastFrameTime: number = 0;

  // Gestion des objets physiques
  private physicsObjects = new Map<string, PhysicsState>();

  constructor(config: Partial<SimulationConfig> = {}) {
    this.logger = Logger.getInstance();
    this.clock = new THREE.Clock();

    // Configuration par défaut
    this.config = {
      targetFPS: 60,
      maxFrameTime: 1/30, // 30 FPS minimum
      enableDebug: true,
      enableRenderSystem: true,
      enableLegacyComponents: false, // Désactiver par défaut pour éviter les erreurs de mocks
      physics: {},
      wind: {},
      input: {},
      render: {},
      ...config
    };

    this.logger.info('SimulationApp initializing with ECS architecture', 'SimulationApp');

    // Initialiser les systèmes
    this.initializeSystems();

    // Initialiser les composants existants (si activés)
    if (this.config.enableLegacyComponents) {
      this.initializeLegacyComponents();
    }
  }

  /**
   * Initialise tous les systèmes de simulation
   */
  private initializeSystems(): void {
    this.logger.info('Initializing simulation systems...', 'SimulationApp');

    // Créer les systèmes avec leurs configurations
    this.physicsSystem = new PhysicsSystem(this.config.physics);
    this.windSystem = new WindSystem(this.config.wind);
    this.inputSystem = new InputSystem(this.config.input);

    // Créer le système de rendu seulement si activé
    if (this.config.enableRenderSystem) {
      this.renderSystem = new RenderSystem(this.config.render);
    }

    this.logger.info('All simulation systems created', 'SimulationApp');
  }

  /**
   * Initialise les composants existants pour compatibilité
   */
  private initializeLegacyComponents(): void {
    this.logger.info('Initializing legacy components...', 'SimulationApp');

    // Configurer la géométrie du kite
    KiteGeometry.setMeshSubdivisionLevel(CONFIG.kite.defaultMeshSubdivisionLevel);

    // Créer la barre de contrôle
    this.setupControlBar();

    // Créer le kite
    this.kite = new Kite();
    this.kite.position.set(0, 5, 0);

    // Ajouter le kite à la scène de rendu (si RenderSystem activé)
    if (this.config.enableRenderSystem && this.renderSystem) {
      const scene = this.renderSystem.getScene();
      if (scene) {
        scene.add(this.kite);
        scene.add(this.controlBar);
      }
    }

    // Créer l'UI Manager (avec mocks appropriés)
    const physicsEngineMock = {
      getBridleLengths: () => ({ nez: 0.5, center: 0.5, tip: 0.5 }),
      setBridleLength: () => {},
      getKiteState: () => ({}),
      getWindState: () => ({}),
      update: () => {}
    } as any;

    const debugRendererMock = {
      isDebugMode: () => false,
      toggleDebugMode: () => {},
      renderDebugInfo: () => {},
      clearDebugInfo: () => {},
      setDebugMode: () => {},
      renderManager: {} as any,
      debugArrows: [],
      debugMode: false,
      vectorVisibility: {}
    } as any;

    this.uiManager = new UIManager(
      physicsEngineMock,
      debugRendererMock,
      () => this.reset(), // resetCallback
      () => { /* toggle play */ } // togglePlayCallback
    );

    // Enregistrer le kite comme objet physique
    this.registerPhysicsObject('kite', {
      position: this.kite.position.clone(),
      velocity: new THREE.Vector3(),
      acceleration: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      angularAcceleration: new THREE.Vector3(),
      mass: 0.5, // kg
      momentOfInertia: new THREE.Matrix3().identity()
    });

    this.logger.info('Legacy components initialized', 'SimulationApp');
  }

  /**
   * Configure la barre de contrôle
   */
  private setupControlBar(): void {
    this.controlBar = new THREE.Group();
    this.controlBar.name = 'ControlBar';

    // Créer une barre simple pour l'instant
    const barGeometry = new THREE.CylinderGeometry(0.02, 0.02, 2);
    const barMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
    const bar = new THREE.Mesh(barGeometry, barMaterial);

    this.controlBar.add(bar);
    this.controlBar.position.set(0, 1, 5);
  }

  /**
   * Initialise l'application de simulation
   */
  async initialize(): Promise<void> {
    try {
      this.logger.info('Starting SimulationApp initialization...', 'SimulationApp');

      // Initialiser tous les systèmes
      const initPromises = [
        this.physicsSystem.initialize(),
        this.windSystem.initialize(),
        this.inputSystem.initialize()
      ];

      // Ajouter RenderSystem seulement si activé
      if (this.config.enableRenderSystem) {
        initPromises.push(this.renderSystem.initialize());
      }

      await Promise.all(initPromises);

      // Démarrer le rendu (si activé)
      if (this.config.enableRenderSystem) {
        this.renderSystem.startRendering();
      }

      this.isInitialized = true;
      this.logger.info('SimulationApp fully initialized', 'SimulationApp');

    } catch (error) {
      this.logger.error(`SimulationApp initialization failed: ${error}`, 'SimulationApp');
      throw error;
    }
  }

  /**
   * Boucle principale de simulation (ECS-inspired)
   */
  update = (): void => {
    if (!this.isInitialized || !this.isRunning) return;

    const currentTime = performance.now();
    const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, this.config.maxFrameTime);
    this.lastFrameTime = currentTime;

    this.totalTime += deltaTime;
    this.frameCount++;

    // Créer le contexte de simulation partagé
    const context = {
      deltaTime,
      totalTime: this.totalTime,
      isPaused: !this.isRunning,
      debugMode: this.config.enableDebug
    };

    try {
      // 1. Mise à jour des entrées (priorité haute)
      this.inputSystem.update(context);

      // 2. Mise à jour du vent
      this.windSystem.update(context);

      // 3. Mise à jour de la physique
      this.physicsSystem.update(context);

      // 4. Mise à jour du rendu (priorité basse)
      if (this.config.enableRenderSystem) {
        this.renderSystem.update(context);
      }

      // 5. Synchronisation avec les composants existants
      this.syncLegacyComponents(context);

      // 6. Mise à jour de l'UI
      this.updateUI(context);

    } catch (error) {
      this.logger.error(`Simulation update error: ${error}`, 'SimulationApp');
    }

    // Continuer la boucle
    if (this.isRunning) {
      requestAnimationFrame(this.update);
    }
  };

  /**
   * Synchronise les composants existants avec les systèmes
   */
  private syncLegacyComponents(context: any): void {
    if (!this.config.enableLegacyComponents) return;

    // Obtenir l'état des entrées
    const inputState = this.inputSystem.getInputState();

    // Appliquer la rotation de la barre
    this.controlBar.rotation.z = inputState.barPosition * Math.PI / 6; // Max ±30°

    // Obtenir l'état physique du kite
    const kitePhysics = this.physicsObjects.get('kite');
    if (kitePhysics) {
      // Synchroniser la position du kite
      this.kite.position.copy(kitePhysics.position);

      // Calculer le vent apparent pour le kite
      const apparentWind = this.windSystem.getApparentWind(
        kitePhysics.position,
        kitePhysics.velocity
      );

      // TODO: Appliquer les forces aérodynamiques basées sur le vent apparent
      // Pour l'instant, juste une force de gravité simple
      if (kitePhysics.position.y > 0) {
        kitePhysics.acceleration.set(0, -9.81, 0);
      } else {
        kitePhysics.acceleration.set(0, 0, 0);
        kitePhysics.velocity.set(0, 0, 0);
        kitePhysics.position.y = 0;
      }

      // Intégration simple d'Euler
      kitePhysics.velocity.add(kitePhysics.acceleration.clone().multiplyScalar(context.deltaTime));
      kitePhysics.position.add(kitePhysics.velocity.clone().multiplyScalar(context.deltaTime));
    }

    // Gestion du reset
    if (inputState.resetPressed) {
      this.reset();
    }
  }

  /**
   * Met à jour l'interface utilisateur
   */
  private updateUI(context: any): void {
    // Mettre à jour l'UI si elle existe
    this.updateUIOverlay();
  }

  /**
   * Met à jour l'overlay UI avec les données actuelles
   */
  private updateUIOverlay(): void {
    if (typeof document === 'undefined') return;

    const fpsElement = document.getElementById('fps');
    const posElement = document.getElementById('kite-pos');
    const velElement = document.getElementById('kite-vel');
    const windElement = document.getElementById('wind-speed');
    const barElement = document.getElementById('bar-pos');

    if (fpsElement || posElement || velElement || windElement || barElement) {
      const renderStats = this.renderSystem ? this.renderSystem.getRenderStats() : { fps: 0 };
      const kitePhysics = this.physicsObjects.get('kite');
      const inputState = this.inputSystem.getInputState();
      const windState = this.windSystem.getWindState();

      if (fpsElement) {
        fpsElement.textContent = `FPS: ${renderStats.fps}`;
      }

      if (posElement && kitePhysics) {
        posElement.textContent = `Position: (${kitePhysics.position.x.toFixed(1)}, ${kitePhysics.position.y.toFixed(1)}, ${kitePhysics.position.z.toFixed(1)})`;
      }

      if (velElement && kitePhysics) {
        velElement.textContent = `Vitesse: (${kitePhysics.velocity.x.toFixed(1)}, ${kitePhysics.velocity.y.toFixed(1)}, ${kitePhysics.velocity.z.toFixed(1)})`;
      }

      if (windElement) {
        windElement.textContent = `Vent: ${windState.baseSpeed.toFixed(1)} m/s`;
      }

      if (barElement) {
        barElement.textContent = `Barre: ${(inputState.barPosition * 100).toFixed(0)}%`;
      }
    }
  }

  /**
   * Enregistre un objet physique dans le système
   */
  registerPhysicsObject(id: string, state: PhysicsState): void {
    this.physicsObjects.set(id, state);
    this.physicsSystem.registerPhysicsObject(id, state);
  }

  /**
   * Démarre la simulation
   */
  start(): void {
    if (!this.isInitialized) {
      throw new Error('SimulationApp must be initialized before starting');
    }

    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.logger.info('SimulationApp started', 'SimulationApp');

    // Démarrer la boucle
    requestAnimationFrame(this.update);
  }

  /**
   * Arrête la simulation
   */
  stop(): void {
    this.isRunning = false;
    this.logger.info('SimulationApp stopped', 'SimulationApp');
  }

  /**
   * Réinitialise la simulation
   */
  reset(): void {
    this.logger.info('Resetting simulation...', 'SimulationApp');

    // Réinitialiser les systèmes
    this.physicsSystem.reset();
    this.windSystem.reset();
    this.inputSystem.reset();
    if (this.renderSystem) {
      this.renderSystem.reset();
    }

    // Réinitialiser l'état
    this.frameCount = 0;
    this.totalTime = 0;

    // Réinitialiser les objets physiques
    for (const [id, state] of this.physicsObjects) {
      // TODO: Implémenter une logique de reset par objet
    }

    // Réinitialiser les composants existants
    this.kite.position.set(0, 5, 0);
    this.controlBar.rotation.z = 0;

    this.logger.info('Simulation reset complete', 'SimulationApp');
  }

  /**
   * Obtient les statistiques de performance
   */
  getStats(): {
    fps: number;
    frameCount: number;
    totalTime: number;
    isRunning: boolean;
    physicsObjects: number;
  } {
    const renderStats = this.renderSystem ? this.renderSystem.getRenderStats() : { fps: 0 };

    return {
      fps: renderStats.fps,
      frameCount: this.frameCount,
      totalTime: this.totalTime,
      isRunning: this.isRunning,
      physicsObjects: this.physicsObjects.size
    };
  }

  /**
   * Nettoie les ressources
   */
  dispose(): void {
    this.logger.info('Disposing SimulationApp...', 'SimulationApp');

    this.stop();

    // Disposer les systèmes
    this.physicsSystem.dispose();
    this.windSystem.dispose();
    this.inputSystem.dispose();
    if (this.config.enableRenderSystem) {
      this.renderSystem.dispose();
    }

    // Disposer les composants existants
    if (this.config.enableLegacyComponents) {
      if (this.uiManager) {
        // Note: UIManager n'a pas de méthode dispose
      }
    }

    this.logger.info('SimulationApp disposed', 'SimulationApp');
  }

  /**
   * Alias pour dispose() pour compatibilité avec l'ancien code
   */
  cleanup(): void {
    this.dispose();
  }
}

=== simulation/SimulationApp_legacy.ts ===

/**
 * SimulationApp.ts - Application principale de simulation
 *
 * Point d'entrée refactorisé qui assemble tous les composants modulaires
 */

import * as THREE from "three";

import { Kite } from "../objects/organic/Kite";

import { RenderManager } from "./rendering/RenderManager";
import { DebugRenderer } from "./rendering/DebugRenderer";
import { PhysicsEngine } from "./physics/PhysicsEngine";
import { InputHandler } from "./controllers/InputHandler";
import { UIManager } from "./ui/UIManager";
import { CONFIG } from "./config/SimulationConfig";
import { KiteGeometry } from "./config/KiteGeometry";

export class Simulation {
  private renderManager: RenderManager;
  private debugRenderer: DebugRenderer;
  private physicsEngine!: PhysicsEngine;
  private inputHandler: InputHandler;
  private uiManager!: UIManager;
  private kite!: Kite;
  private controlBar!: THREE.Group;
  private clock: THREE.Clock;
  private isPlaying: boolean = true;
  private leftLine: THREE.Line | null = null;
  private rightLine: THREE.Line | null = null;
  private frameCount: number = 0;

  constructor() {
    console.log("🚀 Démarrage de la Simulation V8 - Version modulaire");

    try {
      const container = document.getElementById("app");
      if (!container) {
        throw new Error("Container #app non trouvé");
      }

      this.renderManager = new RenderManager(container);
      this.debugRenderer = new DebugRenderer(this.renderManager);
      this.inputHandler = new InputHandler();
      this.clock = new THREE.Clock();

      // 🔧 Initialiser le niveau de subdivision du maillage
      KiteGeometry.setMeshSubdivisionLevel(CONFIG.kite.defaultMeshSubdivisionLevel);

      this.setupControlBar();
      this.setupKite();
      this.physicsEngine = new PhysicsEngine(
        this.kite,
        this.controlBar.position
      );
      this.setupUI();
      this.createControlLines();
      this.animate();
    } catch (error) {
      console.error(
        "❌ Erreur lors de l'initialisation de la Simulation:",
        error
      );
      throw error;
    }
  }

  private setupKite(): void {
    this.kite = new Kite();
    const pilot = this.controlBar.position.clone();
    // Position initiale : 95% de la longueur de ligne pour avoir lignes légèrement tendues
    const initialDistance = CONFIG.lines.defaultLength * CONFIG.initialization.initialDistanceFactor;

    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);

    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);
    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();

    console.log(
      `📍 Position initiale du kite: ${this.kite.position.toArray()}`
    );
    this.renderManager.addObject(this.kite);
  }

  private setupControlBar(): void {
    this.controlBar = new THREE.Group();
    this.controlBar.position.copy(CONFIG.controlBar.position);

    const barGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.width
    );
    const barMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.7,
      roughness: 0.3,
    });
    const bar = new THREE.Mesh(barGeometry, barMaterial);
    bar.rotation.z = CONFIG.controlBar.barRotation;
    this.controlBar.add(bar);

    const handleGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleLength
    );
    const handleMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      roughness: 0.6,
    });

    const halfWidth = CONFIG.controlBar.width / 2;
    const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    leftHandle.position.set(-halfWidth, 0, 0);
    this.controlBar.add(leftHandle);

    const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    rightHandle.position.set(halfWidth, 0, 0);
    this.controlBar.add(rightHandle);

    const pilotGeometry = new THREE.BoxGeometry(
      CONFIG.pilot.width,
      CONFIG.pilot.height,
      CONFIG.pilot.depth
    );
    const pilotMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a4a4a,
      roughness: 0.8,
    });
    const pilot = new THREE.Mesh(pilotGeometry, pilotMaterial);
    pilot.position.set(0, CONFIG.pilot.offsetY, CONFIG.pilot.offsetZ);
    pilot.castShadow = true;

    this.renderManager.addObject(this.controlBar);
    this.renderManager.addObject(pilot);
  }

  /**
   * Calcule la distance horizontale via Pythagore
   * Évite la duplication de code (utilisé dans setupKite et resetSimulation)
   */
  private calculateHorizontalDistance(hypotenuse: number, vertical: number): number {
    const minHorizontal = 0.1; // m - Distance horizontale minimale pour éviter kite au-dessus du pilote
    return Math.max(
      minHorizontal,
      Math.sqrt(Math.max(0, hypotenuse * hypotenuse - vertical * vertical))
    );
  }

  private createControlLines(): void {
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: CONFIG.visualization.lineWidth,
    });

    const leftGeometry = new THREE.BufferGeometry();
    const rightGeometry = new THREE.BufferGeometry();

    this.leftLine = new THREE.Line(leftGeometry, lineMaterial);
    this.rightLine = new THREE.Line(rightGeometry, lineMaterial);

    this.renderManager.addObject(this.leftLine);
    this.renderManager.addObject(this.rightLine);
  }

  private updateControlLines(): void {
    if (!this.leftLine || !this.rightLine) return;

    const ctrlLeft = this.kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = this.kite.getPoint("CTRL_DROIT");

    if (!ctrlLeft || !ctrlRight) return;

    const kiteLeftWorld = ctrlLeft.clone();
    const kiteRightWorld = ctrlRight.clone();
    this.kite.localToWorld(kiteLeftWorld);
    this.kite.localToWorld(kiteRightWorld);

    const handles = this.physicsEngine
      .getControlBarManager()
      .getHandlePositions(this.kite.position);

    const leftPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.left, kiteLeftWorld);
    const rightPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.right, kiteRightWorld);

    this.leftLine.geometry.setFromPoints(leftPoints);
    this.rightLine.geometry.setFromPoints(rightPoints);

    this.physicsEngine
      .getControlBarManager()
      .updateVisual(this.controlBar, this.kite);
  }

  private setupUI(): void {
    this.uiManager = new UIManager(
      this.physicsEngine,
      this.debugRenderer,
      () => this.resetSimulation(),
      () => this.togglePlayPause()
    );
  }

  private resetSimulation(): void {
    const currentLineLength =
      this.physicsEngine.getLineSystem().lineLength ||
      CONFIG.lines.defaultLength;
    const initialDistance = currentLineLength * CONFIG.initialization.initialDistanceFactor;

    const pilot = this.controlBar.position.clone();
    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);
    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);

    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();
    this.controlBar.quaternion.identity();

    this.physicsEngine = new PhysicsEngine(this.kite, this.controlBar.position);
    this.physicsEngine.setLineLength(currentLineLength);

    this.updateControlLines();
    console.log(`🔄 Simulation réinitialisée`);
  }

  private togglePlayPause(): void {
    this.isPlaying = !this.isPlaying;
    this.uiManager.updatePlayButton(this.isPlaying);
  }

  private animate = (): void => {
    requestAnimationFrame(this.animate);

    this.frameCount++;

    if (this.isPlaying) {
      try {
        const deltaTime = this.clock.getDelta();
        this.inputHandler.update(deltaTime);
        const targetRotation = this.inputHandler.getTargetBarRotation();

        this.physicsEngine.update(deltaTime, targetRotation, false);
        this.updateControlLines();
        this.debugRenderer.updateDebugArrows(this.kite, this.physicsEngine);
      } catch (error) {
        console.error("❌ Erreur dans la boucle d'animation:", error);
        this.isPlaying = false;
      }
    }

    this.renderManager.render();
  };

  public cleanup(): void {
    console.log("🧹 Nettoyage de la Simulation...");
    this.isPlaying = false;

    this.debugRenderer.clearDebugArrows();

    if (this.leftLine) {
      this.renderManager.removeObject(this.leftLine);
      this.leftLine = null;
    }
    if (this.rightLine) {
      this.renderManager.removeObject(this.rightLine);
      this.rightLine = null;
    }

    if (this.kite) {
      this.renderManager.removeObject(this.kite);
    }

    if (this.controlBar) {
      this.renderManager.removeObject(this.controlBar);
    }

    console.log("✅ Simulation nettoyée");
  }
}

=== simulation/config/KiteGeometry.ts ===

/**
 * KiteGeometry.ts - Définition de la géométrie du cerf-volant pour la simulation Kite
 *
 * Rôle :
 *   - Définit la forme, les points anatomiques et les surfaces du cerf-volant
 *   - Sert de plan de construction pour tous les calculs physiques et graphiques
 *   - Utilisé pour le calcul des forces, la création du modèle 3D et la configuration
 *
 * Dépendances principales :
 *   - Three.js : Utilisé pour les coordonnées et la géométrie
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise KiteGeometry pour la surface et les points
 *   - Tous les modules physiques et graphiques utilisent KiteGeometry pour les calculs
 *
 * Utilisation typique :
 *   - Importé dans les modules de physique, de rendu et de configuration
 *   - Sert à positionner les points et surfaces du kite
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

/**
 * Géométrie du cerf-volant
 *
 * La forme du cerf-volant - comme un plan de construction
 * On définit où sont tous les points importants du cerf-volant
 */
export class KiteGeometry {
  // Les points clés du cerf-volant (comme les coins d'une maison)
  // Coordonnées en mètres : [gauche/droite, haut/bas, avant/arrière]
  static readonly POINTS = {
    NEZ: new THREE.Vector3(0, 0.65, 0), // Le bout pointu en haut
    SPINE_BAS: new THREE.Vector3(0, 0, 0), // Le centre en bas
    BORD_GAUCHE: new THREE.Vector3(-0.825, 0, 0), // L'extrémité de l'aile gauche
    BORD_DROIT: new THREE.Vector3(0.825, 0, 0), // L'extrémité de l'aile droite
    WHISKER_GAUCHE: new THREE.Vector3(-0.4125, 0.1, -0.15), // Stabilisateur gauche (légèrement en arrière)
    WHISKER_DROIT: new THREE.Vector3(0.4125, 0.1, -0.15), // Stabilisateur droit (légèrement en arrière)
    CTRL_GAUCHE: new THREE.Vector3(-0.15, 0.3, -0.2), // Où s'attache la ligne gauche
    CTRL_DROIT: new THREE.Vector3(0.15, 0.3, -0.2), // Où s'attache la ligne droite
  };

  /**
   * Calcule l'aire d'un triangle 3D à partir de ses 3 sommets
   * Utilise la formule : Aire = 0.5 × ||AB × AC||
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxième sommet du triangle
   * @param v3 Troisième sommet du triangle
   * @returns L'aire du triangle en m²
   */
  private static calculateTriangleArea(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): number {
    // Créer deux vecteurs représentant deux côtés du triangle
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    
    // Le produit vectoriel donne un vecteur perpendiculaire
    // dont la longueur = aire du parallélogramme formé par edge1 et edge2
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    
    // L'aire du triangle = la moitié de l'aire du parallélogramme
    return cross.length() / 2;
  }

  /**
   * Calcule le centroïde (centre géométrique) d'un triangle
   * Le centroïde est situé à l'intersection des médianes du triangle
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxième sommet du triangle  
   * @param v3 Troisième sommet du triangle
   * @returns Le point centroïde du triangle
   */
  static calculateTriangleCentroid(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): THREE.Vector3 {
    return v1.clone()
      .add(v2)
      .add(v3)
      .divideScalar(3);
  }

  // Le cerf-volant est fait de 4 triangles de tissu
  // Chaque triangle a 3 coins (vertices) et une surface en mètres carrés
  //
  // ORDRE DES VERTICES (règle main droite) :
  // Les normales doivent pointer vers l'ARRIÈRE (Z positif) pour recevoir le vent
  // qui vient de l'arrière (direction -Z).
  // Order : sens horaire vu de l'arrière = normale vers l'arrière
  //
  // NOTE : Les aires sont calculées automatiquement à partir de la géométrie réelle
  // pour garantir la cohérence physique
  //
  // NOTE : Les masses sont calculées après, voir SURFACES_WITH_MASS ci-dessous
  static readonly SURFACES = [
    {
      // Surface haute gauche (normale doit pointer vers arrière)
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE
      ),
    },
    {
      // Surface basse gauche
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS
      ),
    },
    {
      // Surface haute droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT
      ),
    },
    {
      // Surface basse droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT
      ),
    },
  ];

  /**
   * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
   * @param v1, v2, v3 : sommets du triangle
   * @returns Tableau de 4 sous-triangles {vertices, area}
   */
  private static subdivideTriangle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3) {
    // Calcul des milieux
    const m12 = v1.clone().add(v2).multiplyScalar(0.5);
    const m23 = v2.clone().add(v3).multiplyScalar(0.5);
    const m31 = v3.clone().add(v1).multiplyScalar(0.5);

    // 4 sous-triangles
    const tris = [
      { vertices: [v1, m12, m31] },
      { vertices: [v2, m23, m12] },
      { vertices: [v3, m31, m23] },
      { vertices: [m12, m23, m31] },
    ];
    // Ajoute l'aire à chaque sous-triangle
    return tris.map(t => ({
      vertices: t.vertices,
      area: KiteGeometry.calculateTriangleArea(t.vertices[0], t.vertices[1], t.vertices[2])
    }));
  }

  /**
   * Subdivise récursivement un triangle selon un niveau donné
   * @param v1, v2, v3 : sommets du triangle
   * @param level : niveau de subdivision (0 = pas de subdivision)
   * @returns Tableau de tous les sous-triangles
   */
  private static subdivideTriangleRecursive(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3,
    level: number
  ): { vertices: THREE.Vector3[]; area: number }[] {
    if (level <= 0) {
      // Pas de subdivision : retourner le triangle original
      return [{
        vertices: [v1, v2, v3],
        area: KiteGeometry.calculateTriangleArea(v1, v2, v3)
      }];
    }

    // Subdiviser en 4 sous-triangles
    const subTriangles = KiteGeometry.subdivideTriangle(v1, v2, v3);

    // Appliquer récursivement la subdivision à chaque sous-triangle
    const result: { vertices: THREE.Vector3[]; area: number }[] = [];
    for (const subTri of subTriangles) {
      const [sv1, sv2, sv3] = subTri.vertices;
      result.push(...KiteGeometry.subdivideTriangleRecursive(sv1, sv2, sv3, level - 1));
    }

    return result;
  }

  /**
   * Subdivision du maillage pour améliorer la précision aérodynamique.
   *
   * POURQUOI LA SUBDIVISION :
   * - Un triangle unique ne peut avoir qu'une seule normale → angle d'attaque uniforme
   * - Avec subdivision, chaque sous-triangle peut avoir un angle d'attaque local différent
   * - Permet de capturer les variations spatiales du vent et de la courbure virtuelle
   * - Améliore le réalisme des couples aérodynamiques distribués
   *
   * COÛT PERFORMANCE :
   * - Niveau 0 : 4 triangles (rapide, peu précis)
   * - Niveau 1 : 16 triangles (bon compromis)
   * - Niveau 2 : 64 triangles (précis, coût modéré) ← recommandé
   * - Niveau 3 : 256 triangles (très précis, coûteux)
   * - Niveau 4+ : 1024+ triangles (impact performance significatif)
   */

  /**
   * Niveau de subdivision actuel du maillage
   * Par défaut niveau 1 (16 triangles), peut être changé via setMeshSubdivisionLevel()
   */
  private static meshSubdivisionLevel: number = 1; // Niveau par défaut, sera initialisé depuis CONFIG dans SimulationApp

  /**
   * Cache typé des surfaces subdivisées
   */
  private static _subdividedSurfaces: { vertices: THREE.Vector3[]; area: number }[] | null = null;

  /**
   * Constantes pour la subdivision
   */
  private static readonly MAX_SUBDIVISION_LEVEL = 3; // Limite raisonnable pour éviter surcharge

  /**
   * Calcule le nombre de triangles par surface originale pour un niveau donné
   * Formule : 4^niveau (car chaque subdivision découpe en 4)
   *
   * @param level - Niveau de subdivision (0, 1, 2, 3...)
   * @returns Nombre de sous-triangles par surface originale
   *
   * @example
   * TRIANGLES_PER_SURFACE_AT_LEVEL(0) → 1 triangle
   * TRIANGLES_PER_SURFACE_AT_LEVEL(1) → 4 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(2) → 16 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(3) → 64 triangles
   */
  static TRIANGLES_PER_SURFACE_AT_LEVEL(level: number): number {
    return Math.pow(4, level);
  }

  /**
   * Modifie le niveau de subdivision du maillage
   *
   * @param level - Niveau de subdivision (0=4 triangles, 1=16, 2=64, 3=256)
   *
   * IMPORTANT : Des niveaux élevés (>3) peuvent causer des problèmes de performance.
   * Le niveau est automatiquement limité à MAX_SUBDIVISION_LEVEL (3).
   */
  static setMeshSubdivisionLevel(level: number): void {
    // Clamper entre 0 et MAX
    const clampedLevel = Math.max(0, Math.min(level, KiteGeometry.MAX_SUBDIVISION_LEVEL));

    // Warning si niveau trop élevé
    if (level > KiteGeometry.MAX_SUBDIVISION_LEVEL) {
      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(level);
      console.warn(
        `⚠️ Niveau de subdivision ${level} trop élevé (${totalTriangles} triangles).\n` +
        `Limité à ${KiteGeometry.MAX_SUBDIVISION_LEVEL} pour éviter surcharge performance.\n` +
        `Si vous avez vraiment besoin de plus, augmentez MAX_SUBDIVISION_LEVEL.`
      );
    }

    if (clampedLevel !== KiteGeometry.meshSubdivisionLevel) {
      KiteGeometry.meshSubdivisionLevel = clampedLevel;
      // Invalider le cache des surfaces subdivisées
      KiteGeometry._subdividedSurfaces = null;

      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(clampedLevel);
      console.log(`🔧 Maillage subdivisé : niveau ${clampedLevel} → ${totalTriangles} triangles au total`);
    }
  }

  /**
   * Retourne le niveau de subdivision actuel du maillage
   */
  static getMeshSubdivisionLevel(): number {
    return KiteGeometry.meshSubdivisionLevel;
  }

  /**
   * Maillage fin : tous les sous-triangles du kite selon le niveau de subdivision configuré
   *
   * CACHE : Les surfaces sont calculées une seule fois puis mises en cache.
   * Le cache est invalidé automatiquement quand le niveau change.
   *
   * @returns Tableau de tous les sous-triangles avec leurs vertices et aires
   */
  static get SUBDIVIDED_SURFACES(): { vertices: THREE.Vector3[]; area: number }[] {
    if (!KiteGeometry._subdividedSurfaces) {
      KiteGeometry._subdividedSurfaces = KiteGeometry.SURFACES.flatMap(surface =>
        KiteGeometry.subdivideTriangleRecursive(
          surface.vertices[0],
          surface.vertices[1],
          surface.vertices[2],
          KiteGeometry.meshSubdivisionLevel
        )
      );
    }
    return KiteGeometry._subdividedSurfaces;
  }

  // Calcul automatique de la surface totale
  static readonly TOTAL_AREA = KiteGeometry.SURFACES.reduce(
    (sum, surface) => sum + surface.area,
    0
  );  // ============================================================================
  // CALCUL AUTOMATIQUE DE LA MASSE DU CERF-VOLANT
  // ============================================================================

  /**
   * Spécifications des matériaux utilisés pour calculer la masse
   * Basé sur des composants réels de kites sport/stunt
   *
   * CORRECTION: Grammages augmentés pour atteindre masse réaliste de 0.3-0.4 kg
   * (Précédente masse calculée de ~0.153 kg était ×2.5 trop légère)
   */
  private static readonly MATERIAL_SPECS = {
    // Tubes de carbone (masse linéique en g/m)
    carbon: {
      spine: 10,        // 5mm diamètre renforcé (corrigé de 10)
      leadingEdge: 10,  // 5mm diamètre standard (corrigé de 10)
      strut: 4,         // 4mm diamètre léger (corrigé de 2)
    },
    // Tissu (grammage en g/m²)
    fabric: {
      ripstop: 40,     // Ripstop nylon standard (corrigé de 40)
    },
    // Accessoires (masse en grammes)
    accessories: {
      connectorsLeadingEdge: 1,  // Connecteurs pour les bords d'attaque
      connectorCenterT: 1,       // Connecteur central en T
      connectorsStruts: 1,       // Connecteurs pour les struts
      bridleSystem: 1,          // Système de brides complet
      reinforcements: 1,        // Renforts et coutures
    },
  };

  /**
   * Calcule la longueur totale de tous les tubes de la frame
   * @returns Objet contenant les longueurs par type de tube et le total
   */
  private static calculateFrameLengths(): {
    spine: number;
    leadingEdges: number;
    struts: number;
    total: number;
  } {
    const spine = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.SPINE_BAS
    );

    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_GAUCHE
    );
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_DROIT
    );
    const leadingEdges = leadingEdgeLeft + leadingEdgeRight;

    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_GAUCHE
    );
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const struts = strutLeft + strutRight + spreader;

    return {
      spine,
      leadingEdges,
      struts,
      total: spine + leadingEdges + struts,
    };
  }

  /**
   * Calcule la masse de la structure (frame) en carbone
   * @returns Masse en kilogrammes
   */
  private static calculateFrameMass(): number {
    const lengths = KiteGeometry.calculateFrameLengths();
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;

    const spineMass = lengths.spine * specs.spine;
    const leadingEdgesMass = lengths.leadingEdges * specs.leadingEdge;
    const strutsMass = lengths.struts * specs.strut;

    // Somme en grammes, conversion en kg
    return (spineMass + leadingEdgesMass + strutsMass) / 1000;
  }

  /**
   * Calcule la masse du tissu (voile)
   * @returns Masse en kilogrammes
   */
  private static calculateFabricMass(): number {
    const grammage = KiteGeometry.MATERIAL_SPECS.fabric.ripstop;
    // Surface en m² × grammage en g/m² → conversion en kg
    return (KiteGeometry.TOTAL_AREA * grammage) / 1000;
  }

  /**
   * Calcule la masse totale des accessoires
   * @returns Masse en kilogrammes
   */
  private static calculateAccessoriesMass(): number {
    const acc = KiteGeometry.MATERIAL_SPECS.accessories;
    const total =
      acc.connectorsLeadingEdge +
      acc.connectorCenterT +
      acc.connectorsStruts +
      acc.bridleSystem +
      acc.reinforcements;

    // Conversion g → kg
    return total / 1000;
  }

  /**
   * Calcule la masse totale du cerf-volant (frame + tissu + accessoires)
   * Calculée automatiquement depuis la géométrie et les spécifications matériaux
   * @returns Masse en kilogrammes
   */
  static calculateTotalMass(): number {
    return (
      KiteGeometry.calculateFrameMass() +
      KiteGeometry.calculateFabricMass() +
      KiteGeometry.calculateAccessoriesMass()
    );
  }

  /**
   * Masse totale du cerf-volant calculée automatiquement
   * Basée sur la géométrie réelle et les matériaux standards
   */
  static readonly TOTAL_MASS = KiteGeometry.calculateTotalMass();

  /**
   * 🔴 BUG FIX #2 : Distribution masse frame selon géométrie RÉELLE
   * 
   * Topologie du kite (4 surfaces triangulaires) :
   *   Surface 0 (haute gauche)  : NEZ → BORD_GAUCHE → WHISKER_GAUCHE
   *   Surface 1 (basse gauche)  : NEZ → WHISKER_GAUCHE → SPINE_BAS
   *   Surface 2 (haute droite)  : NEZ → BORD_DROIT → WHISKER_DROIT
   *   Surface 3 (basse droite)  : NEZ → WHISKER_DROIT → SPINE_BAS
   * 
   * Attribution des segments de frame aux surfaces :
   *   - Spine (NEZ → SPINE_BAS) : partagée 50/50 entre hautes et basses
   *   - Leading edge gauche (NEZ → BORD_GAUCHE) : 100% surface 0
   *   - Leading edge droit (NEZ → BORD_DROIT) : 100% surface 2
   *   - Strut gauche (BORD_GAUCHE → WHISKER_GAUCHE) : partagé surface 0/1
   *   - Strut droit (BORD_DROIT → WHISKER_DROIT) : partagé surface 2/3
   *   - Spreader (WHISKER_GAUCHE → WHISKER_DROIT) : partagé entre toutes
   * 
   * @returns Tableau de 4 masses (kg) pour chaque surface
   */
  private static calculateFrameMassDistribution(): number[] {
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;
    
    // Masses linéiques (kg/m)
    const spineUnitMass = specs.spine / 1000;        // g/m → kg/m
    const leadingEdgeUnitMass = specs.leadingEdge / 1000;
    const strutUnitMass = specs.strut / 1000;
    
    // Longueurs individuelles des segments
    const spineLength = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.SPINE_BAS);
    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_GAUCHE);
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_DROIT);
    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_GAUCHE);
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    /**
     * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
     * @param v1, v2, v3 : sommets du triangle
     * @returns Tableau de 4 sous-triangles {vertices, area}
     */

    // Masses individuelles des segments
    const spineMass = spineLength * spineUnitMass;
    const leadingEdgeLeftMass = leadingEdgeLeft * leadingEdgeUnitMass;
    const leadingEdgeRightMass = leadingEdgeRight * leadingEdgeUnitMass;
    const strutLeftMass = strutLeft * strutUnitMass;
    const strutRightMass = strutRight * strutUnitMass;
    const spreaderMass = spreader * strutUnitMass;
    
    // Attribution géométrique réaliste aux surfaces
    const frameMasses = [
      // Surface 0 (haute gauche) : spine + leading edge gauche + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      leadingEdgeLeftMass +         // 100% leading edge gauche
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 1 (basse gauche) : spine + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 2 (haute droite) : spine + leading edge droit + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      leadingEdgeRightMass +        // 100% leading edge droit
      (strutRightMass * 0.5) +      // 50% strut droit (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)

      // Surface 3 (basse droite) : spine + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partagée entre 4 surfaces)
      (strutRightMass * 0.5) +      // 50% strut droit (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)
    ];
    
    return frameMasses;
  }

  /**
   * Distribution de la masse sur les surfaces
   * Chaque surface porte une fraction de la masse totale
   * 
   * Modèle physique CORRIGÉ :
   * - Masse de tissu (fabric) : Distribuée proportionnellement à l'aire
   * - Masse de frame : Distribuée selon géométrie réelle (🔴 BUG FIX #2)
   * - Masse d'accessoires : Distribuée uniformément sur les 4 surfaces
   * 
   * @returns Masse de chaque surface en kg
   */
  static calculateSurfaceMasses(): number[] {
    const fabricMass = KiteGeometry.calculateFabricMass();
    const frameMasses = KiteGeometry.calculateFrameMassDistribution();  // 🔴 BUG FIX #2
    const accessoriesMass = KiteGeometry.calculateAccessoriesMass();
    
    // Accessoires répartis uniformément (connecteurs dispersés sur tout le kite)
    const uniformAccessories = accessoriesMass / KiteGeometry.SURFACES.length;
    
    // La masse de tissu est répartie proportionnellement à l'aire
    return KiteGeometry.SURFACES.map((surface, index) => {
      const fabricMassRatio = surface.area / KiteGeometry.TOTAL_AREA;
      const surfaceFabricMass = fabricMass * fabricMassRatio;
      
      return surfaceFabricMass + frameMasses[index] + uniformAccessories;
    });
  }

  /**
   * Masses précalculées pour chaque surface (en kg)
   * Index correspond à l'index dans SURFACES
   */
  static readonly SURFACE_MASSES = KiteGeometry.calculateSurfaceMasses();

  /**
   * Surfaces enrichies avec leur masse individuelle
   * Utilisées par AerodynamicsCalculator pour appliquer la gravité distribuée
   */
  static readonly SURFACES_WITH_MASS = KiteGeometry.SURFACES.map((surface, index) => ({
    ...surface,
    mass: KiteGeometry.SURFACE_MASSES[index],
  }));

  /**
   * Calcule le moment d'inertie approximatif du cerf-volant
   * Utilise la formule simplifiée : I ≈ m × r²
   * où r est le rayon de giration moyen
   * @returns Moment d'inertie en kg·m²
   */
  static calculateInertia(): number {
    // Constantes pour calcul d'inertie (éviter dépendance circulaire avec CONFIG)
    const GYRATION_DIVISOR = Math.sqrt(2); // wingspan / √2 pour forme delta (triangle isocèle)

    // Rayon de giration correct pour forme delta wing
    // Formule réaliste : r = wingspan / √2 (au lieu de /4)
    // Référence : géométrie d'un triangle isocèle
    const wingspan =
      KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
        KiteGeometry.POINTS.BORD_DROIT
      );
    const radiusOfGyration = wingspan / GYRATION_DIVISOR;  // ≈ 1.167 m au lieu de 0.4125 m

    const physicalInertia = KiteGeometry.TOTAL_MASS * radiusOfGyration * radiusOfGyration;

    // 🔧 FIX INERTIE: Factor 0.1 pour réactivité immédiate au vent
    // Le kite doit être "emporté" par le vent, pas résister par inertie
    // Factor 0.1 ramène à ~0.042 kg·m² (très réactif, comme un tissu léger)
    const REACTIVE_INERTIA_FACTOR = 0.1;
    return physicalInertia * REACTIVE_INERTIA_FACTOR;
  }

  /**
   * Moment d'inertie calculé automatiquement
   */
  static readonly INERTIA = KiteGeometry.calculateInertia();
}


=== simulation/config/PhysicsConstants.ts ===

/**
 * PhysicsConstants.ts - Constantes physiques globales pour la simulation Kite
 *
 * Rôle :
 *   - Définit les limites physiques, tolérances et facteurs de sécurité du monde virtuel
 *   - Sert à garantir la stabilité et la cohérence de la simulation
 *   - Utilisé pour éviter les comportements irréalistes ou dangereux
 *
 * Dépendances principales :
 *   - Aucun import direct, mais utilisé par tous les modules physiques et de configuration
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise PhysicsConstants pour fixer les limites
 *   - Tous les modules du projet importent PhysicsConstants pour les vérifications
 *
 * Utilisation typique :
 *   - Importé dans les modules de physique, de contrôle et de rendu
 *   - Sert à valider les valeurs et à limiter les extrêmes
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
export class PhysicsConstants {
  // Tolérances numériques
  static readonly EPSILON = 1e-4; // Sans unité - Seuil pour "presque zéro" (comparaisons flottants)
  static readonly EPSILON_FINE = 1e-6; // Sans unité - Seuil fin pour calculs précis (LinePhysics)

  // Contrôles et contraintes
  static readonly CONTROL_DEADZONE = 0.01; // rad - Zone morte pour input barre de contrôle
  static readonly LINE_CONSTRAINT_TOLERANCE = 0.0005; // m - Tolérance contraintes lignes (0.5mm)
  static readonly LINE_TENSION_FACTOR = 0.99; // Sans unité - Facteur tension lignes (99% = légèrement tendues)
  static readonly CONSTRAINT_ITERATIONS = 2; // Sans unité - Nombre d'itérations pour convergence PBD

  // Sol et friction
  static readonly GROUND_FRICTION = 0.95; // Sans unité - Facteur friction sol (5% perte vitesse)

  // Rendu caténaire
  static readonly CATENARY_SEGMENTS = 10; // Sans unité - Nombre segments pour courbe caténaire

  // Limites de sécurité physique (éviter explosions numériques)
  static readonly MAX_FORCE = 1000; // N - Force maximale (équivalent ~100kg)
  static readonly MAX_VELOCITY = 30; // m/s - Vitesse maximale kite (108 km/h)
  static readonly MAX_ANGULAR_VELOCITY = 15; // rad/s - Limite élevée pour permettre convergence naturelle
  static readonly MAX_ACCELERATION = 100; // m/s² - Accélération maximale (~10G)
  static readonly MAX_ANGULAR_ACCELERATION = 5; // rad/s² - Accélération angulaire réaliste
}

=== simulation/config/SimulationConfig.ts ===

/**
 * SimulationConfig.ts - Configuration         // C  // Facteurs d'échelle aérodynamiques équilibrés
  liftScale: 1.2, // Facteur de portance
  dragScale: 1.2, // Facteur de traînée (équilibré avec portance)ficients d'amortissement (en 1/s) - appliqués avec formule exponentielle
  linearDampingCoeff: 0.2, // Amortissement linéaire modéré
  angularDragFactor: 1.0, // Amortissement angulaire équilibré pour stabilisation naturelleamping coefficients (en 1/s) - appliqués avec formule exponentielle
  linearDampingCoeff: 1.5, // 🔧 RÉALISTE: Friction aérodynamique modérée pour stabilisation naturelle
    // Angular damping : UN SEUL mécanisme (angular drag proportionnel à ω)
  angularDragFactor: 5.0, // 🔧 STABILITÉ CRITIQUE: Très fort amortissement pour éviter rotation excessive
  },le de la simulation K  wind: {
    defaultSpeed: 25, // km/h - Vitesse réaliste pour cerf-volant sport (15-30 km/h typique)
    defaultDirection: 0, // degrés
    defaultTurbulence: 5, // % - Turbulence réaliste pour conditions normales
    turbulenceScale: 0.05,*
 * Rôle :
 *   - Définit tous les paramètres physiques, aérodynamiques, géométriques et environnementaux
 *   - Sert de source unique de vérité pour les réglages du monde virtuel
 *   - Permet d'ajuster le comportement du kite, du vent, des lignes, etc.
 *
 * Dépendances principales :
 *   - KiteGeometry.ts : Utilisé pour la surface et les points du kite
 *   - Utilisé par tous les modules physiques et de rendu
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsConstants.ts : Définit les limites et tolérances physiques
 *   - KiteGeometry.ts : Définit la géométrie du kite
 *   - Tous les modules du projet importent SimulationConfig pour accéder aux paramètres
 *
 * Utilisation typique :
 *   - Importé dans tous les modules pour accéder aux réglages
 *   - Sert à personnaliser la simulation (test, debug, tuning)
 *
 * Voir aussi :
 *   - src/simulation/config/PhysicsConstants.ts
 *   - src/simulation/config/KiteGeometry.ts
 */
import * as THREE from "three";

import { KiteGeometry } from "./KiteGeometry";

/**
 * Configuration épurée de la simulation
 *
 * Les réglages de notre monde virtuel - comme les règles d'un jeu
 * Vous pouvez changer ces valeurs pour voir comment le cerf-volant réagit
 */
export const CONFIG = {
  physics: {
    gravity: 9.81, // La gravité terrestre (fait tomber les objets)
    airDensity: 1.225, // Densité de l'air (l'air épais pousse plus fort)
    deltaTimeMax: 0.016, // Mise à jour max 60 fois par seconde (pour rester fluide)
    // Damping coefficients (en 1/s) - appliqués avec formule exponentielle
  linearDampingCoeff: 1, // 🔧 FIX INERTIE: Drastiquement réduit pour réactivité immédiate
    // 🔴 SOLUTION #2 : Amortissement angulaire réduit pour équilibre naturel
  angularDragFactor: 1.5, // � ÉQUILIBRE: Réduit de 5.0 → 1.0 pour permettre stabilisation naturelle
  },
  aero: {
  // 🔴 SOLUTION #2 : Forces aérodynamiques équilibrées
  liftScale: 1.2, // � ÉQUILIBRÉ: Réduit de 1.5 → 1.2 
  dragScale: 1.2, // � ÉQUILIBRÉ: Maintenu à 1.2 (cohérent avec lift)
  },
  kite: {
    // Masse et inertie calculées AUTOMATIQUEMENT depuis la géométrie
    // Basées sur:
    // - Frame carbone (spine 5mm, leading edges 5mm, struts 4mm)
    // - Tissu ripstop nylon 120 g/m² (corrigé pour atteindre masse réaliste)
    // - Accessoires (connecteurs, bridage, renforts)
    // Voir KiteGeometry.calculateTotalMass() pour les détails
    mass: KiteGeometry.TOTAL_MASS, // kg - Calculée automatiquement (~0.31 kg après correction)
    area: KiteGeometry.TOTAL_AREA, // m² - Surface totale (calculée automatiquement)
    inertia: KiteGeometry.INERTIA, // kg·m² - Moment d'inertie (I ≈ m·r², calculé automatiquement)
    minHeight: 0, // m - Altitude minimale (plus haut pour éviter le sol)
    // 🔧 MAILLAGE FIN PARAMÉTRABLE (défaut = niveau 1 = 16 triangles)
    defaultMeshSubdivisionLevel: 1, // Niveau par défaut (0=4, 1=16, 2=64, 3=256 triangles)
  },
  lines: {
    defaultLength: 15, // m - Longueur par défaut
    stiffness: 1200, // N/m - Rigidité réduite pour plus de souplesse (2200 était trop rigide)
    preTension: 75, // N - Tension minimale toujours présente
    maxTension: 800, // N - Tension max avant rupture (~80% charge nominale)
    dampingCoeff: 0.05, // Coefficient d'amortissement interne (0-1)
    linearMassDensity: 0.0005, // kg/m - Masse linéique pour calcul caténaire
  },
  wind: {
    defaultSpeed: 20, // km/h - Vitesse idéale pour cerf-volant
    defaultDirection: 0, // degrés
    defaultTurbulence: 0.001, // % - Turbulence réaliste (0.001 → 10)
    turbulenceScale: 0.05,
    turbulenceFreqBase: 0.05,
    turbulenceFreqY: 0.3,
    turbulenceFreqZ: 0.3,
    turbulenceIntensityXZ: 0.2,
    turbulenceIntensityY: 0.2,
  },
  rendering: {
    shadowMapSize: 2048,
    antialias: true,
    fogStart: 100,
    fogEnd: 1000,
  },
  debugVectors: true, // Active ou désactive l'affichage des vecteurs de debug
  controlBar: {
    width: 0.6, // m - Largeur de la barre
    position: new THREE.Vector3(0, 1.2, 8), // Position initiale
    barRadius: 0.02, // m - Rayon du cylindre de la barre
    barRotation: Math.PI / 2, // rad - Rotation pour orientation horizontale
    handleRadius: 0.03, // m - Rayon des poignées
    handleLength: 0.15, // m - Longueur des poignées
  },
  pilot: {
    width: 0.4, // m - Largeur du corps du pilote
    height: 1.6, // m - Hauteur du corps du pilote
    depth: 0.3, // m - Profondeur du corps du pilote
    offsetY: 0.8, // m - Décalage vertical par rapport à la barre
    offsetZ: 8.5, // m - Distance derrière la barre
  },
  initialization: {
    initialKiteY: 7.0, // m - Altitude initiale du kite
    initialDistanceFactor: 0.98, // Sans unité - Facteur de distance initiale (98% de longueur ligne → lignes légèrement tendues au départ)
  },
  visualization: {
    lineWidth: 2, // pixels - Largeur des lignes de contrôle
  },
  debug: {
    // Seuils de tension des brides pour couleurs visuelles
    bridleTensionLow: 1, // N - Seuil tension molle (vert)
    bridleTensionHigh: 100, // N - Seuil tension élevée (rouge)
    // Seuils pour vecteurs debug
    minVectorLength: 0.01, // m - Longueur minimale pour afficher un vecteur
    minVelocityDisplay: 0.1, // m/s - Vitesse minimale pour afficher vecteur vitesse
  },
  input: {
    rotationSpeed: 0.5, // rad/s - Vitesse de rotation de la barre (input utilisateur)
    returnSpeed: 3.0, // rad/s - Vitesse de retour au centre de la barre
    maxRotation: Math.PI / 3, // rad - Rotation maximale de la barre (°)
  },
  kiteInertia: {
    gyrationDivisor: Math.sqrt(2), // Sans unité - Diviseur pour rayon de giration (wingspan / √2)
    inertiaFactor: 1, // Sans unité - Facteur ajustement inertie (compromis stabilité/réactivité)
  },
};

=== simulation/controllers/ControlBarManager.ts ===

/**
 * ControlBarManager.ts - Gestionnaire de la barre de contrôle pour la simulation Kite
 *
 * Rôle :
 *   - Gère la position et l'orientation de la barre de contrôle du cerf-volant
 *   - Calcule les positions des poignées et la rotation de la barre
 *   - Sert d'interface entre le pilote et le système de lignes
 *
 * Dépendances principales :
 *   - Kite.ts : Modèle 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Paramètres et limites physiques
 *   - Types : HandlePositions pour typer les poignées
 *   - Three.js : Pour la géométrie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilisé par KiteController et PhysicsEngine pour manipuler la barre et les lignes
 *   - Interagit avec LineSystem pour la gestion des tensions
 *
 * Utilisation typique :
 *   - Instancié au démarrage, appelé à chaque frame pour mettre à jour la position des poignées
 *   - Sert à la visualisation et au contrôle du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/simulation/physics/LineSystem.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { HandlePositions } from "../types";

/**
 * Gestionnaire de la barre de contrôle
 *
 * Gère la position et l'orientation de la barre de contrôle du cerf-volant
 */
export class ControlBarManager {
  private position: THREE.Vector3;
  private rotation: number = 0;

  constructor(position: THREE.Vector3 = CONFIG.controlBar.position) {
    this.position = position.clone();
  }

  /**
   * Calcule le quaternion de rotation de la barre
   */
  private computeRotationQuaternion(
    toKiteVector: THREE.Vector3
  ): THREE.Quaternion {
    const barDirection = new THREE.Vector3(1, 0, 0);
    const rotationAxis = new THREE.Vector3()
      .crossVectors(barDirection, toKiteVector)
      .normalize();

    if (rotationAxis.length() < PhysicsConstants.CONTROL_DEADZONE) {
      rotationAxis.set(0, 1, 0);
    }

    return new THREE.Quaternion().setFromAxisAngle(rotationAxis, this.rotation);
  }

  /**
   * Obtient les positions des poignées (méthode unique centralisée)
   */
  getHandlePositions(kitePosition: THREE.Vector3): HandlePositions {
    const toKiteVector = kitePosition.clone().sub(this.position).normalize();
    const rotationQuaternion = this.computeRotationQuaternion(toKiteVector);

    const halfWidth = CONFIG.controlBar.width / 2;
    const handleLeftLocal = new THREE.Vector3(-halfWidth, 0, 0);
    const handleRightLocal = new THREE.Vector3(halfWidth, 0, 0);

    handleLeftLocal.applyQuaternion(rotationQuaternion);
    handleRightLocal.applyQuaternion(rotationQuaternion);

    return {
      left: handleLeftLocal.clone().add(this.position),
      right: handleRightLocal.clone().add(this.position),
    };
  }

  /**
   * Met à jour la rotation de la barre
   */
  setRotation(rotation: number): void {
    this.rotation = rotation;
  }

  getRotation(): number {
    return this.rotation;
  }

  getPosition(): THREE.Vector3 {
    return this.position.clone();
  }

  /**
   * Met à jour l'objet 3D visuel de la barre
   */
  updateVisual(bar: THREE.Group, kite: Kite): void {
    if (!bar) return;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const centerKite = kiteLeftWorld
        .clone()
        .add(kiteRightWorld)
        .multiplyScalar(0.5);
      const toKiteVector = centerKite.clone().sub(this.position).normalize();

      bar.quaternion.copy(this.computeRotationQuaternion(toKiteVector));
    }
  }
}

=== simulation/controllers/InputHandler.ts ===

/**
 * InputHandler.ts - Gestionnaire des entrées utilisateur pour la simulation Kite
 *
 * Rôle :
 *   - Gère les contrôles clavier pour piloter le cerf-volant
 *   - Traduit les actions utilisateur en rotation de la barre de contrôle
 *   - Sert d'interface entre l'utilisateur et le système de contrôle
 *
 * Dépendances principales :
 *   - PhysicsConstants.ts : Paramètres et limites pour la gestion des entrées
 *
 * Relation avec les fichiers adjacents :
 *   - Utilisé par ControlBarManager et PhysicsEngine pour appliquer les commandes utilisateur
 *
 * Utilisation typique :
 *   - Instancié au démarrage, écoute les événements clavier pour piloter le kite
 *   - Sert à la visualisation et au contrôle du kite
 *
 * Voir aussi :
 *   - src/simulation/controllers/ControlBarManager.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 */
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire des entrées utilisateur
 *
 * Gère les contrôles clavier pour piloter le cerf-volant
 */
export class InputHandler {
  private currentRotation: number = 0;
  private keysPressed = new Set<string>();
  private rotationSpeed: number = CONFIG.input.rotationSpeed;
  private returnSpeed: number = CONFIG.input.returnSpeed;
  private maxRotation: number = CONFIG.input.maxRotation;

  constructor() {
    this.setupKeyboardControls();
  }

  private setupKeyboardControls(): void {
    window.addEventListener("keydown", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.add(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });

    window.addEventListener("keyup", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.delete(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });
  }

  update(deltaTime: number): void {
    const left =
      this.keysPressed.has("ArrowLeft") ||
      this.keysPressed.has("q") ||
      this.keysPressed.has("a");
    const right =
      this.keysPressed.has("ArrowRight") || this.keysPressed.has("d");
    const dir = (left ? 1 : 0) + (right ? -1 : 0);

    if (dir !== 0) {
      this.currentRotation += dir * this.rotationSpeed * deltaTime;
    } else {
      if (Math.abs(this.currentRotation) > PhysicsConstants.EPSILON) {
        const sign = Math.sign(this.currentRotation);
        this.currentRotation -= sign * this.returnSpeed * deltaTime;
        if (Math.sign(this.currentRotation) !== sign) {
          this.currentRotation = 0;
        }
      } else {
        this.currentRotation = 0;
      }
    }

    this.currentRotation = Math.max(
      -this.maxRotation,
      Math.min(this.maxRotation, this.currentRotation)
    );
  }

  getTargetBarRotation(): number {
    return this.currentRotation;
  }
}

=== simulation/controllers/KiteController.ts ===

/**
 * KiteController.ts - Contrôleur du cerf-volant pour la simulation Kite
 *
 * Rôle :
 *   - Gère l'état physique et le mouvement du cerf-volant
 *   - Applique les forces, met à jour la position, la vitesse et l'orientation
 *   - Détecte les situations extrêmes (accélération, vitesse, rotation)
 *
 * Dépendances principales :
 *   - Kite.ts : Modèle 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Paramètres et limites physiques
 *   - ConstraintSolver.ts : Applique les contraintes de ligne
 *   - Types : KiteState, HandlePositions pour typer l'état
 *   - Three.js : Pour la géométrie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilisé par PhysicsEngine pour manipuler le kite
 *   - Interagit avec ControlBarManager pour la gestion des lignes
 *
 * Utilisation typique :
 *   - Instancié par PhysicsEngine, appelé à chaque frame pour mettre à jour l'état du kite
 *   - Sert à la visualisation et au contrôle du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/controllers/ControlBarManager.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, HandlePositions } from "../types";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { ConstraintSolver } from "../physics/ConstraintSolver";

/**
 * Contrôleur du cerf-volant
 *
 * Gère l'état physique et le mouvement du cerf-volant
 */
export class KiteController {
  private kite: Kite;
  private state: KiteState;
  private previousPosition: THREE.Vector3;
  // États pour les warnings
  private hasExcessiveAccel: boolean = false;
  private hasExcessiveVelocity: boolean = false;
  private hasExcessiveAngular: boolean = false;
  private lastAccelMagnitude: number = 0;
  private lastVelocityMagnitude: number = 0;

  // Lissage temporel des forces
  private smoothedForce: THREE.Vector3;
  private smoothedTorque: THREE.Vector3;
  private forceSmoothingRate: number = KiteController.DEFAULT_FORCE_SMOOTHING_RATE; // 🔧 PHASE 1: Quasi-désactivé pour restaurer réactivité

  // Constantes pour éviter les facteurs magiques
  private static readonly DEFAULT_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MIN_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MAX_FORCE_SMOOTHING_RATE = 20.0;

  constructor(kite: Kite) {
    this.kite = kite;
    this.state = {
      position: kite.position.clone(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: kite.quaternion.clone(),
    };
    this.previousPosition = kite.position.clone();
    this.kite.userData.lineLength = CONFIG.lines.defaultLength;

    // Initialiser les forces lissées avec gravité initiale (évite chute au démarrage)
    const initialGravity = new THREE.Vector3(0, -CONFIG.kite.mass * CONFIG.physics.gravity, 0);
    this.smoothedForce = initialGravity.clone();
    this.smoothedTorque = new THREE.Vector3();
  }

  /**
   * Met à jour la position et l'orientation du cerf-volant
   */
  update(
    forces: THREE.Vector3,
    torque: THREE.Vector3,
    handles: HandlePositions,
    deltaTime: number
  ): void {
    // Valider les forces brutes
    const validForces = this.validateForces(forces);
    const validTorque = this.validateTorque(torque);

    // Lissage exponentiel des forces (indépendant du framerate)
    // smoothingFactor = 1 - e^(-rate × dt)
    const smoothingFactor = 1 - Math.exp(-this.forceSmoothingRate * deltaTime);
    this.smoothedForce.lerp(validForces, smoothingFactor);
    this.smoothedTorque.lerp(validTorque, smoothingFactor);

    // Utiliser les forces lissées pour la physique
    const newPosition = this.integratePhysics(this.smoothedForce, deltaTime);

    // Résolution itérative des contraintes PBD pour convergence stable
    // Les contraintes lignes ↔ brides s'influencent mutuellement
    // Une seule passe n'est pas suffisante - il faut itérer jusqu'à convergence

    for (let iter = 0; iter < PhysicsConstants.CONSTRAINT_ITERATIONS; iter++) {
      // Appliquer les contraintes de lignes (Position-Based Dynamics)
      // Le solveur peut modifier newPosition ainsi que state.velocity / state.angularVelocity
      try {
        ConstraintSolver.enforceLineConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          handles
        );
      } catch (err) {
        // Ne pas laisser une exception du solveur casser la boucle principale
        console.error(`⚠️ Erreur dans ConstraintSolver.enforceLineConstraints (iter ${iter}):`, err);
      }

      // Appliquer les contraintes des brides (Position-Based Dynamics)
      // Les brides sont des contraintes INTERNES qui lient les points du kite entre eux
      try {
        ConstraintSolver.enforceBridleConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          this.kite.getBridleLengths()
        );
      } catch (err) {
        console.error(`⚠️ Erreur dans ConstraintSolver.enforceBridleConstraints (iter ${iter}):`, err);
      }
    }

    // Gérer la collision avec le sol - corrige newPosition et vitesse si nécessaire
    try {
      ConstraintSolver.handleGroundCollision(this.kite, newPosition, this.state.velocity);
    } catch (err) {
      console.error("⚠️ Erreur dans ConstraintSolver.handleGroundCollision:", err);
    }

    // Valider la position finale
    this.validatePosition(newPosition);

    // Appliquer la position et l'orientation
    this.kite.position.copy(newPosition);
    this.updateOrientation(this.smoothedTorque, deltaTime); // Utiliser le torque lissé
    this.previousPosition.copy(newPosition);
  }
  /**
   * Valide les forces appliquées au cerf-volant
   */
  private validateForces(forces: THREE.Vector3): THREE.Vector3 {
    if (
      !forces ||
      forces.length() > PhysicsConstants.MAX_FORCE ||
      isNaN(forces.length())
    ) {
      console.error(
        `⚠️ Forces invalides: ${forces ? forces.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return forces;
  }

  /**
   * Valide le couple
   */
  private validateTorque(torque: THREE.Vector3): THREE.Vector3 {
    if (!torque || isNaN(torque.length())) {
      console.error(
        `⚠️ Couple invalide: ${torque ? torque.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return torque;
  }

  /**
   * Intègre les forces pour calculer la nouvelle position (méthode d'Euler)
   * Implémente la 2ème loi de Newton : F = ma → a = F/m
   */
  private integratePhysics(
    forces: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Newton : accélération = Force / masse
    // IMPORTANT: clone() pour ne pas modifier le vecteur forces en place!
    const acceleration = forces.clone().divideScalar(CONFIG.kite.mass);
    this.lastAccelMagnitude = acceleration.length();

    // Sécurité : limiter pour éviter l'explosion numérique
    this.hasExcessiveAccel = acceleration.length() > PhysicsConstants.MAX_ACCELERATION;
    if (this.hasExcessiveAccel) {
      acceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ACCELERATION);
    }

    // Intégration d'Euler : v(t+dt) = v(t) + a·dt
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier acceleration!
    this.state.velocity.add(acceleration.clone().multiplyScalar(deltaTime));

    // Amortissement exponentiel : v(t) = v₀ × e^(-c×dt)
    // Formule physiquement correcte, indépendante du framerate
    const linearDampingFactor = Math.exp(-CONFIG.physics.linearDampingCoeff * deltaTime);
    this.state.velocity.multiplyScalar(linearDampingFactor);
    this.lastVelocityMagnitude = this.state.velocity.length();

    // Garde-fou vitesse max (réalisme physique)
    this.hasExcessiveVelocity = this.state.velocity.length() > PhysicsConstants.MAX_VELOCITY;
    if (this.hasExcessiveVelocity) {
      this.state.velocity
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_VELOCITY);
    }

    // Position : x(t+dt) = x(t) + v·dt
    return this.kite.position
      .clone()
      .add(this.state.velocity.clone().multiplyScalar(deltaTime));
  }

  /**
   * Valide la position finale
   */
  private validatePosition(newPosition: THREE.Vector3): void {
    if (isNaN(newPosition.x) || isNaN(newPosition.y) || isNaN(newPosition.z)) {
      console.error(`⚠️ Position NaN détectée! Reset à la position précédente`);
      newPosition.copy(this.previousPosition);
      this.state.velocity.set(0, 0, 0);
    }
  }

  /**
   * Met à jour l'orientation du cerf-volant - Dynamique du corps rigide
   */
  private updateOrientation(torque: THREE.Vector3, deltaTime: number): void {
    // Couple d'amortissement (résistance aérodynamique à la rotation)
    // τ_drag = -I × k_drag × ω  (unités correctes: kg·m² × 1/s × rad/s = N·m)
    const dampTorque = this.state.angularVelocity
      .clone()
      .multiplyScalar(-CONFIG.kite.inertia * CONFIG.physics.angularDragFactor);
    const effectiveTorque = torque.clone().add(dampTorque);

    // Dynamique rotationnelle : α = T / I
    // IMPORTANT: clone() pour ne pas modifier effectiveTorque en place!
    const angularAcceleration = effectiveTorque.clone().divideScalar(
      CONFIG.kite.inertia
    );

    // Limiter l'accélération angulaire
    if (
      angularAcceleration.length() > PhysicsConstants.MAX_ANGULAR_ACCELERATION
    ) {
      angularAcceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ANGULAR_ACCELERATION);
    }

    // Mise à jour de la vitesse angulaire
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier angularAcceleration!
    this.state.angularVelocity.add(
      angularAcceleration.clone().multiplyScalar(deltaTime)
    );

    // Note: Amortissement déjà appliqué via dampTorque ci-dessus
    // Pas de damping exponentiel supplémentaire pour éviter sur-amortissement

    // 🔧 DÉSACTIVATION TEMPORAIRE : Limiter la vitesse angulaire
    // Cause des positions impossibles car empêche la convergence naturelle
    // this.hasExcessiveAngular = this.state.angularVelocity.length() > PhysicsConstants.MAX_ANGULAR_VELOCITY;
    // if (this.hasExcessiveAngular) {
    //   this.state.angularVelocity
    //     .normalize()
    //     .multiplyScalar(PhysicsConstants.MAX_ANGULAR_VELOCITY);
    // }
    this.hasExcessiveAngular = false; // Toujours faux pour l'instant

    // Appliquer la rotation
    if (this.state.angularVelocity.length() > PhysicsConstants.EPSILON) {
      const deltaRotation = new THREE.Quaternion();
      const axis = this.state.angularVelocity.clone().normalize();
      const angle = this.state.angularVelocity.length() * deltaTime;
      deltaRotation.setFromAxisAngle(axis, angle);

      this.kite.quaternion.multiply(deltaRotation);
      this.kite.quaternion.normalize();
    }
  }

  getState(): KiteState {
    return { ...this.state };
  }

  getKite(): Kite {
    return this.kite;
  }

  setLineLength(length: number): void {
    this.kite.userData.lineLength = length;
  }

  /**
   * Retourne les états de warning pour l'affichage
   */
  getWarnings(): {
    accel: boolean;
    velocity: boolean;
    angular: boolean;
    accelValue: number;
    velocityValue: number;
  } {
    return {
      accel: this.hasExcessiveAccel,
      velocity: this.hasExcessiveVelocity,
      angular: this.hasExcessiveAngular,
      accelValue: this.lastAccelMagnitude,
      velocityValue: this.lastVelocityMagnitude,
    };
  }

  /**
   * Définit le taux de lissage des forces physiques
   * @param rate - Taux en 1/s (valeurs typiques: 1-10, plus élevé = lissage plus rapide)
   */
  setForceSmoothing(rate: number): void {
    this.forceSmoothingRate = Math.max(
      KiteController.MIN_FORCE_SMOOTHING_RATE,
      Math.min(KiteController.MAX_FORCE_SMOOTHING_RATE, rate)
    );
  }

  /**
   * Retourne le taux de lissage actuel des forces (en 1/s)
   */
  getForceSmoothing(): number {
    return this.forceSmoothingRate;
  }
}

=== simulation/index.ts ===

/**
 * Point d'entrée principal de la simulation modulaire
 */

// Export de la classe principale
export { SimulationApp as Simulation } from './SimulationApp';

// Re-export de tous les modules pour faciliter l'importation
export * from './config/PhysicsConstants';
export * from './config/KiteGeometry';
export * from './config/SimulationConfig';

export * from './types';

export * from './physics/WindSimulator';
export * from './physics/AerodynamicsCalculator';
export * from './physics/LineSystem';
export * from './physics/PhysicsEngine';

export * from './controllers/ControlBarManager';
export * from './controllers/KiteController';
export * from './controllers/InputHandler';

export * from './rendering/RenderManager';
export * from './rendering/DebugRenderer';

export * from './ui/UIManager';

export * from './physics/ConstraintSolver';

=== simulation/physics/AerodynamicsCalculator.ts ===

/**
 * AerodynamicsCalculator.ts - Calculateur de forces aérodynamiques distribuées
 *
 * Calcule les forces aérodynamiques (portance, traînée) et gravitationnelles 
 * distribuées sur chaque surface du kite selon les principes de la mécanique des fluides.
 *
 * Modèle physique :
 *   - Portance : CL = sin(α)×cos(α) (plaqu      gravity: gravityForce,  // Gravité distribuée par surface plane)
 *   - Traînée : CD = sin²(α) (plaque plane)
 *   - Gravité distribuée par masse surfacique
 *   - Couples émergents de la distribution spatiale des forces
 *
 * @see PhysicsEngine.ts - Utilise les forces calculées
 * @see KiteGeometry.ts - Définit les surfaces et masses
 */
import * as THREE from "three";

import { KiteGeometry } from "../config/KiteGeometry";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { SurfaceForce } from "../types/PhysicsTypes";

/**
 * Calculateur de forces aérodynamiques
 *
 * Calcule comment le vent pousse sur le cerf-volant selon sa forme et orientation
 */
export class AerodynamicsCalculator {
  // Constantes de calculs aérodynamiques
  private static readonly HALF_AIR_DENSITY = 0.5 * CONFIG.physics.airDensity;
  private static readonly MIN_WIND_SPEED = 0.01; // m/s - seuil minimal pour calculs aéro

  /**
   * Calcule le couple (moment) d'une force appliquée à un point
   * Méthode utilitaire pour éviter la répétition de new THREE.Vector3().crossVectors()
   */
  private static calculateTorque(lever: THREE.Vector3, force: THREE.Vector3): THREE.Vector3 {
    return new THREE.Vector3().crossVectors(lever, force);
  }

  /**
   * Calcule la normale d'un triangle dans l'espace monde
   * Méthode utilitaire pour éviter la duplication de code
   *
   * @param surface - Surface triangulaire avec vertices
   * @param kiteOrientation - Quaternion d'orientation du kite (optionnel)
   * @returns Vecteur normal unitaire dans l'espace monde
   */
  private static calculateSurfaceNormal(
    surface: { vertices: THREE.Vector3[] },
    kiteOrientation?: THREE.Quaternion
  ): THREE.Vector3 {
    // Calcul des arêtes du triangle
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    
    // Normale locale (produit vectoriel normalisé)
    const normal = new THREE.Vector3()
      .crossVectors(edge1, edge2)
      .normalize();
    
    // Transformation dans l'espace monde si orientation fournie
    return kiteOrientation ? normal.applyQuaternion(kiteOrientation) : normal;
  }

  /**
   * Calcule comment le vent pousse sur le cerf-volant
   *
   * COMMENT ÇA MARCHE :
   * 1. On regarde chaque triangle du cerf-volant
   * 2. On calcule sous quel angle le vent frappe ce triangle
   * 3. Plus le vent frappe de face, plus la force est grande
   * 4. On additionne toutes les forces pour avoir la force totale
   *
   * POURQUOI C'EST IMPORTANT :
   * Si un côté du kite reçoit plus de vent, il sera poussé plus fort
   * Cette différence fait tourner le kite naturellement !
   */
  static calculateForces(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion,
    kitePosition?: THREE.Vector3,
    kiteVelocity?: THREE.Vector3,
    angularVelocity?: THREE.Vector3
  ): {
    lift: THREE.Vector3;
    drag: THREE.Vector3;
    gravity: THREE.Vector3;  // Gravité distribuée par surface
    torque: THREE.Vector3;
    leftForce?: THREE.Vector3;
    rightForce?: THREE.Vector3;
    surfaceForces: SurfaceForce[];
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < 0.1) {
      return {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),  // Pas de gravité si vent nul
        torque: new THREE.Vector3(),
        surfaceForces: [],
      };
    }

    const windDir = apparentWind.clone().normalize();
    const dynamicPressure = AerodynamicsCalculator.HALF_AIR_DENSITY * windSpeed * windSpeed;

    // Forces séparées pour gauche et droite
    const leftForce = new THREE.Vector3();
    const rightForce = new THREE.Vector3();
    const totalForce = new THREE.Vector3();
    const totalTorque = new THREE.Vector3();
    
    // Accumulation des forces par type (formules plaque plane : CL = sin(α)×cos(α), CD = sin²(α))
    const totalLift = new THREE.Vector3();      // Portance totale
    const totalDrag = new THREE.Vector3();      // Traînée totale
    const gravityForce = new THREE.Vector3();   // Gravité distribuée par surface/frame
    
    // Séparation couples aéro et gravité pour scaling cohérent
    const aeroTorque = new THREE.Vector3();
    const gravityTorque = new THREE.Vector3();
    
    // Collection des forces par surface pour le debug
    const surfaceForces: SurfaceForce[] = [];

    // On examine chaque triangle du cerf-volant un par un
    // C'est comme vérifier comment le vent frappe chaque panneau d'un parasol
    KiteGeometry.SUBDIVIDED_SURFACES.forEach((surface, surfaceIndex) => {
      // 🔴 MAILLAGE FIN : Distribuer la masse proportionnellement à l'aire
      // Trouver quelle surface originale contient ce sous-triangle
      const trianglesPerSurface = KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(
        KiteGeometry.getMeshSubdivisionLevel()
      );
      const originalSurfaceIndex = Math.floor(surfaceIndex / trianglesPerSurface);
      const originalSurfaceMass = KiteGeometry.SURFACE_MASSES[originalSurfaceIndex];

      // Distribuer la masse proportionnellement à l'aire relative
      const totalAreaForOriginal = KiteGeometry.SURFACES[originalSurfaceIndex].area;
      const massRatio = surface.area / totalAreaForOriginal;
      const surfaceMass = originalSurfaceMass * massRatio;
      // 🔴 DÉSACTIVATION TEMPORAIRE du vent apparent local pour debug
      // Le calcul local peut réduire trop fortement le vent perçu en rotation
      
      // Utiliser le vent apparent GLOBAL pour toutes les surfaces
      const localApparentWind = apparentWind.clone();
      const localWindSpeed = localApparentWind.length();
      
      if (localWindSpeed < 0.1) {
        return; // Pas de vent sur cette surface
      }
      
      const localWindDir = localApparentWind.clone().normalize();
      const localDynamicPressure = 0.5 * CONFIG.physics.airDensity * localWindSpeed * localWindSpeed;
      
      // Pour comprendre comment le vent frappe ce triangle,
      // on doit savoir dans quelle direction il "regarde"
      // (comme l'orientation d'un panneau solaire)
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      // Calcul de l'angle d'incidence pour une plaque plane (cerf-volant)
      // α = angle entre la direction du vent et la surface
      const windDotNormal = localWindDir.dot(normaleMonde);
      const cosTheta = Math.abs(windDotNormal); // cos(θ) où θ = angle vent-normale

      // Pour une plaque : sin(α) = cos(θ) et cos(α) = sin(θ)
      const sinAlpha = cosTheta;
      const cosAlpha = Math.sqrt(1 - sinAlpha * sinAlpha); // sin²+cos²=1

      // Si le vent glisse sur le côté (angle = 0), pas de force
      if (sinAlpha <= PhysicsConstants.EPSILON) {
        return;
      }

      // 🔴 BUG FIX #4 : COEFFICIENTS PLAQUE PLANE CORRECTS (Hoerner)
      // Formules physiques pour plaque plane inclinée à angle α :
      //   C_L = sin(α) × cos(α)  → Coefficient de portance
      //   C_D = sin²(α)           → Coefficient de traînée
      // Ces coefficients sont validés expérimentalement !
      
      const CL = sinAlpha * cosAlpha;  // Coefficient lift
      const CD = sinAlpha * sinAlpha;   // Coefficient drag (= CN)
      
      // 🔍 DEBUG première surface (angle et coefficients) - DISABLED for performance
      // if (surfaceIndex === 0) {
      //   const alphaDeg = Math.asin(sinAlpha) * 180 / Math.PI;

      // }
      
      // Direction : normale à la surface, orientée face au vent
      const windFacingNormal = windDotNormal >= 0 ? normaleMonde.clone() : normaleMonde.clone().negate();
      
      // DIRECTION LIFT : Perpendiculaire au vent, dans le plan (vent, normale)
      // Méthode : liftDir = normalize(windFacingNormal - (windFacingNormal·windDir)×windDir)
      const liftDir = windFacingNormal.clone()
        .sub(localWindDir.clone().multiplyScalar(windFacingNormal.dot(localWindDir)))
        .normalize();
      
      // Vérifier validité (éviter division par zéro si vent // normale)
      if (liftDir.lengthSq() < PhysicsConstants.EPSILON) {
        liftDir.copy(windFacingNormal);  // Fallback : utiliser normale
      }
      
      // DIRECTION DRAG : Parallèle au vent
      const dragDir = localWindDir.clone();
      
      // FORCES AÉRODYNAMIQUES (AVANT scaling) avec pression dynamique LOCALE
      const liftMagnitude = localDynamicPressure * surface.area * CL;
      const dragMagnitude = localDynamicPressure * surface.area * CD;
      
      const liftForce = liftDir.clone().multiplyScalar(liftMagnitude);
      const dragForce = dragDir.clone().multiplyScalar(dragMagnitude);
      
      // Force aérodynamique totale = lift + drag (vectoriel)
      const aeroForce = liftForce.clone().add(dragForce);
      
      // GRAVITÉ DISTRIBUÉE (émergente, pas scriptée !)
      // Chaque surface porte une fraction de la masse totale
      // La gravité est appliquée au centre géométrique de chaque surface
      // → Couple gravitationnel émerge naturellement de r × F_gravity
      const gravity = new THREE.Vector3(0, -surfaceMass * CONFIG.physics.gravity, 0);
      
      // Accumulation des forces par type
      totalLift.add(liftForce);
      totalDrag.add(dragForce);
      gravityForce.add(gravity);
      
      // Force totale sur cette surface = aéro + gravité
      const totalSurfaceForce = aeroForce.clone().add(gravity);
      
      // Pour le debug : conserver lift/drag locaux
      const lift = liftForce.clone();
      const drag = dragForce.clone();

      // 6. Centre de pression = centre géométrique du triangle
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // 🔍 DEBUG TOUTES les surfaces : géométrie + forces - DISABLED for performance


      // On note si cette force est sur le côté gauche ou droit
      // C'est important car si un côté a plus de force,
      // le kite va tourner (comme un bateau avec une seule rame)
      const isLeft = centre.x < 0; // Négatif = gauche, Positif = droite

      if (isLeft) {
        leftForce.add(totalSurfaceForce); // Force totale (aéro + gravité)
      } else {
        rightForce.add(totalSurfaceForce); // Force totale (aéro + gravité)
      }

      totalForce.add(totalSurfaceForce);

      // Friction (négligeable pour l'air, nulle)
      const friction = new THREE.Vector3();

      // Résultante = force aéro totale (lift + drag vectoriel)
      const resultant = aeroForce.clone();

      surfaceForces.push({
        surfaceIndex,
        lift,
        drag,
        friction,
        resultant,
        center: centre.clone(), // Coordonnées locales du kite
        normal: normaleMonde.clone(),
        area: surface.area,
      });

      // Le couple, c'est ce qui fait tourner le kite
      // Imaginez une porte : si vous poussez près des gonds, elle tourne peu
      // Si vous poussez loin des gonds, elle tourne beaucoup
      // Ici, plus la force est loin du centre, plus elle fait tourner
      //
      // Séparation couples aéro et gravité pour scaling cohérent :
      // - Couple aéro : sera scalé proportionnellement aux forces (liftScale/dragScale)
      // - Couple gravité : physique pure, pas de scaling
      // Note: centre est déjà en coordonnées locales, on applique seulement la rotation
      const centreWorldForTorque = centre.clone().applyQuaternion(kiteOrientation);
      
      // Couples calculés via méthode utilitaire
      aeroTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, aeroForce));
      gravityTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, gravity));
      totalTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, totalSurfaceForce));


    });

    // PHYSIQUE ÉMERGENTE : Le couple vient de la différence G/D
    // Si leftForce > rightForce → rotation vers la droite
    // Si rightForce > leftForce → rotation vers la gauche
    // AUCUN facteur artificiel nécessaire!

    // 🔴 BUG FIX #4 : PAS DE DÉCOMPOSITION GLOBALE !
    // Les lift/drag ont déjà été calculés CORRECTEMENT par surface avec CL/CD
    // Il suffit d'appliquer les scaling factors directement
    const lift = totalLift.multiplyScalar(CONFIG.aero.liftScale);
    const drag = totalDrag.multiplyScalar(CONFIG.aero.dragScale);

    // 🔍 DEBUG : Afficher forces calculées - DISABLED for performance
    // Uncomment for debugging:


    // 🔍 DEBUG CRITIQUE : Asymétrie gauche/droite - DISABLED for performance
    // const leftMag = leftForce.length();
    // const rightMag = rightForce.length();
    // const asymmetry = leftMag - rightMag;
    // const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag * 100) : 0;
    // const leftArr = leftForce.toArray();
    // const rightArr = rightForce.toArray();
    // const diffArr = leftForce.clone().sub(rightForce).toArray();


    // CORRECTION CRITIQUE : Scaling cohérent du couple aérodynamique
    // Le couple DOIT être scalé proportionnellement aux forces aéro pour cohérence physique
    // Si les forces sont doublées (scale=2), le couple doit l'être aussi
    // MAIS la gravité reste inchangée (physique pure)
    const averageAeroScale = (CONFIG.aero.liftScale + CONFIG.aero.dragScale) / 2;
    const scaledAeroTorque = aeroTorque.multiplyScalar(averageAeroScale);
    
    // Couple total = couple aéro scalé + couple gravité (non scalé)
    const finalTorque = scaledAeroTorque.clone().add(gravityTorque);

    return {
      lift,
      drag,
      gravity: gravityForce,  // � RESTAURÉ : Gravité distribuée par surface
      torque: finalTorque,  // Couple cohérent avec forces scalées
      leftForce, // Exposer les forces pour analyse
      rightForce, // Permet de voir l'asymétrie émergente
      surfaceForces, // Forces individuelles par surface pour debug
    };
  }

  /**
   * Calcule des métriques pour le debug
   */
  static computeMetrics(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): {
    apparentSpeed: number;
    liftMag: number;
    dragMag: number;
    lOverD: number;
    aoaDeg: number;
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < PhysicsConstants.EPSILON) {
      return { apparentSpeed: 0, liftMag: 0, dragMag: 0, lOverD: 0, aoaDeg: 0 };
    }

    const { lift } = this.calculateForces(apparentWind, kiteOrientation);
    const liftMag = lift.length();
    const dragMag = 0; // Traînée intégrée dans les forces totales
    const lOverD = 0; // Ratio non applicable pour un cerf-volant

    // Calcul approximatif de l'angle d'attaque
    const windDir = apparentWind.clone().normalize();
    const weightedNormal = new THREE.Vector3();

    KiteGeometry.SURFACES.forEach((surface) => {
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      const facing = windDir.dot(normaleMonde);
      const cosIncidence = Math.max(0, Math.abs(facing));

      const normalDir =
        facing >= 0 ? normaleMonde : normaleMonde.clone().negate();
      weightedNormal.add(normalDir.multiplyScalar(surface.area * cosIncidence));
    });

    let aoaDeg = 0;
    if (
      weightedNormal.lengthSq() >
      PhysicsConstants.EPSILON * PhysicsConstants.EPSILON
    ) {
      const eff = weightedNormal.normalize();
      const dot = Math.max(-1, Math.min(1, eff.dot(windDir)));
      const phiDeg = (Math.acos(dot) * 180) / Math.PI;
      aoaDeg = Math.max(0, 90 - phiDeg);
    }

    return { apparentSpeed: windSpeed, liftMag, dragMag, lOverD, aoaDeg };
  }
}

=== simulation/physics/BridleSystem.ts ===

/**
 * BridleSystem.ts - Orchestrateur du système de bridage du cerf-volant
 *
 * Rôle :
 *   - Coordonne les 6 brides (3 gauches + 3 droites)
 *   - Calcule les tensions pour affichage/debug (pas de forces appliquées)
 *   - Les contraintes de distance sont gérées par ConstraintSolver
 *
 * IMPORTANT : Les brides sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT les points d'attache (distance max)
 *   - Elles ne TIRENT PAS les points les uns vers les autres
 *   - Le ConstraintSolver.enforceBridleConstraints() gère la contrainte géométrique
 *
 * Architecture :
 *   - Similar à LineSystem mais pour les brides internes au kite
 *   - Réutilise LinePhysics pour les calculs de tension
 *   - Les 6 brides sont des instances Line indépendantes
 *
 * Relation avec les autres modules :
 *   - Utilise BridleFactory pour créer les brides
 *   - Utilise LinePhysics pour calculer tensions
 *   - Utilisé par PhysicsEngine
 *   - Les contraintes sont appliquées dans ConstraintSolver
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts (pattern similaire)
 *   - src/factories/BridleFactory.ts
 *   - src/simulation/physics/ConstraintSolver.ts
 */

import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { BridleFactory } from "@factories/BridleFactory";

import { BridleLengths, BridleTensions } from "../types/BridleTypes";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

/**
 * Système de gestion des brides
 *
 * Gère les 6 brides qui relient les points anatomiques du kite
 * aux points de contrôle (CTRL_GAUCHE, CTRL_DROIT).
 */
export class BridleSystem {
  // Brides gauches (3)
  private leftNez: Line;
  private leftInter: Line;
  private leftCentre: Line;

  // Brides droites (3)
  private rightNez: Line;
  private rightInter: Line;
  private rightCentre: Line;

  // Services de calcul physique (réutilisés)
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(bridleLengths: BridleLengths) {
    // Valider les longueurs
    BridleFactory.validateBridleLengths(bridleLengths);

    // Créer les 6 brides via factory
    const { left, right } = BridleFactory.createAllBridles(bridleLengths);

    // Assigner brides gauches
    [this.leftNez, this.leftInter, this.leftCentre] = left;

    // Assigner brides droites
    [this.rightNez, this.rightInter, this.rightCentre] = right;

    // Services de calcul physique
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  /**
   * Calcule les tensions de toutes les brides
   *
   * Note : Ces tensions sont calculées pour affichage/debug uniquement.
   * Les brides sont des contraintes géométriques gérées par ConstraintSolver,
   * elles n'appliquent PAS de forces au kite.
   *
   * @param kite - Instance du cerf-volant
   * @returns Tensions des 6 brides (Newtons)
   */
  calculateBridleTensions(kite: Kite): BridleTensions {
    const deltaTime = 1 / 60; // Approximation pour calcul vélocité

    // Configuration des 6 brides avec leur métadonnées
    const bridleConfigs = [
      { line: this.leftNez, start: "NEZ", end: "CTRL_GAUCHE", key: "leftNez" },
      { line: this.leftInter, start: "INTER_GAUCHE", end: "CTRL_GAUCHE", key: "leftInter" },
      { line: this.leftCentre, start: "CENTRE", end: "CTRL_GAUCHE", key: "leftCentre" },
      { line: this.rightNez, start: "NEZ", end: "CTRL_DROIT", key: "rightNez" },
      { line: this.rightInter, start: "INTER_DROIT", end: "CTRL_DROIT", key: "rightInter" },
      { line: this.rightCentre, start: "CENTRE", end: "CTRL_DROIT", key: "rightCentre" },
    ] as const;

    // Calculer toutes les tensions en une passe
    const tensionsMap = new Map<string, number>();
    for (const config of bridleConfigs) {
      const tension = this.calculateSingleBridleTension(
        kite,
        config.line,
        config.start,
        config.end,
        deltaTime
      );
      tensionsMap.set(config.key, tension);
    }

    // Construire le résultat
    return {
      leftNez: tensionsMap.get("leftNez")!,
      leftInter: tensionsMap.get("leftInter")!,
      leftCentre: tensionsMap.get("leftCentre")!,
      rightNez: tensionsMap.get("rightNez")!,
      rightInter: tensionsMap.get("rightInter")!,
      rightCentre: tensionsMap.get("rightCentre")!,
    };
  }

  /**
   * Calcule la tension d'une bride individuelle
   *
   * @param kite - Instance du cerf-volant
   * @param bridle - Instance Line de la bride
   * @param startPointName - Nom du point de départ (ex: "NEZ")
   * @param endPointName - Nom du point d'arrivée (ex: "CTRL_GAUCHE")
   * @param deltaTime - Pas de temps pour calcul vélocité
   * @returns Tension en Newtons
   */
  private calculateSingleBridleTension(
    kite: Kite,
    bridle: Line,
    startPointName: string,
    endPointName: string,
    deltaTime: number
  ): number {
    // Récupérer positions locales
    const startLocal = kite.getPoint(startPointName);
    const endLocal = kite.getPoint(endPointName);

    if (!startLocal || !endLocal) {
      console.warn(`⚠️ Points bride introuvables: ${startPointName} ou ${endPointName}`);
      return 0;
    }

    // Convertir en coordonnées monde
    const startWorld = kite.localToWorld(startLocal);
    const endWorld = kite.localToWorld(endLocal);

    // Calculer vélocité relative avec VelocityCalculator
    const key = `${startPointName}_${endPointName}`;
    const velocity = this.velocityCalculator.calculateRelative(
      `${key}_start`,
      `${key}_end`,
      startWorld,
      endWorld,
      deltaTime
    );

    // Calculer tension via LinePhysics
    const result = this.physics.calculateTensionForce(
      bridle,
      startWorld,
      endWorld,
      velocity
    );

    // Mettre à jour l'état de la bride
    bridle.updateState(result.currentLength, result.tension, performance.now());

    return result.tension;
  }

  /**
   * Met à jour les longueurs des brides
   *
   * @param newLengths - Nouvelles longueurs (partial update)
   * @deprecated Utilisez PhysicsEngine.setBridleLength() à la place
   */
  setBridleLengths(newLengths: Partial<BridleLengths>): void {
    // Note: Les instances Line sont immuables. Pour changer les longueurs,
    // il faut recréer BridleSystem avec les nouvelles longueurs.
    // Cette méthode est dépréciée - utilisez PhysicsEngine.setBridleLength()
    console.warn("⚠️ BridleSystem.setBridleLengths() est déprécié. Utilisez PhysicsEngine.setBridleLength() à la place");
    console.log("   Nouvelles longueurs demandées:", newLengths);
  }

  /**
   * Obtient les longueurs actuelles des brides
   *
   * @returns BridleLengths actuelles
   */
  getBridleLengths(): BridleLengths {
    return {
      nez: this.leftNez.config.length,
      inter: this.leftInter.config.length,
      centre: this.leftCentre.config.length,
    };
  }

  /**
   * Obtient toutes les instances Line des brides
   * (utile pour ConstraintSolver)
   *
   * @returns Objet contenant les 6 brides
   */
  getAllBridles(): {
    left: { nez: Line; inter: Line; centre: Line };
    right: { nez: Line; inter: Line; centre: Line };
  } {
    return {
      left: {
        nez: this.leftNez,
        inter: this.leftInter,
        centre: this.leftCentre,
      },
      right: {
        nez: this.rightNez,
        inter: this.rightInter,
        centre: this.rightCentre,
      },
    };
  }

  /**
   * Vérifie si une bride est tendue
   *
   * @param side - Côté (left/right)
   * @param position - Position (nez/inter/centre)
   * @returns true si tendue
   */
  isBridleTaut(side: 'left' | 'right', position: 'nez' | 'inter' | 'centre'): boolean {
    const bridleMap = {
      left: { nez: this.leftNez, inter: this.leftInter, centre: this.leftCentre },
      right: { nez: this.rightNez, inter: this.rightInter, centre: this.rightCentre },
    };

    return bridleMap[side][position].isTaut();
  }

  /**
   * Obtient des statistiques sur l'état des brides
   * (utile pour debug/monitoring)
   */
  getStats(): {
    tautCount: number;
    avgTension: number;
    maxTension: number;
    minTension: number;
  } {
    const bridles = [
      this.leftNez,
      this.leftInter,
      this.leftCentre,
      this.rightNez,
      this.rightInter,
      this.rightCentre,
    ];

    const tautCount = bridles.filter(b => b.isTaut()).length;
    const tensions = bridles.map(b => b.getCurrentTension());
    const avgTension = tensions.reduce((sum, t) => sum + t, 0) / tensions.length;
    const maxTension = Math.max(...tensions);
    const minTension = Math.min(...tensions);

    return { tautCount, avgTension, maxTension, minTension };
  }
}


=== simulation/physics/ConstraintSolver.ts ===

/**
 * ConstraintSolver.ts - Solveur de contraintes pour les lignes du cerf-volant
 *
 * Rôle :
 *   - Applique les contraintes de distance sur les lignes via l'algorithme Position-Based Dynamics (PBD)
 *   - Garantit la stabilité géométrique du kite et le respect des longueurs de ligne
 *   - Permet la rotation naturelle et le décrochage du kite
 *
 * Dépendances principales :
 *   - Kite.ts : Accès à la géométrie et points du cerf-volant
 *   - PhysicsConstants.ts : Constantes physiques pour la tolérance et la gestion des contraintes
 *   - SimulationConfig.ts : Paramètres de configuration
 *   - Types : Utilise HandlePositions pour typer les poignées
 *
 * Relation avec les fichiers adjacents :
 *   - LineSystem.ts : Utilise ConstraintSolver pour appliquer les contraintes sur les lignes
 *   - PhysicsEngine.ts : Orchestration de l'appel au solveur
 *
 * Utilisation typique :
 *   - Appelé par LineSystem ou PhysicsEngine pour maintenir la contrainte de distance
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { HandlePositions } from "../types";
import { BridleLengths } from "../types/BridleTypes";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Solveur de contraintes pour les lignes
 *
 * Implémente l'algorithme Position-Based Dynamics (PBD) pour maintenir
 * les contraintes de distance des lignes
 */
export class ConstraintSolver {
  /**
   * Applique les contraintes des lignes - Solver PBD (Position-Based Dynamics)
   * Algorithme sophistiqué qui respecte la contrainte de distance tout en
   * permettant la rotation naturelle du kite
   */
  static enforceLineConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    handles: HandlePositions
  ): void {
    // PRINCIPE DE LA PYRAMIDE DE CONTRAINTE :
    // Le cerf-volant est constamment poussé par le vent contre la sphère de contrainte
    // Les lignes + brides forment une pyramide qui maintient une géométrie stable
    // Le kite "glisse" sur la surface de la sphère définie par la longueur des lignes
    // C'est quand il sort de cette sphère qu'il "décroche"

    const lineLength =
      kite.userData.lineLength || CONFIG.lines.defaultLength;
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) return;

    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // Résolution PBD pour chaque ligne
    const solveLine = (ctrlLocal: THREE.Vector3, handle: THREE.Vector3) => {
      // Utiliser position prédite pour transformation locale→monde
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const cpWorld = kite.localToWorld(ctrlLocal);
      kite.position.copy(originalPos);
      const diff = cpWorld.clone().sub(handle);
      const dist = diff.length();

      if (dist <= lineLength - tol) return; // Ligne molle

      const n = diff.clone().normalize();
      const C = dist - lineLength;

      const r = cpWorld.clone().sub(predictedPosition);
      const alpha = new THREE.Vector3().crossVectors(r, n);
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);
      const denom = invMass + alpha.lengthSq() * invInertia;
      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections
      const dPos = n.clone().multiplyScalar(-invMass * lambda);
      predictedPosition.add(dPos);

      const dTheta = alpha.clone().multiplyScalar(-invInertia * lambda);
      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse
      kite.position.copy(predictedPosition);
      const cpWorld2 = kite.localToWorld(ctrlLocal);
      kite.position.copy(originalPos);
      const n2 = cpWorld2.clone().sub(handle).normalize();
      const r2 = cpWorld2.clone().sub(predictedPosition);
      const pointVel = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, r2));
      const radialSpeed = pointVel.dot(n2);

      if (radialSpeed > 0) {
        const rxn = new THREE.Vector3().crossVectors(r2, n2);
        const eff = invMass + rxn.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        state.velocity.add(n2.clone().multiplyScalar(J * invMass));
        const angImpulse = new THREE.Vector3().crossVectors(
          r2,
          n2.clone().multiplyScalar(J)
        );
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Plusieurs passes pour mieux satisfaire les contraintes
    for (let i = 0; i < PhysicsConstants.CONSTRAINT_ITERATIONS; i++) {
      solveLine(ctrlLeft, handles.left);
      solveLine(ctrlRight, handles.right);
    }
  }

  /**
   * Applique les contraintes des brides - Solver PBD (Position-Based Dynamics)
   * 
   * Les brides sont des contraintes INTERNES au kite qui relient :
   * - NEZ → CTRL_GAUCHE / CTRL_DROIT
   * - INTER_GAUCHE → CTRL_GAUCHE
   * - INTER_DROIT → CTRL_DROIT
   * - CENTRE → CTRL_GAUCHE / CTRL_DROIT
   * 
   * Contrairement aux lignes principales (kite ↔ pilote), les brides lient
   * des points du MÊME objet (le kite). Elles définissent la forme et rigidité
   * interne du cerf-volant.
   */
  static enforceBridleConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    bridleLengths: BridleLengths
  ): void {
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;
    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // Définition des 6 brides (3 par côté)
    const bridles = [
      // Brides gauches
      { start: "NEZ", end: "CTRL_GAUCHE", length: bridleLengths.nez },
      { start: "INTER_GAUCHE", end: "CTRL_GAUCHE", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_GAUCHE", length: bridleLengths.centre },
      // Brides droites
      { start: "NEZ", end: "CTRL_DROIT", length: bridleLengths.nez },
      { start: "INTER_DROIT", end: "CTRL_DROIT", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_DROIT", length: bridleLengths.centre },
    ];

    // Résolution PBD pour chaque bride
    const solveBridle = (
      startName: string,
      endName: string,
      bridleLength: number
    ) => {
      const startLocal = kite.getPoint(startName);
      const endLocal = kite.getPoint(endName);

      if (!startLocal || !endLocal) {
        console.warn(`⚠️ Points bride introuvables: ${startName} ou ${endName}`);
        return;
      }

      // Convertir points locaux en coordonnées monde (avec position prédite)
      const originalPos = kite.position.clone();
      kite.position.copy(predictedPosition);
      const startWorld = kite.localToWorld(startLocal);
      const endWorld = kite.localToWorld(endLocal);
      kite.position.copy(originalPos);

      // Calculer distance actuelle
      const diff = endWorld.clone().sub(startWorld);
      const dist = diff.length();

      // Si bride molle, pas de contrainte
      if (dist <= bridleLength - tol) return;

      // Direction de contrainte (normalisée)
      const n = diff.clone().normalize();

      // Violation de contrainte C = distance - longueur_bride
      const C = dist - bridleLength;

      // Calcul des bras de levier pour rotation
      const rStart = startWorld.clone().sub(predictedPosition);
      const rEnd = endWorld.clone().sub(predictedPosition);

      // Moments angulaires
      const alphaStart = new THREE.Vector3().crossVectors(rStart, n);
      const alphaEnd = new THREE.Vector3().crossVectors(rEnd, n.clone().negate());

      // Inverse masses
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);

      // Dénominateur pour lambda (inclut rotation)
      // Les deux points appartiennent au même corps rigide, donc contribution double
      const denom =
        2 * invMass +
        alphaStart.lengthSq() * invInertia +
        alphaEnd.lengthSq() * invInertia;

      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections de position
      // Point start : poussé dans direction -n
      const dPosStart = n.clone().multiplyScalar(-invMass * lambda);
      // Point end : poussé dans direction +n
      const dPosEnd = n.clone().multiplyScalar(invMass * lambda);

      // Correction nette de position (moyenne)
      const dPos = dPosStart.clone().add(dPosEnd).multiplyScalar(0.5);
      predictedPosition.add(dPos);

      // Correction de rotation (moyenne des deux contributions)
      const dThetaStart = alphaStart.clone().multiplyScalar(-invInertia * lambda);
      const dThetaEnd = alphaEnd.clone().multiplyScalar(-invInertia * lambda);
      const dTheta = dThetaStart.clone().add(dThetaEnd).multiplyScalar(0.5);

      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse (dampening)
      kite.position.copy(predictedPosition);
      const startWorld2 = kite.localToWorld(startLocal);
      const endWorld2 = kite.localToWorld(endLocal);
      kite.position.copy(originalPos);

      const n2 = endWorld2.clone().sub(startWorld2).normalize();
      const rStart2 = startWorld2.clone().sub(predictedPosition);
      const rEnd2 = endWorld2.clone().sub(predictedPosition);

      // Vitesses des points
      const velStart = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rStart2));
      const velEnd = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rEnd2));

      // Vitesse relative le long de la bride
      const relVel = velEnd.clone().sub(velStart);
      const radialSpeed = relVel.dot(n2);

      // Si les points s'éloignent, appliquer correction de vitesse
      if (radialSpeed > 0) {
        const rxnStart = new THREE.Vector3().crossVectors(rStart2, n2);
        const rxnEnd = new THREE.Vector3().crossVectors(rEnd2, n2.clone().negate());
        const eff =
          2 * invMass + rxnStart.lengthSq() * invInertia + rxnEnd.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        // Correction vitesse linéaire
        state.velocity.add(n2.clone().multiplyScalar(J * invMass));

        // Correction vitesse angulaire (moyenne des deux contributions)
        const angImpulseStart = new THREE.Vector3().crossVectors(
          rStart2,
          n2.clone().multiplyScalar(J)
        );
        const angImpulseEnd = new THREE.Vector3().crossVectors(
          rEnd2,
          n2.clone().multiplyScalar(-J)
        );
        const angImpulse = angImpulseStart.clone().add(angImpulseEnd).multiplyScalar(0.5);
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Résoudre toutes les brides (1 passe suffit généralement)
    // Les brides sont courtes et rigides, convergence rapide
    bridles.forEach(({ start, end, length }) => {
      solveBridle(start, end, length);
    });
  }

  /**
   * Gère la collision avec le sol
   */
  static handleGroundCollision(
    kite: Kite,
    newPosition: THREE.Vector3,
    velocity: THREE.Vector3
  ): void {
    const groundY = CONFIG.kite.minHeight;
    const pointsMap = kite.getPointsMap?.() as
      | Map<string, [number, number, number]>
      | undefined;

    if (pointsMap && pointsMap.size > 0) {
      let minY = Infinity;
      const q = kite.quaternion;

      pointsMap.forEach(([px, py, pz]) => {
        const world = new THREE.Vector3(px, py, pz)
          .applyQuaternion(q)
          .add(newPosition);
        if (world.y < minY) minY = world.y;
      });

      if (minY < groundY) {
        const lift = groundY - minY;
        newPosition.y += lift;

        if (velocity.y < 0) velocity.y = 0;
        velocity.x *= PhysicsConstants.GROUND_FRICTION;
        velocity.z *= PhysicsConstants.GROUND_FRICTION;
      }
      return;
    }

    // Fallback simple
    if (newPosition.y < groundY) {
      newPosition.y = groundY;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x *= PhysicsConstants.GROUND_FRICTION;
      velocity.z *= PhysicsConstants.GROUND_FRICTION;
    }
  }
}

=== simulation/physics/LinePhysics.ts ===

/**
 * LinePhysics.ts - Service de calculs physiques pour les lignes de cerf-volant
 *
 * Rôle :
 *   - Calculer les forces de tension dans une ligne (modèle Dyneema réaliste)
 *   - Appliquer pré-tension, élasticité linéaire et damping
 *   - Calculer l'affaissement caténaire pour le rendu
 *
 * Responsabilité :
 *   - Physique pure : F = F₀ + k×Δx - c×v_radial
 *   - Pas de gestion d'état (stateless)
 *   - Pas de dépendance Three.js (calculs vectoriels purs)
 *
 * Modèle Physique :
 *   - Lignes haute performance (Dyneema/Spectra)
 *   - Élasticité ~2-3%, rigidité EA/L ≈ 2200 N/m pour 15m
 *   - Toujours pré-tendues (50-100N minimum)
 *   - Damping interne (dissipation d'énergie)
 *
 * Relation avec les autres modules :
 *   - Opère sur des objets Line
 *   - Appelé par LineSystem pour calculer forces
 *   - Pas de dépendance sur la scène 3D
 *
 * Philosophie :
 *   - Pure function : Entrées → Sorties, pas d'effet de bord
 *   - Testable unitairement (pas de mock Three.js requis)
 *   - Single Responsibility : Calculs physiques uniquement
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts (entité métier)
 *   - docs/LINE_PHYSICS_AUDIT_2025-10-01.md (références physiques)
 */

import { Vector3 } from 'three';
import { Line } from '@objects/mechanical/Line';
import { PhysicsConstants } from '../config/PhysicsConstants';

/**
 * Résultat d'un calcul de force de tension
 */
export interface TensionResult {
  /** Force vectorielle à appliquer (N) */
  force: Vector3;

  /** Magnitude de la tension (N) */
  tension: number;

  /** Extension actuelle (m) */
  extension: number;

  /** Longueur actuelle (m) */
  currentLength: number;

  /** Ligne tendue ou molle */
  isTaut: boolean;
}

/**
 * Service de calculs physiques pour lignes de cerf-volant
 *
 * @example
 * ```typescript
 * const physics = new LinePhysics();
 * const result = physics.calculateTensionForce(
 *   line,
 *   new Vector3(0, 10, 0),  // Position kite
 *   new Vector3(0, 0, 0),   // Position poignée
 *   new Vector3(0, -1, 0)   // Vitesse relative
 * );
 * console.log(`Tension: ${result.tension}N`);
 * ```
 */
export class LinePhysics {
  /** Constante gravitationnelle (m/s²) */
  private static readonly GRAVITY = 9.81;

  /** Epsilon fin pour calculs de précision (réutilise PhysicsConstants) */
  private static readonly EPSILON = PhysicsConstants.EPSILON_FINE;

  /**
   * Calcule la force de tension dans une ligne
   *
   * Modèle : F = F₀ + k×Δx - c×v_radial
   * - F₀ : Pré-tension minimale (toujours présente)
   * - k×Δx : Composante élastique (si ligne tendue)
   * - c×v_radial : Damping (dissipation d'énergie)
   *
   * @param line - Ligne à analyser
   * @param startPos - Position point d'attache départ (kite ou barre)
   * @param endPos - Position point d'attache arrivée (barre ou kite)
   * @param relativeVelocity - Vitesse relative entre les deux points (pour damping)
   * @returns Résultat du calcul (force, tension, extension)
   */
  calculateTensionForce(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    relativeVelocity: Vector3 = new Vector3()
  ): TensionResult {
    // Vecteur ligne et direction
    const lineVector = new Vector3().subVectors(endPos, startPos);
    const currentLength = lineVector.length();

    // Éviter division par zéro
    if (currentLength < LinePhysics.EPSILON) {
      return {
        force: new Vector3(),
        tension: 0,
        extension: 0,
        currentLength: 0,
        isTaut: false
      };
    }

    const lineDir = lineVector.clone().normalize();
    const restLength = line.config.length;

    // 1. Composante élastique : F_elastic = F₀ + k×Δx
    let elasticTension: number;
    let extension: number;
    let isTaut: boolean;

    if (currentLength > restLength) {
      // Ligne tendue : ajouter force élastique à la pré-tension
      extension = currentLength - restLength;
      elasticTension = line.config.preTension + line.config.stiffness * extension;
      isTaut = true;
    } else {
      // Ligne molle : maintenir pré-tension minimale
      extension = 0;
      elasticTension = line.config.preTension;
      isTaut = false;
    }

    // 2. Composante de damping : F_damp = -c × v_along_line
    const velocityAlongLine = relativeVelocity.dot(lineDir);
    const dampingTension = -line.config.dampingCoeff * velocityAlongLine;

    // 3. Tension totale (limitée par maxTension)
    const totalTension = Math.min(
      Math.max(elasticTension + dampingTension, 0), // Jamais négative
      line.config.maxTension
    );

    // 4. Force vectorielle
    const force = lineDir.clone().multiplyScalar(totalTension);

    return {
      force,
      tension: totalTension,
      extension,
      currentLength,
      isTaut
    };
  }

  /**
   * Calcule l'affaissement caténaire réel pour une ligne horizontale
   *
   * Formule simplifiée : sag = (ρ × g × L²) / (8 × T)
   * où :
   * - ρ : masse linéique (kg/m)
   * - g : gravité (9.81 m/s²)
   * - L : longueur ligne (m)
   * - T : tension (N)
   *
   * @param line - Ligne à analyser
   * @param tension - Tension actuelle (N)
   * @returns Affaissement vertical au centre (m)
   *
   * @example
   * ```typescript
   * const sag = physics.calculateCatenarySag(line, 100);
   * console.log(`Sag: ${sag * 1000}mm`); // ~1.4mm pour Dyneema 15m @ 100N
   * ```
   */
  calculateCatenarySag(line: Line, tension: number): number {
    if (tension < LinePhysics.EPSILON) {
      return 0; // Pas de tension = pas d'affaissement défini
    }

    const rho = line.config.linearMassDensity;
    const L = line.config.length;

    // Formule caténaire simplifiée (ligne horizontale)
    const sag = (rho * LinePhysics.GRAVITY * L * L) / (8 * tension);

    return Math.max(0, sag); // Toujours positif
  }

  /**
   * Calcule les points d'une vraie caténaire pour le rendu
   *
   * Équation complète : y(x) = a × cosh(x/a) - a
   * où a = T / (ρ × g)
   *
   * @param line - Ligne à analyser
   * @param startPos - Position départ
   * @param endPos - Position arrivée
   * @param tension - Tension actuelle (N)
   * @param segments - Nombre de segments pour la courbe
   * @returns Tableau de points 3D formant la caténaire
   *
   * @remarks
   * Pour lignes très tendues (T > 100N), la caténaire est quasi-linéaire
   * Pour lignes molles (T < 50N), l'affaissement devient visible
   */
  calculateCatenaryPoints(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    tension: number,
    segments: number = 10
  ): Vector3[] {
    const directDistance = startPos.distanceTo(endPos);

    // Si ligne tendue ou très courte, approximation linéaire suffit
    if (directDistance >= line.config.length * 0.98 || tension > 100) {
      return [startPos.clone(), endPos.clone()];
    }

    // Paramètre de la caténaire : a = T / (ρ × g)
    const rho = line.config.linearMassDensity;
    const a = tension / (rho * LinePhysics.GRAVITY);

    // Calcul sag maximal
    const sag = this.calculateCatenarySag(line, tension);

    const points: Vector3[] = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Position linéaire interpolée
      const point = new Vector3().lerpVectors(startPos, endPos, t);

      // Ajout de l'affaissement en Y (forme parabolique simplifiée)
      // Pour un vrai cosh, il faudrait transformer en coordonnées locales
      point.y -= sag * 4 * t * (1 - t); // Maximum au centre (t=0.5)

      points.push(point);
    }

    return points;
  }

  /**
   * Calcule l'énergie élastique stockée dans une ligne
   *
   * E = ½ × k × Δx²
   *
   * @param line - Ligne à analyser
   * @returns Énergie en Joules
   */
  calculateElasticEnergy(line: Line): number {
    const extension = line.getExtension();
    return 0.5 * line.config.stiffness * extension * extension;
  }

  /**
   * Estime la fréquence propre d'oscillation de la ligne
   *
   * f ≈ (1/2π) × √(k/m_effective)
   *
   * @param line - Ligne à analyser
   * @param attachedMass - Masse attachée au bout (kg)
   * @returns Fréquence en Hz
   */
  calculateNaturalFrequency(line: Line, attachedMass: number): number {
    if (attachedMass < LinePhysics.EPSILON) {
      return 0;
    }

    // Masse effective de la ligne (1/3 de la masse totale)
    const lineMass = line.config.linearMassDensity * line.config.length;
    const effectiveMass = attachedMass + lineMass / 3;

    const omega = Math.sqrt(line.config.stiffness / effectiveMass);
    const frequency = omega / (2 * Math.PI);

    return frequency;
  }

  /**
   * Vérifie si la ligne est dans un état physique valide
   *
   * @param line - Ligne à valider
   * @returns true si valide, false sinon
   */
  validateLine(line: Line): boolean {
    const config = line.config;

    return (
      config.length > 0 &&
      config.stiffness > 0 &&
      config.preTension >= 0 &&
      config.maxTension > config.preTension &&
      config.dampingCoeff >= 0 &&
      config.dampingCoeff <= 1 &&
      config.linearMassDensity > 0
    );
  }
}


=== simulation/physics/LineSystem.ts ===

/**
 * LineSystem.ts - Orchestrateur du système de lignes du cerf-volant
 *
 * Rôle :
 *   - Coordonne les lignes gauche/droite du système de pilotage
 *   - Calcule les tensions pour affichage/debug (pas de forces appliquées)
 *   - Les contraintes de distance sont gérées par ConstraintSolver
 *
 * IMPORTANT : Les lignes sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT le kite (distance max)
 *   - Elles ne TIRENT PAS le kite vers le pilote
 *   - Le ConstraintSolver.enforceLineConstraints() gère la contrainte géométrique
 */
import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { LineFactory } from "@factories/LineFactory";

import { ControlBarManager } from "../controllers/ControlBarManager";
import { PhysicsConstants } from "../config/PhysicsConstants";

import { LinePhysics } from "./LinePhysics";
import { VelocityCalculator } from "./VelocityCalculator";

export class LineSystem {
  private leftLine: Line;
  private rightLine: Line;
  private physics: LinePhysics;
  private velocityCalculator: VelocityCalculator;

  constructor(lineLength?: number) {
    const [left, right] = LineFactory.createLinePair(lineLength);
    this.leftLine = left;
    this.rightLine = right;
    this.physics = new LinePhysics();
    this.velocityCalculator = new VelocityCalculator();
  }

  calculateLineTensions(
    kite: Kite,
    controlRotation: number,
    pilotPosition: THREE.Vector3
  ): {
    leftForce: THREE.Vector3;
    rightForce: THREE.Vector3;
    torque: THREE.Vector3;
  } {
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) {
      return {
        leftForce: new THREE.Vector3(),
        rightForce: new THREE.Vector3(),
        torque: new THREE.Vector3(),
      };
    }

    const leftWorld = kite.localToWorld(ctrlLeft);
    const rightWorld = kite.localToWorld(ctrlRight);

    const tempControlBar = new ControlBarManager(pilotPosition);
    tempControlBar.setRotation(controlRotation);
    const handles = tempControlBar.getHandlePositions(kite.position);

    // Calculer vélocités relatives avec VelocityCalculator
    const leftVelocity = this.velocityCalculator.calculateRelative(
      "leftKite", "leftBar",
      leftWorld, handles.left,
      1 / 60
    );
    const rightVelocity = this.velocityCalculator.calculateRelative(
      "rightKite", "rightBar",
      rightWorld, handles.right,
      1 / 60
    );

    // Calculer tensions pour info/debug uniquement (pas de force appliquée)
    const leftResult = this.physics.calculateTensionForce(this.leftLine, leftWorld, handles.left, leftVelocity);
    const rightResult = this.physics.calculateTensionForce(this.rightLine, rightWorld, handles.right, rightVelocity);

    // Mettre à jour l'état des lignes (pour affichage)
    this.leftLine.updateState(leftResult.currentLength, leftResult.tension, performance.now());
    this.rightLine.updateState(rightResult.currentLength, rightResult.tension, performance.now());

    // ⚠️ IMPORTANT : PAS DE FORCES NI DE COUPLE APPLIQUÉS
    // Les lignes sont des contraintes géométriques (ConstraintSolver)
    // Le kite est retenu à distance max, pas tiré vers le pilote
    return {
      leftForce: new THREE.Vector3(), // Force nulle
      rightForce: new THREE.Vector3(), // Force nulle
      torque: new THREE.Vector3(), // Couple nul
    };
  }

  calculateCatenary(start: THREE.Vector3, end: THREE.Vector3, segments: number = PhysicsConstants.CATENARY_SEGMENTS): THREE.Vector3[] {
    const tension = this.leftLine.getCurrentTension();
    return this.physics.calculateCatenaryPoints(this.leftLine, start, end, tension, segments);
  }

  setLineLength(length: number): void {
    const [left, right] = LineFactory.createLinePair(length);
    this.leftLine = left;
    this.rightLine = right;
    // Réinitialiser l'historique des vélocités
    this.velocityCalculator.resetAll();
  }

  get lineLength(): number {
    return this.leftLine.config.length;
  }

  set lineLength(length: number) {
    this.setLineLength(length);
  }

  /**
   * Retourne les tensions actuelles des lignes gauche et droite
   * @returns Objet contenant les tensions en Newtons
   */
  getTensions(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentTension(),
      right: this.rightLine.getCurrentTension()
    };
  }
}


=== simulation/physics/PhysicsEngine.ts ===

/**
 * PhysicsEngine.ts - Moteur physique principal de la simulation Kite
 *
 * Rôle :
 *   - Orchestration de tou    // C      gravity,  // Gravité distribuée par surfacelcul des forces aérodynamiques et gravitationnelles distribuées calculs physiques du cerf-volant (vent, lignes, forces, contrôles)
 *   - Point d'entrée pour la boucle de simulation physique (appelé à chaque frame)
 *   - Centralise l'accès aux sous-modules physiques
 *
 * Dépendances principales :
 *   - WindSimulator.ts : Simulation du vent et turbulences
 *   - LineSystem.ts : Calcul des tensions et contraintes des lignes
 *   - AerodynamicsCalculator.ts : Calcul des forces aérodynamiques
 *   - KiteController.ts : Gestion de l'état physique du cerf-volant
 *   - ControlBarManager.ts : Gestion de la barre de contrôle du pilote
 *   - SimulationConfig.ts : Paramètres globaux de la simulation
 *   - Kite.ts : Modèle 3D et points anatomiques du cerf-volant
 *
 * Relation avec les fichiers adjacents :
 *   - Tous les fichiers du dossier 'physics' sont des sous-modules utilisés par PhysicsEngine
 *   - Les modules 'controllers' et 'objects' sont utilisés pour manipuler le kite et la barre
 *
 * Utilisation typique :
 *   - Instancié au démarrage, appelé à chaque frame pour mettre à jour la physique
 *   - Sert d'API centrale pour accéder à l'état physique du kite
 *
 * Voir aussi :
 *   - src/simulation/physics/WindSimulator.ts
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteController } from "../controllers/KiteController";
import { ControlBarManager } from "../controllers/ControlBarManager";
import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

import { WindSimulator } from "./WindSimulator";
import { LineSystem } from "./LineSystem";
import { BridleSystem } from "./BridleSystem";
import { AerodynamicsCalculator } from "./AerodynamicsCalculator";

/**
 * Moteur physique principal
 *
 * Orchestre toutes les simulations physiques du cerf-volant
 */
export class PhysicsEngine {
  private windSimulator: WindSimulator;
  private lineSystem: LineSystem;
  private bridleSystem: BridleSystem;
  private kiteController: KiteController;
  private controlBarManager: ControlBarManager;
  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = 1000; // Log toutes les 1000ms (1 seconde)
  private startTime: number = Date.now(); // Temps de démarrage pour elapsed time
  private frameCount: number = 0; // Compteur de frames

  constructor(kite: Kite, controlBarPosition: THREE.Vector3) {
    this.windSimulator = new WindSimulator();
    this.lineSystem = new LineSystem();
    this.bridleSystem = new BridleSystem(kite.getBridleLengths());
    this.kiteController = new KiteController(kite);
    this.controlBarManager = new ControlBarManager(controlBarPosition);
  }

  /**
   * LE CŒUR DE LA SIMULATION - Appelée 60 fois par seconde
   *
   * C'est ici que tout se passe ! Cette fonction orchestre toute la physique.
   *
   * VOICI CE QUI SE PASSE À CHAQUE INSTANT :
   * 1. On regarde comment la barre est tournée
   * 2. On calcule où sont les mains du pilote
   * 3. On calcule le vent que ressent le kite
   * 4. On calcule toutes les forces :
   *    - Le vent qui pousse
   *    - Les lignes qui tirent
   *    - La gravité qui attire vers le bas
   * 5. On fait bouger le kite selon ces forces
   *
   * C'est comme une boucle infinie qui simule la réalité !
   */
  update(
    deltaTime: number,
    targetBarRotation: number,
    isPaused: boolean = false
  ): void {
    // Si en pause, ne rien faire
    if (isPaused) return;

    // Limiter le pas de temps pour éviter l'instabilité numérique
    deltaTime = Math.min(deltaTime, CONFIG.physics.deltaTimeMax);

    // Appliquer directement la rotation de la barre (pas de lissage, déjà géré par InputHandler)
    this.controlBarManager.setRotation(targetBarRotation);

    // Récupérer l'état actuel du système
    const kite = this.kiteController.getKite();
    const handles = this.controlBarManager.getHandlePositions(kite.position);

    // Vent apparent = vent réel - vitesse du kite (principe de relativité)
    const kiteState = this.kiteController.getState();

    // 🔍 DEBUG: Vérifier la vitesse du kite pour comprendre le vent apparent faible - DISABLED for performance


    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );


    // � PHYSIQUE ÉMERGENTE : Forces aéro + gravité distribuée calculées par surface
    // - Chaque surface porte une fraction de la masse (fabric + frame + accessoires)
    // - Gravité appliquée au centre géométrique de chaque surface
    // - Le couple gravitationnel émerge naturellement de r × F_gravity
    // - Le couple total émerge de la différence gauche/droite naturelle
    const {
      lift,
      drag,
      gravity,  // � RESTAURÉ : Gravité distribuée (plus réaliste physiquement)
      torque: totalTorque,  // Inclut déjà couple aéro + couple gravitationnel !
    } = AerodynamicsCalculator.calculateForces(
      apparentWind, 
      kite.quaternion,
      kite.position,
      kiteState.velocity,
      kiteState.angularVelocity
    );

    // CALCUL DES TENSIONS (pour affichage/debug uniquement)
    // Les lignes ne TIRENT PAS le kite - elles le RETIENNENT à distance max
    // La contrainte géométrique est appliquée par ConstraintSolver dans KiteController
    const pilotPosition = this.controlBarManager.getPosition();
    this.lineSystem.calculateLineTensions(kite, this.controlBarManager.getRotation(), pilotPosition);

    // CALCUL DES TENSIONS DES BRIDES (pour affichage/debug uniquement)
    // Les brides sont des contraintes INTERNES au kite
    // Les contraintes géométriques sont appliquées par ConstraintSolver.enforceBridleConstraints()
    const bridleTensions = this.bridleSystem.calculateBridleTensions(kite);

    // Incrémenter le compteur de frames
    this.frameCount++;

    // 📊 LOG COMPLET toutes les secondes
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;
      this.logPhysicsState(kite, kiteState, apparentWind, lift, drag, gravity, totalTorque, bridleTensions, deltaTime, currentTime);
    }

    // Mettre à jour la visualisation des brides selon leurs tensions
    kite.updateBridleVisualization(bridleTensions);

    // Somme vectorielle des forces (2ème loi de Newton : F = ma)
    const totalForce = new THREE.Vector3()
      .add(lift)     // Portance aérodynamique (perpendiculaire au vent)
      .add(drag)     // Traînée aérodynamique (parallèle au vent)
      .add(gravity); // Gravité distribuée (déjà calculée par surface)
      // PAS de forces de lignes - elles sont des contraintes géométriques

    // Couple total = moment aérodynamique + moment gravitationnel (émergent)
    // Les lignes n'appliquent PAS de couple - elles contraignent la position
    // L'orientation émerge de l'équilibre des forces distribuées + contraintes

    // Intégration physique : F=ma et T=Iα pour calculer nouvelle position/orientation
    this.kiteController.update(totalForce, totalTorque, handles, deltaTime);
  }

  setBridleFactor(_factor: number): void {
    // Fonctionnalité désactivée dans V8 - physique émergente pure
  }

  /**
   * Ajuste une longueur de bride physique (en mètres)
   * @param bridleName - 'nez', 'inter' ou 'centre'
   * @param length - longueur en mètres
   */
  setBridleLength(bridleName: 'nez' | 'inter' | 'centre', length: number): void {
    this.kiteController.getKite().setBridleLengths({ [bridleName]: length });
  }

  setWindParams(params: Partial<WindParams>): void {
    this.windSimulator.setParams(params);
  }

  setLineLength(length: number): void {
    this.lineSystem.setLineLength(length);
    this.kiteController.setLineLength(length);
  }

  getKiteController(): KiteController {
    return this.kiteController;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getControlBarManager(): ControlBarManager {
    return this.controlBarManager;
  }

  /**
   * Retourne les longueurs actuelles des brides du kite
   */
  getBridleLengths() {
    return this.kiteController.getKite().getBridleLengths();
  }

  /**
   * Définit le taux de lissage des forces (en 1/s)
   */
  setForceSmoothing(rate: number): void {
    this.kiteController.setForceSmoothing(rate);
  }

  /**
   * Retourne le taux de lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController.getForceSmoothing();
  }

  /**
   * Affiche l'état physique complet du kite (appelé toutes les secondes)
   */
  private logPhysicsState(
    kite: Kite,
    kiteState: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    apparentWind: THREE.Vector3,
    lift: THREE.Vector3,
    drag: THREE.Vector3,
    gravity: THREE.Vector3,
    totalTorque: THREE.Vector3,
    bridleTensions: { leftNez: number; rightNez: number; leftInter: number; rightInter: number; leftCentre: number; rightCentre: number },
    deltaTime: number,
    currentTime: number
  ): void {
    // Calculs supplémentaires pour le log
    const elapsedTime = (currentTime - this.startTime) / 1000; // en secondes
    const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
    const pitch = euler.x * (180 / Math.PI); // Convertir en degrés
    const roll = euler.z * (180 / Math.PI);
    const yaw = euler.y * (180 / Math.PI);

    // Tensions des lignes
    const lineTensions = this.lineSystem.getTensions();

    // Accélération (approximation : F/m)
    const totalForceCalc = new THREE.Vector3().add(lift).add(drag).add(gravity);
    const acceleration = totalForceCalc.clone().divideScalar(CONFIG.kite.mass);

    // Ratio portance/traînée
    const liftMag = lift.length();
    const dragMag = drag.length();
    const ldRatio = dragMag > 0.01 ? liftMag / dragMag : 0;

    console.log('\n╔═══════════════════════════════════════════════════════════════════════════╗');
    console.log(`║ 📊 ÉTAT COMPLET DU KITE - Frame #${this.frameCount.toString().padStart(6, '0')}                              ║`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ ⏱️  Temps: ${elapsedTime.toFixed(3)}s | Δt: ${(deltaTime * 1000).toFixed(2)}ms | FPS: ${(1/deltaTime).toFixed(1)}    ║`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ 📍 POSITION & ORIENTATION                                                 ║`);
    console.log(`║    Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m`);
    console.log(`║    Distance pilote: ${kite.position.length().toFixed(2)} m`);
    console.log(`║    Angles: Pitch ${pitch.toFixed(1)}° | Roll ${roll.toFixed(1)}° | Yaw ${yaw.toFixed(1)}°`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ 🚀 CINÉMATIQUE                                                            ║`);
    console.log(`║    Vitesse: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s`);
    console.log(`║    Accélération: (${acceleration.x.toFixed(2)}, ${acceleration.y.toFixed(2)}, ${acceleration.z.toFixed(2)}) m/s² | Mag: ${acceleration.length().toFixed(2)} m/s²`);
    console.log(`║    Vit. angulaire: (${kiteState.angularVelocity.x.toFixed(2)}, ${kiteState.angularVelocity.y.toFixed(2)}, ${kiteState.angularVelocity.z.toFixed(2)}) rad/s | Mag: ${kiteState.angularVelocity.length().toFixed(2)} rad/s`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ 💨 AÉRODYNAMIQUE                                                          ║`);
    console.log(`║    Vent apparent: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s`);
    console.log(`║    Portance: (${lift.x.toFixed(2)}, ${lift.y.toFixed(2)}, ${lift.z.toFixed(2)}) N | Mag: ${liftMag.toFixed(2)} N`);
    console.log(`║    Traînée: (${drag.x.toFixed(2)}, ${drag.y.toFixed(2)}, ${drag.z.toFixed(2)}) N | Mag: ${dragMag.toFixed(2)} N`);
    console.log(`║    Ratio L/D: ${ldRatio.toFixed(2)}`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ ⚖️  FORCES & COUPLES                                                       ║`);
    console.log(`║    Gravité: (${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}, ${gravity.z.toFixed(2)}) N | Mag: ${gravity.length().toFixed(2)} N`);
    console.log(`║    Force totale: (${totalForceCalc.x.toFixed(2)}, ${totalForceCalc.y.toFixed(2)}, ${totalForceCalc.z.toFixed(2)}) N | Mag: ${totalForceCalc.length().toFixed(2)} N`);
    console.log(`║    Couple total: (${totalTorque.x.toFixed(2)}, ${totalTorque.y.toFixed(2)}, ${totalTorque.z.toFixed(2)}) N⋅m | Mag: ${totalTorque.length().toFixed(2)} N⋅m`);
    console.log('╠═══════════════════════════════════════════════════════════════════════════╣');
    console.log(`║ 🪢 TENSIONS                                                                ║`);
    console.log(`║    Ligne gauche: ${lineTensions.left.toFixed(2)} N | Ligne droite: ${lineTensions.right.toFixed(2)} N`);
    console.log(`║    Asymétrie: ${(lineTensions.left - lineTensions.right).toFixed(2)} N (${((lineTensions.left - lineTensions.right) / Math.max(lineTensions.left, lineTensions.right) * 100).toFixed(1)}%)`);
    console.log(`║    Brides: NEZ L/R: ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)} N`);
    console.log(`║            INTER L/R: ${bridleTensions.leftInter.toFixed(1)}/${bridleTensions.rightInter.toFixed(1)} N`);
    console.log(`║            CENTRE L/R: ${bridleTensions.leftCentre.toFixed(1)}/${bridleTensions.rightCentre.toFixed(1)} N`);
    console.log('╚═══════════════════════════════════════════════════════════════════════════╝\n');
  }
}

=== simulation/physics/VelocityCalculator.ts ===

/**
 * VelocityCalculator.ts - Service de calcul de vélocité relative
 *
 * Rôle :
 *   - Calcule la vélocité relative entre deux points à partir de leur historique de positions
 *   - Stocke les positions précédentes pour permettre la dérivation temporelle
 *   - Service réutilisable par LineSystem et BridleSystem
 *
 * Principe :
 *   v = Δpos / Δt
 *   où Δpos = position_actuelle - position_précédente
 *
 * Responsabilité :
 *   - Gestion de l'historique des positions (Map clé → position)
 *   - Calcul de vélocité par différence finie
 *   - Service stateless réutilisable
 *
 * Relation avec les autres modules :
 *   - Utilisé par LineSystem pour calculer vélocité relative lignes
 *   - Utilisé par BridleSystem pour calculer vélocité relative brides
 *
 * Philosophie :
 *   - DRY (Don't Repeat Yourself) : élimine duplication LineSystem/BridleSystem
 *   - Single Responsibility : calcul vélocité uniquement
 *   - Testable unitairement
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/BridleSystem.ts
 */

import * as THREE from "three";

/**
 * Service de calcul de vélocité relative par différence finie
 *
 * Maintient un historique des positions précédentes pour calculer
 * la dérivée temporelle (vélocité) par différence finie d'ordre 1.
 *
 * @example
 * ```typescript
 * const velCalc = new VelocityCalculator();
 *
 * // Frame 1
 * const vel1 = velCalc.calculate("kite", pos1, deltaTime);
 * // vel1 = (0, 0, 0) car pas d'historique
 *
 * // Frame 2
 * const vel2 = velCalc.calculate("kite", pos2, deltaTime);
 * // vel2 = (pos2 - pos1) / deltaTime
 * ```
 */
export class VelocityCalculator {
  /**
   * Historique des positions précédentes
   * Clé : identifiant unique (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * Valeur : dernière position connue
   */
  private previousPositions: Map<string, THREE.Vector3> = new Map();

  /**
   * Calcule la vélocité relative d'un point entre deux frames
   *
   * Utilise la différence finie d'ordre 1 :
   * v = (pos_actuelle - pos_précédente) / Δt
   *
   * Au premier appel pour une clé, retourne (0, 0, 0) car pas d'historique.
   *
   * @param key - Identifiant unique du point (ex: "leftKite", "NEZ_CTRL_GAUCHE")
   * @param currentPos - Position actuelle du point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vecteur vélocité en m/s
   *
   * @example
   * ```typescript
   * const vel = calculator.calculate(
   *   "line_left_kite",
   *   new THREE.Vector3(0, 10, 0),
   *   1/60 // 60 FPS
   * );
   * ```
   */
  calculate(
    key: string,
    currentPos: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Récupérer position précédente
    const prevPos = this.previousPositions.get(key);

    // Si pas d'historique ou deltaTime invalide, retourner vélocité nulle
    if (!prevPos || deltaTime <= 0) {
      // Mémoriser position actuelle pour prochain frame
      this.previousPositions.set(key, currentPos.clone());
      return new THREE.Vector3();
    }

    // Calculer vélocité par différence finie
    const velocity = currentPos.clone().sub(prevPos).divideScalar(deltaTime);

    // Mémoriser position actuelle pour prochain frame
    this.previousPositions.set(key, currentPos.clone());

    return velocity;
  }

  /**
   * Calcule la vélocité relative entre deux points (utilisé par LineSystem)
   *
   * Cette version calcule la différence de vélocité entre deux points,
   * utile pour calculer la vitesse relative d'une ligne qui relie deux objets.
   *
   * v_relative = v_point1 - v_point2
   *
   * @param keyPoint1 - Identifiant unique du premier point
   * @param keyPoint2 - Identifiant unique du second point
   * @param currentPos1 - Position actuelle du premier point
   * @param currentPos2 - Position actuelle du second point
   * @param deltaTime - Pas de temps entre les frames (en secondes)
   * @returns Vélocité relative entre les deux points
   *
   * @example
   * ```typescript
   * const velRelative = calculator.calculateRelative(
   *   "kite", "bar",
   *   kitePos, barPos,
   *   1/60
   * );
   * ```
   */
  calculateRelative(
    keyPoint1: string,
    keyPoint2: string,
    currentPos1: THREE.Vector3,
    currentPos2: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    const vel1 = this.calculate(keyPoint1, currentPos1, deltaTime);
    const vel2 = this.calculate(keyPoint2, currentPos2, deltaTime);

    // Vélocité relative = différence des vélocités
    return new THREE.Vector3().subVectors(vel1, vel2);
  }

  /**
   * Réinitialise l'historique pour une clé donnée
   *
   * Utile quand on change drastiquement la position d'un objet
   * (ex: reset de simulation)
   *
   * @param key - Identifiant du point à réinitialiser
   */
  reset(key: string): void {
    this.previousPositions.delete(key);
  }

  /**
   * Réinitialise tout l'historique
   *
   * Utile pour reset complet de la simulation
   */
  resetAll(): void {
    this.previousPositions.clear();
  }

  /**
   * Retourne le nombre de points suivis
   *
   * Utile pour debug/monitoring
   */
  getTrackedCount(): number {
    return this.previousPositions.size;
  }
}


=== simulation/physics/WindSimulator.ts ===

/**
 * WindSimulator.ts - Simulateur de vent et turbulences pour la simulation Kite
 *
 * Rôle :
 *   - Génère le vent et ses variations (direction, vitesse, turbulence)
 *   - Fournit le vent apparent ressenti par le cerf-volant
 *   - Sert de source d'environnement pour la physique et le rendu
 *
 * Dépendances principales :
 *   - SimulationConfig.ts : Paramètres de vent et turbulence
 *   - Types/WindTypes.ts : Typage des paramètres de vent
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsEngine.ts : Utilise WindSimulator pour obtenir le vent à chaque frame
 *   - Les autres modules du dossier 'physics' utilisent le vent pour calculer les forces
 *
 * Utilisation typique :
 *   - Instancié par PhysicsEngine, appelé pour obtenir le vent local ou global
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Simulateur de vent et turbulences
 *
 * Gère le vent et ses variations pour créer des conditions réalistes
 */
export class WindSimulator {
  private params: WindParams;
  private time: number = 0; // Compteur de temps pour faire varier les turbulences
  private windSpeedMs: number = 0;
  private windRad: number = 0;

  constructor() {
    // On démarre avec les réglages par défaut du vent
    this.params = {
      speed: CONFIG.wind.defaultSpeed,
      direction: CONFIG.wind.defaultDirection,
      turbulence: CONFIG.wind.defaultTurbulence,
    };
    this.updateWindInternals();
  }

  private updateWindInternals(): void {
    this.windSpeedMs = this.params.speed / 3.6;
    this.windRad = (this.params.direction * Math.PI) / 180;
  }

  /**
   * Calcule les turbulences du vent
   * Méthode extraite pour éviter la duplication de code
   */
  private calculateTurbulence(baseWindVector: THREE.Vector3): THREE.Vector3 {
    if (this.params.turbulence <= 0) {
      return baseWindVector.clone();
    }

    const turbIntensity =
      (this.params.turbulence / 100) * CONFIG.wind.turbulenceScale;
    const freq = CONFIG.wind.turbulenceFreqBase;

    const turbulenceVector = baseWindVector.clone();

    // Utiliser des sinus pour créer des variations douces et naturelles
    turbulenceVector.x +=
      Math.sin(this.time * freq) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;
    turbulenceVector.y +=
      Math.sin(this.time * freq * CONFIG.wind.turbulenceFreqY) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityY;
    turbulenceVector.z +=
      Math.cos(this.time * freq * CONFIG.wind.turbulenceFreqZ) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;

    return turbulenceVector;
  }

  /**
   * Calcule le vent que "ressent" le cerf-volant
   * C'est comme quand vous mettez la main par la fenêtre d'une voiture :
   * - Si la voiture roule vite, vous sentez plus de vent
   * - Si vous allez contre le vent, il est plus fort
   * - Si vous allez avec le vent, il est plus faible
   */
  getApparentWind(
    kiteVelocity: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    this.time += deltaTime;

    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    const windVector = this.calculateTurbulence(baseWindVector);

    // Le vent apparent = vent réel - vitesse du kite
    // Si le kite va vite vers l'avant, il "crée" du vent de face
    const apparent = windVector.clone().sub(kiteVelocity);

    // 🔍 DEBUG: Vérifier le calcul du vent apparent - DISABLED for performance
    // console.log(`🔍 WIND CALC: Real wind (${windVector.x.toFixed(2)}, ${windVector.y.toFixed(2)}, ${windVector.z.toFixed(2)}) = ${windVector.length().toFixed(2)} m/s | Kite vel (${kiteVelocity.x.toFixed(2)}, ${kiteVelocity.y.toFixed(2)}, ${kiteVelocity.z.toFixed(2)}) = ${kiteVelocity.length().toFixed(2)} m/s | Apparent (${apparent.x.toFixed(2)}, ${apparent.y.toFixed(2)}, ${apparent.z.toFixed(2)}) = ${apparent.length().toFixed(2)} m/s`);

    return apparent;
  }

  /**
   * Obtient le vecteur de vent à une position donnée
   */
  getWindAt(_position: THREE.Vector3): THREE.Vector3 {
    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    return this.calculateTurbulence(baseWindVector);
  }

  setParams(params: Partial<WindParams>): void {
    Object.assign(this.params, params);
    this.updateWindInternals();
  }

  getParams(): WindParams {
    return { ...this.params };
  }
}

=== simulation/rendering/DebugRenderer.ts ===

/**
 * DebugRenderer.ts - Gestionnaire du rendu de debug pour la simulation Kite
 *
 * Rôle :
 *   - Affiche visuellement les forces physiques (portance, traînée, friction, résultante) et la vitesse du cerf-volant
 *   - Met à jour le panneau d'informations de debug (HTML)
 *   - Permet d'activer/désactiver le mode debug et de gérer l'affichage des vecteurs
 *
 * Dépendances principales :
 *   - RenderManager.ts : Ajoute/retire les objets de debug à la scène Three.js
 *   - PhysicsEngine.ts : Récupère l'état physique du cerf-volant et les forces calculées
 *   - AerodynamicsCalculator.ts : Calcule les forces aérodynamiques sur chaque surface du kite
 *   - Kite.ts : Accès à la géométrie et aux points anatomiques du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Paramètres physiques et configuration
 *   - Types : Utilise SurfaceForce, KiteState pour typer les données physiques
 *
 * Relation avec les fichiers adjacents :
 *   - RenderManager.ts : Fichier adjacent direct, gère la scène 3D et l'environnement visuel. DebugRenderer utilise RenderManager pour afficher les flèches de debug.
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec RenderManager.
 *
 * Utilisation typique :
 *   - Instancié dans la boucle de simulation pour afficher les vecteurs de forces et la vitesse du kite
 *   - Interagit avec le DOM pour afficher les infos de debug
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/rendering/RenderManager.ts
 */
import * as THREE from "three";
import { Primitive } from "@core/Primitive";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, SurfaceForce } from "../types";
import { PhysicsEngine } from "../physics/PhysicsEngine";
import { AerodynamicsCalculator } from "../physics/AerodynamicsCalculator";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { KiteGeometry } from "../config/KiteGeometry";

import { RenderManager } from "./RenderManager";

/**
 * Palette de couleurs améliorée pour les vecteurs de debug
 */
const DEBUG_COLORS = {
  // Vecteurs de mouvement
  velocity: 0x00ff00,        // Vert vif - Vitesse du kite
  apparentWind: 0x00ffff,    // Cyan - Vent apparent

  // Forces globales
  globalLift: 0x4169e1,      // Bleu royal - Portance globale
  globalResultant: 0xffffff, // Blanc - Résultante globale

  // Forces par surface
  surfaceLift: 0x00bfff,     // Bleu ciel profond - Portance locale
  surfaceDrag: 0xff4444,     // Rouge vif - Traînée
  surfaceFriction: 0xaaaaaa, // Gris moyen - Friction
  surfaceResultant: 0xffdd00,// Jaune vif - Résultante locale
  
  // Masse distribuée
  surfaceMass: 0xff00ff,     // Magenta - Force gravitationnelle par surface
};

/**
 * Tailles des vecteurs pour meilleure lisibilité
 */
const VECTOR_SCALES = {
  velocity: 0.6,
  apparentWind: 0.5,
  globalLift: 0.25,
  globalResultant: 0.35,
  surfaceLift: 0.35,
  surfaceDrag: 0.35,
  surfaceFriction: 0.25,
  surfaceResultant: 0.45,
  surfaceMass: 3.0,  // Amplifier pour visibilité (gravité ~0.8N par surface)
};

/**
 * Configuration des têtes de flèches pour un rendu plus fin et précis
 */
const ARROW_HEAD_CONFIG = {
  // Grandes flèches (vitesse, vent apparent, résultantes)
  large: {
    headLength: 0.15,  // Longueur de la tête de flèche
    headWidth: 0.12,   // Largeur de la tête de flèche
  },
  // Flèches moyennes (forces globales)
  medium: {
    headLength: 0.12,
    headWidth: 0.09,
  },
  // Petites flèches (forces par surface)
  small: {
    headLength: 0.10,
    headWidth: 0.07,
  },
  // Très petites flèches (friction)
  tiny: {
    headLength: 0.08,
    headWidth: 0.06,
  },
};

/**
 * Gestionnaire du rendu de debug
 *
 * Affiche les forces, vitesses et informations de debug
 */
/**
 * Configuration des vecteurs visibles
 */
interface VectorVisibility {
  velocity: boolean;
  apparentWind: boolean;
  globalForces: boolean;
  surfaceForces: boolean;
  surfaceMass: boolean;  // Afficher forces gravitationnelles distribuées
}

export class DebugRenderer {
  private renderManager: RenderManager;
  private debugArrows: THREE.ArrowHelper[] = [];
  private debugMode: boolean;
  private vectorVisibility: VectorVisibility = {
    velocity: true,
    apparentWind: true,
    globalForces: true,
    surfaceForces: true,
    surfaceMass: false,  // Désactivé par défaut (peut surcharger l'affichage)
  };

  constructor(renderManager: RenderManager) {
    this.renderManager = renderManager;
    this.debugMode = CONFIG.debugVectors === true;
    this.setupDebugControls();
  }

  isDebugMode(): boolean {
    return this.debugMode;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;

    const debugBtn = document.getElementById("debug-physics");
    const debugPanel = document.getElementById("debug-panel");

    if (debugBtn) {
      debugBtn.textContent = this.debugMode ? "🔍 Debug ON" : "🔍 Debug OFF";
      debugBtn.classList.toggle("active", this.debugMode);
    }

    if (debugPanel) {
      debugPanel.style.display = this.debugMode ? "block" : "none";
    }

    document.body.classList.toggle("debug-mode", this.debugMode);

    if (!this.debugMode) {
      this.clearDebugArrows();
    }
  }

  toggleDebugMode(): void {
    this.setDebugMode(!this.debugMode);
  }

  /**
   * Configure le panneau de contrôle des vecteurs de debug
   */
  private setupDebugControls(): void {
    // Trouver ou créer le conteneur de contrôles
    let controlsContainer = document.getElementById("debug-vector-controls");

    if (!controlsContainer) {
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        controlsContainer = document.createElement("div");
        controlsContainer.id = "debug-vector-controls";
        controlsContainer.style.cssText = `
          margin-top: 15px;
          padding-top: 15px;
          border-top: 1px solid rgba(255,255,255,0.2);
        `;

        controlsContainer.innerHTML = `
          <strong style="display: block; margin-bottom: 10px;">🎨 Vecteurs visibles:</strong>
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-velocity" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ff00;">●</span> Vitesse kite
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-apparent-wind" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ffff;">●</span> Vent apparent
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-global-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #4169e1;">●</span> Forces globales
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ffdd00;">●</span> Forces surfaces
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-mass" style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ff00ff;">●</span> Masse distribuée
            </label>
          </div>
        `;

        debugPanel.appendChild(controlsContainer);

        // Ajouter les event listeners
        document.getElementById("toggle-velocity")?.addEventListener("change", (e) => {
          this.vectorVisibility.velocity = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-apparent-wind")?.addEventListener("change", (e) => {
          this.vectorVisibility.apparentWind = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-global-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.globalForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-mass")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceMass = (e.target as HTMLInputElement).checked;
        });
      }
    }
  }

  clearDebugArrows(): void {
    this.debugArrows.forEach((arrow) => {
      this.renderManager.removeObject(arrow);
    });
    this.debugArrows = [];
  }

  updateDebugArrows(kite: Kite, physicsEngine: PhysicsEngine): void {
    if (!this.debugMode) return;

    this.clearDebugArrows();

    const kiteState = physicsEngine.getKiteController().getState();
    const kitePosition = kite.position.clone();

    // Calculer le centre géométrique entre NEZ et SPINE_BAS
    const centerLocal = new THREE.Vector3(0, 0.325, 0);
    const centerWorld = kite.localToWorld(centerLocal.clone());

    // Vecteur de vitesse du kite (vert vif)
    if (this.vectorVisibility.velocity && kiteState.velocity.length() > CONFIG.debug.minVelocityDisplay) {
      const velocityArrow = Primitive.arrow(
        kiteState.velocity.clone().normalize(),
        centerWorld,
        kiteState.velocity.length() * VECTOR_SCALES.velocity,
        DEBUG_COLORS.velocity,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(velocityArrow);
      this.debugArrows.push(velocityArrow);
    }

    const windSim = physicsEngine.getWindSimulator();
    const wind = windSim.getWindAt(kitePosition);
    const relativeWind = wind.clone().sub(kiteState.velocity);

    // Vecteur de vent apparent (cyan)
    if (this.vectorVisibility.apparentWind && relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const apparentWindArrow = Primitive.arrow(
        relativeWind.clone().normalize(),
        centerWorld,
        relativeWind.length() * VECTOR_SCALES.apparentWind,
        DEBUG_COLORS.apparentWind,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(apparentWindArrow);
      this.debugArrows.push(apparentWindArrow);
    }

    if (relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const { lift, drag, surfaceForces } = AerodynamicsCalculator.calculateForces(
        relativeWind,
        kite.quaternion
      );

      // Forces globales (si activé)
      if (this.vectorVisibility.globalForces) {
        // Portance globale (bleu royal)
        if (lift.length() > CONFIG.debug.minVectorLength) {
          const liftArrow = Primitive.arrow(
            lift.clone().normalize(),
            centerWorld,
            Math.sqrt(lift.length()) * VECTOR_SCALES.globalLift,
            DEBUG_COLORS.globalLift,
            ARROW_HEAD_CONFIG.medium.headLength,
            ARROW_HEAD_CONFIG.medium.headWidth
          );
          this.renderManager.addObject(liftArrow);
          this.debugArrows.push(liftArrow);
        }

        // Résultante globale (blanc) - somme de toutes les surfaces
        const globalResultant = surfaceForces.reduce((sum, sf) => sum.add(sf.resultant.clone()), new THREE.Vector3());
        if (globalResultant.length() > CONFIG.debug.minVectorLength) {
          const resultantArrow = Primitive.arrow(
            globalResultant.clone().normalize(),
            centerWorld,
            Math.sqrt(globalResultant.length()) * VECTOR_SCALES.globalResultant,
            DEBUG_COLORS.globalResultant,
            ARROW_HEAD_CONFIG.large.headLength,
            ARROW_HEAD_CONFIG.large.headWidth
          );
          this.renderManager.addObject(resultantArrow);
          this.debugArrows.push(resultantArrow);
        }
      }

      // Afficher les forces par surface (si activé)
      if (this.vectorVisibility.surfaceForces) {
        this.displaySurfaceForces(surfaceForces, kite);
      }

      // Afficher les vecteurs de masse distribuée (si activé)
      if (this.vectorVisibility.surfaceMass) {
        this.displaySurfaceMass(kite);
      }

      this.updateDebugDisplay(kiteState, kitePosition, { lift, drag }, physicsEngine);
    }
  }

  private updateDebugDisplay(
    kiteState: KiteState,
    kitePosition: THREE.Vector3,
    forces: { lift: THREE.Vector3; drag: THREE.Vector3 },
    physicsEngine: PhysicsEngine
  ): void {
    const debugInfo = document.getElementById("debug-info");
    if (!debugInfo || !this.debugMode) return;

    const { lift, drag } = forces;

    // Calcul des tensions des lignes
    const lineLength = physicsEngine.getLineSystem().lineLength;
    const handles = physicsEngine
      .getControlBarManager()
      .getHandlePositions(kitePosition);

    const kite = physicsEngine.getKiteController().getKite();
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    let tensionInfo = "N/A";
    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const distL = kiteLeftWorld.distanceTo(handles.left);
      const distR = kiteRightWorld.distanceTo(handles.right);
      const tautL = distL >= lineLength - PhysicsConstants.CONTROL_DEADZONE;
      const tautR = distR >= lineLength - PhysicsConstants.CONTROL_DEADZONE;

      tensionInfo = `L:${tautL ? "TENDU" : "RELÂCHÉ"}(${distL.toFixed(2)}m) R:${
        tautR ? "TENDU" : "RELÂCHÉ"
      }(${distR.toFixed(2)}m)`;
    }

    // Informations du vent
    const windParams = physicsEngine.getWindSimulator().getParams();

    // Assemblage des informations de debug
    const totalForce = Math.sqrt(lift.lengthSq() + drag.lengthSq());

    debugInfo.innerHTML = `
            <strong>🪁 Position Cerf-volant:</strong><br>
            X: ${kitePosition.x.toFixed(2)}m, Y: ${kitePosition.y.toFixed(
      2
    )}m, Z: ${kitePosition.z.toFixed(2)}m<br><br>

            <strong>💨 Vent:</strong><br>
            Vitesse: ${windParams.speed.toFixed(1)} km/h<br>
            Direction: ${windParams.direction.toFixed(0)}°<br>
            Turbulence: ${windParams.turbulence.toFixed(1)}%<br><br>

            <strong>⚡ Forces Aérodynamiques:</strong><br>
            Portance: ${lift.length().toFixed(3)} N<br>
            Traînée: ${drag.length().toFixed(3)} N<br>
            Force Totale: ${totalForce.toFixed(3)} N<br><br>

            <strong>🔗 Tensions Lignes:</strong><br>
            ${tensionInfo}<br><br>

            <strong>🏃 Vitesse Cerf-volant:</strong><br>
            ${kiteState.velocity.length().toFixed(2)} m/s<br><br>

            <strong>⚙️ Performance:</strong><br>
            Statut: <span style="color: #00ff88;">STABLE</span>
        `;
  }

  /**
   * Affiche une flèche de force pour chaque surface du kite
   */
  private displaySurfaceForces(surfaceForces: SurfaceForce[], kite: Kite): void {
    const colorPalette = [
      0xff6b6b, // Rouge - Surface 0 (haute gauche)
      0x51cf66, // Vert - Surface 1 (basse gauche) 
      0x667eea, // Bleu - Surface 2 (haute droite)
      0xff9f43, // Orange - Surface 3 (basse droite)
    ];

    surfaceForces.forEach((surfaceForce) => {
      const { lift, drag, friction, resultant, center, surfaceIndex } = surfaceForce;
      const centerWorld = center.clone();
      kite.localToWorld(centerWorld);

      // Portance locale (bleu ciel profond)
      if (lift.length() > CONFIG.debug.minVectorLength) {
        const liftArrow = Primitive.arrow(
          lift.clone().normalize(),
          centerWorld,
          Math.sqrt(lift.length()) * VECTOR_SCALES.surfaceLift,
          DEBUG_COLORS.surfaceLift,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(liftArrow);
        this.debugArrows.push(liftArrow);
      }

      // Traînée (rouge vif)
      if (drag.length() > CONFIG.debug.minVectorLength) {
        const dragArrow = Primitive.arrow(
          drag.clone().normalize(),
          centerWorld,
          Math.sqrt(drag.length()) * VECTOR_SCALES.surfaceDrag,
          DEBUG_COLORS.surfaceDrag,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(dragArrow);
        this.debugArrows.push(dragArrow);
      }

      // Friction (gris moyen)
      if (friction && friction.length() > CONFIG.debug.minVectorLength) {
        const frictionArrow = Primitive.arrow(
          friction.clone().normalize(),
          centerWorld,
          Math.sqrt(friction.length()) * VECTOR_SCALES.surfaceFriction,
          DEBUG_COLORS.surfaceFriction,
          ARROW_HEAD_CONFIG.tiny.headLength,
          ARROW_HEAD_CONFIG.tiny.headWidth
        );
        this.renderManager.addObject(frictionArrow);
        this.debugArrows.push(frictionArrow);
      }

      // Résultante locale (jaune vif)
      if (resultant.length() > CONFIG.debug.minVectorLength) {
        const resultantArrow = Primitive.arrow(
          resultant.clone().normalize(),
          centerWorld,
          Math.sqrt(resultant.length()) * VECTOR_SCALES.surfaceResultant,
          DEBUG_COLORS.surfaceResultant,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(resultantArrow);
        this.debugArrows.push(resultantArrow);
      }
    });
  }

  /**
   * Affiche les vecteurs de force gravitationnelle pour chaque surface
   * Visualise la masse distribuée (physique émergente)
   */
  private displaySurfaceMass(kite: Kite): void {
    // Pour chaque surface avec sa masse
    KiteGeometry.SURFACES_WITH_MASS.forEach((surface: any, surfaceIndex: number) => {
      // Centre géométrique de la surface (coordonnées locales)
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Transformer en coordonnées monde
      const centerWorld = kite.localToWorld(centre.clone());

      // Force gravitationnelle = m × g (vers le bas)
      const gravityForce = new THREE.Vector3(0, -surface.mass * CONFIG.physics.gravity, 0);
      const forceMagnitude = gravityForce.length();

      // Afficher flèche magenta pointant vers le bas
      if (forceMagnitude > CONFIG.debug.minVectorLength) {
        const gravityArrow = Primitive.arrow(
          gravityForce.clone().normalize(),
          centerWorld,
          forceMagnitude * VECTOR_SCALES.surfaceMass,
          DEBUG_COLORS.surfaceMass,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(gravityArrow);
        this.debugArrows.push(gravityArrow);

        // Optionnel : Ajouter une sphère pour montrer la masse
        // Taille proportionnelle à la masse
        const sphereRadius = surface.mass * 0.2; // 0.2m pour 1kg
        const massIndicator = new THREE.Mesh(
          new THREE.SphereGeometry(sphereRadius, 8, 8),
          new THREE.MeshBasicMaterial({
            color: DEBUG_COLORS.surfaceMass,
            transparent: true,
            opacity: 0.3,
            wireframe: true
          })
        );
        massIndicator.position.copy(centerWorld);
        this.renderManager.addObject(massIndicator);
        this.debugArrows.push(massIndicator as any); // Pour cleanup
      }
    });
  }
}



=== simulation/rendering/RenderManager.ts ===

/**
 * RenderManager.ts - Gestionnaire du rendu 3D pour la simulation Kite
 *
 * Rôle :
 *   - Gère la scène Three.js, la caméra, le rendu et l'environnement visuel (ciel, sol, nuages, lumières)
 *   - Ajoute et retire dynamiquement des objets 3D (cerf-volant, flèches de debug, etc.)
 *   - Fournit l'API pour le rendu et la gestion de la scène
 *
 * Dépendances principales :
 *   - Three.js : Moteur de rendu 3D
 *   - SimulationConfig.ts : Paramètres de configuration du rendu (fog, ombres, etc.)
 *
 * Relation avec les fichiers adjacents :
 *   - DebugRenderer.ts : Fichier adjacent direct, utilise RenderManager pour afficher les vecteurs de debug (flèches de forces, vitesse, etc.)
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec DebugRenderer.
 *
 * Utilisation typique :
 *   - Instancié au démarrage de la simulation pour initialiser la scène et le rendu
 *   - Utilisé par DebugRenderer pour ajouter/retirer des objets de debug
 *
 * Voir aussi :
 *   - src/simulation/rendering/DebugRenderer.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire du rendu 3D
 *
 * Gère la scène 3D, la caméra, le rendu et l'environnement visuel
 */
export class RenderManager {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(
      0x87ceeb,
      CONFIG.rendering.fogStart,
      CONFIG.rendering.fogEnd
    );

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 5, 12);
    this.camera.lookAt(0, 3, -5);

    this.renderer = new THREE.WebGLRenderer({
      antialias: CONFIG.rendering.antialias,
      alpha: true,
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxDistance = 50;
    this.controls.minDistance = 2;

    this.setupEnvironment();
    window.addEventListener("resize", () => this.onResize());
  }

  private setupEnvironment(): void {
    // Création d'un beau ciel dégradé
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel profond
        bottomColor: { value: new THREE.Color(0x87ceeb) }, // Bleu ciel plus clair
        offset: { value: 400 },
        exponent: { value: 0.6 },
      },
      side: THREE.BackSide,
    });

    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);

    // Ajout de quelques nuages pour plus de réalisme
    this.addClouds();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 50, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    sunLight.shadow.mapSize.width = CONFIG.rendering.shadowMapSize;
    sunLight.shadow.mapSize.height = CONFIG.rendering.shadowMapSize;
    this.scene.add(sunLight);

    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    this.scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    this.scene.add(gridHelper);
  }

  private addClouds(): void {
    // Création de quelques nuages simples et réalistes
    const cloudGroup = new THREE.Group();

    // Matériau pour les nuages - blanc semi-transparent
    const cloudMaterial = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
    });

    // Création de plusieurs nuages à différentes positions
    for (let i = 0; i < 8; i++) {
      const cloud = new THREE.Group();

      // Chaque nuage est composé de plusieurs sphères pour un aspect naturel
      for (let j = 0; j < 5; j++) {
        const cloudPart = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random() * 4 + 2, 6, 4),
          cloudMaterial
        );

        cloudPart.position.x = Math.random() * 10 - 5;
        cloudPart.position.y = Math.random() * 2 - 1;
        cloudPart.position.z = Math.random() * 10 - 5;
        cloudPart.scale.setScalar(Math.random() * 0.5 + 0.5);

        cloud.add(cloudPart);
      }

      // Position des nuages dans le ciel
      cloud.position.set(
        (Math.random() - 0.5) * 200, // X: -100 à 100
        Math.random() * 30 + 20, // Y: 20 à 50 (hauteur dans le ciel)
        (Math.random() - 0.5) * 200 // Z: -100 à 100
      );

      cloudGroup.add(cloud);
    }

    this.scene.add(cloudGroup);
  }

  addObject(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  render(): void {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  private onResize(): void {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  getScene(): THREE.Scene {
    return this.scene;
  }
}

=== simulation/systems/InputSystem.ts ===

/**
 * InputSystem.ts - Système de gestion des entrées utilisateur
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface InputState {
  // Entrées analogiques (normalisées -1 à 1)
  barPosition: number; // Position de la barre (-1: tirée gauche, 0: neutre, 1: tirée droite)
  barVelocity: number; // Vitesse de mouvement de la barre

  // Entrées numériques
  resetPressed: boolean;
  debugTogglePressed: boolean;

  // État interne
  lastBarPosition: number;
  smoothingFactor: number;
}

export interface InputConfig {
  barSmoothingEnabled: boolean;
  barSmoothingFactor: number; // Facteur de lissage (0-1, plus proche de 1 = plus lisse)
  deadzone: number; // Zone morte pour éviter les oscillations
  maxBarSpeed: number; // Vitesse maximale de changement de la barre
  keyboardEnabled: boolean;
  mouseEnabled: boolean;
}

export class InputSystem extends BaseSimulationSystem {
  private logger: Logger;
  private inputState: InputState;
  private config: InputConfig;

  // Gestion des événements
  private keyStates = new Map<string, boolean>();
  private mousePosition = new THREE.Vector2();
  private mouseButtons = new Map<number, boolean>();

  constructor(config: Partial<InputConfig> = {}) {
    super('InputSystem', 1); // Haute priorité (traité en premier)

    this.logger = Logger.getInstance();
    this.config = {
      barSmoothingEnabled: true,
      barSmoothingFactor: 0.8,
      deadzone: 0.05,
      maxBarSpeed: 2.0, // unités par seconde
      keyboardEnabled: true,
      mouseEnabled: true,
      ...config
    };

    this.inputState = {
      barPosition: 0,
      barVelocity: 0,
      resetPressed: false,
      debugTogglePressed: false,
      lastBarPosition: 0,
      smoothingFactor: this.config.barSmoothingFactor
    };

    this.setupEventListeners();
  }

  async initialize(): Promise<void> {
    this.logger.info('InputSystem initialized', 'InputSystem');
  }

  update(context: SimulationContext): void {
    // Mettre à jour l'état des entrées
    this.updateKeyboardInput();
    this.updateMouseInput();

    // Calculer la position de la barre avec lissage
    this.updateBarPosition(context.deltaTime);

    // Mettre à jour les états des boutons (pulse)
    this.updateButtonStates();
  }

  /**
   * Configure les écouteurs d'événements
   */
  private setupEventListeners(): void {
    if (typeof window === 'undefined') return;

    // Écouteurs clavier
    if (this.config.keyboardEnabled) {
      window.addEventListener('keydown', this.onKeyDown.bind(this));
      window.addEventListener('keyup', this.onKeyUp.bind(this));
    }

    // Écouteurs souris
    if (this.config.mouseEnabled) {
      window.addEventListener('mousemove', this.onMouseMove.bind(this));
      window.addEventListener('mousedown', this.onMouseDown.bind(this));
      window.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
  }

  /**
   * Gestionnaire d'événement clavier (appui)
   */
  private onKeyDown(event: KeyboardEvent): void {
    this.keyStates.set(event.code, true);

    // Empêcher le comportement par défaut pour certaines touches
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyR'].includes(event.code)) {
      event.preventDefault();
    }
  }

  /**
   * Gestionnaire d'événement clavier (relâchement)
   */
  private onKeyUp(event: KeyboardEvent): void {
    this.keyStates.set(event.code, false);
  }

  /**
   * Gestionnaire de mouvement de souris
   */
  private onMouseMove(event: MouseEvent): void {
    this.mousePosition.set(event.clientX, event.clientY);
  }

  /**
   * Gestionnaire d'appui souris
   */
  private onMouseDown(event: MouseEvent): void {
    this.mouseButtons.set(event.button, true);
  }

  /**
   * Gestionnaire de relâchement souris
   */
  private onMouseUp(event: MouseEvent): void {
    this.mouseButtons.set(event.button, false);
  }

  /**
   * Met à jour les entrées clavier
   */
  private updateKeyboardInput(): void {
    // Contrôle de la barre avec les flèches gauche/droite
    let targetBarPosition = 0;

    if (this.keyStates.get('ArrowLeft')) {
      targetBarPosition = -1; // Barre tirée à gauche
    } else if (this.keyStates.get('ArrowRight')) {
      targetBarPosition = 1; // Barre tirée à droite
    }

    // Appliquer la zone morte
    if (Math.abs(targetBarPosition) < this.config.deadzone) {
      targetBarPosition = 0;
    }

    this.inputState.barPosition = targetBarPosition;

    // Boutons pulse
    this.inputState.resetPressed = this.keyStates.get('KeyR') || false;
    this.inputState.debugTogglePressed = this.keyStates.get('KeyD') || false;
  }

  /**
   * Met à jour les entrées souris (réservé pour extension future)
   */
  private updateMouseInput(): void {
    // Pour l'instant, la souris n'est pas utilisée pour le contrôle principal
    // Mais on pourrait l'utiliser pour un contrôle plus fin
  }

  /**
   * Met à jour la position de la barre avec lissage
   */
  private updateBarPosition(deltaTime: number): void {
    const targetPosition = this.inputState.barPosition;

    if (this.config.barSmoothingEnabled) {
      // Lissage exponentiel
      const smoothedPosition = THREE.MathUtils.lerp(
        this.inputState.lastBarPosition,
        targetPosition,
        1.0 - Math.pow(1.0 - this.inputState.smoothingFactor, deltaTime * 60)
      );

      this.inputState.lastBarPosition = smoothedPosition;
      this.inputState.barPosition = smoothedPosition;
    } else {
      this.inputState.lastBarPosition = targetPosition;
    }

    // Calculer la vitesse de changement
    this.inputState.barVelocity = (this.inputState.barPosition - this.inputState.lastBarPosition) / deltaTime;

    // Limiter la vitesse maximale
    if (Math.abs(this.inputState.barVelocity) > this.config.maxBarSpeed) {
      this.inputState.barVelocity = Math.sign(this.inputState.barVelocity) * this.config.maxBarSpeed;
    }
  }

  /**
   * Met à jour les états des boutons (pulse - seulement true pendant un frame)
   */
  private updateButtonStates(): void {
    // Pour l'instant, pas de logique pulse nécessaire car on utilise directement les keyStates
    // Mais on pourrait implémenter une logique de pulse ici si nécessaire
  }

  /**
   * Obtient l'état actuel des entrées
   */
  getInputState(): Readonly<InputState> {
    return this.inputState;
  }

  /**
   * Force une position de barre (pour debug ou automation)
   */
  setBarPosition(position: number): void {
    this.inputState.barPosition = THREE.MathUtils.clamp(position, -1, 1);
    this.inputState.lastBarPosition = this.inputState.barPosition;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<InputConfig> {
    return this.config;
  }

  reset(): void {
    this.inputState.barPosition = 0;
    this.inputState.barVelocity = 0;
    this.inputState.lastBarPosition = 0;
    this.inputState.resetPressed = false;
    this.inputState.debugTogglePressed = false;

    // Réinitialiser les états des touches
    this.keyStates.clear();
    this.mouseButtons.clear();

    this.logger.info('InputSystem reset', 'InputSystem');
  }

  dispose(): void {
    // Supprimer les écouteurs d'événements
    if (typeof window !== 'undefined') {
      window.removeEventListener('keydown', this.onKeyDown.bind(this));
      window.removeEventListener('keyup', this.onKeyUp.bind(this));
      window.removeEventListener('mousemove', this.onMouseMove.bind(this));
      window.removeEventListener('mousedown', this.onMouseDown.bind(this));
      window.removeEventListener('mouseup', this.onMouseUp.bind(this));
    }

    this.logger.info('InputSystem disposed', 'InputSystem');
  }
}

=== simulation/systems/PhysicsSystem.ts ===

/**
 * PhysicsSystem.ts - Système de simulation physique
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { PHYSICAL_CONSTANTS } from '../../factories/presets/PhysicalPresets';

export interface PhysicsState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  acceleration: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  angularAcceleration: THREE.Vector3;
  mass: number;
  momentOfInertia: THREE.Matrix3;
}

export interface PhysicsConfig {
  gravityEnabled: boolean;
  airResistanceEnabled: boolean;
  groundCollisionEnabled: boolean;
  maxVelocity: number;
  maxAngularVelocity: number;
  timeStep: number;
  airDensity: number;
  gravity: number;
  minVelocity: number;
}

export class PhysicsSystem extends BaseSimulationSystem {
  private logger: Logger;
  private physicsObjects = new Map<string, PhysicsState>();
  private config: PhysicsConfig;

  constructor(config: Partial<PhysicsConfig> = {}) {
    super('PhysicsSystem', 10); // Priorité 10 (après les systèmes d'entrée)

    this.logger = Logger.getInstance();
    this.config = {
      gravityEnabled: true,
      airResistanceEnabled: true,
      groundCollisionEnabled: true,
      maxVelocity: 100,
      maxAngularVelocity: 50,
      airDensity: PHYSICAL_CONSTANTS.airDensity,
      gravity: PHYSICAL_CONSTANTS.gravity,
      minVelocity: 0.01,
      timeStep: 1/60,
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('PhysicsSystem initialized', 'PhysicsSystem');
  }

  update(context: SimulationContext): void {
    const deltaTime = Math.min(context.deltaTime, this.config.timeStep);

    // Mise à jour de tous les objets physiques
    for (const [id, state] of this.physicsObjects.entries()) {
      this.updatePhysicsObject(id, state, deltaTime);
    }
  }

  reset(): void {
    this.physicsObjects.clear();
    this.logger.info('PhysicsSystem reset', 'PhysicsSystem');
  }

  dispose(): void {
    this.physicsObjects.clear();
    this.logger.info('PhysicsSystem disposed', 'PhysicsSystem');
  }

  /**
   * Enregistre un objet physique dans le système
   */
  registerPhysicsObject(id: string, initialState: Partial<PhysicsState>): void {
    const state: PhysicsState = {
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      acceleration: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      angularAcceleration: new THREE.Vector3(),
      mass: 1.0,
      momentOfInertia: new THREE.Matrix3().identity(),
      ...initialState
    };

    this.physicsObjects.set(id, state);
    this.logger.debug(`Physics object registered: ${id}`, 'PhysicsSystem');
  }

  /**
   * Désenregistre un objet physique
   */
  unregisterPhysicsObject(id: string): boolean {
    const removed = this.physicsObjects.delete(id);
    if (removed) {
      this.logger.debug(`Physics object unregistered: ${id}`, 'PhysicsSystem');
    }
    return removed;
  }

  /**
   * Obtient l'état physique d'un objet
   */
  getPhysicsState(id: string): PhysicsState | undefined {
    return this.physicsObjects.get(id);
  }

  /**
   * Applique une force à un objet
   */
  applyForce(id: string, force: THREE.Vector3, point?: THREE.Vector3): void {
    const state = this.physicsObjects.get(id);
    if (!state) return;

    // F = ma => a = F/m
    const acceleration = force.clone().divideScalar(state.mass);
    state.acceleration.add(acceleration);

    // Si un point d'application est spécifié, calculer le couple
    if (point) {
      const r = point.clone().sub(state.position);
      const torque = r.clone().cross(force);
      this.applyTorque(id, torque);
    }
  }

  /**
   * Applique un couple (torque) à un objet
   */
  applyTorque(id: string, torque: THREE.Vector3): void {
    const state = this.physicsObjects.get(id);
    if (!state) return;

    // τ = Iα => α = I⁻¹τ
    const angularAcceleration = torque.clone();
    angularAcceleration.applyMatrix3(state.momentOfInertia.clone().invert());
    state.angularAcceleration.add(angularAcceleration);
  }

  /**
   * Met à jour la physique d'un objet
   */
  private updatePhysicsObject(id: string, state: PhysicsState, deltaTime: number): void {
    // Appliquer la gravité
    if (this.config.gravityEnabled) {
      const gravity = new THREE.Vector3(0, -PHYSICAL_CONSTANTS.gravity, 0);
      state.acceleration.add(gravity);
    }

    // Appliquer la résistance de l'air
    if (this.config.airResistanceEnabled) {
      this.applyAirResistance(state);
    }

    // Intégration des accélérations (méthode d'Euler)
    state.velocity.add(state.acceleration.clone().multiplyScalar(deltaTime));
    state.position.add(state.velocity.clone().multiplyScalar(deltaTime));

    // Intégration angulaire
    state.angularVelocity.add(state.angularAcceleration.clone().multiplyScalar(deltaTime));

    // Limiter les vitesses
    this.clampVelocities(state);

    // Collision avec le sol
    if (this.config.groundCollisionEnabled) {
      this.handleGroundCollision(state);
    }

    // Réinitialiser les accélérations pour le prochain frame
    state.acceleration.set(0, 0, 0);
    state.angularAcceleration.set(0, 0, 0);
  }

  /**
   * Applique la résistance de l'air
   */
  private applyAirResistance(state: PhysicsState): void {
    if (state.velocity.lengthSq() < this.config.minVelocity * this.config.minVelocity) {
      return;
    }

    // Force de traînée : F_d = 0.5 * ρ * v² * C_d * A
    // Approximation simplifiée : F_d = -k * v (linéaire)
    const dragCoefficient = 0.1; // Coefficient simplifié
    const dragForce = state.velocity.clone()
      .normalize()
      .multiplyScalar(-dragCoefficient * state.velocity.lengthSq());

    state.acceleration.add(dragForce.divideScalar(state.mass));
  }

  /**
   * Limite les vitesses maximales
   */
  private clampVelocities(state: PhysicsState): void {
    if (state.velocity.length() > this.config.maxVelocity) {
      state.velocity.normalize().multiplyScalar(this.config.maxVelocity);
    }

    if (state.angularVelocity.length() > this.config.maxAngularVelocity) {
      state.angularVelocity.normalize().multiplyScalar(this.config.maxAngularVelocity);
    }
  }

  /**
   * Gère les collisions avec le sol
   */
  private handleGroundCollision(state: PhysicsState): void {
    const groundY = 0;

    if (state.position.y <= groundY && state.velocity.y < 0) {
      // Collision avec le sol
      state.position.y = groundY;
      state.velocity.y *= -0.3; // Coefficient de restitution (rebond)

      // Friction
      const friction = 0.8;
      state.velocity.x *= friction;
      state.velocity.z *= friction;

      // Arrêter si la vitesse est très faible
      if (Math.abs(state.velocity.y) < 0.01) {
        state.velocity.y = 0;
      }
    }
  }

  /**
   * Calcule les forces aérodynamiques (pour usage par d'autres systèmes)
   */
  calculateAerodynamicForces(
    velocity: THREE.Vector3,
    area: number,
    liftCoeff: number,
    dragCoeff: number,
    normal: THREE.Vector3
  ): { lift: THREE.Vector3, drag: THREE.Vector3 } {
    const speed = velocity.length();
    if (speed < this.config.minVelocity) {
      return { lift: new THREE.Vector3(), drag: new THREE.Vector3() };
    }

    const velocityDir = velocity.clone().normalize();

    // Force de portance (perpendiculaire à la vitesse)
    const liftDir = normal.clone().cross(velocityDir).cross(velocityDir).normalize();
    const lift = liftDir.multiplyScalar(0.5 * PHYSICAL_CONSTANTS.airDensity * speed * speed * area * liftCoeff);

    // Force de traînée (opposée à la vitesse)
    const drag = velocityDir.clone().multiplyScalar(-0.5 * PHYSICAL_CONSTANTS.airDensity * speed * speed * area * dragCoeff);

    return { lift, drag };
  }

  /**
   * Obtient tous les IDs des objets physiques
   */
  getPhysicsObjectIds(): string[] {
    return Array.from(this.physicsObjects.keys());
  }

  /**
   * Met à jour la configuration
   */
  updateConfig(newConfig: Partial<PhysicsConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.logger.info('PhysicsSystem config updated', 'PhysicsSystem');
  }

  /**
   * Obtient les statistiques du système
   */
  getStats(): any {
    return {
      objectCount: this.physicsObjects.size,
      config: this.config
    };
  }
}

=== simulation/systems/RenderSystem.ts ===

/**
 * RenderSystem.ts - Système de rendu Three.js
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';

export interface RenderState {
  scene: THREE.Scene;
  camera: THREE.Camera;
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
  isRendering: boolean;
  frameCount: number;
  fps: number;
  lastFrameTime: number;
}

export interface RenderConfig {
  antialias: boolean;
  shadowMapEnabled: boolean;
  shadowMapType: THREE.ShadowMapType;
  pixelRatio: number;
  clearColor: number;
  clearAlpha: number;
  targetFPS: number;
  vsync: boolean;
  powerPreference: 'default' | 'high-performance' | 'low-power';
}

export class RenderSystem extends BaseSimulationSystem {
  private logger: Logger;
  private renderState: RenderState | null = null;
  private config: RenderConfig;
  private fpsCounter = { frames: 0, lastTime: 0, fps: 0 };

  constructor(config: Partial<RenderConfig> = {}) {
    super('RenderSystem', 100); // Basse priorité (rendu en dernier)

    this.logger = Logger.getInstance();
    this.config = {
      antialias: true,
      shadowMapEnabled: true,
      shadowMapType: THREE.PCFSoftShadowMap,
      pixelRatio: 1, // Valeur par défaut, sera mise à jour dans initialize()
      clearColor: 0x87CEEB, // Bleu ciel
      clearAlpha: 1.0,
      targetFPS: 60,
      vsync: true,
      powerPreference: 'high-performance',
      ...config
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('RenderSystem initializing...', 'RenderSystem');

    // Mettre à jour pixelRatio maintenant que window est disponible
    if (typeof window !== 'undefined') {
      this.config.pixelRatio = Math.min(window.devicePixelRatio, 2);
    }

    try {
      await this.initializeRenderer();
      this.logger.info('RenderSystem initialized successfully', 'RenderSystem');
    } catch (error) {
      this.logger.error(`RenderSystem initialization failed: ${error}`, 'RenderSystem');
      throw error;
    }
  }

  /**
   * Initialise le renderer Three.js
   */
  private async initializeRenderer(): Promise<void> {
    if (typeof document === 'undefined') {
      throw new Error('RenderSystem requires a DOM environment');
    }

    // Créer le canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'kite-simulator-canvas';

    // Créer le renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: this.config.antialias,
      alpha: false,
      powerPreference: this.config.powerPreference
    });

    // Configurer le renderer
    renderer.setPixelRatio(this.config.pixelRatio);
    renderer.setClearColor(this.config.clearColor, this.config.clearAlpha);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Configurer les ombres
    if (this.config.shadowMapEnabled) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = this.config.shadowMapType;
    }

    // Créer la scène
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(this.config.clearColor, 50, 200);

    // Créer la caméra (sera configurée par le système de caméra séparé)
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Initialiser l'état de rendu
    this.renderState = {
      scene,
      camera,
      renderer,
      canvas,
      isRendering: false,
      frameCount: 0,
      fps: 0,
      lastFrameTime: performance.now()
    };

    // Configurer la taille initiale
    this.onResize();

    // Ajouter le canvas au DOM
    const container = document.getElementById('app') || document.body;
    container.appendChild(canvas);

    // Écouteur de redimensionnement
    window.addEventListener('resize', this.onResize.bind(this));
  }

  update(context: SimulationContext): void {
    if (!this.renderState || !this.renderState.isRendering) return;

    // Calculer le FPS
    this.updateFPS();

    // Rendre la scène
    this.renderState.renderer.render(this.renderState.scene, this.renderState.camera);

    this.renderState.frameCount++;
  }

  /**
   * Met à jour le compteur FPS
   */
  private updateFPS(): void {
    if (!this.renderState) return;

    const now = performance.now();
    this.fpsCounter.frames++;

    if (now - this.fpsCounter.lastTime >= 1000) {
      this.renderState.fps = Math.round((this.fpsCounter.frames * 1000) / (now - this.fpsCounter.lastTime));
      this.fpsCounter.frames = 0;
      this.fpsCounter.lastTime = now;
    }
  }

  /**
   * Gestionnaire de redimensionnement de la fenêtre
   */
  private onResize(): void {
    if (!this.renderState) return;

    const width = window.innerWidth;
    const height = window.innerHeight;

    // Mettre à jour la caméra
    if (this.renderState.camera instanceof THREE.PerspectiveCamera) {
      this.renderState.camera.aspect = width / height;
      this.renderState.camera.updateProjectionMatrix();
    }

    // Mettre à jour le renderer
    this.renderState.renderer.setSize(width, height);
  }

  /**
   * Démarre le rendu
   */
  startRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = true;
      this.logger.info('Rendering started', 'RenderSystem');
    }
  }

  /**
   * Arrête le rendu
   */
  stopRendering(): void {
    if (this.renderState) {
      this.renderState.isRendering = false;
      this.logger.info('Rendering stopped', 'RenderSystem');
    }
  }

  /**
   * Obtient l'état de rendu actuel
   */
  getRenderState(): Readonly<RenderState> | null {
    return this.renderState;
  }

  /**
   * Obtient la scène Three.js
   */
  getScene(): THREE.Scene | null {
    return this.renderState?.scene || null;
  }

  /**
   * Obtient la caméra
   */
  getCamera(): THREE.Camera | null {
    return this.renderState?.camera || null;
  }

  /**
   * Obtient le renderer
   */
  getRenderer(): THREE.WebGLRenderer | null {
    return this.renderState?.renderer || null;
  }

  /**
   * Obtient le canvas
   */
  getCanvas(): HTMLCanvasElement | null {
    return this.renderState?.canvas || null;
  }

  /**
   * Obtient les statistiques de rendu
   */
  getRenderStats(): { fps: number; frameCount: number; isRendering: boolean } {
    if (!this.renderState) {
      return { fps: 0, frameCount: 0, isRendering: false };
    }

    return {
      fps: this.renderState.fps,
      frameCount: this.renderState.frameCount,
      isRendering: this.renderState.isRendering
    };
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<RenderConfig> {
    return this.config;
  }

  reset(): void {
    if (this.renderState) {
      this.renderState.frameCount = 0;
      this.renderState.fps = 0;
      this.renderState.lastFrameTime = performance.now();
    }

    this.fpsCounter = { frames: 0, lastTime: 0, fps: 0 };
    this.logger.info('RenderSystem reset', 'RenderSystem');
  }

  dispose(): void {
    if (this.renderState) {
      // Supprimer les écouteurs
      window.removeEventListener('resize', this.onResize.bind(this));

      // Disposer le renderer
      this.renderState.renderer.dispose();

      // Supprimer le canvas du DOM
      if (this.renderState.canvas.parentNode) {
        this.renderState.canvas.parentNode.removeChild(this.renderState.canvas);
      }

      this.renderState = null;
    }

    this.logger.info('RenderSystem disposed', 'RenderSystem');
  }
}

=== simulation/systems/WindSystem.ts ===

/**
 * WindSystem.ts - Système de simulation du vent
 */

import * as THREE from 'three';
import { BaseSimulationSystem, SimulationContext } from '../../base/BaseSimulationSystem';
import { Logger } from '../../utils/Logging';
import { MathUtils } from '../../utils/MathUtils';
import { PHYSICAL_CONSTANTS } from '../../factories/presets/PhysicalPresets';

export interface WindState {
  baseDirection: THREE.Vector3; // Direction principale du vent
  baseSpeed: number; // Vitesse de base du vent (m/s)
  turbulence: number; // Intensité de la turbulence (0-1)
  gustFrequency: number; // Fréquence des rafales (Hz)
  gustAmplitude: number; // Amplitude des rafales
  time: number; // Temps écoulé pour l'animation
}

export interface WindConfig {
  baseSpeed: number;
  baseDirection: THREE.Vector3;
  turbulenceEnabled: boolean;
  turbulenceIntensity: number;
  gustsEnabled: boolean;
  gustFrequency: number;
  gustAmplitude: number;
  windShearEnabled: boolean; // Variation de vitesse avec l'altitude
  updateFrequency: number; // Fréquence de mise à jour (Hz)
}

export class WindSystem extends BaseSimulationSystem {
  private logger: Logger;
  private windState: WindState;
  private config: WindConfig;
  private lastUpdateTime: number = 0;

  constructor(config: Partial<WindConfig> = {}) {
    super('WindSystem', 5); // Priorité 5 (avant la physique)

    this.logger = Logger.getInstance();
    this.config = {
      baseSpeed: 5.0, // 5 m/s vent léger
      baseDirection: new THREE.Vector3(1, 0, 0), // Vent venant de l'est
      turbulenceEnabled: true,
      turbulenceIntensity: 0.3,
      gustsEnabled: true,
      gustFrequency: 0.1, // Une rafale toutes les 10 secondes
      gustAmplitude: 2.0,
      windShearEnabled: true,
      updateFrequency: 10, // 10 Hz
      ...config
    };

    // Normaliser la direction
    this.config.baseDirection.normalize();

    this.windState = {
      baseDirection: this.config.baseDirection.clone(),
      baseSpeed: this.config.baseSpeed,
      turbulence: this.config.turbulenceIntensity,
      gustFrequency: this.config.gustFrequency,
      gustAmplitude: this.config.gustAmplitude,
      time: 0
    };
  }

  async initialize(): Promise<void> {
    this.logger.info('WindSystem initialized', 'WindSystem');
  }

  update(context: SimulationContext): void {
    // Mise à jour périodique pour éviter les calculs trop fréquents
    if (context.totalTime - this.lastUpdateTime < 1.0 / this.config.updateFrequency) {
      return;
    }

    this.lastUpdateTime = context.totalTime;
    this.windState.time = context.totalTime;

    // Calculer le vent apparent avec turbulence et rafales
    this.updateWindState(context.deltaTime);
  }

  /**
   * Met à jour l'état du vent avec turbulence et rafales
   */
  private updateWindState(deltaTime: number): void {
    // Direction de base (peut être modifiée par des facteurs externes)
    this.windState.baseDirection.copy(this.config.baseDirection);

    // Ajouter turbulence si activée
    if (this.config.turbulenceEnabled) {
      this.addTurbulence(deltaTime);
    }

    // Ajouter rafales si activées
    if (this.config.gustsEnabled) {
      this.addGustEffect(deltaTime);
    }

    // Normaliser la direction après modifications
    this.windState.baseDirection.normalize();
  }

  /**
   * Ajoute de la turbulence au vent
   */
  private addTurbulence(deltaTime: number): void {
    // Générer du bruit pseudo-aléatoire basé sur le temps
    const noiseX = Math.sin(this.windState.time * 2.1) * Math.cos(this.windState.time * 1.3);
    const noiseY = Math.sin(this.windState.time * 1.7) * Math.cos(this.windState.time * 2.4);
    const noiseZ = Math.sin(this.windState.time * 1.9) * Math.cos(this.windState.time * 1.8);

    // Appliquer l'intensité de la turbulence
    const turbulenceVector = new THREE.Vector3(noiseX, noiseY, noiseZ);
    turbulenceVector.multiplyScalar(this.config.turbulenceIntensity * 0.1);

    // Ajouter à la direction
    this.windState.baseDirection.add(turbulenceVector);
  }

  /**
   * Ajoute l'effet des rafales
   */
  private addGustEffect(deltaTime: number): void {
    // Calculer l'amplitude de la rafale actuelle
    const gustPhase = Math.sin(this.windState.time * this.config.gustFrequency * Math.PI * 2);
    const gustStrength = Math.max(0, gustPhase) * this.config.gustAmplitude;

    // Rafales principalement dans la direction du vent
    const gustVector = this.config.baseDirection.clone();
    gustVector.multiplyScalar(gustStrength * 0.1);

    this.windState.baseDirection.add(gustVector);
  }

  /**
   * Calcule le vent apparent à une position donnée
   * @param position Position dans l'espace 3D
   * @param objectVelocity Vitesse de l'objet (pour vent relatif)
   * @returns Vecteur vent apparent
   */
  getApparentWind(position: THREE.Vector3, objectVelocity: THREE.Vector3 = new THREE.Vector3()): THREE.Vector3 {
    // Vent de base
    let wind = this.windState.baseDirection.clone();
    wind.multiplyScalar(this.windState.baseSpeed);

    // Ajouter cisaillement du vent (variation avec l'altitude)
    if (this.config.windShearEnabled) {
      wind = this.applyWindShear(wind, position.y);
    }

    // Vent apparent = vent absolu - vitesse de l'objet
    const apparentWind = wind.clone();
    apparentWind.sub(objectVelocity);

    return apparentWind;
  }

  /**
   * Applique le cisaillement du vent (variation avec l'altitude)
   */
  private applyWindShear(wind: THREE.Vector3, altitude: number): THREE.Vector3 {
    // Le vent augmente avec l'altitude selon une loi logarithmique simplifiée
    // En réalité, c'est plus complexe, mais cette approximation suffit
    const shearFactor = Math.max(0.5, Math.log(Math.max(1, altitude + 1)) * 0.3 + 0.7);

    const shearedWind = wind.clone();
    shearedWind.multiplyScalar(shearFactor);

    return shearedWind;
  }

  /**
   * Obtient l'état actuel du vent
   */
  getWindState(): Readonly<WindState> {
    return this.windState;
  }

  /**
   * Modifie la direction du vent
   */
  setWindDirection(direction: THREE.Vector3): void {
    this.config.baseDirection.copy(direction);
    this.config.baseDirection.normalize();
    this.windState.baseDirection.copy(this.config.baseDirection);
  }

  /**
   * Modifie la vitesse du vent
   */
  setWindSpeed(speed: number): void {
    this.config.baseSpeed = Math.max(0, speed);
    this.windState.baseSpeed = this.config.baseSpeed;
  }

  /**
   * Obtient la configuration actuelle
   */
  getConfig(): Readonly<WindConfig> {
    return this.config;
  }

  reset(): void {
    this.windState.time = 0;
    this.windState.baseDirection.copy(this.config.baseDirection);
    this.windState.baseSpeed = this.config.baseSpeed;
    this.lastUpdateTime = 0;
    this.logger.info('WindSystem reset', 'WindSystem');
  }

  dispose(): void {
    // Pas de ressources spécifiques à nettoyer
    this.logger.info('WindSystem disposed', 'WindSystem');
  }
}

=== simulation/systems/index.ts ===

/**
 * systems/index.ts - Export des systèmes de simulation
 *
 * Point d'entrée centralisé pour tous les systèmes de simulation.
 * Permet d'importer facilement tous les systèmes depuis un seul endroit.
 */

export { PhysicsSystem, type PhysicsState, type PhysicsConfig } from './PhysicsSystem';
export { WindSystem, type WindState, type WindConfig } from './WindSystem';
export { InputSystem, type InputState, type InputConfig } from './InputSystem';
export { RenderSystem, type RenderState, type RenderConfig } from './RenderSystem';

=== simulation/types/BridleTypes.ts ===

/**
 * BridleTypes.ts - Types et interfaces pour le système de bridage
 *
 * Définit les structures de données pour les brides du cerf-volant.
 * Les brides relient des points anatomiques du kite (NEZ, INTER, CENTRE)
 * aux points de contrôle (CTRL_GAUCHE, CTRL_DROIT).
 */

/**
 * Longueurs physiques des 3 types de brides
 * (identique pour gauche et droite)
 */
export interface BridleLengths {
  /** Longueur bride NEZ → CTRL (mètres) */
  nez: number;

  /** Longueur bride INTER → CTRL (mètres) */
  inter: number;

  /** Longueur bride CENTRE → CTRL (mètres) */
  centre: number;
}

/**
 * Tensions actuelles des 6 brides
 * (3 gauches + 3 droites)
 */
export interface BridleTensions {
  /** Tension bride NEZ gauche (Newtons) */
  leftNez: number;

  /** Tension bride INTER gauche (Newtons) */
  leftInter: number;

  /** Tension bride CENTRE gauche (Newtons) */
  leftCentre: number;

  /** Tension bride NEZ droite (Newtons) */
  rightNez: number;

  /** Tension bride INTER droite (Newtons) */
  rightInter: number;

  /** Tension bride CENTRE droite (Newtons) */
  rightCentre: number;
}

/**
 * Définition d'une attache de bride
 * (relie deux points anatomiques du kite)
 */
export interface BridleAttachment {
  /** Nom du point de départ (ex: "NEZ", "INTER_GAUCHE") */
  startPoint: string;

  /** Nom du point d'arrivée (ex: "CTRL_GAUCHE", "CTRL_DROIT") */
  endPoint: string;

  /** Longueur au repos (mètres) */
  length: number;

  /** Identifiant unique (ex: "bridle_left_nez") */
  id: string;
}

/**
 * Type des côtés du bridage
 */
export type BridleSide = 'left' | 'right';

/**
 * Type des positions de bride
 */
export type BridlePosition = 'nez' | 'inter' | 'centre';

/**
 * Configuration complète d'une bride (utilisé par BridleFactory)
 */
export interface BridleConfig {
  /** Côté de la bride */
  side: BridleSide;

  /** Position de la bride */
  position: BridlePosition;

  /** Longueur (mètres) */
  length: number;

  /** Identifiant unique */
  id: string;
}


=== simulation/types/PhysicsTypes.ts ===

/**
 * PhysicsTypes.ts - Types et interfaces pour la physique de la simulation Kite
 *
 * Rôle :
 *   - Définit les structures de données pour l'état du cerf-volant, les forces, les poignées, etc.
 *   - Sert à typer les échanges entre les modules physiques et de rendu
 *
 * Dépendances principales :
 *   - Three.js : Pour les vecteurs et quaternions
 *
 * Relation avec les fichiers adjacents :
 *   - WindTypes.ts : Définit les types pour le vent
 *   - Tous les modules physiques et de rendu importent PhysicsTypes pour typer les données
 *
 * Utilisation typique :
 *   - Utilisé dans PhysicsEngine, AerodynamicsCalculator, DebugRenderer, etc.
 *   - Sert à garantir la cohérence des échanges de données physiques
 *
 * Voir aussi :
 *   - src/simulation/types/WindTypes.ts
 */
import * as THREE from "three";

/**
 * Types et interfaces pour la physique de la simulation
 */

export interface KiteState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  orientation: THREE.Quaternion;
}

export interface HandlePositions {
  left: THREE.Vector3;
  right: THREE.Vector3;
}

/**
 * Force appliquée sur une surface spécifique du kite
 */
export interface SurfaceForce {
  /** Indice de la surface dans KiteGeometry.SURFACES */
  surfaceIndex: number;
  /** Portance sur cette surface (en Newton) */
  lift: THREE.Vector3;
  /** Traînée sur cette surface (en Newton) */
  drag: THREE.Vector3;
  /** Friction sur cette surface (optionnel, en Newton) */
  friction?: THREE.Vector3;
  /** Force totale (résultante) sur cette surface (en Newton) */
  resultant: THREE.Vector3;
  /** Centre géométrique de la surface (en coordonnées monde) */
  center: THREE.Vector3;
  /** Normale de la surface (en coordonnées monde) */
  normal: THREE.Vector3;
  /** Surface en m² */
  area: number;
}

=== simulation/types/WindTypes.ts ===


/**
 * WindTypes.ts - Types pour le système de vent de la simulation Kite
 *
 * Rôle :
 *   - Définit la structure des paramètres de vent (vitesse, direction, turbulence)
 *   - Sert à typer les échanges entre le simulateur de vent et les autres modules
 *
 * Dépendances principales :
 *   - Aucun import direct, mais utilisé par WindSimulator et PhysicsEngine
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsTypes.ts : Définit les types pour la physique
 *   - Tous les modules physiques et de rendu importent WindTypes pour typer le vent
 *
 * Utilisation typique :
 *   - Utilisé dans WindSimulator, PhysicsEngine, DebugRenderer, etc.
 *   - Sert à garantir la cohérence des échanges de données de vent
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 */

export interface WindParams {
  speed: number; // km/h
  direction: number; // degrés
  turbulence: number; // pourcentage
}

=== simulation/types/index.ts ===


/**
 * index.ts - Export centralisé de tous les types de la simulation Kite
 *
 * Rôle :
 *   - Centralise l'export des types physiques et de vent
 *   - Permet d'importer tous les types depuis un seul point
 *
 * Dépendances principales :
 *   - PhysicsTypes.ts : Types pour la physique
 *   - WindTypes.ts : Types pour le vent
 *
 * Relation avec les fichiers adjacents :
 *   - Sert de point d'entrée pour tous les imports de types dans le projet
 *
 * Utilisation typique :
 *   - Importé dans les modules physiques, de rendu, de configuration, etc.
 *   - Facilite la maintenance et la cohérence des types
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 *   - src/simulation/types/WindTypes.ts
 */

export * from './PhysicsTypes';
export * from './WindTypes';

=== simulation/ui/UIManager.ts ===

import { PhysicsEngine } from "../physics/PhysicsEngine";
import { CONFIG } from "../config/SimulationConfig";
import { DebugRenderer } from "../rendering/DebugRenderer";
import { KiteGeometry } from "../config/KiteGeometry";

/**
 * Gestionnaire de l'interface utilisateur
 *
 * Gère les contrôles et interactions utilisateur
 */
export class UIManager {
  private physicsEngine: PhysicsEngine;
  private debugRenderer: DebugRenderer;
  private resetCallback: () => void;
  private togglePlayCallback: () => void;

  constructor(
    physicsEngine: PhysicsEngine,
    debugRenderer: DebugRenderer,
    resetCallback: () => void,
    togglePlayCallback: () => void
  ) {
    this.physicsEngine = physicsEngine;
    this.debugRenderer = debugRenderer;
    this.resetCallback = resetCallback;
    this.togglePlayCallback = togglePlayCallback;
    this.setupControls();
  }

  private setupControls(): void {
    const resetBtn = document.getElementById("reset-sim");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.resetCallback();
      });
    }

    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.togglePlayCallback();
      });
    }

    const debugBtn = document.getElementById("debug-physics");
    if (debugBtn) {
      // Initialiser l'état du bouton
      debugBtn.textContent = this.debugRenderer.isDebugMode() ? "🔍 Debug ON" : "🔍 Debug OFF";
      debugBtn.classList.toggle("active", this.debugRenderer.isDebugMode());

      debugBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.debugRenderer.toggleDebugMode();
      });
    }

    // Activer la classe debug-mode sur le body si debugMode est true
    if (this.debugRenderer.isDebugMode()) {
      document.body.classList.add("debug-mode");
      // Afficher le panneau de debug si le mode debug est activé
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        debugPanel.style.display = "block";
      }
    }

    this.setupWindControls();
  }

  private setupWindControls(): void {
    // Configuration des contrôles de vent
    const speedSlider = document.getElementById(
      "wind-speed"
    ) as HTMLInputElement;
    const speedValue = document.getElementById("wind-speed-value");
    if (speedSlider && speedValue) {
      speedSlider.value = CONFIG.wind.defaultSpeed.toString();
      speedValue.textContent = `${CONFIG.wind.defaultSpeed} km/h`;

      speedSlider.oninput = () => {
        const speed = parseFloat(speedSlider.value);
        this.physicsEngine.setWindParams({ speed });
        speedValue.textContent = `${speed} km/h`;
      };
    }

    const dirSlider = document.getElementById(
      "wind-direction"
    ) as HTMLInputElement;
    const dirValue = document.getElementById("wind-direction-value");
    if (dirSlider && dirValue) {
      dirSlider.value = CONFIG.wind.defaultDirection.toString();
      dirValue.textContent = `${CONFIG.wind.defaultDirection}°`;

      dirSlider.oninput = () => {
        const direction = parseFloat(dirSlider.value);
        this.physicsEngine.setWindParams({ direction });
        dirValue.textContent = `${direction}°`;
      };
    }

    const turbSlider = document.getElementById(
      "wind-turbulence"
    ) as HTMLInputElement;
    const turbValue = document.getElementById("wind-turbulence-value");
    if (turbSlider && turbValue) {
      turbSlider.value = CONFIG.wind.defaultTurbulence.toString();
      turbValue.textContent = `${CONFIG.wind.defaultTurbulence}%`;

      turbSlider.oninput = () => {
        const turbulence = parseFloat(turbSlider.value);
        this.physicsEngine.setWindParams({ turbulence });
        turbValue.textContent = `${turbulence}%`;
      };
    }

    const lengthSlider = document.getElementById(
      "line-length"
    ) as HTMLInputElement;
    const lengthValue = document.getElementById("line-length-value");
    if (lengthSlider && lengthValue) {
      lengthSlider.value = CONFIG.lines.defaultLength.toString();
      lengthValue.textContent = `${CONFIG.lines.defaultLength}m`;

      lengthSlider.oninput = () => {
        const length = parseFloat(lengthSlider.value);
        this.physicsEngine.setLineLength(length);
        lengthValue.textContent = `${length}m`;
      };
    }

    // Contrôles des brides (3 sliders indépendants)
    // Récupérer les valeurs actuelles depuis le Kite
    const currentBridleLengths = this.physicsEngine.getBridleLengths();
    
    const bridleNezSlider = document.getElementById("bridle-nez") as HTMLInputElement;
    const bridleNezValue = document.getElementById("bridle-nez-value");
    if (bridleNezSlider && bridleNezValue) {
      bridleNezSlider.value = currentBridleLengths.nez.toString();
      bridleNezValue.textContent = `${currentBridleLengths.nez.toFixed(2)}m`;

      bridleNezSlider.oninput = () => {
        const length = parseFloat(bridleNezSlider.value);
        this.physicsEngine.setBridleLength('nez', length);
        bridleNezValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleInterSlider = document.getElementById("bridle-inter") as HTMLInputElement;
    const bridleInterValue = document.getElementById("bridle-inter-value");
    if (bridleInterSlider && bridleInterValue) {
      bridleInterSlider.value = currentBridleLengths.inter.toString();
      bridleInterValue.textContent = `${currentBridleLengths.inter.toFixed(2)}m`;

      bridleInterSlider.oninput = () => {
        const length = parseFloat(bridleInterSlider.value);
        this.physicsEngine.setBridleLength('inter', length);
        bridleInterValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleCentreSlider = document.getElementById("bridle-centre") as HTMLInputElement;
    const bridleCentreValue = document.getElementById("bridle-centre-value");
    if (bridleCentreSlider && bridleCentreValue) {
      bridleCentreSlider.value = currentBridleLengths.centre.toString();
      bridleCentreValue.textContent = `${currentBridleLengths.centre.toFixed(2)}m`;

      bridleCentreSlider.oninput = () => {
        const length = parseFloat(bridleCentreSlider.value);
        this.physicsEngine.setBridleLength('centre', length);
        bridleCentreValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    // Contrôles de damping physique
    const linearDampingSlider = document.getElementById(
      "linear-damping"
    ) as HTMLInputElement;
    const linearDampingValue = document.getElementById("linear-damping-value");
    if (linearDampingSlider && linearDampingValue) {
      linearDampingSlider.value = CONFIG.physics.linearDampingCoeff.toString();
      linearDampingValue.textContent = CONFIG.physics.linearDampingCoeff.toFixed(2);

      linearDampingSlider.oninput = () => {
        const damping = parseFloat(linearDampingSlider.value);
        CONFIG.physics.linearDampingCoeff = damping;
        linearDampingValue.textContent = damping.toFixed(2);
      };
    }

    const angularDampingSlider = document.getElementById(
      "angular-damping"
    ) as HTMLInputElement;
    const angularDampingValue = document.getElementById("angular-damping-value");
    if (angularDampingSlider && angularDampingValue) {
      angularDampingSlider.value = CONFIG.physics.angularDragFactor.toString();
      angularDampingValue.textContent = CONFIG.physics.angularDragFactor.toFixed(2);

      angularDampingSlider.oninput = () => {
        const dragFactor = parseFloat(angularDampingSlider.value);
        CONFIG.physics.angularDragFactor = dragFactor;
        angularDampingValue.textContent = dragFactor.toFixed(2);
      };
    }

    // 🔧 Contrôle du niveau de subdivision du maillage
    const meshLevelSlider = document.getElementById(
      "mesh-subdivision-level"
    ) as HTMLInputElement;
    const meshLevelValue = document.getElementById("mesh-subdivision-level-value");
    if (meshLevelSlider && meshLevelValue) {
      meshLevelSlider.value = CONFIG.kite.defaultMeshSubdivisionLevel.toString();
      meshLevelValue.textContent = `${CONFIG.kite.defaultMeshSubdivisionLevel} (${Math.pow(4, CONFIG.kite.defaultMeshSubdivisionLevel + 1)} triangles)`;

      meshLevelSlider.oninput = () => {
        const level = parseInt(meshLevelSlider.value);
        CONFIG.kite.defaultMeshSubdivisionLevel = level;
        KiteGeometry.setMeshSubdivisionLevel(level);
        const triangleCount = Math.pow(4, level + 1);
        meshLevelValue.textContent = `${level} (${triangleCount} triangles)`;
        console.log(`🔧 Maillage changé : niveau ${level} = ${triangleCount} triangles`);
      };
    }

    // Contrôles aérodynamiques
    const liftScaleSlider = document.getElementById(
      "lift-scale"
    ) as HTMLInputElement;
    const liftScaleValue = document.getElementById("lift-scale-value");
    if (liftScaleSlider && liftScaleValue) {
      liftScaleSlider.value = CONFIG.aero.liftScale.toString();
      liftScaleValue.textContent = CONFIG.aero.liftScale.toFixed(2);

      liftScaleSlider.oninput = () => {
        const scale = parseFloat(liftScaleSlider.value);
        CONFIG.aero.liftScale = scale;
        liftScaleValue.textContent = scale.toFixed(2);
      };
    }

    const dragScaleSlider = document.getElementById(
      "drag-scale"
    ) as HTMLInputElement;
    const dragScaleValue = document.getElementById("drag-scale-value");
    if (dragScaleSlider && dragScaleValue) {
      dragScaleSlider.value = CONFIG.aero.dragScale.toString();
      dragScaleValue.textContent = CONFIG.aero.dragScale.toFixed(2);

      dragScaleSlider.oninput = () => {
        const scale = parseFloat(dragScaleSlider.value);
        CONFIG.aero.dragScale = scale;
        dragScaleValue.textContent = scale.toFixed(2);
      };
    }

    // Contrôle du lissage des forces physiques
    const forceSmoothingSlider = document.getElementById(
      "force-smoothing"
    ) as HTMLInputElement;
    const forceSmoothingValue = document.getElementById("force-smoothing-value");
    if (forceSmoothingSlider && forceSmoothingValue) {
      forceSmoothingSlider.value = this.physicsEngine.getForceSmoothing().toString();
      forceSmoothingValue.textContent = this.physicsEngine.getForceSmoothing().toFixed(2);

      forceSmoothingSlider.oninput = () => {
        const smoothing = parseFloat(forceSmoothingSlider.value);
        this.physicsEngine.setForceSmoothing(smoothing);
        forceSmoothingValue.textContent = smoothing.toFixed(2);
      };
    }
  }

  updatePlayButton(isPlaying: boolean): void {
    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.textContent = isPlaying ? "⏸️ Pause" : "▶️ Lancer";
    }
  }
}

=== types/index.ts ===

/**
 * Types centralisés pour le système de visualisation 3D
 * Interface unique et cohérente pour tous les objets
 */

import * as THREE from 'three';

/**
 * Position 3D simple [x, y, z]
 */
export type Position3D = [number, number, number];

/**
 * Interface principale que TOUS les objets doivent implémenter
 * 🎮 v3.0: Compatible avec l'architecture StructuredObject + Node3D
 */
export interface ICreatable {
  /**
   * Retourne l'objet lui-même (StructuredObject hérite de Node3D)
   * Pattern fluent pour la nouvelle architecture
   */
  create(): this;

  /**
   * Nom affiché dans l'interface utilisateur
   */
  getName(): string;

  /**
   * Description courte de l'objet
   */
  getDescription(): string;

  /**
   * Nombre de primitives utilisées (pour statistiques)
   */
  getPrimitiveCount(): number;
}

/**
 * Options pour créer des surfaces
 */
export interface SurfaceOptions {
  color?: string;
  transparent?: boolean;
  opacity?: number;
  doubleSide?: boolean;
  wireframe?: boolean;
}

/**
 * Configuration pour les matériaux
 */
export interface MaterialConfig {
  color: string;
  transparent?: boolean;
  opacity?: number;
  metalness?: number;
  roughness?: number;
  side?: THREE.Side;
}

/**
 * Interface pour un point nommé dans l'espace 3D
 */
export interface NamedPoint {
  name: string;
  position: THREE.Vector3;
  visible?: boolean;
}

/**
 * Métadonnées optionnelles pour les objets
 */
export interface ObjectMetadata {
  category?: string;
  complexity?: 'simple' | 'medium' | 'complex';
  tags?: string[];
  author?: string;
  version?: string;
}

=== utils/GeometryUtils.ts ===

/**
 * GeometryUtils.ts - Utilitaires géométriques pour la simulation 3D
 */

import * as THREE from 'three';

export class GeometryUtils {
  /**
   * Calcule l'aire d'un triangle 3D
   */
  static triangleArea(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): number {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const cross = edge1.cross(edge2);
    return cross.length() * 0.5;
  }

  /**
   * Calcule la normale d'un triangle
   */
  static triangleNormal(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    return edge1.cross(edge2).normalize();
  }

  /**
   * Calcule le centroïde d'un triangle
   */
  static triangleCentroid(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3): THREE.Vector3 {
    return v1.clone().add(v2).add(v3).divideScalar(3);
  }

  /**
   * Vérifie si un point est à l'intérieur d'un triangle (dans le plan)
   */
  static pointInTriangle2D(point: THREE.Vector2, v1: THREE.Vector2, v2: THREE.Vector2, v3: THREE.Vector2): boolean {
    const d1 = this.sign(point, v1, v2);
    const d2 = this.sign(point, v2, v3);
    const d3 = this.sign(point, v3, v1);

    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(hasNeg && hasPos);
  }

  /**
   * Calcule le barycentre d'un ensemble de points
   */
  static centroid(points: THREE.Vector3[]): THREE.Vector3 {
    if (points.length === 0) return new THREE.Vector3();

    const sum = points.reduce((acc, point) => acc.add(point), new THREE.Vector3());
    return sum.divideScalar(points.length);
  }

  /**
   * Calcule la bounding box d'un ensemble de points
   */
  static boundingBox(points: THREE.Vector3[]): { min: THREE.Vector3; max: THREE.Vector3 } {
    if (points.length === 0) {
      return { min: new THREE.Vector3(), max: new THREE.Vector3() };
    }

    const min = points[0].clone();
    const max = points[0].clone();

    for (let i = 1; i < points.length; i++) {
      min.min(points[i]);
      max.max(points[i]);
    }

    return { min, max };
  }

  /**
   * Projette un point sur un plan défini par un point et une normale
   */
  static projectPointOnPlane(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): THREE.Vector3 {
    const toPoint = point.clone().sub(planePoint);
    const distance = toPoint.dot(planeNormal);
    return point.clone().sub(planeNormal.clone().multiplyScalar(distance));
  }

  /**
   * Calcule la distance d'un point à un plan
   */
  static pointToPlaneDistance(point: THREE.Vector3, planePoint: THREE.Vector3, planeNormal: THREE.Vector3): number {
    const toPoint = point.clone().sub(planePoint);
    return toPoint.dot(planeNormal);
  }

  /**
   * Vérifie si deux segments se croisent (2D)
   */
  static segmentsIntersect2D(
    a1: THREE.Vector2, a2: THREE.Vector2,
    b1: THREE.Vector2, b2: THREE.Vector2
  ): boolean {
    const denom = (a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x);
    if (Math.abs(denom) < 1e-6) return false; // Parallèles

    const t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x)) / denom;
    const u = -((a1.x - a2.x) * (a1.y - b1.y) - (a1.y - a2.y) * (a1.x - b1.x)) / denom;

    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }

  /**
   * Calcule l'angle solide d'un triangle vu depuis un point
   */
  static solidAngle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3, viewpoint: THREE.Vector3): number {
    const a = v1.clone().sub(viewpoint).normalize();
    const b = v2.clone().sub(viewpoint).normalize();
    const c = v3.clone().sub(viewpoint).normalize();

    const numerator = Math.abs(a.dot(b.cross(c)));
    const denominator = 1 + a.dot(b) + b.dot(c) + c.dot(a);
    return 2 * Math.atan2(numerator, denominator);
  }

  /**
   * Génère des points sur une sphère
   */
  static fibonacciSphere(samples: number, radius: number = 1): THREE.Vector3[] {
    const points: THREE.Vector3[] = [];
    const phi = Math.PI * (3 - Math.sqrt(5)); // Angle d'or

    for (let i = 0; i < samples; i++) {
      const y = 1 - (i / (samples - 1)) * 2; // y entre -1 et 1
      const radiusAtY = Math.sqrt(1 - y * y);

      const theta = phi * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      points.push(new THREE.Vector3(x, y, z).multiplyScalar(radius));
    }

    return points;
  }

  /**
   * Fonction auxiliaire pour pointInTriangle2D
   */
  private static sign(p1: THREE.Vector2, p2: THREE.Vector2, p3: THREE.Vector2): number {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
  }
}

=== utils/Logging.ts ===

/**
 * Logging.ts - Système de logging configurable pour la simulation
 */

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: number;
  category?: string;
  data?: any;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.INFO;
  private logs: LogEntry[] = [];
  private maxLogs: number = 1000;
  private categories: Set<string> = new Set();

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Configure le niveau de log minimum
   */
  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }

  /**
   * Active/désactive une catégorie de logs
   */
  setCategoryEnabled(category: string, enabled: boolean): void {
    if (enabled) {
      this.categories.add(category);
    } else {
      this.categories.delete(category);
    }
  }

  /**
   * Log de debug
   */
  debug(message: string, category?: string, data?: any): void {
    this.log(LogLevel.DEBUG, message, category, data);
  }

  /**
   * Log d'information
   */
  info(message: string, category?: string, data?: any): void {
    this.log(LogLevel.INFO, message, category, data);
  }

  /**
   * Log d'avertissement
   */
  warn(message: string, category?: string, data?: any): void {
    this.log(LogLevel.WARN, message, category, data);
  }

  /**
   * Log d'erreur
   */
  error(message: string, category?: string, data?: any): void {
    this.log(LogLevel.ERROR, message, category, data);
  }

  /**
   * Log générique
   */
  private log(level: LogLevel, message: string, category?: string, data?: any): void {
    // Vérifier le niveau
    if (level < this.logLevel) return;

    // Vérifier la catégorie si spécifiée
    if (category && !this.categories.has(category)) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: Date.now(),
      category,
      data
    };

    // Ajouter aux logs internes
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift(); // Supprimer le plus ancien
    }

    // Afficher dans la console selon le niveau
    const prefix = category ? `[${category}]` : '';
    const formattedMessage = `${prefix} ${message}`;

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(`🐛 ${formattedMessage}`, data || '');
        break;
      case LogLevel.INFO:
        console.info(`ℹ️ ${formattedMessage}`, data || '');
        break;
      case LogLevel.WARN:
        console.warn(`⚠️ ${formattedMessage}`, data || '');
        break;
      case LogLevel.ERROR:
        console.error(`❌ ${formattedMessage}`, data || '');
        break;
    }
  }

  /**
   * Obtient tous les logs
   */
  getLogs(level?: LogLevel, category?: string): LogEntry[] {
    return this.logs.filter(entry => {
      if (level !== undefined && entry.level < level) return false;
      if (category && entry.category !== category) return false;
      return true;
    });
  }

  /**
   * Obtient les derniers logs
   */
  getRecentLogs(count: number = 10): LogEntry[] {
    return this.logs.slice(-count);
  }

  /**
   * Efface tous les logs
   */
  clearLogs(): void {
    this.logs = [];
  }

  /**
   * Exporte les logs au format JSON
   */
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * Importe des logs depuis JSON
   */
  importLogs(json: string): void {
    try {
      const imported = JSON.parse(json) as LogEntry[];
      this.logs.push(...imported);
      // Garder seulement les maxLogs plus récents
      if (this.logs.length > this.maxLogs) {
        this.logs = this.logs.slice(-this.maxLogs);
      }
    } catch (error) {
      this.error('Erreur lors de l\'import des logs', 'Logger', error);
    }
  }

  /**
   * Statistiques des logs
   */
  getStats(): {
    total: number;
    byLevel: Record<LogLevel, number>;
    byCategory: Record<string, number>;
  } {
    const byLevel = {
      [LogLevel.DEBUG]: 0,
      [LogLevel.INFO]: 0,
      [LogLevel.WARN]: 0,
      [LogLevel.ERROR]: 0,
      [LogLevel.NONE]: 0
    };

    const byCategory: Record<string, number> = {};

    for (const entry of this.logs) {
      byLevel[entry.level]++;

      if (entry.category) {
        byCategory[entry.category] = (byCategory[entry.category] || 0) + 1;
      }
    }

    return {
      total: this.logs.length,
      byLevel,
      byCategory
    };
  }
}

// Instance globale pour utilisation facile
export const log = Logger.getInstance();

=== utils/MathUtils.ts ===

/**
 * MathUtils.ts - Utilitaires mathématiques pour la simulation 3D
 */

import * as THREE from 'three';

export class MathUtils {
  /**
   * Clamp une valeur entre min et max
   */
  static clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }

  /**
   * Interpolation linéaire
   */
  static lerp(a: number, b: number, t: number): number {
    return a + (b - a) * MathUtils.clamp(t, 0, 1);
  }

  /**
   * Interpolation sphérique (pour les rotations)
   */
  static slerp(q1: THREE.Quaternion, q2: THREE.Quaternion, t: number): THREE.Quaternion {
    return new THREE.Quaternion().slerpQuaternions(q1, q2, MathUtils.clamp(t, 0, 1));
  }

  /**
   * Distance euclidienne entre deux points 3D
   */
  static distance(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceTo(p2);
  }

  /**
   * Distance au carré (plus rapide pour les comparaisons)
   */
  static distanceSquared(p1: THREE.Vector3, p2: THREE.Vector3): number {
    return p1.distanceToSquared(p2);
  }

  /**
   * Angle entre deux vecteurs (en radians)
   */
  static angleBetween(v1: THREE.Vector3, v2: THREE.Vector3): number {
    return v1.angleTo(v2);
  }

  /**
   * Projection d'un vecteur sur un autre
   */
  static project(v: THREE.Vector3, onto: THREE.Vector3): THREE.Vector3 {
    const ontoNormalized = onto.clone().normalize();
    return ontoNormalized.multiplyScalar(v.dot(ontoNormalized));
  }

  /**
   * Composante perpendiculaire d'un vecteur par rapport à un autre
   */
  static perpendicular(v: THREE.Vector3, to: THREE.Vector3): THREE.Vector3 {
    return v.clone().sub(this.project(v, to));
  }

  /**
   * Vérifie si un nombre est proche de zéro
   */
  static isZero(value: number, epsilon: number = 1e-6): boolean {
    return Math.abs(value) < epsilon;
  }

  /**
   * Vérifie si deux nombres sont égaux avec une tolérance
   */
  static equals(a: number, b: number, epsilon: number = 1e-6): boolean {
    return Math.abs(a - b) < epsilon;
  }

  /**
   * Génère un nombre aléatoire entre min et max
   */
  static random(min: number = 0, max: number = 1): number {
    return Math.random() * (max - min) + min;
  }

  /**
   * Convertit degrés en radians
   */
  static degToRad(degrees: number): number {
    return degrees * Math.PI / 180;
  }

  /**
   * Convertit radians en degrés
   */
  static radToDeg(radians: number): number {
    return radians * 180 / Math.PI;
  }

  /**
   * Normalise un angle en radians entre -PI et PI
   */
  static normalizeAngle(angle: number): number {
    while (angle > Math.PI) angle -= 2 * Math.PI;
    while (angle < -Math.PI) angle += 2 * Math.PI;
    return angle;
  }

  /**
   * Interpolation smoothstep (plus douce que lerp)
   */
  static smoothstep(edge0: number, edge1: number, x: number): number {
    const t = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  }

  /**
   * Fonction de easing (ease-in-out)
   */
  static easeInOut(t: number): number {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }
}

=== utils/UidGenerator.ts ===

/**
 * UidGenerator.ts - Générateur d'identifiants uniques
 */

export class UidGenerator {
  private static counter = 0;
  private static readonly chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

  /**
   * Génère un UID simple basé sur timestamp et compteur
   */
  static generate(prefix: string = ''): string {
    const timestamp = Date.now().toString(36);
    const count = (this.counter++).toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    return `${prefix}${timestamp}${count}${random}`;
  }

  /**
   * Génère un UID court (8 caractères)
   */
  static generateShort(): string {
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += this.chars.charAt(Math.floor(Math.random() * this.chars.length));
    }
    return result;
  }

  /**
   * Génère un UID basé sur des propriétés d'objet
   */
  static generateFromObject(obj: any, properties: string[]): string {
    let hash = 0;
    const str = properties.map(prop => obj[prop] || '').join('|');

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }

  /**
   * Génère un UUID v4 standard
   */
  static generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Génère un ID séquentiel
   */
  static generateSequential(prefix: string = 'id_'): string {
    return `${prefix}${(this.counter++).toString().padStart(6, '0')}`;
  }

  /**
   * Réinitialise le compteur (utile pour les tests)
   */
  static reset(): void {
    this.counter = 0;
  }

  /**
   * Vérifie si une chaîne est un UID valide (format de base)
   */
  static isValid(uid: string): boolean {
    // Vérification basique : contient des lettres, chiffres, et fait une longueur raisonnable
    return /^[A-Za-z0-9_-]{8,}$/.test(uid);
  }

  /**
   * Génère un hash simple d'une chaîne
   */
  static hashString(str: string): string {
    let hash = 0;
    if (str.length === 0) return hash.toString(36);

    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convertir en 32 bits
    }

    return Math.abs(hash).toString(36);
  }
}

