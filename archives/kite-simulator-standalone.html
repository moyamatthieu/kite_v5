<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur de Cerf-volant 3D - Version Avancée</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
            user-select: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            color: white;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #info-panel {
            top: 20px;
            left: 20px;
            min-width: 280px;
        }

        .info-header h2 {
            font-size: 20px;
            margin: 0 0 15px 0;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .info-unit {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        #control-panel {
            top: 20px;
            right: 20px;
            width: 320px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #29b6f6;
            cursor: pointer;
        }

        #quick-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 15px 20px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 30px;
        }

        .control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #wind-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
        }

        #wind-indicator:hover {
            border-color: rgba(79, 195, 247, 0.8);
            background: rgba(30, 30, 40, 0.95);
            transform: scale(1.05);
        }

        .wind-compass {
            width: 80px;
            height: 80px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        .wind-arrow {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 25px solid #29b6f6;
            transform-origin: 50% 35px;
            transform: translateX(-50%);
            transition: transform 0.3s ease;
        }

        .wind-arrow::before {
            display: none;
        }

        .wind-speed {
            margin-top: 8px;
            font-size: 12px;
            font-weight: 600;
            color: white;
            text-align: center;
        }

        /* Points cardinaux */
        .compass-point {
            position: absolute;
            font-size: 9px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.6);
        }

        .compass-point.north {
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-point.south {
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-point.east {
            right: 3px;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-point.west {
            left: 3px;
            top: 50%;
            transform: translateY(-50%);
        }

        .wind-direction-label {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            white-space: nowrap;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #29b6f6;
        }

        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active .toggle-knob {
            transform: translateX(24px);
        }

        @media (max-width: 768px) {
            #control-panel {
                width: 280px;
            }
            .info-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Console Log Panel */
        #console-panel {
            user-select: text;
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 400px;
            height: 200px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            z-index: 1000;
        }

        #console-header {
            font-size: 12px;
            color: rgba(0, 255, 0, 0.8);
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }

        #console-content {
            user-select: text;
            flex: 1;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
        }

        .console-line {
            margin-bottom: 2px;
            word-wrap: break-word;
        }

        .console-line.info {
            color: #00ff00;
        }

        .console-line.warn {
            color: #ffaa00;
        }

        .console-line.error {
            color: #ff4444;
        }

        .console-line.debug {
            color: #88ccff;
        }

        /* Legend Panel - Positionné sous le panneau de contrôle */
        #legend-panel {
            position: absolute;
            top: 400px;  /* Positionné sous le panneau de contrôle */
            right: 20px;
            width: 320px;  /* Même largeur que le panneau de contrôle */
            max-height: 500px;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            color: white;
            overflow-y: auto;
            z-index: 1000;
        }

        #legend-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #4fc3f7;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .legend-section {
            margin-bottom: 20px;
        }

        .legend-section h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
            border-left: 3px solid #4fc3f7;
            padding-left: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 8px;
            border-radius: 2px;
        }

        .legend-arrow {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .legend-description {
            flex: 1;
            line-height: 1.2;
        }

        /* Toggle buttons for panels */
        .panel-toggle {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 12px;
            cursor: pointer;
            z-index: 1001;
        }

        #console-toggle {
            bottom: 230px;
            left: 20px;
        }

        #legend-toggle {
            top: 380px;  /* Juste au-dessus de la légende */
            right: 20px;
        }

        .panel-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        /* === NOUVEAUX STYLES POUR LES AMÉLIORATIONS === */

        /* Sélecteur de météo */
        .weather-select {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 14px;
            cursor: pointer;
        }

        .weather-select option {
            background: #2a2a3a;
            color: white;
        }

        .weather-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Indicateur de rafale */
        .gust-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 0, 0.8);
            color: #000;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            animation: gustPulse 0.5s ease-in-out infinite alternate;
            z-index: 1000;
            display: none;
        }

        @keyframes gustPulse {
            0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Particules de vent - Toggle */
        .wind-particles-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .wind-particles-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .wind-particles-toggle.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }

        /* Effets de collision */
        .collision-effect {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            animation: collisionEffect 1s ease-out forwards;
        }

        @keyframes collisionEffect {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(2) translateY(-20px);
            }
        }

        /* Améliorations pour les contrôles météo */
        .control-section h3 {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weather-transition {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
            padding: 8px 12px;
            margin: 10px 0;
            border-radius: 0 5px 5px 0;
            font-size: 12px;
            animation: weatherTransition 0.3s ease-in-out;
        }

        @keyframes weatherTransition {
            0% { opacity: 0; transform: translateX(-10px); }
            100% { opacity: 1; transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Console Log Panel -->
    <div id="console-panel">
        <div id="console-header">📊 Console du Simulateur</div>
        <div id="console-content"></div>
    </div>
    <button id="console-toggle" class="panel-toggle">Masquer Console</button>

    <!-- Legend Panel -->
    <div id="legend-panel">
        <div id="legend-header">🎯 Légende des Vecteurs</div>
        
        <div class="legend-section">
            <h4>Forces Aérodynamiques</h4>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #00ff00;">↑</div>
                <div class="legend-description">
                    <strong>Portance</strong> - Force vers le haut
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #ff0000;">→</div>
                <div class="legend-description">
                    <strong>Traînée</strong> - Résistance à l'air
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #ff8800;">↗</div>
                <div class="legend-description">
                    <strong>Force Aéro</strong> - Résultante
                </div>
            </div>
        </div>

        <div class="legend-section">
            <h4>Vitesses & Vent</h4>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #ffff00;">→</div>
                <div class="legend-description">
                    <strong>Vitesse Kite</strong> - Déplacement
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #0088ff;">→</div>
                <div class="legend-description">
                    <strong>Vent</strong> - Direction et force
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #00ffff;">→</div>
                <div class="legend-description">
                    <strong>Vent Relatif</strong> - Vent perçu
                </div>
            </div>
        </div>

        <div class="legend-section">
            <h4>Forces & Contrôles</h4>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #ff6600;">↓</div>
                <div class="legend-description">
                    <strong>Gravité</strong> - Poids du kite
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #ffffff;">↗</div>
                <div class="legend-description">
                    <strong>Tension</strong> - Force des lignes
                </div>
            </div>
            <div class="legend-item">
                <div class="legend-arrow" style="color: #88ff88;">⊥</div>
                <div class="legend-description">
                    <strong>Normale</strong> - Perpendiculaire voile
                </div>
            </div>
        </div>

        <div class="legend-section">
            <h4>Contrôles</h4>
            <div style="font-size: 10px; color: rgba(255,255,255,0.7); line-height: 1.2;">
                📷 <strong>CAMÉRA:</strong> ZQSD déplacer • A/E haut/bas • Molette zoom • C reset<br>
                🪁 <strong>CERF-VOLANT:</strong> ← → Barre de contrôle • ↑ ↓ Trim (futur)<br>
                💨 <strong>VENT:</strong> + - Vitesse • Clic boussole pour direction<br>
                ⌨️ <strong>GÉNÉRAL:</strong> R reset • Espace lancer • F mode caméra • P pause
            </div>
        </div>
    </div>
    <button id="legend-toggle" class="panel-toggle">Masquer Légende</button>

    <!-- Info Panel -->
    <div id="info-panel" class="ui-panel">
        <div class="info-header">
            <h2>Données de Vol</h2>
        </div>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Altitude</div>
                <div class="info-value">
                    <span id="altitude">0.0</span>
                    <span class="info-unit">m</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Distance</div>
                <div class="info-value">
                    <span id="distance">0.0</span>
                    <span class="info-unit">m</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Vitesse</div>
                <div class="info-value">
                    <span id="speed">0.0</span>
                    <span class="info-unit">m/s</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Angle d'attaque</div>
                <div class="info-value">
                    <span id="aoa">0</span>
                    <span class="info-unit">°</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Tension G</div>
                <div class="info-value">
                    <span id="tensionLeft">0.0</span>
                    <span class="info-unit">N</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Tension D</div>
                <div class="info-value">
                    <span id="tensionRight">0.0</span>
                    <span class="info-unit">N</span>
                </div>
            </div>
            <div class="info-item">
                <div class="info-label">Contrôle Barre</div>
                <div class="info-value">
                    <span id="controlAngle">0.0</span>
                    <span class="info-unit">°</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div id="control-panel" class="ui-panel">
        <div class="control-section">
            <h3>🌬️ Conditions de Vent</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Vitesse du vent</span>
                    <span id="windSpeedValue">5.0 m/s</span>
                </div>
                <input type="range" class="slider" id="windSpeed" min="0" max="20" value="5" step="0.5">
            </div>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Turbulences</span>
                    <span id="turbulenceValue">20%</span>
                </div>
                <input type="range" class="slider" id="turbulence" min="0" max="100" value="20" step="5">
            </div>
        </div>
        
        <div class="control-section">
            <h3>🪁 Options</h3>
            <div class="toggle-container">
                <span>Annotations</span>
                <div class="toggle-switch" id="annotationsToggle">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            <div class="toggle-container">
                <span>Trajectoire</span>
                <div class="toggle-switch active" id="trailToggle">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            <div class="toggle-container">
                <span>Télémétrie</span>
                <div class="toggle-switch" id="telemetryToggle">
                    <div class="toggle-knob"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quick Controls -->
    <div id="quick-controls">
        <button class="control-btn" id="launchBtn">
            <span>🚀</span>
            <span>Lancer</span>
        </button>
        <button class="control-btn" id="resetBtn">
            <span>🔄</span>
            <span>Réinitialiser</span>
        </button>
        <button class="control-btn" id="pauseBtn">
            <span>⏸️</span>
            <span>Pause</span>
        </button>
    </div>

    <!-- Wind Indicator -->
    <div id="wind-indicator">
        <div class="wind-compass">
            <div class="compass-point north">N</div>
            <div class="compass-point south">S</div>
            <div class="compass-point east">E</div>
            <div class="compass-point west">W</div>
            <div class="wind-arrow" id="windArrow"></div>
            <div class="wind-direction-label" id="windDirectionLabel">N</div>
        </div>
        <div class="wind-speed" id="windSpeedIndicator">5.0 m/s</div>
    </div>

    <!-- Indicateur de rafales -->
    <div id="gust-indicator" class="gust-indicator" style="display: none;">
        💨 RAFALE !
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // =====================================================================================
        // === RÉSUMÉ COMPLET DE LA CAUSALITÉ DU SIMULATEUR DE CERF-VOLANT ===
        // =====================================================================================
        /**
         * ARCHITECTURE GLOBALE ET FLUX DE DONNÉES
         * =======================================
         * 
         * Ce simulateur est organisé selon une architecture modulaire avec des interactions
         * claires entre les différents composants. Voici le flux complet de causalité :
         * 
         * 1. INITIALISATION (Constructor → init() → initializeEnvironmentAsync())
         *    ├─ Création de la scène 3D (Three.js)
         *    ├─ Configuration de la physique et des contrôles
         *    ├─ Construction progressive de l'environnement (terrain, ciel, station)
         *    ├─ Création du cerf-volant avec sa géométrie complexe
         *    ├─ Mise en place des lignes de vol et systèmes de traînée
         *    └─ Activation de la boucle de rendu principale
         * 
         * 2. BOUCLE PRINCIPALE (animate() → updatePhysics() → render())
         *    ├─ Calcul des forces aérodynamiques basé sur le vent relatif
         *    ├─ Intégration physique (vitesse, position, rotation)
         *    ├─ Application des contraintes (lignes, sol, limites)
         *    ├─ Mise à jour des éléments visuels (cerf-volant, lignes, traînée)
         *    └─ Rendu de la scène 3D
         * 
         * 3. SYSTÈME DE VENT (Direction contrôlable → Forces → Réaction du cerf-volant)
         *    ├─ Interface utilisateur : Boussole interactive (setupWindDirectionControl)
         *    ├─ Calcul vectoriel : Direction → Vecteur 3D (calculateWindForce)
         *    ├─ Physique : Vent relatif → Portance + Traînée (calculateAerodynamicForces)
         *    ├─ Intégration : Forces → Accélération → Vitesse → Position
         *    └─ Feedback visuel : Manche à air, indicateurs, télémétrie
         * 
         * 4. INTERACTION UTILISATEUR (Events → State → Simulation)
         *    ├─ Contrôles directionels : Boussole cliquable pour direction du vent
         *    ├─ Sliders : Vitesse du vent et turbulences en temps réel
         *    ├─ Boutons : Lancement, reset, toggles d'affichage
         *    ├─ Caméra : Contrôles souris pour navigation 3D
         *    └─ Clavier : Contrôles directs du cerf-volant (roulis)
         * 
         * 5. SYSTÈMES DE FEEDBACK (Simulation → Affichage → Utilisateur)
         *    ├─ Console de debug : Logs en temps réel des événements
         *    ├─ Télémétrie : Affichage des forces et paramètres physiques
         *    ├─ Indicateurs visuels : Manche à air, vecteurs de force
         *    ├─ Interface graphique : Valeurs numériques, graphiques
         *    └─ Traînée visuelle : Historique de la trajectoire
         * 
         * RELATIONS DE CAUSALITÉ CLÉS :
         * =============================
         * 
         * • Direction du vent (UI) → calculateWindForce() → Forces aérodynamiques
         * • Forces aérodynamiques → updatePhysics() → Position/Rotation du cerf-volant
         * • Position du cerf-volant → updateLines() → Tension des lignes
         * • Tension des lignes → Contraintes physiques → Limitation du mouvement
         * • Mouvement du cerf-volant → updateTrail() → Traînée visuelle
         * • État global → updateTelemetry() → Affichage des instruments
         * • Événements utilisateur → State updates → Réaction immédiate de la simulation
         * 
         * POINTS DE CONTRÔLE CRITIQUES :
         * ==============================
         * 
         * • STABILITÉ : Limitations de forces et vitesses pour éviter l'instabilité
         * • RÉALISME : Coefficients aérodynamiques basés sur la physique réelle
         * • PERFORMANCE : Optimisations pour maintenir 60 FPS
         * • ROBUSTESSE : Gestion d'erreurs et reset automatique en cas de problème
         * • EXPÉRIENCE : Interface intuitive avec feedback immédiat
         * 
         * Cette architecture garantit une simulation cohérente où chaque action de
         * l'utilisateur produit une réaction physiquement plausible et visuellement
         * satisfaisante du cerf-volant.
         */

        // =====================================================================================
        // === SYSTÈME D'OPTIMISATION DES PERFORMANCES ===
        // =====================================================================================

        // === POOL D'OBJETS POUR RÉDUIRE LES ALLOCATIONS MÉMOIRE ===
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 10) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.available = [];
                this.inUse = new Set();
                
                // Pré-allocation
                for (let i = 0; i < initialSize; i++) {
                    this.available.push(createFn());
                }
            }
            
            acquire() {
                let obj = this.available.pop();
                if (!obj) {
                    obj = this.createFn();
                }
                this.inUse.add(obj);
                return obj;
            }
            
            release(obj) {
                if (this.inUse.has(obj)) {
                    this.inUse.delete(obj);
                    this.resetFn(obj);
                    this.available.push(obj);
                }
            }
            
            clear() {
                this.available.length = 0;
                this.inUse.clear();
            }
        }

        // === POOLS GLOBAUX ===
        const VECTOR_POOL = new ObjectPool(
            () => new THREE.Vector3(),
            (v) => v.set(0, 0, 0),
            20
        );

        const QUATERNION_POOL = new ObjectPool(
            () => new THREE.Quaternion(),
            (q) => q.set(0, 0, 0, 1),
            10
        );

        // =====================================================================================
        // === ZONE DE CONFIGURATION GLOBALE DU SIMULATEUR DE CERF-VOLANT ===
        // =====================================================================================
        
        // === CONSTANTES PHYSIQUES ===
        const PHYSICS_CONSTANTS = {
            GRAVITY: -9.82,                       // Accélération gravitationnelle (m/s²)
            AIR_DENSITY_SEA_LEVEL: 1.225,         // Densité de l'air au niveau de la mer (kg/m³)
            HALF: 0.5,                            // Constante mathématique 1/2
            OSCILLATION_AMPLITUDE: 0.05,          // Amplitude des oscillations
            DIHEDRAL_FORCE_FACTOR: 0.5,           // Facteur de force dièdrale
            VECTOR_SCALE_FACTOR: 0.5,             // Facteur d'échelle pour affichage vecteurs
            CORRECTION_DAMPING: 0.5                // Facteur d'amortissement des corrections
        };
        
        const KITE_CONFIG = {
            // === PARAMÈTRES PHYSIQUES ===
            physics: {
                gravity: PHYSICS_CONSTANTS.GRAVITY,
                airDensity: PHYSICS_CONSTANTS.AIR_DENSITY_SEA_LEVEL,
                kiteMass: 0.8,                     // Masse du cerf-volant augmentée pour stabilité (kg)
                kiteArea: 2.4,                     // Surface de la voile (m²)
                dragCoefficient: 0.06,             // Coefficient de traînée augmenté
                liftCoefficientMax: 1.2,           // Coefficient de portance maximum
                windSpeed: 5.0,                    // Vitesse du vent par défaut (m/s)
                windTurbulenceScale: 0.3,          // Échelle de turbulence (0-1)
                lineLength: 25,                    // Longueur des lignes (m)
                lineStiffness: 50,                 // Rigidité des lignes
                lineDamping: 0.98                  // Amortissement des lignes
            },
            
            // === DIMENSIONS DU CERF-VOLANT ===
            kite: {
                initialPosition: { x: 0, y: 10, z: -10 },  // Position initiale (déplacé de 10m vers l'arrière)
                width: 3.0,                              // Envergure (m)
                height: 2.0,                             // Hauteur (m)
                depth: 0.15,                             // Profondeur des whiskers (m)
                color: 0xff4444                          // Couleur de la voile
            },
            
            // === PARAMÈTRES VISUELS ===
            visual: {
                // Points de connexion
                connectorSize: 0.03,               // Taille des sphères de connexion (m)
                annotationScale: { x: 0.4, y: 0.1, z: 1 },  // Échelle des annotations
                annotationOffset: { x: 0, y: 0.15, z: 0 },  // Décalage des annotations
                
                // Barres structurelles
                frameRadius: {
                    main: 0.03,                    // Rayon des barres principales (m)
                    whisker: 0.02                  // Rayon des barres whisker (m)
                },
                frameColor: 0x2a2a2a,              // Couleur des barres (gris foncé)
                
                // Bords de tissu
                fabricEdgeColor: 0x000000,         // Couleur des bords (noir)
                fabricEdgeWidth: 4,                // Épaisseur des bords
                
                // Lignes de bridage
                bridleColor: 0x000000,             // Couleur des brides (noir)
                bridleWidth: 2,                    // Épaisseur des brides
                
                // Lignes de vol
                flyLineColor: 0x000000,            // Couleur des lignes de vol (noir)
                flyLineWidth: 2,                   // Épaisseur des lignes de vol
                
                // Traînée
                trailColor: 0xff4444,              // Couleur de la traînée
                trailOpacity: 0.6,                 // Opacité de la traînée
                trailWidth: 3,                     // Épaisseur de la traînée
                trailMaxPoints: 100                // Nombre maximum de points de traînée
            },
            
            // === ENVIRONNEMENT ===
            environment: {
                // Sol
                groundSize: 300,                   // Taille du sol (m x m)
                groundColor: 0x90EE90,             // Couleur du sol (vert clair)
                
                // Grille
                gridSize: 300,                     // Taille de la grille (m)
                gridDivisions: 40,                 // Nombre de divisions
                gridColorMain: 0x444444,           // Couleur principale de la grille
                gridColorSub: 0x888888,            // Couleur secondaire de la grille
                
                // Ciel
                skySize: 400,                      // Rayon de la sphère du ciel (m)
                skyColor: 0x87CEEB,                // Couleur du ciel (bleu ciel)
                fogColor: 0x87CEEB,                // Couleur du brouillard
                fogNear: 100,                      // Distance proche du brouillard
                fogFar: 1000                       // Distance lointaine du brouillard
            },
            
            // === STATION DE CONTRÔLE ===
            controlStation: {
                // Base
                baseSize: { width: 1.5, height: 0.2, depth: 1.5 },
                baseColor: 0x2196f3,               // Bleu
                
                // Poteau
                poleRadius: 0.03,
                poleHeight: 1.3,
                poleColor: 0x333333,               // Gris foncé
                
                // Poignées
                handleRadius: 0.08,
                handleColor: 0xff6b35,             // Orange
                handlePositions: { left: -0.3, right: 0.3, height: 1.2 },
                
                // Barre de contrôle
                controlBarRadius: 0.015,
                controlBarLength: 0.8,
                controlBarColor: 0x444444,         // Gris
                
                // Points d'attache
                attachRadius: 0.03,
                attachColor: 0x333333,             // Gris foncé
                attachPositions: { left: -0.35, right: 0.35, height: 1.2 }
            },
            
            // === MANCHE À AIR ===
            windsock: {
                // Position
                position: { x: -5, y: 0, z: 0 },  // Position relative à la station
                
                // Mât
                mastRadius: 0.04,
                mastHeight: 4.0,
                mastColor: 0xf0f0f0,               // Blanc
                
                // Base
                baseRadius: 0.15,
                baseHeight: 0.1,
                baseColor: 0x808080,               // Gris
                
                // Girouette
                ringOuterRadius: 0.25,
                ringInnerRadius: 0.02,
                ringColor: 0xf0f0f0,               // Blanc
                ringHeight: 4.0,
                
                // Support
                supportRadius: 0.015,
                supportHeight: 0.3,
                supportColor: 0x333333,            // Gris foncé
                
                // Segments de la manche (OACI)
                segments: [
                    { radius: 0.15, length: 0.24, color: 0xff0000 },  // Rouge
                    { radius: 0.13, length: 0.24, color: 0xffffff },  // Blanc
                    { radius: 0.11, length: 0.24, color: 0xff0000 },  // Rouge
                    { radius: 0.09, length: 0.24, color: 0xffffff },  // Blanc
                    { radius: 0.07, length: 0.24, color: 0xff0000 }   // Rouge (pointe)
                ],
                segmentOpacity: 0.9,
                
                // Animation
                animationSpeed: 1.5,               // Vitesse d'oscillation naturelle
                oscillationAmplitude: 0.01,        // Amplitude des oscillations
                windExtensionFactor: 0.08,         // Facteur d'extension selon le vent
                maxExtension: 0.25                 // Extension maximum
            },
            
            // === ÉCLAIRAGE ===
            lighting: {
                // Lumière ambiante
                ambientIntensity: 0.6,
                ambientColor: 0xffffff,            // Blanc
                
                // Lumière directionnelle
                directionalIntensity: 0.8,
                directionalColor: 0xffffff,        // Blanc
                directionalPosition: { x: 50, y: 100, z: 50 },
                
                // Ombres
                shadowMapSize: 2048,               // Taille de la carte d'ombres
                shadowType: 'PCFSoft'              // Type d'ombres
            },
            
            // === CAMÉRA ===
            camera: {
                // === PARAMÈTRES DE BASE ===
                fov: 60,                           // Champ de vision (degrés)
                near: 0.1,                         // Plan proche
                far: 1000,                         // Plan lointain
                initialPosition: { x: 0, y: 10, z: 30 },
                lookAt: { x: 0, y: 5, z: 0 },
                
                // === CONTRÔLES DE MOUVEMENT ===
                movement: {
                    speed: 15,                     // Vitesse de déplacement (m/s)
                    zoomSpeed: 3,                  // Vitesse de zoom
                    rotationSensitivity: 0.003,    // Sensibilité rotation souris
                    minDistance: 5,                // Distance minimum
                    maxDistance: 100,              // Distance maximum
                    constrainToGround: true,       // Empêcher de passer sous le sol
                    groundHeight: 0.5              // Hauteur minimale au-dessus du sol
                },
                
                // === CONTRÔLES CLAVIER AZERTY ===
                controls: {
                    forward: 'KeyZ',               // Avancer
                    backward: 'KeyS',              // Reculer
                    left: 'KeyQ',                  // Aller à gauche
                    right: 'KeyD',                 // Aller à droite
                    up: 'KeyA',                    // Monter
                    down: 'KeyE',                  // Descendre
                    toggleMode: 'KeyF',            // Basculer entre modes libre/suivi
                    reset: 'KeyC'                  // Reset caméra
                },
                
                // === MODE SUIVI AUTOMATIQUE ===
                followMode: {
                    distance: 15,                  // Distance de suivi du cerf-volant
                    height: 8,                     // Hauteur relative de suivi
                    smoothing: 0.05,               // Facteur de lissage du suivi (0-1)
                    manualAdjustmentSpeed: 2,      // Vitesse des ajustements manuels en mode suivi
                    lookAheadDistance: 5,          // Distance de prédiction du mouvement
                    verticalDamping: 0.8           // Amortissement des mouvements verticaux
                },
                
                // === ZOOM INTELLIGENT ===
                intelligentZoom: {
                    enabled: true,                 // Activer le zoom vers le cerf-volant
                    targetOffset: 2,               // Décalage du point cible pour le zoom
                    speedMultiplier: 1.5,          // Multiplicateur de vitesse de zoom
                    minZoomDistance: 3,            // Distance minimum de zoom
                    maxZoomDistance: 50            // Distance maximum de zoom
                }
            },
            
            // === PHYSIQUE AÉRODYNAMIQUE ===
            aerodynamics: {
                // Coefficients de portance par angle d'attaque
                liftCurve: {
                    linearZone: { min: 0, max: 15, coeff: 0.08 },      // Zone linéaire
                    transitionZone: { min: 15, max: 25 },              // Zone de transition
                    stallZone: { min: 25, falloff: 0.03 }              // Zone de décrochage
                },
                
                // Facteurs de stabilité
                stability: {
                    dihedral: 0.5,                 // Effet dièdre (stabilité latérale)
                    pitchDamping: 0.3,             // Amortissement en tangage
                    yawDamping: 0.4,               // Amortissement en lacet
                    dampingFactor: 0.95            // Facteur d'amortissement général
                },
                
                // Limites de sécurité
                limits: {
                    maxVelocity: 30,               // Vitesse maximum (m/s)
                    maxForce: 500,                 // Force maximum (N)
                    maxAngularVelocity: 5,         // Vitesse angulaire max (rad/s)
                    emergencyResetThreshold: 100   // Seuil de reset d'urgence
                }
            },
            
            // === SYSTÈME DE VENT ===
            wind: {
                // === PARAMÈTRES DE BASE ===
                defaultSpeed: 5.0,                 // Vitesse par défaut (m/s)
                defaultDirection: 0,               // Direction par défaut (degrés)
                minSpeed: 0,                       // Vitesse minimum
                maxSpeed: 15,                      // Vitesse maximum
                
                // === EFFETS ENVIRONNEMENTAUX ===
                altitude: {
                    gradient: 0.02,                // Gradient d'altitude (2% par mètre)
                    reference: 50,                 // Hauteur de référence (m)
                    maxHeight: 100                 // Hauteur maximum considérée
                },
                
                // === TURBULENCES ===
                turbulence: {
                    scale: 0.3,                    // Échelle par défaut (0-1)
                    frequency: 2.0,                // Fréquence des variations
                    amplitude: 0.1,                // Amplitude des turbulences
                    minScale: 0,                   // Turbulence minimum
                    maxScale: 1.0                  // Turbulence maximum
                },
                
                // === INTERFACE UTILISATEUR ===
                ui: {
                    compassSize: 150,              // Taille de la boussole (px)
                    compassSensitivity: 1.0,       // Sensibilité de rotation
                    updateInterval: 50,            // Intervalle de mise à jour (ms)
                    smoothing: 0.1                 // Lissage des changements
                },
                
                // === INDICATEURS VISUELS ===
                indicators: {
                    arrowScale: 1.5,               // Échelle de la flèche directionnelle
                    arrowColor: 0xff6b35,          // Couleur de la flèche (orange)
                    windsockAnimation: true,       // Animation de la manche à air
                    responseSpeed: 2.0             // Vitesse de réponse des indicateurs
                }
            },
            
            // === SYSTÈME DE CONTRÔLES ===
            controls: {
                // === CLAVIER (CERF-VOLANT) ===
                kite: {
                    rollLeft: 'ArrowLeft',         // Roulis gauche
                    rollRight: 'ArrowRight',       // Roulis droit
                    pitchUp: 'ArrowUp',            // Cabrer
                    pitchDown: 'ArrowDown',        // Piquer
                    sensitivity: 2.0,              // Sensibilité des contrôles
                    deadzone: 0.01                 // Zone morte
                },
                
                // === SOURIS ===
                mouse: {
                    rotationSensitivity: 0.003,    // Sensibilité de rotation
                    zoomSensitivity: 1.0,          // Sensibilité du zoom
                    panSensitivity: 1.0,           // Sensibilité du panoramique
                    invertY: false                 // Inverser l'axe Y
                },
                
                // === ACTIONS PRINCIPALES ===
                actions: {
                    launch: 'Space',               // Lancer/atterrir
                    reset: 'KeyR',                 // Réinitialiser
                    toggleAnnotations: 'KeyH',     // Basculer annotations
                    toggleTelemetry: 'KeyT',       // Basculer télémétrie
                    toggleTrail: 'KeyL'            // Basculer traînée
                },
                
                // === INTERFACE UTILISATEUR ===
                ui: {
                    sliderUpdateInterval: 50,      // Intervalle de mise à jour (ms)
                    buttonFeedbackDuration: 200,   // Durée du feedback visuel (ms)
                    animationSpeed: 0.3            // Vitesse des animations
                }
            },
            
            // === SYSTÈME DE LIGNES ===
            lines: {
                // === PARAMÈTRES PHYSIQUES ===
                length: 25,                        // Longueur par défaut (m)
                stiffness: 50,                     // Rigidité
                damping: 0.98,                     // Amortissement
                elasticity: 0.1,                   // Élasticité
                
                // === CONTRAINTES ===
                maxTension: 200,                   // Tension maximum (N)
                tensionMultiplier: 15,             // Multiplicateur de force de tension
                breakingPoint: 300,                // Point de rupture (N)
                
                // === VISUALISATION ===
                visual: {
                    color: 0x000000,               // Couleur des lignes (noir)
                    width: 2,                      // Épaisseur
                    segments: 20,                  // Nombre de segments pour la courbure
                    opacity: 1.0,                  // Opacité
                    showTension: false             // Afficher les forces de tension
                },
                
                // === POINTS D'ATTACHE ===
                attachments: {
                    ground: {
                        left: { x: -0.35, y: 1.2, z: 0 },     // Attache gauche
                        right: { x: 0.35, y: 1.2, z: 0 }      // Attache droite
                    },
                    kite: {
                        leftControl: "P_CONTROLE_G",           // Point de contrôle gauche
                        rightControl: "P_CONTROLE_D"           // Point de contrôle droit
                    }
                }
            },
            
            // === INTERFACE UTILISATEUR ===
            ui: {
                updateInterval: 16,                // Intervalle de mise à jour (ms) - 60 FPS max
                
                // Animations des boutons
                buttonAnimationDuration: 200,     // Durée des animations (ms)
                launchButtonColor: 'rgba(76, 175, 80, 0.3)',   // Vert
                resetButtonColor: 'rgba(255, 152, 0, 0.3)'     // Orange
            },
            
            // === PERFORMANCE ===
            performance: {
                maxDeltaTime: 0.016,               // Delta temps maximum (60 FPS)
                asyncInitDelay: 10,                // Délai entre les étapes d'init (ms)
                geometrySegments: {
                    sphere: 16,                    // Segments des sphères
                    cylinder: 8,                   // Segments des cylindres
                    cone: 8                        // Segments des cônes
                }
            },
            
            // === TÉLÉMÉTRIE ===
            telemetry: {
                enabled: false,                    // Activé/désactivé par défaut
                vectorScale: 0.5,                  // Échelle des vecteurs
                updateInterval: 50,                // Intervalle de mise à jour (ms)
                
                // Configuration des vecteurs
                vectors: {
                    // Forces aérodynamiques
                    lift: { color: 0x00ff00, enabled: true, label: "Portance" },           // Vert
                    drag: { color: 0xff0000, enabled: true, label: "Traînée" },           // Rouge
                    totalAero: { color: 0x00ffff, enabled: true, label: "Force Aéro" },   // Cyan
                    
                    // Vitesses
                    velocity: { color: 0xffff00, enabled: true, label: "Vitesse" },        // Jaune
                    windSpeed: { color: 0x0000ff, enabled: true, label: "Vent" },         // Bleu
                    relativeWind: { color: 0xff00ff, enabled: true, label: "Vent Relatif" }, // Magenta
                    
                    // Forces physiques
                    gravity: { color: 0xffa500, enabled: true, label: "Gravité" },        // Orange
                    tension: { color: 0xffffff, enabled: true, label: "Tension" },        // Blanc
                    totalForce: { color: 0x9400d3, enabled: true, label: "Force Totale" }, // Violet
                    
                    // Orientation
                    normal: { color: 0x808080, enabled: true, label: "Normale" },         // Gris
                    centerOfPressure: { color: 0xffc0cb, enabled: true, label: "Centre Pression" } // Rose
                },
                
                // Configuration de l'affichage
                display: {
                    lineWidth: 3,                  // Épaisseur des lignes
                    arrowSize: 0.2,                // Taille des flèches
                    labelSize: 0.3,                // Taille des étiquettes
                    opacity: 0.8                   // Opacité des vecteurs
                }
            }
        };
        
        // =====================================================================================
        // === UTILITAIRES DE VALIDATION ET HELPERS ===
        // =====================================================================================
        
        /**
         * Utilitaires pour la validation des paramètres et fonctions helpers
         */
        const VALIDATION_UTILS = {
            /**
             * Valide qu'un nombre est dans une plage donnée
             */
            validateRange(value, min, max, defaultValue, paramName = 'paramètre') {
                if (typeof value !== 'number' || isNaN(value)) {
                    console.warn(`${paramName} invalide (${value}), utilisation de la valeur par défaut: ${defaultValue}`);
                    return defaultValue;
                }
                if (value < min || value > max) {
                    console.warn(`${paramName} hors limites (${value}), limité à [${min}, ${max}]`);
                    return Math.max(min, Math.min(max, value));
                }
                return value;
            },
            
            /**
             * Valide un vecteur Three.js
             */
            validateVector3(vector, defaultVector = new THREE.Vector3()) {
                if (!vector || typeof vector.x !== 'number' || typeof vector.y !== 'number' || typeof vector.z !== 'number') {
                    return defaultVector.clone();
                }
                return vector;
            },
            
            /**
             * Limite deltaTime pour éviter les instabilités physiques
             */
            clampDeltaTime(deltaTime) {
                return Math.min(deltaTime, KITE_CONFIG.performance.maxDeltaTime);
            }
        };
        
        /**
         * Helpers mathématiques pour les calculs physiques
         */
        const MATH_HELPERS = {
            /**
             * Conversion degrés vers radians
             */
            degToRad(degrees) {
                return degrees * Math.PI / 180;
            },
            
            /**
             * Conversion radians vers degrés
             */
            radToDeg(radians) {
                return radians * 180 / Math.PI;
            },
            
            /**
             * Interpolation linéaire sécurisée
             */
            lerp(a, b, t) {
                t = Math.max(0, Math.min(1, t)); // Clamp t entre 0 et 1
                return a + (b - a) * t;
            },
            
            /**
             * Normalise un angle en degrés entre 0 et 360
             */
            normalizeAngle(angle) {
                angle = angle % 360;
                return angle < 0 ? angle + 360 : angle;
            }
        };
        
        // =====================================================================================
        // === SYSTÈME MODULAIRE DE CONSTRUCTION DU CERF-VOLANT ===
        // =====================================================================================
        
        /**
         * CLASSE KITEPOINT - Point structurel du cerf-volant
         */
        class KitePoint {
            constructor(x, y, z, name, color = 0xffffff) {
                this.position = new THREE.Vector3(x, y, z);
                this.name = name;
                this.color = color;
            }
        }

        /**
         * CLASSE KITECOMPONENT - Classe de base pour tous les composants
         */
        class KiteComponent {
            constructor(name) {
                this.name = name;
                this.mesh = null;
            }
        }

        /**
         * CLASSE KITESTRUCTURE - Structure principale du cerf-volant
         */
        class KiteStructure {
            constructor() {
                this.points = new Map();
                this.components = [];
                this.group = new THREE.Group();
                this.annotations = [];
            }

            addPoint(point) {
                this.points.set(point.name, point);
                return this;
            }
            
            getPoint(name) {
                return this.points.get(name);
            }
            
            addComponent(component) {
                this.components.push(component);
                this.group.add(component.mesh);
                return this;
            }
            
            render() {
                return this.group;
            }
            
            createVisiblePoints(showConnectors = true) {
                this.points.forEach((point) => {
                    if (showConnectors) {
                        const connector = this.createConnector(point.position, point.color);
                        this.group.add(connector);
                    }
                    
                    const sprite = this.createTextSprite(point.name, point.color);
                    sprite.position.copy(point.position).add(new THREE.Vector3(0, 0.15, 0));
                    sprite.scale.set(0.4, 0.1, 1);
                    sprite.visible = false; // Masqué par défaut
                    this.annotations.push(sprite);
                    this.group.add(sprite);
                });
            }
            
            createConnector(position, color) {
                const connectorMaterial = new THREE.MeshPhongMaterial({ 
                    color: color,
                    shininess: 100
                });
                
                const sphereGeometry = new THREE.SphereGeometry(0.03, 16, 16);
                const connector = new THREE.Mesh(sphereGeometry, connectorMaterial);
                connector.position.copy(position);
                connector.castShadow = true;
                
                return connector;
            }
            
            createTextSprite(text, color = 0x333333) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.95)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.strokeStyle = '#' + color.toString(16).padStart(6, '0');
                context.lineWidth = 2;
                context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
                
                context.font = 'Bold 20px Arial';
                context.fillStyle = '#000000';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true,
                    sizeAttenuation: true
                });
                
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.5, 0.125, 1);
                sprite.renderOrder = 999;
                
                return sprite;
            }
            
            toggleAnnotations(visible) {
                this.annotations.forEach(annotation => {
                    annotation.visible = visible;
                });
            }
        }

        /**
         * CLASSE KITESAIL - Composant voile du cerf-volant
         */
        class KiteSail extends KiteComponent {
            constructor(points, color = 0xff0000) {
                super('sail');
                this.points = points;
                this.color = color;
                this.createMesh();
            }
            
            createMesh() {
                const vertices = [];
                const indices = [];
                
                this.points.forEach(point => {
                    vertices.push(point.position.x, point.position.y, point.position.z);
                });
                
                // Triangulation pour un cerf-volant delta
                indices.push(
                    0, 1, 2,
                    0, 2, 3,
                    0, 3, 4,
                    0, 4, 5
                );
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: this.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 100,
                    specular: 0x222222
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.material = material;
            }
            
            setColor(color) {
                this.color = color;
                this.material.color.set(color);
            }
        }

        /**
         * CLASSE KITEFRAME - Composant barre structurelle
         */
        class KiteFrame extends KiteComponent {
            constructor(start, end, radius = 0.02, color = 0x2a2a2a, name = 'frame') {
                super(name);
                this.start = start;
                this.end = end;
                this.radius = radius;
                this.color = color;
                this.createMesh();
            }
            
            createMesh() {
                const distance = this.start.position.distanceTo(this.end.position);
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: this.color,
                    shininess: 100
                });
                
                const geometry = new THREE.CylinderGeometry(this.radius, this.radius, distance, 8);
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.start.position).add(this.end.position).multiplyScalar(0.5);
                this.mesh.lookAt(this.end.position);
                this.mesh.rotateX(Math.PI / 2);
                this.mesh.castShadow = true;
            }
        }

        /**
         * CLASSE KITEFABRICEDGE - Composant bord de tissu
         * Représente les coutures et renforts des bords de la voile
         */
        class KiteFabricEdge extends KiteComponent {
            constructor(start, end, color = 0x000000, lineWidth = 3, name = 'fabricEdge') {
                super(name);
                this.start = start;
                this.end = end;
                this.color = color;
                this.lineWidth = lineWidth;
                this.createMesh();
            }
            
            createMesh() {
                const material = new THREE.LineBasicMaterial({ 
                    color: this.color, 
                    linewidth: this.lineWidth
                });
                
                const points = [
                    this.start.position,
                    this.end.position
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.mesh = new THREE.Line(geometry, material);
            }
        }

        /**
         * CLASSE KITEBRIDLE - Composant ligne de bridage
         */
        class KiteBridle extends KiteComponent {
            constructor(start, end, color = 0x000000, lineWidth = 2, name = 'bridle') {
                super(name);
                this.start = start;
                this.end = end;
                this.color = color;
                this.lineWidth = lineWidth;
                this.createMesh();
            }
            
            createMesh() {
                const material = new THREE.LineBasicMaterial({ 
                    color: this.color, 
                    linewidth: this.lineWidth
                });
                
                const points = [
                    this.start.position,
                    this.end.position
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.mesh = new THREE.Line(geometry, material);
            }
        }

        /**
         * CLASSE DELTAKITEBUILDER - Constructeur de cerf-volant delta avancé
         * Structure géométrique inspirée de la version kite.html
         */
        class DeltaKiteBuilder {
            constructor(width = KITE_CONFIG.kite.width, height = KITE_CONFIG.kite.height, depth = KITE_CONFIG.kite.depth) {
                // === STOCKAGE DES DIMENSIONS ===
                this.width = width;      // Envergure (largeur)
                this.height = height;    // Hauteur du nez à la base
                this.depth = depth;      // Profondeur des whiskers
                
                // === INITIALISATION DE LA STRUCTURE ===
                this.structure = new KiteStructure();
                
                // === CONFIGURATION PAR DÉFAUT ===
                this.sailColor = KITE_CONFIG.kite.color; // Couleur depuis la configuration
            }
            
            /**
             * MÉTHODE: Construire tous les points structurels
             * 
             * GÉOMÉTRIE D'UN CERF-VOLANT DELTA :
             * 
             *                   P_NEZ (0, height/2, 0)
             *                      ▲
             *                     /|\
             *                    / | \
             *                   /  |  \
             *        P_INTER_G ●   |   ● P_INTER_D
             *                 /    |    \
             *                /     |     \
             *               /      ●      \  ← P_BRIDE
             *              /    P_BRIDE    \
             *             /                 \
             *   P_BORD_G ●                   ● P_BORD_D
             *           |  \               /  |
             *           |   ● P_WHISKER_G ●   |
             *           |         |         |
             *           |         |         |
             *           |    P_SPINE_BAS    |
             *           |         ●         |
             *           └─────────┼─────────┘
             */
            buildStructuralPoints() {
                // === POINTS PRINCIPAUX (BASE DU CERF-VOLANT) ===
                
                // Nez : Point le plus haut, centre de la forme delta
                const pNez = new KitePoint(0, this.height / 2, 0, "P_NEZ", 0xff0000);
                
                // Base de l'épine centrale : Point le plus bas au centre
                const pSpineBas = new KitePoint(0, -this.height / 2, 0, "P_SPINE_BAS", 0xffff00);
                
                // Bords gauche et droit : Extrémités de la largeur
                const pBordGauche = new KitePoint(-this.width / 2, -this.height / 2, 0, "P_BORD_GAUCHE", 0x00ff00);
                const pBordDroit = new KitePoint(this.width / 2, -this.height / 2, 0, "P_BORD_DROIT", 0x0000ff);
                
                // Whiskers : Points arrière qui donnent de la profondeur
                // Positionnés plus haut que la base et vers l'arrière (Z négatif)
                const pWhiskerG = new KitePoint(-this.width / 4, -this.height / 2 + 0.4, -this.depth * 1.8, "P_WHISKER_G", 0xff00ff);
                const pWhiskerD = new KitePoint(this.width / 4, -this.height / 2 + 0.4, -this.depth * 1.8, "P_WHISKER_D", 0x00ffff);
                
                // === AJOUT DES POINTS PRINCIPAUX À LA STRUCTURE ===
                this.structure
                    .addPoint(pNez)
                    .addPoint(pSpineBas)
                    .addPoint(pBordGauche)
                    .addPoint(pBordDroit)
                    .addPoint(pWhiskerG)
                    .addPoint(pWhiskerD);
                
                // === CALCUL DU POINT DE BRIDE OPTIMISÉ ===
                // Position à 75% pour être cohérente avec la version avancée (structure conservée)
                const pBride = new KitePoint(
                    0, // Centré horizontalement
                    pNez.position.y + (pSpineBas.position.y - pNez.position.y) * 0.75, // 75% vers le bas
                    0, // Même plan que la voile
                    "P_BRIDE",
                    0xffa500 // Orange
                );
                this.structure.addPoint(pBride);
                
                // === CALCUL DES INTERSECTIONS (GÉOMÉTRIE AVANCÉE) ===
                // Points où la barre transversale croise les bords d'attaque
                
                // INTERSECTION GAUCHE :
                const leadingEdgeDirectionG = new THREE.Vector3().subVectors(pBordGauche.position, pNez.position);
                const tGauche = (pBride.position.y - pNez.position.y) / leadingEdgeDirectionG.y;
                const pInterG = new KitePoint(
                    pNez.position.x + leadingEdgeDirectionG.x * tGauche,
                    pBride.position.y, // Même hauteur que le point de bride
                    pNez.position.z + leadingEdgeDirectionG.z * tGauche,
                    "P_INTER_ATTACHE_G",
                    0x800080 // Violet
                );
                
                // INTERSECTION DROITE :
                const leadingEdgeDirectionD = new THREE.Vector3().subVectors(pBordDroit.position, pNez.position);
                const tDroit = (pBride.position.y - pNez.position.y) / leadingEdgeDirectionD.y;
                const pInterD = new KitePoint(
                    pNez.position.x + leadingEdgeDirectionD.x * tDroit,
                    pBride.position.y,
                    pNez.position.z + leadingEdgeDirectionD.z * tDroit,
                    "P_INTER_ATTACHE_D",
                    0x008080 // Cyan foncé
                );
                
                this.structure.addPoint(pInterG).addPoint(pInterD);
                
                // === POINTS D'ATTACHE INTERMÉDIAIRES ===
                // Points à mi-chemin entre les intersections et le point de bride
                const pAttacheInterG = new KitePoint(
                    (pInterG.position.x + pBride.position.x) / 2,
                    (pInterG.position.y + pBride.position.y) / 2,
                    (pInterG.position.z + pBride.position.z) / 2,
                    "P_ATTACHE_INTER_G",
                    0x90EE90 // Vert clair
                );
                
                const pAttacheInterD = new KitePoint(
                    (pInterD.position.x + pBride.position.x) / 2,
                    (pInterD.position.y + pBride.position.y) / 2,
                    (pInterD.position.z + pBride.position.z) / 2,
                    "P_ATTACHE_INTER_D",
                    0x98FB98 // Vert très clair
                );
                
                // === POINTS DE CONTRÔLE DU BRIDAGE OPTIMISÉS ===
                // Configuration réaliste basée sur les standards des cerfs-volants delta
                // Ajustement des longueurs de brides pour un angle d'attaque optimal (25-30°)
                const kiteMiddleHeight = (pNez.position.y + pSpineBas.position.y) / 2; // Milieu de la hauteur
                
                // === CALCUL DES LONGUEURS DE BRIDES OPTIMALES ===
                // Pour un cerf-volant delta, les longueurs relatives des brides déterminent
                // l'angle d'attaque et la stabilité
                
                // Distance du nez au point de bride (bride arrière)
                const bridleNoseDistance = pNez.position.distanceTo(pBride.position);
                
                // Distance des intersections au point de bride (brides latérales)  
                const bridleLateralDistance = pInterG.position.distanceTo(pBride.position);
                
                // === POSITIONNEMENT DES POINTS DE CONTRÔLE AVEC GÉOMÉTRIE DE BRIDAGE ===
                // Configuration simplifiée et réaliste pour un cerf-volant delta
                // Points de contrôle positionnés pour créer un angle d'attaque stable de 25-30°
                
                // Distance de contrôle optimale : environ 40% de la largeur pour la stabilité
                const controlSpacing = this.width * 0.4; // Espacement des points de contrôle
                const controlHeight = pBride.position.y - 0.8; // Hauteur des points de contrôle
                const controlDepth = pBride.position.z + 1.2;  // Profondeur pour angle optimal
                
                const pControleG = new KitePoint(
                    -controlSpacing / 2, // Position gauche équilibrée
                    controlHeight,       // Hauteur calculée pour angle optimal
                    controlDepth,        // Distance arrière pour stabilité
                    "P_CONTROLE_G", 
                    0xDC143C // Rouge foncé
                );
                
                const pControleD = new KitePoint(
                    controlSpacing / 2,  // Position droite symétrique
                    controlHeight,       // Même hauteur que le gauche
                    controlDepth,        // Même profondeur
                    "P_CONTROLE_D", 
                    0xB22222 // Rouge brique
                );
                
                // === AJOUT DE TOUS LES POINTS CALCULÉS ===
                this.structure
                    .addPoint(pAttacheInterG)
                    .addPoint(pAttacheInterD)
                    .addPoint(pControleG)
                    .addPoint(pControleD);
                
                return this; // Retour pour chaînage de méthodes
            }
            
            /**
             * MÉTHODE: Construire la voile du cerf-volant
             * 
             * ORDRE DES POINTS POUR LA TRIANGULATION :
             * 0: P_NEZ (sommet)
             * 1: P_BORD_GAUCHE (bord gauche)
             * 2: P_WHISKER_G (arrière gauche)
             * 3: P_SPINE_BAS (base centrale)
             * 4: P_WHISKER_D (arrière droit)
             * 5: P_BORD_DROIT (bord droit)
             */
            buildSail() {
                // === SÉLECTION DES POINTS DANS L'ORDRE CORRECT ===
                const sailPoints = [
                    this.structure.getPoint("P_NEZ"),           // Point 0: Sommet
                    this.structure.getPoint("P_BORD_GAUCHE"),   // Point 1: Bord gauche
                    this.structure.getPoint("P_WHISKER_G"),     // Point 2: Arrière gauche
                    this.structure.getPoint("P_SPINE_BAS"),     // Point 3: Base
                    this.structure.getPoint("P_WHISKER_D"),     // Point 4: Arrière droit
                    this.structure.getPoint("P_BORD_DROIT")     // Point 5: Bord droit
                ];
                
                // === CRÉATION DE LA VOILE ===
                const sail = new KiteSail(sailPoints, this.sailColor);
                this.structure.addComponent(sail);
                
                // === STOCKAGE DE LA RÉFÉRENCE ===
                this.sailComponent = sail;
                
                return this;
            }
            
            /**
             * MÉTHODE: Construire le squelette rigide avancé
             * 
             * BARRES PRINCIPALES D'UN CERF-VOLANT DELTA :
             * - 2 bords d'attaque (nez vers les bords)
             * - 1 épine centrale (nez vers la base)
             * - 1 barre transversale (entre les intersections)
             * - 2 barres whisker (whiskers vers points intermédiaires)
             */
            buildFrame() {
                const frameMaterial = KITE_CONFIG.visual.frameColor; // Couleur depuis la configuration
                
                // === AJOUT DE TOUTES LES BARRES STRUCTURELLES ===
                this.structure
                    // Bords d'attaque principaux
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_NEZ"),
                        this.structure.getPoint("P_BORD_GAUCHE"),
                        KITE_CONFIG.visual.frameRadius.main, frameMaterial, "BORD_ATTAQUE_G"
                    ))
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_NEZ"),
                        this.structure.getPoint("P_BORD_DROIT"),
                        KITE_CONFIG.visual.frameRadius.main, frameMaterial, "BORD_ATTAQUE_D"
                    ))
                    // Barre transversale (donne la rigidité latérale)
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_INTER_ATTACHE_G"),
                        this.structure.getPoint("P_INTER_ATTACHE_D"),
                        KITE_CONFIG.visual.frameRadius.main, frameMaterial, "TRANSVERSALE_SUP"
                    ))
                    // Épine centrale (barre principale de rigidité)
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_NEZ"),
                        this.structure.getPoint("P_SPINE_BAS"),
                        KITE_CONFIG.visual.frameRadius.main, frameMaterial, "SPINE_CENTRALE"
                    ))
                    // Barres whisker (renforts arrière)
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_WHISKER_G"),
                        this.structure.getPoint("P_ATTACHE_INTER_G"),
                        KITE_CONFIG.visual.frameRadius.whisker, frameMaterial, "BARRE_WHISKER_G"
                    ))
                    .addComponent(new KiteFrame(
                        this.structure.getPoint("P_WHISKER_D"),
                        this.structure.getPoint("P_ATTACHE_INTER_D"),
                        KITE_CONFIG.visual.frameRadius.whisker, frameMaterial, "BARRE_WHISKER_D"
                    ));
                
                return this;
            }
            
            /**
             * MÉTHODE: Construire les bords de tissu
             * 
             * TYPES DE BORDS :
             * - Bords d'attaque : Face au vent (nez vers bords)
             * - Bords de fuite : Arrière de la voile (bords vers whiskers)
             * - Bords inférieurs : Base de la voile (whiskers vers base)
             * - Diagonales : Renforts structurels (whiskers vers nez)
             */
            buildFabricEdges() {
                const edgeColor = KITE_CONFIG.visual.fabricEdgeColor; // Couleur depuis la configuration
                const edgeWidth = KITE_CONFIG.visual.fabricEdgeWidth; // Épaisseur depuis la configuration
                
                this.structure
                    // === BORDS D'ATTAQUE (face au vent) ===
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_NEZ"),
                        this.structure.getPoint("P_BORD_GAUCHE"),
                        edgeColor, edgeWidth, "EDGE_LEAD_G"
                    ))
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_NEZ"),
                        this.structure.getPoint("P_BORD_DROIT"),
                        edgeColor, edgeWidth, "EDGE_LEAD_D"
                    ))
                    
                    // === BORDS DE FUITE (arrière de la voile) ===
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_BORD_GAUCHE"),
                        this.structure.getPoint("P_WHISKER_G"),
                        edgeColor, edgeWidth, "EDGE_TRAIL_G"
                    ))
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_BORD_DROIT"),
                        this.structure.getPoint("P_WHISKER_D"),
                        edgeColor, edgeWidth, "EDGE_TRAIL_D"
                    ))
                    
                    // === BORDS INFÉRIEURS (base de la voile) ===
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_WHISKER_G"),
                        this.structure.getPoint("P_SPINE_BAS"),
                        edgeColor, edgeWidth, "EDGE_BOTTOM_G"
                    ))
                    .addComponent(new KiteFabricEdge(
                        this.structure.getPoint("P_WHISKER_D"),
                        this.structure.getPoint("P_SPINE_BAS"),
                        edgeColor, edgeWidth, "EDGE_BOTTOM_D"
                    ));
                
                return this;
            }
            
            /**
             * MÉTHODE: Construire le système de bridage avancé
             * 
             * SYSTÈME COMPLET ET RÉALISTE :
             * - Connexions principales vers les points de contrôle
             * - Bridage vers le nez (portance)
             * - Bridage vers les intersections (stabilité)
             * - Bridage vers le point central (équilibre)
             */
            buildBridles() {
                const bridleColor = KITE_CONFIG.visual.bridleColor; // Couleur depuis la configuration
                const bridleWidth = KITE_CONFIG.visual.bridleWidth; // Épaisseur depuis la configuration
                
                this.structure
                    // === CONNEXIONS PRINCIPALES VERS LES POINTS DE CONTRÔLE ===
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_BRIDE"),
                        this.structure.getPoint("P_CONTROLE_G"),
                        bridleColor, bridleWidth, "BRIDE_CONTROLE_G"
                    ))
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_BRIDE"),
                        this.structure.getPoint("P_CONTROLE_D"),
                        bridleColor, bridleWidth, "BRIDE_CONTROLE_D"
                    ))
                    
                    // === BRIDAGE GAUCHE (3 POINTS DE FIXATION) ===
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_G"),
                        this.structure.getPoint("P_NEZ"),
                        bridleColor, bridleWidth, "BRIDE_G_NEZ"
                    ))
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_G"),
                        this.structure.getPoint("P_INTER_ATTACHE_G"),
                        bridleColor, bridleWidth, "BRIDE_G_INTER"
                    ))
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_G"),
                        this.structure.getPoint("P_BRIDE"),
                        bridleColor, bridleWidth, "BRIDE_G_BRIDE"
                    ))
                    
                    // === BRIDAGE DROIT (3 POINTS DE FIXATION) ===
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_D"),
                        this.structure.getPoint("P_NEZ"),
                        bridleColor, bridleWidth, "BRIDE_D_NEZ"
                    ))
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_D"),
                        this.structure.getPoint("P_INTER_ATTACHE_D"),
                        bridleColor, bridleWidth, "BRIDE_D_INTER"
                    ))
                    .addComponent(new KiteBridle(
                        this.structure.getPoint("P_CONTROLE_D"),
                        this.structure.getPoint("P_BRIDE"),
                        bridleColor, bridleWidth, "BRIDE_D_BRIDE"
                    ));
                
                return this;
            }
            
            buildVisuals() {
                this.structure.createVisiblePoints();
                return this;
            }
            
            build() {
                return this.structure.render();
            }
            
            toggleAnnotations(visible) {
                this.structure.toggleAnnotations(visible);
                return this;
            }
        }

        /**
         * CLASSE WINDMANAGER - Gestionnaire centralisé du système de vent
         */
        class WindManager {
            constructor(scene, simulator) {
                this.scene = scene;
                this.simulator = simulator;
                
                // === ÉTAT DU VENT ===
                this.state = {
                    speed: KITE_CONFIG.wind.defaultSpeed,
                    direction: KITE_CONFIG.wind.defaultDirection,
                    turbulence: KITE_CONFIG.wind.turbulence.scale
                };
                
                // === NOUVEAU: Système de rafales ===
                this.gustSystem = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    direction: 0,
                    timeRemaining: 0
                };
                
                // === NOUVEAU: Profil de vent vertical ===
                this.windProfile = {
                    groundLevel: 0.7,     // Facteur à 0m
                    gradient: 0.143,      // Loi de puissance 1/7
                    maxAltitude: 200      // Altitude max considérée
                };
                
                // === RÉFÉRENCES AUX OBJETS 3D ===
                this.windIndicator = null;
                this.windsockSegments = [];
                
                // === INTERFACE UTILISATEUR ===
                this.compassElement = null;
                this.isDragging = false;
                this.startAngle = 0;
                
                this.initialize();
            }
            
            initialize() {
                this.createWindIndicators();
                this.setupWindControls();
                this.setupEventListeners();
            }
            
            /**
             * Création des indicateurs visuels de vent
             */
            createWindIndicators() {
                // Groupe principal pour l'indicateur de direction
                const windIndicatorGroup = new THREE.Group();
                
                // Flèche directionnelle
                const arrowGeometry = new THREE.ConeGeometry(0.1, 0.4, 8);
                const arrowMaterial = new THREE.MeshPhongMaterial({ 
                    color: KITE_CONFIG.wind.indicators.arrowColor 
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.rotation.x = -Math.PI / 2;
                arrow.position.y = 0.1;
                arrow.castShadow = true;
                
                // Base de l'indicateur
                const baseGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.1, 8);
                const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.05;
                base.castShadow = true;
                
                windIndicatorGroup.add(arrow);
                windIndicatorGroup.add(base);
                windIndicatorGroup.position.set(0, 0, 2);
                
                this.windIndicator = {
                    group: windIndicatorGroup,
                    arrow: arrow
                };
                
                this.scene.add(windIndicatorGroup);
            }
            
            /**
             * Configuration des contrôles de vent dans l'interface
             */
            setupWindControls() {
                // Slider de vitesse du vent
                const windSpeedSlider = document.getElementById('windSpeed');
                if (windSpeedSlider) {
                    windSpeedSlider.min = KITE_CONFIG.wind.minSpeed;
                    windSpeedSlider.max = KITE_CONFIG.wind.maxSpeed;
                    windSpeedSlider.value = this.state.speed;
                    windSpeedSlider.step = 0.5;
                }
                
                // Slider de turbulences
                const turbulenceSlider = document.getElementById('turbulence');
                if (turbulenceSlider) {
                    turbulenceSlider.min = KITE_CONFIG.wind.turbulence.minScale;
                    turbulenceSlider.max = KITE_CONFIG.wind.turbulence.maxScale;
                    turbulenceSlider.value = this.state.turbulence;
                    turbulenceSlider.step = 0.1;
                }
                
                this.createWindCompass();
            }
            
            /**
             * Création de la boussole interactive pour la direction du vent
             */
            createWindCompass() {
                const windIndicator = document.getElementById('wind-indicator');
                if (!windIndicator) return;
                
                this.compassElement = windIndicator;
                
                // Styles par défaut
                windIndicator.style.width = KITE_CONFIG.wind.ui.compassSize + 'px';
                windIndicator.style.height = KITE_CONFIG.wind.ui.compassSize + 'px';
                windIndicator.style.cursor = 'pointer';
                windIndicator.style.userSelect = 'none';
                
                this.updateCompassVisual();
            }
            
            /**
             * Mise à jour de l'affichage de la boussole
             */
            updateCompassVisual() {
                if (!this.compassElement) return;
                
                const rotation = this.state.direction;
                this.compassElement.style.transform = `rotate(${rotation}deg)`;
                
                // Mise à jour de l'affichage textuel
                const directionText = document.getElementById('directionText');
                if (directionText) {
                    directionText.textContent = `${rotation}°`;
                }
            }
            
            /**
             * Configuration des événements pour les contrôles de vent
             */
            setupEventListeners() {
                // Slider de vitesse du vent
                const windSpeedSlider = document.getElementById('windSpeed');
                if (windSpeedSlider) {
                    windSpeedSlider.addEventListener('input', (e) => {
                        this.setWindSpeed(parseFloat(e.target.value));
                    });
                }
                
                // Slider de turbulences
                const turbulenceSlider = document.getElementById('turbulence');
                if (turbulenceSlider) {
                    turbulenceSlider.addEventListener('input', (e) => {
                        this.setTurbulence(parseFloat(e.target.value));
                    });
                }
                
                // Contrôles de la boussole
                this.setupCompassEvents();
            }
            
            /**
             * Configuration des événements de la boussole
             */
            setupCompassEvents() {
                if (!this.compassElement) return;
                
                const getAngleFromCenter = (event, rect) => {
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const deltaX = event.clientX - centerX;
                    const deltaY = event.clientY - centerY;
                    let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI) + 90;
                    if (angle < 0) angle += 360;
                    return Math.round(angle);
                };
                
                // Événements souris
                this.compassElement.addEventListener('mousedown', (event) => {
                    this.isDragging = true;
                    const rect = this.compassElement.getBoundingClientRect();
                    this.startAngle = getAngleFromCenter(event, rect);
                    this.compassElement.style.cursor = 'grabbing';
                    event.preventDefault();
                });
                
                document.addEventListener('mousemove', (event) => {
                    if (this.isDragging) {
                        const rect = this.compassElement.getBoundingClientRect();
                        const currentAngle = getAngleFromCenter(event, rect);
                        this.setWindDirection(currentAngle);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.compassElement.style.cursor = 'pointer';
                    }
                });
                
                // Événements tactiles
                this.compassElement.addEventListener('touchstart', (event) => {
                    this.isDragging = true;
                    const rect = this.compassElement.getBoundingClientRect();
                    const touch = event.touches[0];
                    this.startAngle = getAngleFromCenter(touch, rect);
                    event.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchmove', (event) => {
                    if (this.isDragging && event.touches.length > 0) {
                        const rect = this.compassElement.getBoundingClientRect();
                        const touch = event.touches[0];
                        const currentAngle = getAngleFromCenter(touch, rect);
                        this.setWindDirection(currentAngle);
                        event.preventDefault();
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                    }
                });
            }
            
            /**
             * Calcul du vecteur de force du vent
             */
            // === NOUVEAU: Génération de rafales aléatoires ===
            generateGust() {
                if (Math.random() < 0.02 && !this.gustSystem.active) { // 2% de chance par frame
                    this.gustSystem = {
                        active: true,
                        intensity: 0.5 + Math.random() * 1.5,        // 50% à 200% du vent de base
                        duration: 2 + Math.random() * 3,             // 2-5 secondes
                        direction: (Math.random() - 0.5) * 30,       // ±15° de variation
                        timeRemaining: 2 + Math.random() * 3
                    };
                    
                    this.simulator.logMessage(`💨 Rafale ! Intensité: ${(this.gustSystem.intensity * 100).toFixed(0)}%`, 'warn');
                    
                    // Afficher l'indicateur de rafale
                    const gustIndicator = document.getElementById('gust-indicator');
                    if (gustIndicator) {
                        gustIndicator.style.display = 'block';
                        gustIndicator.textContent = `💨 RAFALE ${(this.gustSystem.intensity * 100).toFixed(0)}% !`;
                    }
                }
            }

            calculateWindForce(kitePosition) {
                // Vent de base selon la direction configurée
                const windDirectionRad = (this.state.direction * Math.PI) / 180;
                let baseWind = new THREE.Vector3(
                    Math.sin(windDirectionRad) * this.state.speed,
                    0,
                    -Math.cos(windDirectionRad) * this.state.speed
                );
                
                // === NOUVEAU: Profil de vent logarithmique ===
                const altitude = Math.max(0, kitePosition.y);
                const windShear = this.windProfile.groundLevel + 
                    Math.pow(altitude / 10, this.windProfile.gradient) * 
                    (1 - this.windProfile.groundLevel);
                baseWind.multiplyScalar(Math.min(windShear, 2.0));
                
                // === NOUVEAU: Application des rafales ===
                if (this.gustSystem.active) {
                    const gustRad = ((this.state.direction + this.gustSystem.direction) * Math.PI) / 180;
                    const gustWind = new THREE.Vector3(
                        Math.sin(gustRad) * this.state.speed * this.gustSystem.intensity,
                        0,
                        -Math.cos(gustRad) * this.state.speed * this.gustSystem.intensity
                    );
                    
                    // Interpolation douce de la rafale
                    const gustFactor = Math.sin((this.gustSystem.duration - this.gustSystem.timeRemaining) / 
                                      this.gustSystem.duration * Math.PI);
                    baseWind.lerp(gustWind, gustFactor * 0.7);
                }
                
                // Turbulences existantes
                if (this.state.turbulence > 0) {
                    const time = Date.now() * 0.001;
                    const turbulenceX = Math.sin(time * KITE_CONFIG.wind.turbulence.frequency) * 
                                      this.state.turbulence * KITE_CONFIG.wind.turbulence.amplitude;
                    const turbulenceZ = Math.cos(time * KITE_CONFIG.wind.turbulence.frequency * 1.3) * 
                                      this.state.turbulence * KITE_CONFIG.wind.turbulence.amplitude;
                    
                    baseWind.x += turbulenceX * this.state.speed;
                    baseWind.z += turbulenceZ * this.state.speed;
                }
                
                return baseWind;
            }

            // === NOUVEAU: Mise à jour du système de rafales ===
            update(deltaTime) {
                this.generateGust();
                
                if (this.gustSystem.active) {
                    this.gustSystem.timeRemaining -= deltaTime;
                    if (this.gustSystem.timeRemaining <= 0) {
                        this.gustSystem.active = false;
                        this.simulator.logMessage('💨 Fin de la rafale', 'info');
                        
                        // Masquer l'indicateur de rafale
                        const gustIndicator = document.getElementById('gust-indicator');
                        if (gustIndicator) {
                            gustIndicator.style.display = 'none';
                        }
                    }
                }
                
                this.updateIndicators();
            }
            
            /**
             * Mise à jour des indicateurs visuels
             */
            updateIndicators() {
                this.updateWindIndicator();
                this.updateWindsock();
            }
            
            /**
             * Mise à jour de l'indicateur de direction au sol
             */
            updateWindIndicator() {
                if (this.windIndicator && this.windIndicator.group) {
                    const windDirectionRad = (this.state.direction * Math.PI) / 180;
                    this.windIndicator.group.rotation.y = windDirectionRad;
                }
            }
            
            /**
             * Mise à jour de la manche à air
             */
            updateWindsock() {
                if (this.windsockSegments.length === 0) return;
                
                const time = Date.now() * 0.001;
                const windDirectionRad = (this.state.direction * Math.PI) / 180;
                const windSpeed = this.state.speed;
                
                this.windsockSegments.forEach((segment, index) => {
                    // Direction du vent
                    const directionX = Math.sin(windDirectionRad);
                    const directionZ = -Math.cos(windDirectionRad);
                    
                    // Intensité basée sur la vitesse du vent
                    const intensity = Math.min(3.0, Math.max(0.5, windSpeed * 0.12));
                    
                    // Position finale avec l'orientation (la manche à air pointe DANS la direction du vent)
                    const finalX = directionX * intensity;
                    const finalZ = directionZ * intensity;
                    
                    segment.position.set(finalX, 4.0, finalZ);
                    
                    // Rotation pour que la manche à air pointe dans la direction du vent
                    // (et non d'où il vient)
                    segment.rotation.z = windDirectionRad;
                    
                    // Oscillation légère pour simuler les rafales
                    const oscillation = Math.sin(time * 3 + index * PHYSICS_CONSTANTS.HALF) * PHYSICS_CONSTANTS.OSCILLATION_AMPLITUDE;
                    segment.position.y = 4.0 + oscillation;
                    
                    // Opacité basée sur la vitesse du vent
                    segment.material.opacity = Math.max(0.8, Math.min(0.95, 0.8 + windSpeed * 0.03));
                });
            }
            
            /**
             * Définir la vitesse du vent
             */
            setWindSpeed(speed) {
                this.state.speed = Math.max(
                    KITE_CONFIG.wind.minSpeed, 
                    Math.min(KITE_CONFIG.wind.maxSpeed, speed)
                );
                
                // Mettre à jour l'affichage
                const windValue = document.getElementById('windValue');
                if (windValue) {
                    windValue.textContent = this.state.speed.toFixed(1);
                }
                
                // Notification au simulateur
                if (this.simulator && this.simulator.logMessage) {
                    this.simulator.logMessage(`💨 Vent: ${this.state.speed.toFixed(1)} m/s`, 'info');
                }
            }
            
            /**
             * Définir la direction du vent
             */
            setWindDirection(direction) {
                this.state.direction = ((direction % 360) + 360) % 360;
                this.updateCompassVisual();
                
                // Notification au simulateur
                if (this.simulator && this.simulator.logMessage) {
                    this.simulator.logMessage(`🧭 Direction: ${this.state.direction}°`, 'info');
                }
            }
            
            /**
             * Définir l'intensité des turbulences
             */
            setTurbulence(turbulence) {
                this.state.turbulence = Math.max(
                    KITE_CONFIG.wind.turbulence.minScale,
                    Math.min(KITE_CONFIG.wind.turbulence.maxScale, turbulence)
                );
                
                // Mettre à jour l'affichage
                const turbulenceValue = document.getElementById('turbulenceValue');
                if (turbulenceValue) {
                    turbulenceValue.textContent = (this.state.turbulence * 100).toFixed(0) + '%';
                }
            }
            
            /**
             * Obtenir l'état actuel du vent
             */
            getWindState() {
                return { ...this.state };
            }
            
            /**
             * Définir des références aux segments de manche à air
             */
            setWindsockSegments(segments) {
                this.windsockSegments = segments;
            }
        }

        // =====================================================================================
        // === SYSTÈME DE PARTICULES POUR VISUALISER LE VENT ===
        // =====================================================================================
        class WindParticleSystem {
            constructor(scene, count = 200) {
                this.scene = scene;
                this.particles = [];
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(count * 3);
                this.velocities = new Float32Array(count * 3);
                this.lifetimes = new Float32Array(count);
                this.count = count;
                
                // Initialisation des particules
                for (let i = 0; i < count; i++) {
                    this.resetParticle(i);
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                
                // Matériau des particules
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, material);
                this.scene.add(this.mesh);
                this.enabled = false; // Désactivé par défaut
                this.mesh.visible = false;
            }
            
            resetParticle(index) {
                const i3 = index * 3;
                
                // Position aléatoire devant la caméra
                this.positions[i3] = (Math.random() - 0.5) * 100;
                this.positions[i3 + 1] = Math.random() * 50;
                this.positions[i3 + 2] = (Math.random() - 0.5) * 100;
                
                // Vitesse initiale nulle (sera mise à jour avec le vent)
                this.velocities[i3] = 0;
                this.velocities[i3 + 1] = 0;
                this.velocities[i3 + 2] = 0;
                
                // Durée de vie aléatoire
                this.lifetimes[index] = Math.random() * 5 + 5;
            }
            
            update(deltaTime, windForce) {
                if (!this.enabled) return;
                
                const positions = this.geometry.attributes.position.array;
                
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    
                    // Mise à jour de la position avec le vent
                    positions[i3] += windForce.x * deltaTime * 0.5;
                    positions[i3 + 1] += windForce.y * deltaTime * 0.5;
                    positions[i3 + 2] += windForce.z * deltaTime * 0.5;
                    
                    // Mise à jour de la durée de vie
                    this.lifetimes[i] -= deltaTime;
                    
                    // Reset si la particule est trop vieille ou sort des limites
                    if (this.lifetimes[i] <= 0 || 
                        Math.abs(positions[i3]) > 60 || 
                        positions[i3 + 1] < 0 || 
                        positions[i3 + 1] > 60 ||
                        Math.abs(positions[i3 + 2]) > 60) {
                        this.resetParticle(i);
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                this.mesh.visible = enabled;
            }
            
            dispose() {
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.geometry.dispose();
                    this.mesh.material.dispose();
                }
            }
        }

        /**
         * CLASSE PHYSICSMANAGER - Gestionnaire centralisé de la physique
         */
        class PhysicsManager {
            constructor(simulator) {
                this.simulator = simulator;
                
                // === ÉTAT PHYSIQUE ===
                this.forces = {
                    gravity: new THREE.Vector3(),
                    aerodynamic: new THREE.Vector3(),
                    bridage: new THREE.Vector3(),
                    total: new THREE.Vector3()
                };
                
                // === DONNÉES DE TÉLÉMÉTRIE ===
                this.telemetryData = {
                    lift: { direction: new THREE.Vector3(0, 1, 0), magnitude: 0 },
                    drag: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    totalAero: { direction: new THREE.Vector3(0, 0, 0), magnitude: 0 },
                    windSpeed: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    relativeWind: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    normal: { direction: new THREE.Vector3(0, 0, 1), magnitude: 1 }
                };
            }
            
            /**
             * Calcul des forces aérodynamiques
             */
            /**
             * Calcul des forces aérodynamiques avec système de tension des lignes avancé
             */
            calculateAerodynamicForces(kitePosition, kiteVelocity, windForce) {
                // Vent relatif = vent - vitesse du cerf-volant
                const relativeWind = windForce.clone().sub(kiteVelocity);
                const windSpeed = relativeWind.length();
                
                if (windSpeed < 0.1) {
                    // Pas de vent, réinitialiser les données
                    this.telemetryData = {
                        lift: { direction: new THREE.Vector3(0, 1, 0), magnitude: 0 },
                        drag: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                        totalAero: { direction: new THREE.Vector3(0, 0, 0), magnitude: 0 },
                        windSpeed: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                        relativeWind: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                        normal: { direction: new THREE.Vector3(0, 0, 1), magnitude: 1 }
                    };
                    return new THREE.Vector3(0, 0, 0);
                }
                
                // === CALCUL CRITIQUE DE LA TENSION DES LIGNES ===
                const tensionData = this.calculateLineTensions();
                const avgTension = (tensionData.left + tensionData.right) / 2;
                const tensionRatio = Math.min(avgTension / KITE_CONFIG.lines.length, 1.0);
                
                // === DÉTECTION DU DÉCROCHAGE DÛ AUX LIGNES RELÂCHÉES ===
                const minTensionForFlight = 0.7; // 70% de la longueur des lignes
                const isStalled = tensionRatio < minTensionForFlight;
                
                if (isStalled) {
                    if (this.simulator && this.simulator.logMessage) {
                        this.simulator.logMessage(`⚠️ DÉCROCHAGE - Lignes trop relâchées ! Tension: ${(tensionRatio*100).toFixed(0)}%`, 'warn');
                    }
                    
                    // En décrochage : portance réduite drastiquement, traînée énorme
                    const stallDrag = 50 * windSpeed * windSpeed;
                    const windDirection = relativeWind.clone().normalize();
                    const stallForce = windDirection.clone().multiplyScalar(-stallDrag);
                    
                    // === OSCILLATIONS CHAOTIQUES DU DÉCROCHAGE ("FLUTTER") ===
                    const time = Date.now() * 0.001;
                    const oscillationX = Math.sin(time * 8) * windSpeed * 0.3;
                    const oscillationZ = Math.cos(time * 10) * windSpeed * 0.2;
                    
                    stallForce.x += oscillationX;
                    stallForce.z += oscillationZ;
                    
                    this.telemetryData = {
                        lift: { direction: new THREE.Vector3(0, 1, 0), magnitude: 0 },
                        drag: { direction: windDirection.clone().multiplyScalar(-1), magnitude: stallDrag },
                        totalAero: { direction: stallForce.clone().normalize(), magnitude: stallForce.length() },
                        windSpeed: { direction: windDirection.clone(), magnitude: windSpeed },
                        relativeWind: { direction: windDirection.clone(), magnitude: windSpeed },
                        normal: { direction: new THREE.Vector3(0, 0, 1), magnitude: 1 },
                        lineTension: { left: tensionData.left, right: tensionData.right, ratio: tensionRatio }
                    };
                    
                    // Mise à jour UI pour indiquer le décrochage
                    const aoaElement = document.getElementById('aoa');
                    if (aoaElement) {
                        aoaElement.textContent = "STALL";
                        aoaElement.style.color = '#ff0000';
                        aoaElement.style.fontWeight = 'bold';
                        aoaElement.style.textShadow = '0 0 10px #ff0000';
                    }
                    
                    return stallForce;
                }
                
                // === CALCUL DE L'ANGLE D'ATTAQUE BASÉ SUR LA GÉOMÉTRIE DES LIGNES ===
                const lineAngle = this.calculateKiteAngleFromLines(kitePosition, tensionData);
                let aoaDegrees = lineAngle;
                
                // === CORRECTION PAR LE BRIDAGE ET LA FORME DU CERF-VOLANT ===
                const naturalBridleAngle = 25;
                const bridleCorrection = (naturalBridleAngle - aoaDegrees) * 0.3;
                aoaDegrees += bridleCorrection;
                
                // === EFFET DU CONTRÔLE DE LA BARRE ===
                const controlAngle = (this.simulator.controlBar && this.simulator.controlBar.angle) ? this.simulator.controlBar.angle : 0;
                aoaDegrees += (controlAngle * 8);
                
                // === LIMITES PHYSIQUES ===
                aoaDegrees = Math.max(5, Math.min(60, aoaDegrees));
                
                // === CALCUL DE LA SURFACE PROJETÉE ===
                const kiteNormal = new THREE.Vector3(0, 0, 1);
                if (this.simulator.kite) {
                    kiteNormal.applyQuaternion(this.simulator.kite.quaternion);
                }
                const windDirection = relativeWind.clone().normalize();
                const cosAngle = Math.abs(windDirection.dot(kiteNormal));
                const projectedArea = KITE_CONFIG.physics.kiteArea * Math.abs(cosAngle);
                
                // === PRESSION DYNAMIQUE ===
                const dynamicPressure = 0.5 * KITE_CONFIG.physics.airDensity * windSpeed * windSpeed;
                
                // === COURBE DE PORTANCE RÉALISTE AVEC DÉCROCHAGE PROGRESSIF ===
                let liftCoeff = 0;
                let dragCoeff = KITE_CONFIG.physics.dragCoefficient;
                
                if (aoaDegrees <= 8) {
                    liftCoeff = aoaDegrees * 0.08;
                } else if (aoaDegrees <= 20) {
                    liftCoeff = 0.64 + (aoaDegrees - 8) * 0.12;
                } else if (aoaDegrees <= 30) {
                    liftCoeff = 2.08 + (aoaDegrees - 20) * 0.04;
                } else if (aoaDegrees <= 40) {
                    liftCoeff = 2.48 - (aoaDegrees - 30) * 0.10;
                } else {
                    liftCoeff = 1.48 - (aoaDegrees - 40) * 0.12;
                    liftCoeff = Math.max(0.2, liftCoeff);
                }
                
                // === AJUSTEMENT BASÉ SUR LA TENSION DES LIGNES ===
                const tensionEfficiency = 0.3 + tensionRatio * 0.7;
                liftCoeff *= tensionEfficiency;
                
                dragCoeff += Math.sin(aoaDegrees * Math.PI / 180) * 1.2;
                dragCoeff /= (0.5 + tensionRatio * 0.5);
                
                // === CALCUL DES FORCES AÉRODYNAMIQUES ===
                const liftMagnitude = liftCoeff * dynamicPressure * projectedArea;
                const dragMagnitude = dragCoeff * dynamicPressure * projectedArea;
                
                // === DIRECTIONS DES FORCES ===
                const up = new THREE.Vector3(0, 1, 0);
                const liftDirection = new THREE.Vector3();
                liftDirection.crossVectors(windDirection, up).normalize();
                liftDirection.crossVectors(liftDirection, windDirection).normalize();
                
                const dragDirection = windDirection.clone().multiplyScalar(-1);
                
                // === VECTEURS DE FORCES FINAUX ===
                const liftVector = liftDirection.multiplyScalar(liftMagnitude);
                const dragVector = dragDirection.multiplyScalar(dragMagnitude);
                const totalForce = liftVector.clone().add(dragVector);
                
                // === STABILISATION AUTOMATIQUE PAR LES LIGNES ===
                const stabilizingForce = this.calculateLineStabilizingForce(tensionData, aoaDegrees);
                totalForce.add(stabilizingForce);
                
                // === FORCE DE RESTAURATION DU BRIDAGE ===
                const angleError = (aoaDegrees - naturalBridleAngle);
                const restoringForce = angleError * 0.03 * windSpeed;
                const restoringVector = new THREE.Vector3(0, -restoringForce, 0);
                totalForce.add(restoringVector);
                
                // === STOCKAGE TÉLÉMÉTRIE ===
                this.telemetryData = {
                    lift: { direction: liftDirection.clone(), magnitude: liftMagnitude },
                    drag: { direction: dragDirection.clone(), magnitude: dragMagnitude },
                    totalAero: { direction: totalForce.clone().normalize(), magnitude: totalForce.length() },
                    windSpeed: { direction: windDirection.clone(), magnitude: windSpeed },
                    relativeWind: { direction: windDirection.clone(), magnitude: windSpeed },
                    normal: { direction: kiteNormal.clone(), magnitude: 1 },
                    lineTension: { left: tensionData.left, right: tensionData.right, ratio: tensionRatio }
                };
                
                // === MISE À JOUR DE L'INTERFACE ===
                this.updateAerodynamicsUI(aoaDegrees, tensionRatio, tensionData);
                
                return totalForce;
            }

            /**
             * Calcul des tensions des lignes
             */
            calculateLineTensions() {
                if (!this.simulator.kiteBuilder || !this.simulator.kiteBuilder.structure) {
                    return { left: KITE_CONFIG.lines.length, right: KITE_CONFIG.lines.length };
                }
                
                const pControleG = this.simulator.kiteBuilder.structure.getPoint("P_CONTROLE_G");
                const pControleD = this.simulator.kiteBuilder.structure.getPoint("P_CONTROLE_D");
                
                if (!pControleG || !pControleD) {
                    return { left: KITE_CONFIG.lines.length, right: KITE_CONFIG.lines.length };
                }
                
                const leftControlPoint = pControleG.position.clone().applyMatrix4(this.simulator.kite.matrixWorld);
                const rightControlPoint = pControleD.position.clone().applyMatrix4(this.simulator.kite.matrixWorld);
                
                const leftGroundAttach = new THREE.Vector3(-0.35, 1.2, 0);
                const rightGroundAttach = new THREE.Vector3(0.35, 1.2, 0);
                
                const leftTension = leftControlPoint.distanceTo(leftGroundAttach);
                const rightTension = rightControlPoint.distanceTo(rightGroundAttach);
                
                return { left: leftTension, right: rightTension };
            }

            /**
             * Calcul de l'angle du cerf-volant basé sur les lignes
             */
            calculateKiteAngleFromLines(kitePosition, tensionData) {
                const groundCenter = new THREE.Vector3(0, 1.2, 0);
                const lineVector = kitePosition.clone().sub(groundCenter);
                const horizontalDistance = Math.sqrt(lineVector.x * lineVector.x + lineVector.z * lineVector.z);
                
                if (horizontalDistance < 0.1) return 45;
                
                const elevation = Math.atan2(lineVector.y, horizontalDistance) * (180 / Math.PI);
                let baseAngle = Math.max(5, Math.min(85, 90 - elevation));
                
                const tensionDiff = tensionData.left - tensionData.right;
                const lateralCorrection = tensionDiff * 2;
                
                return baseAngle + lateralCorrection;
            }

            /**
             * Calcul des forces de stabilisation des lignes
             */
            calculateLineStabilizingForce(tensionData, aoaDegrees) {
                const stabilizingForce = new THREE.Vector3();
                
                const tensionDiff = tensionData.left - tensionData.right;
                if (Math.abs(tensionDiff) > 0.1) {
                    const rollCorrection = tensionDiff * 0.5;
                    stabilizingForce.x -= rollCorrection;
                }
                
                const avgTension = (tensionData.left + tensionData.right) / 2;
                const tensionRatio = avgTension / KITE_CONFIG.lines.length;
                const naturalAngle = 25;
                const angleError = aoaDegrees - naturalAngle;
                const pitchCorrection = angleError * tensionRatio * 0.1;
                stabilizingForce.y -= pitchCorrection;
                
                return stabilizingForce;
            }

            /**
             * Mise à jour de l'interface utilisateur pour l'aérodynamique
             */
            updateAerodynamicsUI(aoaDegrees, tensionRatio, tensionData) {
                const aoaElement = document.getElementById('aoa');
                if (aoaElement) {
                    aoaElement.textContent = aoaDegrees.toFixed(0);
                    
                    if (tensionRatio < 0.8) {
                        aoaElement.style.color = '#ff6600';
                        aoaElement.style.fontWeight = 'bold';
                        if (aoaDegrees > 25) {
                            aoaElement.style.textShadow = '0 0 5px #ff0000';
                            const time = Date.now() * 0.01;
                            aoaElement.style.opacity = 0.5 + 0.5 * Math.sin(time);
                        }
                    } else if (tensionRatio < 0.9) {
                        aoaElement.style.color = '#ffff00';
                        aoaElement.style.fontWeight = 'normal';
                        aoaElement.style.textShadow = '0 0 3px #ffff00';
                        aoaElement.style.opacity = '1';
                    } else {
                        aoaElement.style.color = '#00ff00';
                        aoaElement.style.fontWeight = 'normal';
                        aoaElement.style.textShadow = 'none';
                        aoaElement.style.opacity = '1';
                    }
                    
                    if (aoaDegrees > 35 && tensionRatio > 0.8) {
                        aoaElement.style.color = '#ff9900';
                        aoaElement.style.textShadow = '0 0 8px #ff9900';
                    }
                }
                
                const tensionLeftElement = document.getElementById('tensionLeft');
                const tensionRightElement = document.getElementById('tensionRight');
                if (tensionLeftElement) tensionLeftElement.textContent = tensionData.left.toFixed(1);
                if (tensionRightElement) tensionRightElement.textContent = tensionData.right.toFixed(1);
            }
            
            /**
             * Calcul des forces de bridage
             */
            calculateBridageForces() {
                const forces = new THREE.Vector3();
                if (!this.simulator.kiteBuilder || !this.simulator.kiteBuilder.structure) return forces;
                
                const pControleG = this.simulator.kiteBuilder.structure.getPoint("P_CONTROLE_G");
                const pControleD = this.simulator.kiteBuilder.structure.getPoint("P_CONTROLE_D");
                if (!pControleG || !pControleD) return forces;
                
                // Positions des points de contrôle en coordonnées monde
                const leftControlPoint = pControleG.position.clone().applyMatrix4(this.simulator.kite.matrixWorld);
                const rightControlPoint = pControleD.position.clone().applyMatrix4(this.simulator.kite.matrixWorld);
                
                // Points d'attache au sol
                const leftGroundAttach = new THREE.Vector3(
                    KITE_CONFIG.lines.attachments.ground.left.x,
                    KITE_CONFIG.lines.attachments.ground.left.y,
                    KITE_CONFIG.lines.attachments.ground.left.z
                );
                const rightGroundAttach = new THREE.Vector3(
                    KITE_CONFIG.lines.attachments.ground.right.x,
                    KITE_CONFIG.lines.attachments.ground.right.y,
                    KITE_CONFIG.lines.attachments.ground.right.z
                );
                
                // === CALCUL DES TENSIONS ===
                const leftVector = leftControlPoint.clone().sub(leftGroundAttach);
                const rightVector = rightControlPoint.clone().sub(rightGroundAttach);
                const leftTension = leftVector.length();
                const rightTension = rightVector.length();
                const lineLength = KITE_CONFIG.lines.length;
                
                // === FORCE DE CONTRAINTE DES LIGNES ===
                if (leftTension > lineLength) {
                    const excess = leftTension - lineLength;
                    const pullDirection = leftVector.normalize().multiplyScalar(-1);
                    forces.add(pullDirection.multiplyScalar(excess * KITE_CONFIG.lines.tensionMultiplier));
                }
                
                if (rightTension > lineLength) {
                    const excess = rightTension - lineLength;
                    const pullDirection = rightVector.normalize().multiplyScalar(-1);
                    forces.add(pullDirection.multiplyScalar(excess * KITE_CONFIG.lines.tensionMultiplier));
                }
                
                // === FORCE DE STABILISATION LATÉRALE ===
                const tensionDifference = leftTension - rightTension;
                if (Math.abs(tensionDifference) > 0.1) {
                    const lateralForce = tensionDifference * 3.0;
                    const rightDirection = new THREE.Vector3(1, 0, 0);
                    forces.add(rightDirection.multiplyScalar(lateralForce));
                }
                
                return forces;
            }
            
            /**
             * Calcul de la gravité
             */
            calculateGravity() {
                return new THREE.Vector3(0, KITE_CONFIG.physics.gravity * KITE_CONFIG.physics.kiteMass, 0);
            }
            
            /**
             * Mise à jour de la physique principale avec validation des paramètres
             */
            updatePhysics(deltaTime, kitePosition, kiteVelocity, windForce) {
                if (!this.simulator.state.isFlying) return;
                
                // Validation et limitation des paramètres d'entrée
                deltaTime = VALIDATION_UTILS.clampDeltaTime(deltaTime);
                kitePosition = VALIDATION_UTILS.validateVector3(kitePosition, new THREE.Vector3(0, 10, 0));
                kiteVelocity = VALIDATION_UTILS.validateVector3(kiteVelocity, new THREE.Vector3());
                windForce = VALIDATION_UTILS.validateVector3(windForce, new THREE.Vector3());
                
                // === CALCUL DES FORCES ===
                this.forces.gravity = this.calculateGravity();
                this.forces.aerodynamic = this.calculateAerodynamicForces(kitePosition, kiteVelocity, windForce);
                this.forces.bridage = this.calculateBridageForces();
                this.forces.total = this.forces.gravity.clone()
                    .add(this.forces.aerodynamic)
                    .add(this.forces.bridage);
                
                // === VÉRIFICATION DE VALIDITÉ ===
                if (!this.isValidVector(this.forces.total)) {
                    console.warn("Forces non valides détectées, reset...");
                    this.simulator.emergencyReset();
                    return { velocity: kiteVelocity, position: kitePosition };
                }
                
                // === INTÉGRATION DE LA VITESSE ===
                const acceleration = this.forces.total.clone().divideScalar(KITE_CONFIG.physics.kiteMass);
                kiteVelocity.add(acceleration.multiplyScalar(deltaTime));
                
                // === LIMITATION DE VITESSE ===
                const maxVelocity = KITE_CONFIG.aerodynamics.limits.maxVelocity;
                if (kiteVelocity.length() > maxVelocity) {
                    kiteVelocity.normalize().multiplyScalar(maxVelocity);
                    
                    // Log périodique de limitation
                    if (this.simulator.frameCounter % 120 === 0) {
                        this.simulator.logMessage(`⚡ Vitesse limitée à ${maxVelocity} m/s`, 'warn');
                    }
                }
                
                // === AMORTISSEMENT NATUREL ===
                kiteVelocity.multiplyScalar(KITE_CONFIG.aerodynamics.stability.dampingFactor);
                
                // === INTÉGRATION DE LA POSITION ===
                kitePosition.add(kiteVelocity.clone().multiplyScalar(deltaTime));
                
                // === VÉRIFICATION DE POSITION ===
                if (!this.isValidVector(kitePosition)) {
                    console.warn("Position non valide détectée, reset...");
                    this.simulator.emergencyReset();
                    return { velocity: kiteVelocity, position: kitePosition };
                }
                
                // === CONTRAINTE DE HAUTEUR MINIMALE ===
                if (kitePosition.y < 0.5) {
                    kitePosition.y = 0.5;
                    kiteVelocity.y = Math.max(0, kiteVelocity.y);
                    
                    // Log de contact avec le sol
                    if (kiteVelocity.length() > 5 && this.simulator.frameCounter % 60 === 0) {
                        this.simulator.logMessage('⚠️ Contact avec le sol !', 'warn');
                    }
                }
                
                return { velocity: kiteVelocity, position: kitePosition };
            }
            
            /**
             * Vérification de validité d'un vecteur
             */
            isValidVector(vector) {
                return isFinite(vector.x) && isFinite(vector.y) && isFinite(vector.z);
            }
            
            /**
             * Obtenir les données de télémétrie
             */
            getTelemetryData() {
                return this.telemetryData;
            }
            
            /**
             * Obtenir les forces calculées
             */
            getForces() {
                return { ...this.forces };
            }
            
            /**
             * Reset des forces et données
             */
            reset() {
                this.forces = {
                    gravity: new THREE.Vector3(),
                    aerodynamic: new THREE.Vector3(),
                    bridage: new THREE.Vector3(),
                    total: new THREE.Vector3()
                };
                
                this.telemetryData = {
                    lift: { direction: new THREE.Vector3(0, 1, 0), magnitude: 0 },
                    drag: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    totalAero: { direction: new THREE.Vector3(0, 0, 0), magnitude: 0 },
                    windSpeed: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    relativeWind: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    normal: { direction: new THREE.Vector3(0, 0, 1), magnitude: 1 }
                };
            }
        }

        // =====================================================================================
        // === SYSTÈME MÉTÉO DYNAMIQUE ===
        // =====================================================================================
        class WeatherSystem {
            constructor(scene, simulator) {
                this.scene = scene;
                this.simulator = simulator;
                
                // États météo possibles
                this.weatherStates = {
                    CLEAR: { name: 'Clair', windBase: 5, turbulence: 0.1, fogDensity: 0.001 },
                    PARTLY_CLOUDY: { name: 'Partiellement nuageux', windBase: 7, turbulence: 0.2, fogDensity: 0.002 },
                    CLOUDY: { name: 'Nuageux', windBase: 10, turbulence: 0.3, fogDensity: 0.004 },
                    WINDY: { name: 'Venteux', windBase: 15, turbulence: 0.4, fogDensity: 0.003 },
                    STORMY: { name: 'Orageux', windBase: 20, turbulence: 0.6, fogDensity: 0.006 }
                };
                
                this.currentWeather = 'CLEAR';
                this.transitionProgress = 0;
                this.targetWeather = 'CLEAR';
                
                this.createWeatherUI();
            }
            
            createWeatherUI() {
                // Ajouter un sélecteur de météo dans l'interface
                const controlPanel = document.getElementById('control-panel');
                if (!controlPanel) return;
                
                const weatherControl = document.createElement('div');
                weatherControl.className = 'control-section';
                weatherControl.innerHTML = `
                    <h3>🌤️ Conditions Météo</h3>
                    <select id="weatherSelect" class="weather-select">
                        <option value="CLEAR">☀️ Clair</option>
                        <option value="PARTLY_CLOUDY">⛅ Partiellement nuageux</option>
                        <option value="CLOUDY">☁️ Nuageux</option>
                        <option value="WINDY">💨 Venteux</option>
                        <option value="STORMY">⛈️ Orageux</option>
                    </select>
                    <div class="weather-info">
                        <span id="weatherStatus">Conditions: Clair</span>
                    </div>
                `;
                
                // Insérer au début du panneau de contrôle
                controlPanel.insertBefore(weatherControl, controlPanel.firstChild);
                
                // Event listener
                document.getElementById('weatherSelect').addEventListener('change', (e) => {
                    this.changeWeather(e.target.value);
                });
            }
            
            changeWeather(newWeather) {
                if (newWeather !== this.currentWeather) {
                    this.targetWeather = newWeather;
                    this.transitionProgress = 0;
                    
                    const weatherData = this.weatherStates[newWeather];
                    this.simulator.logMessage(`🌤️ Changement météo vers: ${weatherData.name}`, 'info');
                }
            }
            
            update(deltaTime) {
                if (this.targetWeather !== this.currentWeather) {
                    // Transition progressive
                    this.transitionProgress += deltaTime * 0.2; // 5 secondes de transition
                    
                    if (this.transitionProgress >= 1) {
                        this.currentWeather = this.targetWeather;
                        this.transitionProgress = 1;
                    }
                    
                    // Interpolation des paramètres
                    const current = this.weatherStates[this.currentWeather];
                    const target = this.weatherStates[this.targetWeather];
                    
                    const windSpeed = MATH_HELPERS.lerp(current.windBase, target.windBase, this.transitionProgress);
                    const turbulence = MATH_HELPERS.lerp(current.turbulence, target.turbulence, this.transitionProgress);
                    const fogDensity = MATH_HELPERS.lerp(current.fogDensity, target.fogDensity, this.transitionProgress);
                    
                    // Application des changements
                    if (this.simulator.windManager) {
                        this.simulator.windManager.setWindSpeed(windSpeed);
                        this.simulator.windManager.setTurbulence(turbulence);
                    }
                    
                    if (this.scene.fog) {
                        this.scene.fog.density = fogDensity;
                    }
                    
                    // Mise à jour UI
                    const weatherStatus = document.getElementById('weatherStatus');
                    if (weatherStatus) {
                        weatherStatus.textContent = `Conditions: ${this.weatherStates[this.currentWeather].name}`;
                    }
                }
            }
        }

        /**
         * CLASSE TELEMETRYSYSTEM - Système de visualisation des forces et vecteurs
         */
        class TelemetrySystem {
            constructor(scene, kite) {
                this.scene = scene;
                this.kite = kite;
                this.vectors = new Map();
                this.labels = new Map();
                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                this.initializeVectors();
            }
            
            initializeVectors() {
                const config = KITE_CONFIG.telemetry.vectors;
                
                Object.entries(config).forEach(([name, settings]) => {
                    if (settings.enabled) {
                        // Créer le vecteur
                        const arrowHelper = new THREE.ArrowHelper(
                            new THREE.Vector3(0, 1, 0), // Direction initiale
                            new THREE.Vector3(0, 0, 0), // Origine
                            1,                          // Longueur
                            settings.color,             // Couleur
                            KITE_CONFIG.telemetry.display.arrowSize * 2,  // Longueur de la tête
                            KITE_CONFIG.telemetry.display.arrowSize       // Largeur de la tête
                        );
                        arrowHelper.visible = false;
                        this.group.add(arrowHelper);
                        this.vectors.set(name, arrowHelper);
                        
                        // Créer l'étiquette
                        const sprite = this.createVectorLabel(settings.label, settings.color);
                        sprite.visible = false;
                        this.group.add(sprite);
                        this.labels.set(name, sprite);
                    }
                });
            }
            
            createVectorLabel(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Fond semi-transparent
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Bordure colorée
                context.strokeStyle = '#' + color.toString(16).padStart(6, '0');
                context.lineWidth = 3;
                context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                
                // Texte
                context.font = 'Bold 24px Arial';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: KITE_CONFIG.telemetry.display.opacity
                });
                
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(KITE_CONFIG.telemetry.display.labelSize * 2, KITE_CONFIG.telemetry.display.labelSize, 1);
                
                return sprite;
            }
            
            updateVector(name, origin, direction, magnitude) {
                const vector = this.vectors.get(name);
                const label = this.labels.get(name);
                
                if (vector && magnitude > 0.01) {
                    // Mettre à jour la position et direction
                    vector.position.copy(origin);
                    vector.setDirection(direction.normalize());
                    vector.setLength(
                        magnitude * KITE_CONFIG.telemetry.vectorScale,
                        magnitude * KITE_CONFIG.telemetry.vectorScale * 0.2,
                        magnitude * KITE_CONFIG.telemetry.vectorScale * 0.1
                    );
                    vector.visible = true;
                    
                    // Mettre à jour la position de l'étiquette
                    if (label) {
                        const labelPos = origin.clone().add(direction.clone().multiplyScalar(magnitude * KITE_CONFIG.telemetry.vectorScale * PHYSICS_CONSTANTS.VECTOR_SCALE_FACTOR));
                        label.position.copy(labelPos);
                        label.visible = true;
                    }
                } else if (vector) {
                    vector.visible = false;
                    if (label) label.visible = false;
                }
            }
            
            setEnabled(enabled) {
                this.group.visible = enabled;
            }
            
            clear() {
                this.vectors.forEach(vector => vector.visible = false);
                this.labels.forEach(label => label.visible = false);
            }
        }

        // =====================================================================================
        // === GESTIONNAIRE DE CAMÉRA INTELLIGENT ===
        // =====================================================================================
        // Cette classe encapsule toute la logique de gestion de la caméra, incluant les modes
        // libre et suivi automatique, les contrôles AZERTY, et le zoom intelligent.
        class CameraManager {
            constructor(scene, renderer) {
                this.scene = scene;
                this.renderer = renderer;
                
                // === CONFIGURATION DEPUIS KITE_CONFIG ===
                this.config = KITE_CONFIG.camera;
                
                // === CRÉATION DE LA CAMÉRA THREE.JS ===
                this.camera = new THREE.PerspectiveCamera(
                    this.config.fov,
                    window.innerWidth / window.innerHeight,
                    this.config.near,
                    this.config.far
                );
                
                // === ÉTAT DE LA CAMÉRA ===
                this.mode = 'free'; // 'free' ou 'follow'
                this.keys = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    up: false,
                    down: false
                };
                
                // === PARAMÈTRES DYNAMIQUES ===
                this.followDistance = this.config.followMode.distance;
                this.followHeight = this.config.followMode.height;
                
                // === POSITION INITIALE ===
                this.initialPosition = new THREE.Vector3(
                    this.config.initialPosition.x,
                    this.config.initialPosition.y,
                    this.config.initialPosition.z
                );
                this.initialTarget = new THREE.Vector3(
                    this.config.lookAt.x,
                    this.config.lookAt.y,
                    this.config.lookAt.z
                );
                
                // === ÉTAT INTERNE ===
                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                
                // === INITIALISATION ===
                this.reset();
                this.setupEventListeners();
            }
            
            // === CONFIGURATION DES CONTRÔLES ===
            setupEventListeners() {
                // === REDIMENSIONNEMENT FENÊTRE ===
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // === CONTRÔLES SOURIS ===
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    this.isMouseDown = true;
                    this.mouseX = event.clientX;
                    this.mouseY = event.clientY;
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.isMouseDown = false;
                });
                
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (this.isMouseDown && this.mode === 'free') {
                        const deltaX = event.clientX - this.mouseX;
                        const deltaY = event.clientY - this.mouseY;
                        
                        // Rotation horizontale (lacet)
                        this.camera.rotateY(-deltaX * this.config.movement.rotationSensitivity);
                        
                        // Rotation verticale (tangage) avec limitation
                        const pitch = -deltaY * this.config.movement.rotationSensitivity;
                        const rightVector = new THREE.Vector3();
                        rightVector.setFromMatrixColumn(this.camera.matrix, 0);
                        this.camera.rotateOnWorldAxis(rightVector, pitch);
                        
                        this.mouseX = event.clientX;
                        this.mouseY = event.clientY;
                    }
                });
                
                // === ZOOM INTELLIGENT ===
                this.renderer.domElement.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    
                    if (this.config.intelligentZoom.enabled && this.targetObject) {
                        // Zoom vers le cerf-volant (ou objet cible)
                        const targetDirection = this.targetObject.position.clone()
                            .sub(this.camera.position)
                            .normalize();
                        
                        const zoomDistance = (event.deltaY > 0 ? 1 : -1) * 
                            this.config.movement.zoomSpeed * 
                            this.config.intelligentZoom.speedMultiplier;
                        
                        // Nouvelle position avec contraintes
                        const newPosition = this.camera.position.clone()
                            .add(targetDirection.multiplyScalar(zoomDistance));
                        
                        const distanceToTarget = newPosition.distanceTo(this.targetObject.position);
                        
                        if (distanceToTarget >= this.config.intelligentZoom.minZoomDistance &&
                            distanceToTarget <= this.config.intelligentZoom.maxZoomDistance) {
                            this.camera.position.copy(newPosition);
                        }
                    }
                }, { passive: false });
                
                // === CONTRÔLES CLAVIER ===
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        case this.config.controls.forward:
                            this.keys.forward = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.backward:
                            this.keys.backward = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.left:
                            this.keys.left = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.right:
                            this.keys.right = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.up:
                            this.keys.up = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.down:
                            this.keys.down = true;
                            event.preventDefault();
                            break;
                        case this.config.controls.toggleMode:
                            this.toggleMode();
                            event.preventDefault();
                            break;
                        case this.config.controls.reset:
                            this.reset();
                            event.preventDefault();
                            break;
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    switch(event.code) {
                        case this.config.controls.forward:
                            this.keys.forward = false;
                            event.preventDefault();
                            break;
                        case this.config.controls.backward:
                            this.keys.backward = false;
                            event.preventDefault();
                            break;
                        case this.config.controls.left:
                            this.keys.left = false;
                            event.preventDefault();
                            break;
                        case this.config.controls.right:
                            this.keys.right = false;
                            event.preventDefault();
                            break;
                        case this.config.controls.up:
                            this.keys.up = false;
                            event.preventDefault();
                            break;
                        case this.config.controls.down:
                            this.keys.down = false;
                            event.preventDefault();
                            break;
                    }
                });
                
                // === GESTION DE LA PERTE DE FOCUS ===
                // Arrêter tous les mouvements quand la fenêtre perd le focus
                window.addEventListener('blur', () => {
                    this.stopAllMovement();
                });
                
                // === GESTION DU FOCUS/DÉFOCUS DES ÉLÉMENTS UI ===
                // Arrêter les mouvements si un élément UI prend le focus
                document.addEventListener('focusin', (event) => {
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'BUTTON' || event.target.tagName === 'SELECT') {
                        this.stopAllMovement();
                    }
                });
            }
            
            // === MÉTHODE POUR FORCER L'ARRÊT DE TOUS LES MOUVEMENTS ===
            stopAllMovement() {
                this.keys.forward = false;
                this.keys.backward = false;
                this.keys.left = false;
                this.keys.right = false;
                this.keys.up = false;
                this.keys.down = false;
            }
            
            // === DÉFINIR L'OBJET À SUIVRE ===
            setTarget(target) {
                this.targetObject = target;
            }
            
            // === BASCULER ENTRE MODES ===
            toggleMode() {
                this.mode = this.mode === 'free' ? 'follow' : 'free';
                
                // Notification visuelle via le système de logs
                const modeText = this.mode === 'follow' ? 'Suivi automatique' : 'Libre';
                // Note: logMessage appelé depuis le simulateur principal
                
                return this.mode;
            }
            
            // === RESET POSITION ===
            reset() {
                this.mode = 'free';
                this.camera.position.copy(this.initialPosition);
                this.camera.lookAt(this.initialTarget);
                
                // Reset paramètres de suivi
                this.followDistance = this.config.followMode.distance;
                this.followHeight = this.config.followMode.height;
                
                // Note: notification de reset via le système de logs principal
            }
            
            // === MISE À JOUR PRINCIPALE ===
            update(deltaTime) {
                if (!deltaTime) return;
                
                if (this.mode === 'follow' && this.targetObject) {
                    this.updateFollowMode(deltaTime);
                } else {
                    this.updateFreeMode(deltaTime);
                }
            }
            
            // === MODE LIBRE ===
            updateFreeMode(deltaTime) {
                // === VÉRIFICATION DE SÉCURITÉ ===
                // Si aucune touche n'est pressée, on ne fait rien
                const hasInput = this.keys.forward || this.keys.backward || 
                                this.keys.left || this.keys.right || 
                                this.keys.up || this.keys.down;
                
                if (!hasInput) {
                    return; // Aucun mouvement si aucune touche pressée
                }
                
                const moveDistance = this.config.movement.speed * deltaTime;
                
                // Vecteurs de direction
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(0, 1, 0);
                
                this.camera.getWorldDirection(forward);
                right.crossVectors(forward, up).normalize();
                
                // Mouvement
                const movement = new THREE.Vector3();
                
                if (this.keys.forward) {
                    movement.add(forward.clone().multiplyScalar(moveDistance));
                }
                if (this.keys.backward) {
                    movement.add(forward.clone().multiplyScalar(-moveDistance));
                }
                if (this.keys.left) {
                    movement.add(right.clone().multiplyScalar(-moveDistance));
                }
                if (this.keys.right) {
                    movement.add(right.clone().multiplyScalar(moveDistance));
                }
                if (this.keys.up) {
                    movement.add(up.clone().multiplyScalar(moveDistance));
                }
                if (this.keys.down) {
                    movement.add(up.clone().multiplyScalar(-moveDistance));
                }
                
                // === APPLICATION DU MOUVEMENT AVEC CONTRAINTES ===
                const newPosition = this.camera.position.clone().add(movement);
                
                // Contrainte de hauteur minimale
                if (newPosition.y < 0.5) {
                    newPosition.y = 0.5;
                }
                
                this.camera.position.copy(newPosition);
                
                // Contrainte au sol
                if (this.config.movement.constrainToGround && 
                    this.camera.position.y < this.config.movement.groundHeight) {
                    this.camera.position.y = this.config.movement.groundHeight;
                }
            }
            
            // === MODE SUIVI ===
            updateFollowMode(deltaTime) {
                if (!this.targetObject) return;
                
                const targetPos = this.targetObject.position.clone();
                
                // Position idéale de la caméra
                const idealOffset = new THREE.Vector3(0, this.followHeight, this.followDistance);
                const targetCameraPos = targetPos.clone().add(idealOffset);
                
                // Interpolation douce
                this.camera.position.lerp(targetCameraPos, this.config.followMode.smoothing);
                
                // Orienter vers la cible
                this.camera.lookAt(targetPos);
                
                // Ajustements manuels en mode suivi
                if (this.keys.up || this.keys.down) {
                    const adjust = (this.keys.up ? 1 : -1) * this.config.followMode.manualAdjustmentSpeed * deltaTime;
                    this.followHeight = Math.max(2, this.followHeight + adjust);
                }
                
                if (this.keys.forward || this.keys.backward) {
                    const adjust = (this.keys.backward ? 1 : -1) * this.config.followMode.manualAdjustmentSpeed * deltaTime;
                    this.followDistance = Math.max(5, Math.min(30, this.followDistance + adjust));
                }
            }
            
            // === GETTERS ===
            getCamera() {
                return this.camera;
            }
            
            getMode() {
                return this.mode;
            }
        }

        // =====================================================================================
        // === SYSTÈME DE COLLISION AVANCÉ ===
        // =====================================================================================
        class CollisionSystem {
            constructor(simulator) {
                this.simulator = simulator;
                this.groundLevel = 0.5;
                this.bounceCoefficient = 0.3;
                this.frictionCoefficient = 0.8;
                
                // Zones de danger (arbres, bâtiments, etc.)
                this.obstacles = [];
                this.createObstacles();
            }
            
            createObstacles() {
                // Création d'arbres simples comme obstacles
                const treeGeometry = new THREE.ConeGeometry(3, 10, 8);
                const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
                
                const treePositions = [
                    { x: -20, z: -20 },
                    { x: 20, z: -25 },
                    { x: -15, z: 15 },
                    { x: 25, z: 20 }
                ];
                
                treePositions.forEach(pos => {
                    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                    tree.position.set(pos.x, 5, pos.z);
                    tree.castShadow = true;
                    tree.receiveShadow = true;
                    
                    this.simulator.scene.add(tree);
                    
                    // Ajouter à la liste des obstacles
                    this.obstacles.push({
                        position: new THREE.Vector3(pos.x, 5, pos.z),
                        radius: 3,
                        height: 10,
                        type: 'tree'
                    });
                });
            }
            
            checkCollisions(kitePosition, kiteVelocity) {
                let collision = null;
                
                // === Collision avec le sol ===
                if (kitePosition.y <= this.groundLevel) {
                    collision = {
                        type: 'ground',
                        point: new THREE.Vector3(kitePosition.x, this.groundLevel, kitePosition.z),
                        normal: new THREE.Vector3(0, 1, 0)
                    };
                    
                    // Rebond avec perte d'énergie
                    kiteVelocity.y = Math.abs(kiteVelocity.y) * this.bounceCoefficient;
                    kiteVelocity.x *= this.frictionCoefficient;
                    kiteVelocity.z *= this.frictionCoefficient;
                    
                    // Ajuster la position
                    kitePosition.y = this.groundLevel;
                    
                    this.simulator.logMessage('💥 Impact au sol !', 'warn');
                }
                
                // === Collision avec les obstacles ===
                this.obstacles.forEach(obstacle => {
                    const distance = kitePosition.distanceTo(obstacle.position);
                    
                    if (distance < obstacle.radius && kitePosition.y < obstacle.height) {
                        collision = {
                            type: obstacle.type,
                            point: obstacle.position.clone(),
                            normal: kitePosition.clone().sub(obstacle.position).normalize()
                        };
                        
                        // Rebond élastique
                        kiteVelocity.reflect(collision.normal);
                        kiteVelocity.multiplyScalar(0.5);
                        
                        // Éloigner le cerf-volant de l'obstacle
                        const pushDirection = collision.normal.clone();
                        kitePosition.add(pushDirection.multiplyScalar(obstacle.radius - distance + 0.5));
                        
                        this.simulator.logMessage(`💥 Collision avec ${obstacle.type} !`, 'error');
                        
                        // Effet visuel de collision
                        this.createCollisionEffect(collision.point);
                    }
                });
                
                return collision;
            }
            
            createCollisionEffect(position) {
                // Particules d'impact simples
                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                
                for (let i = 0; i < 10; i++) {
                    const particle = new THREE.Mesh(geometry, material.clone());
                    particle.position.copy(position);
                    
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 5
                    );
                    
                    this.simulator.scene.add(particle);
                    
                    // Animation de la particule
                    const startTime = Date.now();
                    const animate = () => {
                        const elapsed = (Date.now() - startTime) / 1000;
                        
                        if (elapsed < 1) {
                            particle.position.add(velocity.clone().multiplyScalar(0.016));
                            velocity.y -= 9.8 * 0.016;
                            particle.material.opacity = 1 - elapsed;
                            
                            requestAnimationFrame(animate);
                        } else {
                            this.simulator.scene.remove(particle);
                            particle.geometry.dispose();
                            particle.material.dispose();
                        }
                    };
                    
                    animate();
                }
            }
        }

        // =====================================================================================
        // === CLASSE PRINCIPALE DU SIMULATEUR DE CERF-VOLANT ===
        // =====================================================================================
        // Cette classe gère l'ensemble du simulateur : physique, rendu 3D, interface utilisateur
        // et interactions. Elle coordonne tous les systèmes pour créer une simulation réaliste.
        class KiteFlightSimulator {
            constructor() {
                // === ÉTAT GLOBAL DU SIMULATEUR ===
                // Centralise toutes les variables d'état qui contrôlent le comportement du simulateur
                this.state = {
                    isFlying: false,                    // Indique si le cerf-volant est en vol ou au repos
                    isPaused: false,                    // Indique si la simulation est en pause
                    windSpeed: KITE_CONFIG.wind.defaultSpeed,           // Vitesse du vent en m/s
                    turbulence: KITE_CONFIG.wind.turbulence.scale,      // Intensité des turbulences (0-1)
                    controlInput: 0,                    // Entrée de contrôle utilisateur (-1 à 1)
                    showAnnotations: false,             // Affichage des annotations de debug
                    showTrail: true,                    // Affichage de la traînée du cerf-volant
                    showTelemetry: false,               // Affichage du panneau de télémétrie
                    showConsole: true,                  // Affichage du panneau de console
                    showLegend: true,                   // Affichage de la légende des forces
                    windDirection: KITE_CONFIG.wind.defaultDirection    // Direction du vent en degrés
                };

                // === COMPTEURS ET VARIABLES DE CONTRÔLE ===
                // Ces variables permettent d'optimiser les performances en limitant la fréquence
                // de certaines opérations coûteuses comme les logs ou les calculs complexes
                this.frameCounter = 0;              // Compteur de frames pour la temporisation
                this.lastLoggedSpeed = 0;           // Dernière vitesse loggée (évite le spam)
                this.lastLoggedAltitude = 0;        // Dernière altitude loggée (évite le spam)

                // === MANAGERS CENTRALISÉS ===
                // Ces managers encapsulent les responsabilités spécifiques pour une architecture propre
                this.windManager = null;            // Gestionnaire du système de vent
                this.physicsManager = null;         // Gestionnaire de la physique
                this.cameraManager = null;          // Gestionnaire de la caméra

                // === INITIALISATION DES SYSTÈMES ===
                // L'ordre d'initialisation est important : console d'abord pour capturer
                // tous les messages de debug, puis les systèmes 3D
                this.initConsoleSystem();           // Système de logging et debug
                this.init();                        // Initialisation du moteur 3D et physique
            }

            // =====================================================================================
            // === INITIALISATION DU MOTEUR 3D ET DE LA SCÈNE ===
            // =====================================================================================
            // Cette fonction configure les composants de base de Three.js : scène, caméra,
            // renderer, éclairage. Elle prépare l'environnement 3D avant d'ajouter les objets.
            init() {
                // === ÉTAPE 1 : CONFIGURATION DE BASE THREE.JS ===
                
                // Configuration de la scène 3D principale
                this.scene = new THREE.Scene();
                // Ajout du brouillard pour créer une atmosphère réaliste
                // Plus les objets sont loin, plus ils deviennent flous (effet de distance)
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);  // Couleur ciel, début/fin du brouillard

                // Configuration de la caméra perspective (vision humaine)
                this.camera = new THREE.PerspectiveCamera(
                    60,                                 // Angle de vue (field of view) en degrés
                    window.innerWidth / window.innerHeight,  // Ratio largeur/hauteur
                    0.1,                               // Distance minimale de rendu
                    1000                               // Distance maximale de rendu
                );
                // Position initiale de la caméra : légèrement élevée et en arrière
                this.camera.position.set(0, 10, 30);
                this.camera.lookAt(0, 5, 0);          // Regarde vers un point légèrement élevé

                // Configuration du moteur de rendu WebGL
                this.renderer = new THREE.WebGLRenderer({ antialias: true });  // Antialiasing pour des bords lisses
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                // Activation des ombres pour plus de réalisme
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Ombres douces
                // Ajout du canvas au DOM
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // === ÉTAPE 2 : CONFIGURATION DE L'ÉCLAIRAGE ===
                // Un bon éclairage est crucial pour la perception 3D et le réalisme
                
                // Lumière ambiante : éclairage global uniforme (simule la lumière diffusée par l'atmosphère)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);  // Blanc, intensité modérée
                this.scene.add(ambientLight);

                // Lumière directionnelle : simule le soleil (lumière parallèle avec ombres)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);  // Blanc, forte intensité
                directionalLight.position.set(50, 100, 50);    // Position du "soleil"
                directionalLight.castShadow = true;            // Cette lumière projette des ombres
                // Configuration de la qualité des ombres
                directionalLight.shadow.mapSize.width = 2048;  // Résolution de la carte d'ombre
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // === ÉTAPE 3 : INITIALISATION DES VARIABLES PHYSIQUES ===
                // Ces variables stockent l'état physique du cerf-volant
                this.kiteVelocity = new THREE.Vector3(0, 0, 0);        // Vitesse linéaire (m/s)
                this.kiteAngularVelocity = new THREE.Vector3(0, 0, 0); // Vitesse angulaire (rad/s)
                this.clock = new THREE.Clock();                        // Horloge pour le deltaTime
                
                // === ÉTAPE 4 : INITIALISATION DES MANAGERS ===
                // Création des gestionnaires centralisés pour une architecture propre
                this.windManager = new WindManager(this.scene, this);
                this.physicsManager = new PhysicsManager(this);
                this.cameraManager = new CameraManager(this.scene, this.renderer);
                
                // === NOUVEAUX SYSTÈMES AMÉLIORÉS ===
                this.windParticleSystem = new WindParticleSystem(this.scene, 150);
                this.weatherSystem = new WeatherSystem(this.scene, this);
                this.collisionSystem = new CollisionSystem(this);
                
                // === UTILISATION DE LA CAMÉRA DU MANAGER ===
                // Remplacer la caméra temporaire par celle du CameraManager
                this.camera = this.cameraManager.camera;
                
                // === ÉTAPE 5 : INITIALISATION ASYNCHRONE ===
                // La création des objets complexes se fait de manière asynchrone pour éviter
                // de bloquer l'interface utilisateur pendant le chargement
                this.initializeEnvironmentAsync();
            }

            // =====================================================================================
            // === INITIALISATION ASYNCHRONE DE L'ENVIRONNEMENT ===
            // =====================================================================================
            // Cette approche asynchrone divise la création des objets complexes en étapes
            // pour maintenir la fluidité de l'interface utilisateur pendant le chargement
            async initializeEnvironmentAsync() {
                // === ÉTAPE 1 : SYSTÈMES D'INTERACTION RAPIDES ===
                // Ces éléments doivent être disponibles immédiatement
                this.setupControls();          // Configuration des contrôles souris/clavier
                this.setupEventListeners();    // Événements DOM et interactions
                
                // === ÉTAPE 2 : CRÉATION PROGRESSIVE DES OBJETS 3D ===
                // Chaque étape se fait avec un délai pour permettre le rendu intermédiaire
                await this.createEnvironmentStep();    // Terrain, ciel, station de contrôle
                await this.createKiteStep();           // Cerf-volant et sa structure
                await this.createLinesStep();          // Lignes de vol entre station et cerf-volant
                await this.createTrailStep();          // Système de traînée du cerf-volant
                
                // === ÉTAPE 3 : FINALISATION ===
                // Initialisation des indicateurs de vent (manche à air, boussole)
                this.updateWindIndicators();
                
                // === ÉTAPE 4 : DÉMARRAGE DE LA BOUCLE DE RENDU ===
                // Une fois tout initialisé, on lance l'animation en continu
                this.animate();
            }

            // =====================================================================================
            // === ÉTAPES DE CRÉATION ASYNCHRONE ===
            // =====================================================================================
            // Ces fonctions encapsulent chaque étape de création dans une Promise
            // avec un setTimeout pour éviter de bloquer le thread principal
            
            async createEnvironmentStep() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.createEnvironment();  // Création du terrain, ciel, station
                        resolve();
                    }, 10);  // Délai de 10ms pour permettre le rendu intermédiaire
                });
            }

            async createKiteStep() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.createKite();         // Création du cerf-volant
                        resolve();
                    }, 10);
                });
            }

            async createLinesStep() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.createLines();        // Création des lignes de vol
                        resolve();
                    }, 10);
                });
            }

            async createTrailStep() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        this.createTrail();        // Création du système de traînée
                        resolve();
                    }, 10);
                });
            }

            // =====================================================================================
            // === CRÉATION DE L'ENVIRONNEMENT 3D ===
            // =====================================================================================
            // Cette fonction crée tous les éléments statiques de la scène : terrain, ciel,
            // station de contrôle, et indicateurs de vent (manche à air, boussole)
            createEnvironment() {
                // === CRÉATION DU TERRAIN ===
                // Un plan horizontal qui sert de sol à la simulation
                const groundGeometry = new THREE.PlaneGeometry(300, 300);  // 300m x 300m
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 }); // Vert gazon
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;      // Rotation pour le mettre horizontal
                ground.receiveShadow = true;           // Le sol reçoit les ombres des objets
                this.scene.add(ground);

                // === GRILLE DE RÉFÉRENCE ===
                // Aide visuelle pour juger les distances et positions
                const grid = new THREE.GridHelper(300, 40, 0x444444, 0x888888);  // 40 subdivisions
                grid.position.y = 0.01;               // Légèrement au-dessus du sol pour éviter le z-fighting
                this.scene.add(grid);

                // === CRÉATION DU CIEL ===
                // Une sphère qui entoure toute la scène pour créer l'illusion d'un ciel
                const skyGeometry = new THREE.SphereGeometry(400, 32, 32);  // Rayon 400m
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,                   // Couleur bleu ciel
                    side: THREE.BackSide               // Rendu à l'intérieur de la sphère
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                // === CRÉATION DE LA STATION DE CONTRÔLE ===
                // Cette station représente l'endroit où se tient le pilote du cerf-volant
                const stationGroup = new THREE.Group();  // Groupe principal (statique)
                
                // === BASE DE LA STATION (STATIQUE) ===
                // Plateforme où se tient le pilote - reste toujours fixe
                const baseGeometry = new THREE.BoxGeometry(1.5, 0.2, 1.5);      // 1.5m x 20cm x 1.5m
                const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x2196f3 });  // Bleu
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.1;                 // Légèrement surélevée
                base.castShadow = true;                // Projette une ombre
                stationGroup.add(base);

                // === MÂT CENTRAL VERTICAL (STATIQUE) ===
                // Support de la barre de contrôle - point de pivot
                const poleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.3);  // Rayon 3cm, hauteur 1.3m
                const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); // Gris foncé
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 0.75;               // Centré verticalement
                pole.castShadow = true;
                stationGroup.add(pole);

                // === POINT DE PIVOT CENTRAL (STATIQUE) ===
                // Marqueur visuel du centre de rotation de la barre
                const pivotGeometry = new THREE.SphereGeometry(0.04, 12, 12);
                const pivotMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,           // Rouge pour visibilité
                    emissive: 0x440000         // Légèrement lumineux
                });
                const pivotPoint = new THREE.Mesh(pivotGeometry, pivotMaterial);
                pivotPoint.position.set(0, 1.2, 0);    // Centre de la barre
                pivotPoint.castShadow = true;
                stationGroup.add(pivotPoint);

                // === GROUPE MOBILE DE LA BARRE ===
                // Tous les éléments qui tournent ensemble
                const controlBarGroup = new THREE.Group();
                controlBarGroup.position.set(0, 1.2, 0);  // Positionné au centre de rotation
                
                // === BARRE DE CONTRÔLE HORIZONTALE (MOBILE) ===
                // Tube principal qui relie les poignées
                const controlBarGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.8);  // Tube de 1.5cm de rayon, 80cm de long
                const controlBarMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 }); // Gris
                const controlBar = new THREE.Mesh(controlBarGeometry, controlBarMaterial);
                controlBar.rotation.z = Math.PI / 2;   // Rotation de 90° pour la rendre horizontale
                controlBar.castShadow = true;
                controlBarGroup.add(controlBar);

                // === POIGNÉES DE CONTRÔLE (MOBILES) ===
                // Là où le pilote tient les lignes
                const handleGeometry = new THREE.SphereGeometry(0.08, 16, 16);    // Sphères de 8cm de rayon
                const handleMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b35 }); // Orange
                
                // Poignée gauche
                const handleLeft = new THREE.Mesh(handleGeometry, handleMaterial);
                handleLeft.position.set(-0.3, 0, 0);  // Position relative au groupe
                handleLeft.castShadow = true;
                controlBarGroup.add(handleLeft);
                
                // Poignée droite
                const handleRight = new THREE.Mesh(handleGeometry, handleMaterial);
                handleRight.position.set(0.3, 0, 0);   // Position relative au groupe
                handleRight.castShadow = true;
                controlBarGroup.add(handleRight);

                // === POINTS D'ATTACHE DES LIGNES (MOBILES) ===
                // Points où se connectent physiquement les lignes de vol
                const attachGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                const attachMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,           // Vert pour les distinguer
                    emissive: 0x004400         // Légèrement lumineux
                });
                
                // Point d'attache gauche
                const leftAttach = new THREE.Mesh(attachGeometry, attachMaterial);
                leftAttach.position.set(-0.35, 0, 0);  // Position relative au groupe
                leftAttach.castShadow = true;
                controlBarGroup.add(leftAttach);
                
                // Point d'attache droit
                const rightAttach = new THREE.Mesh(attachGeometry, attachMaterial);
                rightAttach.position.set(0.35, 0, 0);   // Position relative au groupe
                rightAttach.castShadow = true;
                controlBarGroup.add(rightAttach);

                // === AJOUT DU GROUPE MOBILE AU GROUPE PRINCIPAL ===
                stationGroup.add(controlBarGroup);

                // === STOCKAGE DES RÉFÉRENCES ===
                this.controlStation = stationGroup;     // Groupe principal statique
                
                // Stockage des éléments mobiles pour le pilotage
                this.controlBar = {
                    group: controlBarGroup,       // Le groupe entier qui pivote
                    bar: controlBar,              // La barre de contrôle
                    leftAttach: leftAttach,       // Point d'attache gauche
                    rightAttach: rightAttach,     // Point d'attache droit
                    handleLeft: handleLeft,       // Poignée gauche
                    handleRight: handleRight,     // Poignée droite
                    pivotPoint: pivotPoint,       // Point de pivot central
                    angle: 0,                     // Angle de rotation actuel
                    leftAttachPosition: new THREE.Vector3(-0.35, 1.2, 0),  // Position initiale
                    rightAttachPosition: new THREE.Vector3(0.35, 1.2, 0)   // Position initiale
                };
                
                this.scene.add(stationGroup);

                // === CRÉATION DES INDICATEURS DE VENT ===
                // Indicateur directionnel au sol (flèche orange)
                this.createWindDirectionIndicator();
                // Manche à air avec girouette (indicateur OACI standard)
                this.createWindsock();
            }

            createWindsock() {
                const windsockGroup = new THREE.Group();
                
                // === MÂT DE LA MANCHE À AIR ===
                // Mât en aluminium blanc de 4m de hauteur
                const mastGeometry = new THREE.CylinderGeometry(0.04, 0.04, 4.0);
                const mastMaterial = new THREE.MeshPhongMaterial({ color: 0xf0f0f0 });
                const mast = new THREE.Mesh(mastGeometry, mastMaterial);
                mast.position.y = 2.0; // Centre à mi-hauteur
                mast.castShadow = true;
                windsockGroup.add(mast);

                // === BASE DU MÂT ===
                const baseGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1);
                const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.05;
                base.castShadow = true;
                windsockGroup.add(base);

                // === GIROUETTE PIVOTANTE ===
                // Anneau de girouette en acier blanc
                const givetteRingGeometry = new THREE.TorusGeometry(0.25, 0.02, 8, 16);
                const givetteRingMaterial = new THREE.MeshPhongMaterial({ color: 0xf0f0f0 });
                const givetteRing = new THREE.Mesh(givetteRingGeometry, givetteRingMaterial);
                givetteRing.position.y = 4.0;
                givetteRing.rotation.x = Math.PI / 2; // Horizontal
                givetteRing.castShadow = true;
                windsockGroup.add(givetteRing);
                
                // Support de girouette
                const supportGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.3);
                const supportMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.y = 3.85;
                support.castShadow = true;
                windsockGroup.add(support);

                // === MANCHE À AIR ===
                // Spécifications OACI : diamètre 30cm, longueur 120cm, pointe 14cm
                // 3 bandes rouges et 2 bandes blanches alternées
                
                // Segment 1 (rouge) - base
                const seg1Geo = new THREE.ConeGeometry(0.15, 0.24, 8, 1, true);
                const seg1Mat = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const segment1 = new THREE.Mesh(seg1Geo, seg1Mat);
                segment1.position.set(0.25, 4.0, 0.12);
                segment1.rotation.z = -Math.PI / 2;
                windsockGroup.add(segment1);

                // Segment 2 (blanc)
                const seg2Geo = new THREE.ConeGeometry(0.13, 0.24, 8, 1, true);
                const seg2Mat = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const segment2 = new THREE.Mesh(seg2Geo, seg2Mat);
                segment2.position.set(0.25, 4.0, 0.36);
                segment2.rotation.z = -Math.PI / 2;
                windsockGroup.add(segment2);

                // Segment 3 (rouge)
                const seg3Geo = new THREE.ConeGeometry(0.11, 0.24, 8, 1, true);
                const seg3Mat = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const segment3 = new THREE.Mesh(seg3Geo, seg3Mat);
                segment3.position.set(0.25, 4.0, 0.60);
                segment3.rotation.z = -Math.PI / 2;
                windsockGroup.add(segment3);

                // Segment 4 (blanc)
                const seg4Geo = new THREE.ConeGeometry(0.09, 0.24, 8, 1, true);
                const seg4Mat = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const segment4 = new THREE.Mesh(seg4Geo, seg4Mat);
                segment4.position.set(0.25, 4.0, 0.84);
                segment4.rotation.z = -Math.PI / 2;
                windsockGroup.add(segment4);

                // Segment 5 (rouge) - pointe
                const seg5Geo = new THREE.ConeGeometry(0.07, 0.24, 8, 1, true);
                const seg5Mat = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const segment5 = new THREE.Mesh(seg5Geo, seg5Mat);
                segment5.position.set(0.25, 4.0, 1.08);
                segment5.rotation.z = -Math.PI / 2;
                windsockGroup.add(segment5);

                // === POSITIONNEMENT DE LA MANCHE À AIR ===
                // À côté de la station de contrôle, à 5 mètres de distance
                windsockGroup.position.set(-5, 0, 0);
                
                // Stockage des références pour l'animation
                this.windsock = {
                    group: windsockGroup,
                    segments: [segment1, segment2, segment3, segment4, segment5],
                    ring: givetteRing
                };
                
                this.scene.add(windsockGroup);
            }

            createWindDirectionIndicator() {
                // === FLÈCHE INDICATRICE DE LA DIRECTION DU VENT ===
                const windIndicatorGroup = new THREE.Group();
                
                // Base circulaire
                const baseGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05);
                const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.025;
                base.castShadow = true;
                windIndicatorGroup.add(base);
                
                // Tige de la flèche
                const shaftGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.8);
                const shaftMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.position.set(0, 0.45, 0);
                shaft.rotation.z = Math.PI / 2; // Horizontal
                shaft.castShadow = true;
                windIndicatorGroup.add(shaft);
                
                // Pointe de la flèche
                const arrowHeadGeometry = new THREE.ConeGeometry(0.06, 0.2);
                const arrowHeadMaterial = new THREE.MeshPhongMaterial({ color: 0xff4400 });
                const arrowHead = new THREE.Mesh(arrowHeadGeometry, arrowHeadMaterial);
                arrowHead.position.set(0.5, 0.45, 0);
                arrowHead.rotation.z = -Math.PI / 2; // Pointe vers la droite
                arrowHead.castShadow = true;
                windIndicatorGroup.add(arrowHead);
                
                // Empennage de la flèche (queue)
                const tailGeometry = new THREE.ConeGeometry(0.04, 0.15);
                const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xff8800 });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(-0.35, 0.45, 0);
                tail.rotation.z = Math.PI / 2; // Pointe vers la gauche (opposé)
                tail.castShadow = true;
                windIndicatorGroup.add(tail);
                
                // Texte "VENT" sur la base
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 24px Arial';
                context.fillStyle = '#444444';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('VENT', canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const label = new THREE.Sprite(labelMaterial);
                label.position.set(0, 0.8, 0);
                label.scale.set(0.8, 0.2, 1);
                windIndicatorGroup.add(label);
                
                // Position sous la station de contrôle
                windIndicatorGroup.position.set(0, 0, 2);
                
                // Stockage des références
                this.windIndicator = {
                    group: windIndicatorGroup,
                    arrow: windIndicatorGroup // L'ensemble du groupe tourne
                };
                
                this.scene.add(windIndicatorGroup);
            }

            createKite() {
                const builder = new DeltaKiteBuilder(
                    KITE_CONFIG.kite.width,
                    KITE_CONFIG.kite.height,
                    KITE_CONFIG.kite.depth
                );

                this.kite = builder
                    .buildStructuralPoints()
                    .buildSail()
                    .buildFrame()
                    .buildFabricEdges()
                    .buildBridles()
                    .buildVisuals()
                    .build();

                this.kiteBuilder = builder;
                
                // Position initiale
                this.kite.position.set(
                    KITE_CONFIG.kite.initialPosition.x,
                    KITE_CONFIG.kite.initialPosition.y,
                    KITE_CONFIG.kite.initialPosition.z
                );
                
                this.scene.add(this.kite);
                
                // Initialiser le système de télémétrie
                this.telemetrySystem = new TelemetrySystem(this.scene, this.kite);
            }

            createLines() {
                // Lignes de vol principales
                this.lines = {
                    left: null,
                    right: null
                };

                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    linewidth: 2
                });

                // Ligne gauche (de la barre de contrôle au cerf-volant)
                const leftPoints = [
                    new THREE.Vector3(-0.35, 1.2, 0), // Point d'attache gauche sur la barre
                    new THREE.Vector3(0, 0, 0) // Point d'attache sur le cerf-volant (sera mis à jour)
                ];
                const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftPoints);
                this.lines.left = new THREE.Line(leftGeometry, lineMaterial);
                this.scene.add(this.lines.left);

                // Ligne droite (de la barre de contrôle au cerf-volant)
                const rightPoints = [
                    new THREE.Vector3(0.35, 1.2, 0), // Point d'attache droit sur la barre
                    new THREE.Vector3(0, 0, 0) // Point d'attache sur le cerf-volant (sera mis à jour)
                ];
                const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightPoints);
                this.lines.right = new THREE.Line(rightGeometry, lineMaterial);
                this.scene.add(this.lines.right);
            }

            createTrail() {
                this.trail = {
                    points: [],
                    maxPoints: 100,
                    line: null
                };

                const trailMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xff4444,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 3
                });

                const trailGeometry = new THREE.BufferGeometry();
                this.trail.line = new THREE.Line(trailGeometry, trailMaterial);
                this.scene.add(this.trail.line);
            }

            setupControls() {
                // === CONTRÔLES CLAVIER POUR LE CERF-VOLANT ===
                this.keys = {
                    left: false,      // Contrôle cerf-volant (Q/A/←)
                    right: false,     // Contrôle cerf-volant (D/→)
                    up: false,        // Contrôle cerf-volant (W/↑)
                    down: false       // Contrôle cerf-volant (S/↓)
                };

                // Note: Les contrôles de caméra sont maintenant gérés par CameraManager
                // Les propriétés comme cameraKeys, cameraSpeed, etc. sont dans le manager
            }

            // =====================================================================================
            // === CONTRÔLES DE LA VITESSE DU VENT ===
            // =====================================================================================
            increaseWindSpeed() {
                if (this.windManager) {
                    const currentSpeed = this.windManager.baseWindSpeed;
                    const newSpeed = Math.min(currentSpeed + 1, 25); // Maximum 25 m/s
                    this.windManager.baseWindSpeed = newSpeed;
                    
                    // Mise à jour du slider UI
                    const windSpeedSlider = document.getElementById('windSpeed');
                    if (windSpeedSlider) {
                        windSpeedSlider.value = newSpeed;
                    }
                    
                    this.logMessage(`💨 Vitesse du vent: ${newSpeed} m/s (+/- pour ajuster)`, 'info');
                }
            }
            
            decreaseWindSpeed() {
                if (this.windManager) {
                    const currentSpeed = this.windManager.baseWindSpeed;
                    const newSpeed = Math.max(currentSpeed - 1, 0); // Minimum 0 m/s
                    this.windManager.baseWindSpeed = newSpeed;
                    
                    // Mise à jour du slider UI
                    const windSpeedSlider = document.getElementById('windSpeed');
                    if (windSpeedSlider) {
                        windSpeedSlider.value = newSpeed;
                    }
                    
                    this.logMessage(`💨 Vitesse du vent: ${newSpeed} m/s (+/- pour ajuster)`, 'info');
                }
            }

            setupEventListeners() {
                // Redimensionnement de la fenêtre
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // === NOTE: Gestion de la souris et de la molette déléguée au CameraManager ===
                // Les événements mouse et wheel sont maintenant gérés par this.cameraManager

                // === CONTRÔLES CLAVIER ===
                document.addEventListener('keydown', (event) => {
                    switch(event.code) {
                        // === CONTRÔLES BARRE DE CONTRÔLE CERF-VOLANT (FLÈCHES) ===
                        case 'ArrowLeft':
                            this.keys.left = true;
                            event.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.keys.right = true;
                            event.preventDefault();
                            break;
                        case 'ArrowUp':
                            this.keys.up = true;
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                            this.keys.down = true;
                            event.preventDefault();
                            break;
                            
                        // === CONTRÔLES VITESSE DU VENT (+/-) ===
                        case 'Equal':           // Touche + (sans shift)
                        case 'NumpadAdd':       // + du pavé numérique
                            this.increaseWindSpeed();
                            event.preventDefault();
                            break;
                        case 'Minus':           // Touche -
                        case 'NumpadSubtract': // - du pavé numérique
                            this.decreaseWindSpeed();
                            event.preventDefault();
                            break;
                            
                        // === CONTRÔLES GÉNÉRAUX ===
                        case 'Space':
                            event.preventDefault();
                            this.launch();
                            break;
                        case 'KeyR':
                            this.reset();
                            break;
                        case 'KeyP':
                            this.togglePause();
                            break;
                        case 'KeyC':           // Reset caméra - délégué au CameraManager
                            this.cameraManager.reset();
                            this.logMessage('📷 Caméra réinitialisée en mode libre', 'info');
                            break;
                        case 'KeyF':           // Basculer mode suivi/libre - délégué au CameraManager
                            const newMode = this.cameraManager.toggleMode();
                            const modeText = newMode === 'follow' ? 'Suivi automatique' : 'Libre';
                            this.logMessage(`📹 Mode caméra: ${modeText} (F pour basculer)`, 'info');
                            break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    switch(event.code) {
                        // === CONTRÔLES CERF-VOLANT (FLÈCHES) ===
                        case 'ArrowLeft':
                            this.keys.left = false;
                            break;
                        case 'ArrowRight':
                            this.keys.right = false;
                            break;
                        case 'ArrowUp':
                            this.keys.up = false;
                            break;
                        case 'ArrowDown':
                            this.keys.down = false;
                            break;
                            
                        // === NOTE: Contrôles caméra (ZQSD+AE) maintenant gérés par CameraManager ===
                    }
                });

                // Contrôles UI
                this.setupUIControls();
            }

            // =====================================================================================
            // === GESTION DE LA CAMÉRA INTELLIGENTE (DÉLÉGATION AU MANAGER) ===
            // =====================================================================================
            // Cette fonction délègue la gestion de la caméra au CameraManager
            updateFreeCamera(deltaTime) {
                if (this.cameraManager) {
                    this.cameraManager.update(deltaTime);
                }
            }

            // =====================================================================================
            // === CAMÉRA DE SUIVI AUTOMATIQUE (DÉLÉGATION AU MANAGER) ===
            // =====================================================================================
            // Mode caméra qui suit automatiquement le cerf-volant
            updateFollowCamera(deltaTime) {
                if (this.cameraManager) {
                    this.cameraManager.updateFollowMode(deltaTime);
                }
            }

            // =====================================================================================
            // === BASCULER ENTRE LES MODES DE CAMÉRA (DÉLÉGATION AU MANAGER) ===
            // =====================================================================================
            toggleCameraMode() {
                if (this.cameraManager) {
                    const newMode = this.cameraManager.toggleMode();
                    const modeText = newMode === 'follow' ? 'Suivi automatique' : 'Libre';
                    this.logMessage(`📹 Mode caméra: ${modeText}`, 'info');
                }
            }

            // =====================================================================================
            // === RESET DE LA CAMÉRA (DÉLÉGATION AU MANAGER) ===
            // =====================================================================================
            // Remet la caméra à sa position initiale et bascule en mode libre
            resetCamera() {
                if (this.cameraManager) {
                    this.cameraManager.reset();
                }
            }

            // === SYSTÈME DE CONSOLE ===
            initConsoleSystem() {
                this.consoleLines = [];
                this.maxConsoleLines = 50;
                
                // Attendre que le DOM soit prêt
                setTimeout(() => {
                    // Vérifier que l'élément console existe
                    const consoleElement = document.getElementById('console-content');
                    if (!consoleElement) {
                        console.error('Élément console-content non trouvé !');
                        return;
                    }
                    
                    // Intercepter les console.log, warn, error
                    const originalLog = console.log;
                    const originalWarn = console.warn;
                    const originalError = console.error;
                    
                    console.log = (...args) => {
                        this.addConsoleMessage('info', args.join(' '));
                        originalLog.apply(console, args);
                    };
                    
                    console.warn = (...args) => {
                        this.addConsoleMessage('warn', args.join(' '));
                        originalWarn.apply(console, args);
                    };
                    
                    console.error = (...args) => {
                        this.addConsoleMessage('error', args.join(' '));
                        originalError.apply(console, args);
                    };
                    
                    // Message de démarrage
                    this.addConsoleMessage('info', 'Simulateur de cerf-volant initialisé');
                    console.info('Console du simulateur activée !');
                }, 100);
            }

            addConsoleMessage(type, message) {
                const timestamp = new Date().toLocaleTimeString();
                this.consoleLines.push({
                    type: type,
                    message: message,
                    timestamp: timestamp
                });
                
                // Limiter le nombre de lignes
                if (this.consoleLines.length > this.maxConsoleLines) {
                    this.consoleLines.shift();
                }
                
                this.updateConsoleDisplay();
            }

            updateConsoleDisplay() {
                const consoleContent = document.getElementById('console-content');
                if (!consoleContent) return;
                
                consoleContent.innerHTML = this.consoleLines.map(line => 
                    `<div class="console-line ${line.type}">
                        [${line.timestamp}] ${line.message}
                    </div>`
                ).join('');
                
                // Auto-scroll vers le bas
                consoleContent.scrollTop = consoleContent.scrollHeight;
            }

            logMessage(message, type = 'info') {
                this.addConsoleMessage(type, message);
            }

            setupUIControls() {
                // Sliders
                const windSpeedSlider = document.getElementById('windSpeed');
                const turbulenceSlider = document.getElementById('turbulence');
                
                windSpeedSlider.addEventListener('input', (e) => {
                    const oldSpeed = this.state.windSpeed;
                    const newSpeed = parseFloat(e.target.value);
                    
                    // Utiliser le WindManager pour modifier la vitesse
                    this.windManager.setWindSpeed(newSpeed);
                    this.state.windSpeed = newSpeed; // Synchroniser l'état
                    
                    document.getElementById('windSpeedValue').textContent = `${newSpeed} m/s`;
                    document.getElementById('windSpeedIndicator').textContent = `${newSpeed} m/s`;
                    
                    // Log du changement de vent
                    if (Math.abs(oldSpeed - newSpeed) > 0.5) {
                        this.logMessage(`💨 Vent modifié: ${oldSpeed.toFixed(1)} → ${newSpeed.toFixed(1)} m/s`, 'info');
                    }
                });

                turbulenceSlider.addEventListener('input', (e) => {
                    const oldTurbulence = this.state.turbulence;
                    this.state.turbulence = parseFloat(e.target.value) / 100;
                    document.getElementById('turbulenceValue').textContent = `${e.target.value}%`;
                    
                    // Log du changement de turbulence
                    if (Math.abs(oldTurbulence - this.state.turbulence) > 0.1) {
                        this.logMessage(`🌪️ Turbulence: ${(oldTurbulence*100).toFixed(0)}% → ${e.target.value}%`, 'debug');
                    }
                });

                // Toggles
                const annotationsToggle = document.getElementById('annotationsToggle');
                const trailToggle = document.getElementById('trailToggle');

                annotationsToggle.addEventListener('click', () => {
                    this.state.showAnnotations = !this.state.showAnnotations;
                    annotationsToggle.classList.toggle('active');
                    
                    // Toggle annotations du cerf-volant
                    this.kiteBuilder.toggleAnnotations(this.state.showAnnotations);
                    
                    // Toggle annotations de la station de contrôle
                    this.toggleControlStationAnnotations(this.state.showAnnotations);
                    
                    this.logMessage(`📍 Annotations ${this.state.showAnnotations ? 'activées' : 'désactivées'}`, 'debug');
                });

                trailToggle.addEventListener('click', () => {
                    this.state.showTrail = !this.state.showTrail;
                    trailToggle.classList.toggle('active');
                    this.trail.line.visible = this.state.showTrail;
                    if (!this.state.showTrail) {
                        this.trail.points = [];
                        this.updateTrail();
                    }
                    this.logMessage(`✈️ Traînée ${this.state.showTrail ? 'activée' : 'désactivée'}`, 'debug');
                });

                // Toggle Télémétrie
                const telemetryToggle = document.getElementById('telemetryToggle');
                telemetryToggle.addEventListener('click', () => {
                    this.state.showTelemetry = !this.state.showTelemetry;
                    telemetryToggle.classList.toggle('active');
                    if (this.telemetrySystem) {
                        this.telemetrySystem.setEnabled(this.state.showTelemetry);
                    }
                    this.logMessage(`📊 Télémétrie ${this.state.showTelemetry ? 'activée' : 'désactivée'}`, 'info');
                });

                // Boutons
                document.getElementById('launchBtn').addEventListener('click', () => {
                    this.launch();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });

                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.togglePause();
                });

                // Contrôles des panneaux
                document.getElementById('console-toggle').addEventListener('click', () => {
                    this.state.showConsole = !this.state.showConsole;
                    const panel = document.getElementById('console-panel');
                    const button = document.getElementById('console-toggle');
                    
                    if (this.state.showConsole) {
                        panel.style.display = 'flex';
                        button.textContent = 'Masquer Console';
                        this.logMessage('Console affichée', 'info');
                    } else {
                        panel.style.display = 'none';
                        button.textContent = 'Afficher Console';
                    }
                });

                document.getElementById('legend-toggle').addEventListener('click', () => {
                    this.state.showLegend = !this.state.showLegend;
                    const panel = document.getElementById('legend-panel');
                    const button = document.getElementById('legend-toggle');
                    
                    if (this.state.showLegend) {
                        panel.style.display = 'block';
                        button.textContent = 'Masquer Légende';
                        this.logMessage('Légende affichée', 'info');
                    } else {
                        panel.style.display = 'none';
                        button.textContent = 'Afficher Légende';
                        this.logMessage('Légende masquée', 'info');
                    }
                });

                // === NOUVEAUX CONTRÔLES POUR LES AMÉLIORATIONS ===
                
                // Contrôle des particules de vent (créer le bouton dynamiquement)
                const particlesToggle = document.createElement('div');
                particlesToggle.className = 'toggle-container';
                particlesToggle.innerHTML = `
                    <div class="toggle-switch wind-particles-toggle" id="particlesToggle">
                        💨 Particules de vent
                    </div>
                `;
                
                // Ajouter au panneau de contrôle
                const controlPanel = document.getElementById('control-panel');
                if (controlPanel) {
                    const togglesSection = controlPanel.querySelector('.control-section:last-child');
                    if (togglesSection) {
                        togglesSection.appendChild(particlesToggle);
                    }
                }
                
                // Event listener pour les particules
                const particlesToggleElement = document.getElementById('particlesToggle');
                if (particlesToggleElement) {
                    particlesToggleElement.addEventListener('click', () => {
                        const isEnabled = !this.windParticleSystem.enabled;
                        this.windParticleSystem.setEnabled(isEnabled);
                        particlesToggleElement.classList.toggle('active', isEnabled);
                        this.logMessage(`💨 Particules de vent ${isEnabled ? 'activées' : 'désactivées'}`, 'info');
                    });
                }

                // === CONTRÔLES DE LA BOUSSOLE INTERACTIVE ===
                this.setupWindDirectionControl();
            }

            // =====================================================================================
            // === CONTRÔLE INTERACTIF DE LA DIRECTION DU VENT ===
            // =====================================================================================
            // Cette fonction configure la boussole interactive en bas à droite de l'écran
            // qui permet à l'utilisateur de changer la direction du vent en temps réel
            setupWindDirectionControl() {
                // === RÉCUPÉRATION DES ÉLÉMENTS DOM ===
                const windIndicator = document.getElementById('wind-indicator');       // Conteneur principal
                const windArrow = document.getElementById('windArrow');               // Flèche de direction
                const windDirectionLabel = document.getElementById('windDirectionLabel'); // Label N/S/E/W
                
                // === VARIABLES D'ÉTAT DU CONTRÔLE ===
                let isDragging = false;              // Indique si l'utilisateur fait glisser la boussole
                let startAngle = 0;                  // Angle de départ du glissement
                let currentAngle = this.state.windDirection;  // Angle actuel
                
                // === FONCTION DE CALCUL D'ANGLE ===
                // Convertit la position de la souris en angle relatif au centre de la boussole
                const getAngleFromCenter = (event, rect) => {
                    // Calcul du centre de la boussole
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    // Calcul du vecteur depuis le centre vers la souris
                    const deltaX = event.clientX - centerX;
                    const deltaY = event.clientY - centerY;
                    
                    // Conversion en angle polaire (0° = nord, sens horaire)
                    let angle = Math.atan2(deltaX, -deltaY) * 180 / Math.PI;
                    if (angle < 0) angle += 360;  // Normalisation 0-360°
                    return angle;
                };
                
                // === FONCTION DE MISE À JOUR DE LA DIRECTION ===
                // Cette fonction centralise toutes les actions à effectuer quand la direction change
                const updateWindDirection = (angle) => {
                    // Utiliser le WindManager pour modifier la direction
                    this.windManager.setWindDirection(angle);
                    
                    // Mise à jour de l'état global (synchronisation)
                    this.state.windDirection = angle;
                    
                    // === MISE À JOUR VISUELLE DE LA FLÈCHE ===
                    // Rotation de la flèche pour pointer vers la direction du vent
                    windArrow.style.transform = `translateX(-50%) rotate(${angle}deg)`;
                    
                    // === MISE À JOUR DU LABEL CARDINAL ===
                    // Conversion de l'angle en direction cardinale (N, NE, E, etc.)
                    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                    const directionIndex = Math.round(angle / 45) % 8;  // Chaque direction = 45°
                    windDirectionLabel.textContent = directions[directionIndex];
                    
                    // === LOGGING DE DEBUG ===
                    // Message dans la console pour traçabilité
                    this.logMessage(`💨 Direction du vent: ${directions[directionIndex]} (${angle.toFixed(0)}°)`, 'info');
                    
                    // === SYNCHRONISATION DES AUTRES INDICATEURS ===
                    // Mise à jour de la manche à air et du vecteur au sol
                    this.updateWindIndicators();
                };
                
                // === INITIALISATION DE L'AFFICHAGE ===
                // Application de la direction initiale au chargement
                updateWindDirection(this.state.windDirection);
                
                // === GESTION DES ÉVÉNEMENTS SOURIS ===
                
                // Début du glissement : quand l'utilisateur clique sur la boussole
                windIndicator.addEventListener('mousedown', (event) => {
                    isDragging = true;  // Activation du mode glissement
                    const rect = windIndicator.getBoundingClientRect();
                    startAngle = getAngleFromCenter(event, rect);  // Mémorisation de l'angle de départ
                    windIndicator.style.cursor = 'grabbing';       // Changement du curseur
                    event.preventDefault();  // Évite la sélection de texte
                });
                
                // Pendant le glissement : mise à jour continue de la direction
                document.addEventListener('mousemove', (event) => {
                    if (isDragging) {
                        const rect = windIndicator.getBoundingClientRect();
                        currentAngle = getAngleFromCenter(event, rect);  // Calcul du nouvel angle
                        updateWindDirection(currentAngle);              // Application immédiate
                    }
                });
                
                // Fin du glissement : quand l'utilisateur relâche le bouton
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;  // Désactivation du mode glissement
                        windIndicator.style.cursor = 'pointer';  // Retour du curseur normal
                    }
                });
                
                // === GESTION DES ÉVÉNEMENTS TACTILES ===
                // Support pour les appareils à écran tactile (tablettes, smartphones)
                
                // Début du toucher
                windIndicator.addEventListener('touchstart', (event) => {
                    isDragging = true;
                    const rect = windIndicator.getBoundingClientRect();
                    const touch = event.touches[0];  // Premier point de contact
                    startAngle = getAngleFromCenter(touch, rect);
                    event.preventDefault();  // Évite le défilement de la page
                }, { passive: false });
                
                // Pendant le glissement tactile
                document.addEventListener('touchmove', (event) => {
                    if (isDragging && event.touches.length > 0) {
                        const rect = windIndicator.getBoundingClientRect();
                        const touch = event.touches[0];
                        currentAngle = getAngleFromCenter(touch, rect);
                        updateWindDirection(currentAngle);
                        event.preventDefault();  // Évite le défilement de la page
                    }
                }, { passive: false });
                
                // Fin du toucher
                document.addEventListener('touchend', () => {
                    if (isDragging) {
                        isDragging = false;
                    }
                });
            }

            // =====================================================================================
            // === SYNCHRONISATION DES INDICATEURS DE VENT ===
            // =====================================================================================
            // Cette fonction s'assure que tous les indicateurs visuels de vent (manche à air,
            // vecteur au sol, boussole) sont cohérents avec la direction sélectionnée
            updateWindIndicators() {
                // === MISE À JOUR DE LA MANCHE À AIR ===
                // La manche à air s'oriente automatiquement face au vent
                this.updateWindsock();
                
                // === MISE À JOUR DE L'INDICATEUR AU SOL ===
                // Le vecteur orange sous la station pointe vers la direction du vent
                if (this.windIndicator && this.windIndicator.group) {
                    // Conversion de la direction en radians pour la rotation 3D
                    const windDirectionRad = (this.state.windDirection * Math.PI) / 180;
                    // Application de la rotation autour de l'axe Y (vertical)
                    this.windIndicator.group.rotation.y = windDirectionRad;
                }
            }

            launch() {
                if (!this.state.isFlying) {
                    this.state.isFlying = true;
                    
                    // Log du lancement
                    this.logMessage(`🚀 Cerf-volant lancé ! Vent: ${this.state.windSpeed} m/s`, 'info');
                    
                    // Impulse initial
                    const windDirection = new THREE.Vector3(0, 0.3, -1).normalize();
                    const launchForce = windDirection.multiplyScalar(this.state.windSpeed * 2);
                    this.kiteVelocity.add(launchForce);
                    
                    // Animation du bouton
                    const launchBtn = document.getElementById('launchBtn');
                    launchBtn.style.background = 'rgba(76, 175, 80, 0.3)';
                    setTimeout(() => {
                        launchBtn.style.background = '';
                    }, 200);
                }
            }

            reset() {
                // Force la sortie de pause si nécessaire
                if (this.state.isPaused) {
                    this.state.isPaused = false;
                    
                    // Mettre à jour le bouton pause
                    const pauseBtn = document.getElementById('pauseBtn');
                    if (pauseBtn) {
                        const icon = pauseBtn.querySelector('span:first-child');
                        const text = pauseBtn.querySelector('span:last-child');
                        if (icon) icon.textContent = '⏸️';
                        if (text) text.textContent = 'Pause';
                        pauseBtn.style.background = '';
                    }
                    this.logMessage('⏸️ Pause désactivée lors du reset', 'debug');
                }
                
                this.state.isFlying = false;
                this.kiteVelocity.set(0, 0, 0);
                this.kiteAngularVelocity.set(0, 0, 0);
                
                // Log de la réinitialisation
                this.logMessage('🔄 Simulation réinitialisée', 'info');
                
                // Reset position avec vérification
                const initialPos = KITE_CONFIG.kite.initialPosition;
                this.kite.position.set(
                    initialPos.x || 0,
                    initialPos.y || 10,
                    initialPos.z || -10
                );
                
                // Reset rotation
                this.kite.rotation.set(0, 0, 0);
                this.kite.quaternion.set(0, 0, 0, 1);
                
                // Reset forces
                this.totalForce = new THREE.Vector3(0, 0, 0);
                
                // Clear trail
                this.trail.points = [];
                this.updateTrail();
                
                // Clear télémétrie
                if (this.telemetrySystem) {
                    this.telemetrySystem.clear();
                }
                
                // Reset données de télémétrie
                this.telemetryData = {
                    lift: { direction: new THREE.Vector3(0, 1, 0), magnitude: 0 },
                    drag: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    totalAero: { direction: new THREE.Vector3(0, 0, 0), magnitude: 0 },
                    windSpeed: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    relativeWind: { direction: new THREE.Vector3(0, 0, -1), magnitude: 0 },
                    normal: { direction: new THREE.Vector3(0, 0, 1), magnitude: 1 }
                };
                
                // Animation du bouton
                const resetBtn = document.getElementById('resetBtn');
                if (resetBtn) {
                    resetBtn.style.background = 'rgba(255, 152, 0, 0.3)';
                    setTimeout(() => {
                        resetBtn.style.background = '';
                    }, 200);
                }
                
                this.logMessage('Retour à la position initiale', 'debug');
            }

            emergencyReset() {
                this.logMessage('⚠️ Reset d\'urgence déclenché !', 'error');
                this.reset();
                
                // Arrêt temporaire pour éviter les boucles infinies
                this.state.isFlying = false;
                
                // Notification à l'utilisateur
                if (document.getElementById('aoa')) {
                    document.getElementById('aoa').textContent = "ERR";
                }
                
                this.logMessage('Simulation stabilisée après erreur', 'warn');
            }

            togglePause() {
                this.state.isPaused = !this.state.isPaused;
                
                // Mise à jour du bouton
                const pauseBtn = document.getElementById('pauseBtn');
                if (pauseBtn) {
                    const icon = pauseBtn.querySelector('span:first-child');
                    const text = pauseBtn.querySelector('span:last-child');
                    
                    if (this.state.isPaused) {
                        icon.textContent = '▶️';
                        text.textContent = 'Reprendre';
                        pauseBtn.style.background = 'rgba(255, 193, 7, 0.3)'; // Jaune
                        this.logMessage('⏸️ Simulation en pause', 'info');
                    } else {
                        icon.textContent = '⏸️';
                        text.textContent = 'Pause';
                        pauseBtn.style.background = '';
                        this.logMessage('▶️ Simulation reprise', 'info');
                    }
                    
                    // Animation du bouton
                    setTimeout(() => {
                        if (!this.state.isPaused) {
                            pauseBtn.style.background = '';
                        }
                    }, 200);
                }
            }

            // =====================================================================================
            // === CALCUL DES FORCES DE VENT ===
            // =====================================================================================
            // === INTERFACE POUR LE SYSTÈME DE VENT ===
            // =====================================================================================
            // Cette fonction fait interface avec le WindManager pour le calcul des forces du vent
            calculateWindForce() {
                // Vérifier que le cerf-volant existe avant d'accéder à sa position
                if (!this.kite) {
                    // Position par défaut si le cerf-volant n'est pas encore créé
                    const defaultPosition = new THREE.Vector3(0, 10, -10);
                    return this.windManager.calculateWindForce(defaultPosition);
                }
                return this.windManager.calculateWindForce(this.kite.position);
            }

            // =====================================================================================
            // === CALCUL DES FORCES DE STABILISATION ===
            // =====================================================================================
            calculateLineStabilizingForce(tensionData, currentAngle) {
                const stabilizingForce = new THREE.Vector3();
                
                // Force de rappel vers la position d'équilibre
                const idealAngle = 25; // Angle d'attaque idéal
                const angleError = currentAngle - idealAngle;
                
                // Force de rappel proportionnelle à l'erreur
                const recallStrength = angleError * 0.5;
                stabilizingForce.y -= recallStrength;
                
                // Stabilisation latérale basée sur la différence de tension
                const tensionDiff = tensionData.left - tensionData.right;
                const lateralStabilization = tensionDiff * 2;
                stabilizingForce.x -= lateralStabilization;
                
                return stabilizingForce;
            }



            /**
             * SIMULATION DES EFFETS DE PRESSION D'AIR
             * Modélise les forces de stabilisation naturelles du cerf-volant
             */
            calculatePressureForces(windDirection, angleOfAttack, windSpeed) {
                const pressureForces = new THREE.Vector3();
                
                // === EFFET DIÈDRE (STABILITÉ LATÉRALE) ===
                // Les ailes en V créent une différence de pression qui stabilise
                const rollAngle = this.kite.rotation.z;
                if (Math.abs(rollAngle) > 0.05) {
                    const dihedralForce = -rollAngle * windSpeed * PHYSICS_CONSTANTS.DIHEDRAL_FORCE_FACTOR;
                    pressureForces.x += dihedralForce;
                }
                
                // === CENTRE DE PRESSION MOBILE ===
                // Le centre de pression se déplace avec l'angle d'attaque
                const pitchAngle = this.kite.rotation.x;
                const pressureCenterShift = Math.sin(angleOfAttack) * 0.3;
                const stabilizingMoment = -pitchAngle * windSpeed * (1 + pressureCenterShift);
                pressureForces.y += stabilizingMoment * 0.3;
                
                // === EFFET DE DÉRIVE (STABILITÉ DIRECTIONNELLE) ===
                // Les whiskers créent une force de rappel directionnel
                const yawAngle = this.kite.rotation.y;
                if (Math.abs(yawAngle) > 0.1) {
                    const sideslipForce = -yawAngle * windSpeed * 0.4;
                    pressureForces.z += sideslipForce * 0.2;
                }
                
                // === AMORTISSEMENT NATUREL ===
                // La résistance de l'air amortit les oscillations
                const dampingFactor = 0.95;
                pressureForces.multiplyScalar(dampingFactor);
                
                return pressureForces;
            }

            updatePhysics(deltaTime) {
                if (!this.state.isFlying) return;
                
                // === MISE À JOUR DES NOUVEAUX SYSTÈMES ===
                // Mise à jour du gestionnaire de vent avec rafales
                this.windManager.update(deltaTime);
                
                // Mise à jour du système météo
                this.weatherSystem.update(deltaTime);
                
                // === DÉLÉGATION AU PHYSICS MANAGER ===
                const windForce = this.calculateWindForce();
                
                // Mise à jour des particules de vent
                this.windParticleSystem.update(deltaTime, windForce);
                
                const result = this.physicsManager.updatePhysics(
                    deltaTime, 
                    this.kite.position, 
                    this.kiteVelocity, 
                    windForce
                );
                
                // === VÉRIFICATION DES COLLISIONS ===
                const collision = this.collisionSystem.checkCollisions(this.kite.position, this.kiteVelocity);
                if (collision) {
                    // Les collisions sont gérées dans le système de collision
                    this.kiteVelocity.copy(this.kiteVelocity); // Mise à jour après collision
                }
                
                // === MISE À JOUR DES PROPRIÉTÉS ===
                this.kiteVelocity.copy(result.velocity);
                this.kite.position.copy(result.position);
                
                // === ORIENTATION NATURELLE FACE AU VENT ===
                if (windForce.length() > 0.1) {
                    // Calculer l'angle face au vent
                    const windDirection = windForce.clone().normalize();
                    const targetAngle = Math.atan2(windDirection.x, windDirection.z);
                    
                    // Rotation progressive pour éviter les saccades
                    const currentRotation = this.kite.rotation.y;
                    const angleDiff = targetAngle - currentRotation;
                    
                    // Normaliser la différence d'angle entre -π et π
                    const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    
                    // Application progressive de la rotation (0.05 = vitesse d'orientation)
                    this.kite.rotation.y += normalizedDiff * 0.05;
                }
                this.updateKiteOrientation(deltaTime);
                
                // Normaliser le quaternion pour éviter la dérive
                this.kite.quaternion.normalize();
            }

            // =====================================================================================
            // === CALCUL DES FORCES DU SYSTÈME DE BRIDAGE ===
            // =====================================================================================
            // Nouvelle fonction pour calculer les forces du système de bridage
            calculateBridageForces() {
                const forces = new THREE.Vector3();
                
                if (!this.kiteBuilder || !this.kiteBuilder.structure) return forces;
                
                const pControleG = this.kiteBuilder.structure.getPoint("P_CONTROLE_G");
                const pControleD = this.kiteBuilder.structure.getPoint("P_CONTROLE_D");
                
                if (!pControleG || !pControleD) return forces;
                
                // Positions des points de contrôle en coordonnées monde
                const leftControlPoint = pControleG.position.clone().applyMatrix4(this.kite.matrixWorld);
                const rightControlPoint = pControleD.position.clone().applyMatrix4(this.kite.matrixWorld);
                
                // Points d'attache au sol (avec rotation de la barre)
                const leftGroundAttach = this.controlBar?.leftAttachPosition || new THREE.Vector3(-0.35, 1.2, 0);
                const rightGroundAttach = this.controlBar?.rightAttachPosition || new THREE.Vector3(0.35, 1.2, 0);
                
                // === CALCUL DES TENSIONS ===
                const leftVector = leftControlPoint.clone().sub(leftGroundAttach);
                const rightVector = rightControlPoint.clone().sub(rightGroundAttach);
                const leftTension = leftVector.length();
                const rightTension = rightVector.length();
                
                const lineLength = KITE_CONFIG.physics.lineLength;
                
                // === FORCE DE CONTRAINTE DES LIGNES ===
                if (leftTension > lineLength) {
                    const excess = leftTension - lineLength;
                    const pullDirection = leftVector.normalize().multiplyScalar(-1);
                    forces.add(pullDirection.multiplyScalar(excess * 8)); // Force de rappel réduite
                }
                
                if (rightTension > lineLength) {
                    const excess = rightTension - lineLength;
                    const pullDirection = rightVector.normalize().multiplyScalar(-1);
                    forces.add(pullDirection.multiplyScalar(excess * 8)); // Force de rappel réduite
                }
                
                // === FORCE DE STABILISATION LATÉRALE ===
                const tensionDifference = leftTension - rightTension;
                
                if (Math.abs(tensionDifference) > 0.2) {
                    // Force latérale proportionnelle à la différence (réduite)
                    const lateralForce = tensionDifference * 1.5;
                    const rightDirection = new THREE.Vector3(1, 0, 0);
                    forces.add(rightDirection.multiplyScalar(lateralForce));
                    
                    // Moment de rotation pour redresser le cerf-volant (réduit)
                    const rollCorrection = -tensionDifference * 0.15;
                    this.kiteAngularVelocity = this.kiteAngularVelocity || new THREE.Vector3();
                    this.kiteAngularVelocity.z += rollCorrection;
                }
                
                // === EFFET DU CONTRÔLE DE LA BARRE ===
                if (this.controlBar && Math.abs(this.controlBar.angle) > 0.01) {
                    // La rotation de la barre crée une asymétrie dans les tensions (réduite)
                    const controlEffect = this.controlBar.angle * 2.0;
                    
                    // Force de virage
                    const turnForce = new THREE.Vector3(controlEffect, 0, 0);
                    forces.add(turnForce);
                    
                    // Moment de lacet pour le virage (réduit)
                    this.kiteAngularVelocity.y += this.controlBar.angle * 0.1;
                }
                
                return forces;
            }

            // =====================================================================================
            // === ORIENTATION NATURELLE DU CERF-VOLANT ===
            // =====================================================================================
            // Nouvelle fonction pour l'orientation du cerf-volant
            updateKiteOrientation(deltaTime) {
                const windForce = this.calculateWindForce();
                const relativeWind = windForce.clone().sub(this.kiteVelocity);
                
                if (relativeWind.length() > 0.5) {
                    // Direction vers laquelle le cerf-volant doit faire face
                    const targetDirection = relativeWind.clone().normalize();
                    
                    // Calcul de l'orientation cible
                    const targetQuaternion = new THREE.Quaternion();
                    const up = new THREE.Vector3(0, 1, 0);
                    
                    // Ajout d'un angle de bridage naturel
                    const bridageAngle = 27 * Math.PI / 180; // 27° en radians
                    const adjustedDirection = targetDirection.clone();
                    adjustedDirection.y -= Math.sin(bridageAngle);
                    adjustedDirection.normalize();
                    
                    const lookAtMatrix = new THREE.Matrix4().lookAt(
                        new THREE.Vector3(0, 0, 0),
                        adjustedDirection.negate(),
                        up
                    );
                    targetQuaternion.setFromRotationMatrix(lookAtMatrix);
                    
                    // Interpolation plus douce vers l'orientation cible pour stabilité
                    this.kite.quaternion.slerp(targetQuaternion, 0.02);
                }
            }

            // =====================================================================================
            // === APPLICATION DES CONTRAINTES PHYSIQUES ===
            // =====================================================================================
            // Nouvelle fonction pour appliquer les contraintes
            applyConstraints() {
                // === CONTRAINTE DE HAUTEUR MINIMALE ===
                if (this.kite.position.y < 0.5) {
                    this.kite.position.y = 0.5;
                    this.kiteVelocity.y = Math.max(0, this.kiteVelocity.y);
                    
                    if (this.kiteVelocity.length() > 5 && this.frameCounter % 60 === 0) {
                        this.logMessage('⚠️ Contact avec le sol !', 'warn');
                    }
                }
                
                // === CONTRAINTE DE DISTANCE MAXIMALE ===
                const maxDistance = KITE_CONFIG.physics.lineLength + 2; // Petite marge
                const currentDistance = this.kite.position.length();
                
                if (currentDistance > maxDistance) {
                    this.kite.position.normalize().multiplyScalar(maxDistance);
                    
                    // Supprimer la composante radiale de la vitesse
                    const radialDirection = this.kite.position.clone().normalize();
                    const radialVelocity = this.kiteVelocity.dot(radialDirection);
                    if (radialVelocity > 0) {
                        this.kiteVelocity.sub(radialDirection.multiplyScalar(radialVelocity));
                    }
                }
                
                // === VÉRIFICATION DE VALIDITÉ DE LA POSITION ===
                if (!isFinite(this.kite.position.x) || !isFinite(this.kite.position.y) || !isFinite(this.kite.position.z)) {
                    console.warn("Position non valide détectée, reset...");
                    this.emergencyReset();
                }
            }

            updateLines(deltaTime) {
                // Récupération des positions dynamiques des points de contrôle
                const pControleG = this.kiteBuilder.structure.getPoint("P_CONTROLE_G");
                const pControleD = this.kiteBuilder.structure.getPoint("P_CONTROLE_D");
                
                // Transformation des positions locales en positions monde
                const leftControlPoint = new THREE.Vector3();
                const rightControlPoint = new THREE.Vector3();
                
                leftControlPoint.copy(pControleG.position);
                rightControlPoint.copy(pControleD.position);
                
                // Application de la transformation du cerf-volant (position + rotation)
                leftControlPoint.applyMatrix4(this.kite.matrixWorld);
                rightControlPoint.applyMatrix4(this.kite.matrixWorld);
                
                // === POINTS D'ATTACHE DYNAMIQUES SUR LA BARRE DE CONTRÔLE ===
                // Utilisation des positions calculées en fonction de la rotation de la barre
                let leftGroundAttach, rightGroundAttach;
                
                if (this.controlBar && this.controlBar.leftAttachPosition && this.controlBar.rightAttachPosition) {
                    // Utilisation des positions mises à jour par la rotation de la barre
                    leftGroundAttach = this.controlBar.leftAttachPosition.clone();
                    rightGroundAttach = this.controlBar.rightAttachPosition.clone();
                } else {
                    // Positions par défaut si le système de contrôle n'est pas encore initialisé
                    leftGroundAttach = new THREE.Vector3(-0.35, 1.2, 0);
                    rightGroundAttach = new THREE.Vector3(0.35, 1.2, 0);
                }
                
                // Mise à jour ligne gauche (de la barre de contrôle au point de contrôle du cerf-volant)
                const leftPoints = [
                    leftGroundAttach, // Point d'attache dynamique sur la barre de contrôle
                    leftControlPoint // Point de contrôle gauche dynamique
                ];
                this.lines.left.geometry.setFromPoints(leftPoints);
                
                // Mise à jour ligne droite (de la barre de contrôle au point de contrôle du cerf-volant)
                const rightPoints = [
                    rightGroundAttach, // Point d'attache dynamique sur la barre de contrôle
                    rightControlPoint // Point de contrôle droit dynamique
                ];
                this.lines.right.geometry.setFromPoints(rightPoints);
                
                // === CALCUL DES TENSIONS AVEC POSITIONS DYNAMIQUES ===
                // Les tensions varient maintenant en fonction de la position de la barre
                const leftTension = leftControlPoint.distanceTo(leftGroundAttach);
                const rightTension = rightControlPoint.distanceTo(rightGroundAttach);
                
                // === CALCUL DE LA TENSION DIFFÉRENTIELLE ===
                // La différence de tension entre les lignes crée un moment de rotation
                const tensionDifference = leftTension - rightTension;
                const rotationForce = tensionDifference * 0.1; // Facteur de rotation
                
                // Application du moment de rotation au cerf-volant
                if (!this.kiteAngularVelocity) {
                    this.kiteAngularVelocity = new THREE.Vector3(0, 0, 0);
                }
                this.kiteAngularVelocity.y += rotationForce * deltaTime; // Rotation autour de l'axe Y (lacet)
                
                // === CONTRAINTES DES LIGNES AVEC TENSION DIFFÉRENTIELLE ===
                const lineLength = KITE_CONFIG.physics.lineLength;
                
                // Contrainte ligne gauche
                if (leftTension > lineLength) {
                    const correction = leftTension - lineLength;
                    const directionToGround = new THREE.Vector3().subVectors(leftGroundAttach, leftControlPoint).normalize();
                    leftControlPoint.add(directionToGround.multiplyScalar(correction * PHYSICS_CONSTANTS.CORRECTION_DAMPING));
                }
                
                // Contrainte ligne droite
                if (rightTension > lineLength) {
                    const correction = rightTension - lineLength;
                    const directionToGround = new THREE.Vector3().subVectors(rightGroundAttach, rightControlPoint).normalize();
                    rightControlPoint.add(directionToGround.multiplyScalar(correction * PHYSICS_CONSTANTS.CORRECTION_DAMPING));
                }
                
                // Mise à jour de l'affichage des tensions
                document.getElementById('tensionLeft').textContent = (leftTension * 2).toFixed(1);
                document.getElementById('tensionRight').textContent = (rightTension * 2).toFixed(1);
            }

            // =====================================================================================
            // === ANIMATION DE LA BARRE DE CONTRÔLE ===
            // =====================================================================================
            // Cette fonction anime visuellement la barre de contrôle en fonction des entrées
            // utilisateur (touches Q/D ou flèches gauche/droite)
            updateControlStation(deltaTime) {
                if (!this.controlBar || !this.controlBar.group) return;
                
                // === CALCUL DE L'ENTRÉE DE CONTRÔLE ===
                // Combinaison des touches pour calculer l'inclinaison de la barre
                const controlInput = (this.keys.left ? -1 : 0) + (this.keys.right ? 1 : 0);
                
                // === ANIMATION FLUIDE DE LA BARRE ===
                // Au lieu d'appliquer directement l'entrée, on interpole vers la valeur cible
                // pour un mouvement plus naturel et réaliste
                
                // Angle cible basé sur l'entrée utilisateur (±20° maximum pour plus de visibilité)
                const targetRotation = controlInput * 0.35; // 0.35 radians ≈ 20°
                
                // Interpolation douce vers l'angle cible (lissage du mouvement)
                const lerpFactor = Math.min(1.0, deltaTime * 8); // Vitesse d'interpolation
                
                // === ROTATION DU GROUPE ENTIER ===
                // Mise à jour de l'angle stocké avec interpolation
                this.controlBar.angle += (targetRotation - this.controlBar.angle) * lerpFactor;
                
                // Application de la rotation horizontale au groupe entier (rotation autour de l'axe Y)
                this.controlBar.group.rotation.y = this.controlBar.angle;
                
                // === CALCUL DES NOUVELLES POSITIONS GLOBALES DES POINTS D'ATTACHE ===
                // Les positions absolues dans l'espace 3D pour les lignes
                const leftWorldPos = new THREE.Vector3();
                const rightWorldPos = new THREE.Vector3();
                
                // Récupération des positions mondiales après rotation
                this.controlBar.leftAttach.getWorldPosition(leftWorldPos);
                this.controlBar.rightAttach.getWorldPosition(rightWorldPos);
                
                // Stockage des positions pour updateLines()
                this.controlBar.leftAttachPosition = leftWorldPos.clone();
                this.controlBar.rightAttachPosition = rightWorldPos.clone();
                
                // === ANIMATION DU POINT DE PIVOT ===
                // Petit effet visuel pour montrer l'activité
                if (Math.abs(controlInput) > 0) {
                    const time = this.clock.getElapsedTime();
                    const pulse = 1 + Math.sin(time * 10) * 0.2; // Pulsation rapide
                    this.controlBar.pivotPoint.scale.setScalar(pulse);
                } else {
                    // Retour à la taille normale quand pas d'entrée
                    this.controlBar.pivotPoint.scale.setScalar(1);
                }
                
                // === FEEDBACK VISUEL DANS L'INTERFACE ===
                // Mise à jour de l'indicateur de contrôle dans l'UI
                this.state.controlInput = controlInput;
                
                // Mise à jour de l'affichage de l'angle de la barre
                const controlAngleElement = document.getElementById('controlAngle');
                if (controlAngleElement) {
                    const angleDegrees = (this.controlBar.angle * 180 / Math.PI).toFixed(1);
                    controlAngleElement.textContent = `${angleDegrees}°`;
                }
                
                // === LOGGING DE DEBUG ===
                // Log des changements de contrôle significatifs pour le debug
                if (Math.abs(controlInput) > 0 && this.frameCounter % 60 === 0) { // Log toutes les secondes
                    const direction = controlInput > 0 ? 'DROITE' : 'GAUCHE';
                    this.logMessage(`🎮 Barre pivotée: ${direction} (${(this.controlBar.angle * 180 / Math.PI).toFixed(1)}°)`, 'debug');
                }
            }

            // =====================================================================================
            // === GESTION DES ANNOTATIONS DE LA STATION DE CONTRÔLE ===
            // =====================================================================================
            // Cette fonction crée et gère l'affichage des annotations textuelles pour la station
            toggleControlStationAnnotations(show) {
                if (show && !this.controlStationAnnotations) {
                    this.createControlStationAnnotations();
                }
                
                if (this.controlStationAnnotations) {
                    this.controlStationAnnotations.forEach(annotation => {
                        annotation.visible = show;
                    });
                }
            }

            createControlStationAnnotations() {
                this.controlStationAnnotations = [];
                
                // === ANNOTATION DU POINT DE PIVOT ===
                const pivotLabel = this.createTextSprite('🔴 PIVOT\nCentre de rotation', 0xff0000);
                pivotLabel.position.set(0.3, 1.4, 0);  // À côté du point de pivot
                pivotLabel.scale.set(0.5, 0.25, 1);
                this.scene.add(pivotLabel);
                this.controlStationAnnotations.push(pivotLabel);
                
                // === ANNOTATION DES POINTS D'ATTACHE ===
                const leftAttachLabel = this.createTextSprite('🟢 LIGNE G\nAttache gauche', 0x00ff00);
                leftAttachLabel.position.set(-0.5, 1.0, 0);
                leftAttachLabel.scale.set(0.4, 0.2, 1);
                this.scene.add(leftAttachLabel);
                this.controlStationAnnotations.push(leftAttachLabel);
                
                const rightAttachLabel = this.createTextSprite('🟢 LIGNE D\nAttache droite', 0x00ff00);
                rightAttachLabel.position.set(0.5, 1.0, 0);
                rightAttachLabel.scale.set(0.4, 0.2, 1);
                this.scene.add(rightAttachLabel);
                this.controlStationAnnotations.push(rightAttachLabel);
                
                // === ANNOTATION DES POIGNÉES ===
                const leftHandleLabel = this.createTextSprite('🟠 POIGNÉE G\nPrise pilote', 0xff6b35);
                leftHandleLabel.position.set(-0.4, 1.5, 0);
                leftHandleLabel.scale.set(0.35, 0.175, 1);
                this.scene.add(leftHandleLabel);
                this.controlStationAnnotations.push(leftHandleLabel);
                
                const rightHandleLabel = this.createTextSprite('🟠 POIGNÉE D\nPrise pilote', 0xff6b35);
                rightHandleLabel.position.set(0.4, 1.5, 0);
                rightHandleLabel.scale.set(0.35, 0.175, 1);
                this.scene.add(rightHandleLabel);
                this.controlStationAnnotations.push(rightHandleLabel);
                
                // === ANNOTATION DE LA BASE ===
                const baseLabel = this.createTextSprite('🟦 BASE STATION\nPlateforme pilote', 0x2196f3);
                baseLabel.position.set(0, 0.6, 0.8);
                baseLabel.scale.set(0.6, 0.3, 1);
                this.scene.add(baseLabel);
                this.controlStationAnnotations.push(baseLabel);
                
                // === ANNOTATION DE CONTRÔLE ===
                const controlLabel = this.createTextSprite('⌨️ CONTRÔLES\nQ/A/← ↔ D/→', 0xffffff);
                controlLabel.position.set(0, 2.0, 0);
                controlLabel.scale.set(0.5, 0.25, 1);
                this.scene.add(controlLabel);
                this.controlStationAnnotations.push(controlLabel);
            }

            // Fonction utilitaire pour créer des sprites de texte
            createTextSprite(text, color = 0xffffff) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 256;
                
                // Fond semi-transparent
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Bordure
                context.strokeStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.lineWidth = 4;
                context.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Texte
                context.font = 'Bold 28px Arial';
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Texte multi-lignes
                const lines = text.split('\n');
                const lineHeight = 35;
                const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2);
                
                lines.forEach((line, index) => {
                    context.fillText(line, canvas.width / 2, startY + (index * lineHeight));
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                
                return new THREE.Sprite(material);
            }

            updateTrail() {
                if (this.state.showTrail && this.state.isFlying) {
                    this.trail.points.push(this.kite.position.clone());
                    
                    if (this.trail.points.length > this.trail.maxPoints) {
                        this.trail.points.shift();
                    }
                }
                
                if (this.trail.points.length > 1) {
                    this.trail.line.geometry.setFromPoints(this.trail.points);
                }
            }

            updateUI() {
                // Données de vol
                document.getElementById('altitude').textContent = Math.max(0, this.kite.position.y).toFixed(1);
                document.getElementById('distance').textContent = this.kite.position.length().toFixed(1);
                document.getElementById('speed').textContent = this.kiteVelocity.length().toFixed(1);
                
                // Mode de caméra
                const cameraMode = this.cameraManager && this.cameraManager.mode === 'follow' ? '📹 Suivi' : '🎮 Libre';
                const cameraModeElement = document.getElementById('cameraMode');
                if (cameraModeElement) {
                    cameraModeElement.textContent = cameraMode;
                }
                
                // Indicateur de vent
                const windAngle = Math.atan2(0, -this.state.windSpeed) * 180 / Math.PI; // Vent vient du sud (Z négatif)
                document.getElementById('windArrow').style.transform = `translate(-50%, -100%) rotate(${windAngle}deg)`;
                
                // === ANIMATION DE LA MANCHE À AIR ===
                this.updateWindsock();
            }

            updateWindsock() {
                if (!this.windsock) return;
                
                const time = this.clock.getElapsedTime();
                const windSpeed = this.state.windSpeed;
                
                // === DIRECTION DU VENT CONTRÔLABLE ===
                // Utiliser la direction définie par l'utilisateur
                const windDirectionRad = (this.state.windDirection * Math.PI) / 180;
                
                // === ORIENTATION DE LA GIROUETTE ===
                // La girouette pivote pour pointer dans la direction d'où vient le vent
                this.windsock.ring.rotation.y = windDirectionRad;
                
                // === ANIMATION DES SEGMENTS DE LA MANCHE ===
                // Animation plus douce pour un vent laminaire
                this.windsock.segments.forEach((segment, index) => {
                    // Position de base du segment
                    const baseX = 0.25 + (index * 0.24);
                    const baseZ = 0.12 + (index * 0.24);
                    
                    // Calcul de la position dans la direction du vent
                    const directionX = Math.sin(windDirectionRad);
                    const directionZ = Math.cos(windDirectionRad);
                    
                    // Intensité basée sur la vitesse du vent (0.5 à 3.0 pour 5-25 m/s)
                    const intensity = Math.min(3.0, Math.max(0.5, windSpeed * 0.12));
                    
                    // Position finale avec l'orientation
                    const finalX = directionX * intensity;
                    const finalZ = directionZ * intensity;
                    
                    segment.position.set(finalX, 4.0, finalZ);
                    segment.rotation.z = -Math.PI / 2 + windDirectionRad;
                    
                    // Oscillation légère pour simuler les rafales
                    const oscillation = Math.sin(time * 3 + index * PHYSICS_CONSTANTS.HALF) * PHYSICS_CONSTANTS.OSCILLATION_AMPLITUDE;
                    segment.position.y = 4.0 + oscillation;
                });
            }

            updateTelemetry() {
                if (!this.state.showTelemetry || !this.telemetrySystem) return;
                
                const kitePos = this.kite.position.clone();
                
                // Vérifier que la position du cerf-volant est valide
                if (!isFinite(kitePos.x) || !isFinite(kitePos.y) || !isFinite(kitePos.z)) {
                    console.warn("Position du cerf-volant invalide, télémétrie ignorée");
                    return;
                }
                
                // === RÉCUPÉRATION DES DONNÉES DU PHYSICS MANAGER ===
                const telemetryData = this.physicsManager.getTelemetryData();
                const forces = this.physicsManager.getForces();
                
                // Forces aérodynamiques
                if (telemetryData.lift && isFinite(telemetryData.lift.magnitude)) {
                    this.telemetrySystem.updateVector('lift', kitePos, telemetryData.lift.direction, telemetryData.lift.magnitude);
                }
                if (telemetryData.drag && isFinite(telemetryData.drag.magnitude)) {
                    this.telemetrySystem.updateVector('drag', kitePos, telemetryData.drag.direction, telemetryData.drag.magnitude);
                }
                if (telemetryData.totalAero && isFinite(telemetryData.totalAero.magnitude)) {
                    this.telemetrySystem.updateVector('totalAero', kitePos, telemetryData.totalAero.direction, telemetryData.totalAero.magnitude);
                }
                
                // Vitesses
                const velocityMag = this.kiteVelocity.length();
                if (velocityMag > 0.1 && isFinite(velocityMag)) {
                    this.telemetrySystem.updateVector('velocity', kitePos, this.kiteVelocity.clone().normalize(), velocityMag);
                }
                if (telemetryData.windSpeed && isFinite(telemetryData.windSpeed.magnitude)) {
                    this.telemetrySystem.updateVector('windSpeed', kitePos, telemetryData.windSpeed.direction, telemetryData.windSpeed.magnitude);
                }
                if (telemetryData.relativeWind && isFinite(telemetryData.relativeWind.magnitude)) {
                    this.telemetrySystem.updateVector('relativeWind', kitePos, telemetryData.relativeWind.direction, telemetryData.relativeWind.magnitude);
                }
                
                // Forces physiques
                const gravityForce = new THREE.Vector3(0, -1, 0);
                const gravityMag = Math.abs(KITE_CONFIG.physics.gravity * KITE_CONFIG.physics.kiteMass);
                if (isFinite(gravityMag)) {
                    this.telemetrySystem.updateVector('gravity', kitePos, gravityForce, gravityMag);
                }
                
                // Force totale
                if (forces.total && isFinite(forces.total.length())) {
                    this.telemetrySystem.updateVector('totalForce', kitePos, forces.total.clone().normalize(), forces.total.length());
                }
                
                // Normale de la voile
                if (telemetryData.normal && isFinite(telemetryData.normal.magnitude)) {
                    this.telemetrySystem.updateVector('normal', kitePos, telemetryData.normal.direction, telemetryData.normal.magnitude);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.016); // Cap à 60 FPS
                
                // Si la simulation est en pause, ne pas mettre à jour la physique
                if (this.state.isPaused) {
                    // Continuer le rendu mais pas la physique
                    this.renderer.render(this.scene, this.cameraManager.currentCamera);
                    return;
                }
                
                // Incrémenter le compteur de frames
                this.frameCounter++;
                
                // Log des événements importants toutes les 5 secondes (300 frames à 60fps)
                if (this.frameCounter % 300 === 0 && this.state.isFlying) {
                    const speed = this.kiteVelocity.length();
                    const altitude = this.kite.position.y;
                    
                    // Log des changements significatifs
                    if (Math.abs(speed - this.lastLoggedSpeed) > 2) {
                        this.logMessage(`🚀 Vitesse: ${speed.toFixed(1)} m/s (Δ${(speed - this.lastLoggedSpeed).toFixed(1)})`, 'info');
                        this.lastLoggedSpeed = speed;
                    }
                    
                    if (Math.abs(altitude - this.lastLoggedAltitude) > 3) {
                        this.logMessage(`📈 Altitude: ${altitude.toFixed(1)} m (Δ${(altitude - this.lastLoggedAltitude).toFixed(1)})`, 'info');
                        this.lastLoggedAltitude = altitude;
                    }
                }
                
                this.updatePhysics(deltaTime);
                this.updateControlStation(deltaTime); // Mise à jour de l'animation de la barre de contrôle
                this.updateFreeCamera(deltaTime);     // Mise à jour de la caméra libre
                this.updateLines(deltaTime);
                this.updateTrail();
                this.updateUI();
                this.updateTelemetry(); // Ajout de la mise à jour de télémétrie
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialisation optimisée du simulateur
        window.addEventListener('load', () => {
            // Initialisation asynchrone pour éviter le blocage de l'UI
            setTimeout(() => {
                const simulator = new KiteFlightSimulator();
                
                // Stocker la référence globalement pour l'accès aux boutons
                window.kiteSimulator = simulator;
                
                // Message de bienvenue après initialisation complète
                setTimeout(() => {
                    simulator.logMessage('🎯 Simulateur prêt ! Utilisez les contrôles pour voler', 'info');
                    simulator.logMessage('ℹ️ Tip: Activez la télémétrie pour voir les forces', 'debug');
                    simulator.logMessage('📹 Contrôles caméra: Z/S=avant/arrière, Q/D=gauche/droite, A/E=haut/bas, F=suivi auto, C=reset', 'info');
                    simulator.logMessage('🖱️ Molette souris: Zoom intelligent vers le cerf-volant', 'debug');
                    
                    // Vérifier et forcer l'affichage de la console
                    const consolePanel = document.getElementById('console-panel');
                    const consoleToggle = document.getElementById('console-toggle');
                    if (consolePanel && consoleToggle) {
                        consolePanel.style.display = 'flex';
                        consoleToggle.textContent = 'Masquer Console';
                        simulator.logMessage('Console de débogage active', 'debug');
                    }
                }, 2000);
            }, 0);
        });
    </script>
</body>
</html>