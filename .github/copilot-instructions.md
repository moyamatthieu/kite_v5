# Guide pour les agents IA - Simulateur de cerf-volant V8

Ce document fournit des instructions pour interagir avec la base de code du simulateur de cerf-volant. Le respect de ces directives est essentiel pour maintenir la qualit√© et la coh√©rence du code.

## üèóÔ∏è Architecture : Entity-Component-System (ECS) Pure

Le projet utilise une architecture **ECS pure**. Il est crucial de comprendre et de respecter cette s√©paration stricte :

1.  **Components (`src/ecs/components/`)** :
    *   Ce sont des conteneurs de **donn√©es pures** uniquement (par exemple, `PhysicsComponent`, `TransformComponent`).
    *   **R√®gle :** Ne jamais y ajouter de m√©thodes ou de logique. Ils doivent √™tre s√©rialisables (POJO - Plain Old JavaScript Objects).

2.  **Systems (`src/ecs/systems/`)** :
    *   Ils contiennent **toute la logique** du simulateur.
    *   Chaque syst√®me op√®re sur un ensemble d'entit√©s qui poss√®dent des composants sp√©cifiques. Par exemple, le `PhysicsSystem` met √† jour les entit√©s ayant un `PhysicsComponent` et un `TransformComponent`.
    *   **R√®gle :** L'ordre d'ex√©cution des syst√®mes est d√©fini dans `src/ecs/SimulationApp.ts`. Cet ordre est critique. Lors de l'ajout d'un nouveau syst√®me, ins√©rez-le au bon endroit dans le pipeline de la boucle de simulation (`initializeSystems` et `update`).

3.  **Entities (`src/ecs/entities/`)** :
    *   Les entit√©s sont de simples identifiants. Elles sont assembl√©es √† l'aide de "factories" (usines) dans ce r√©pertoire.
    *   **R√®gle :** Pour cr√©er un nouvel objet dans la simulation (par exemple, un obstacle), cr√©ez une nouvelle usine (par exemple, `ObstacleFactory.ts`) qui attache les composants n√©cessaires. N'instanciez pas les entit√©s directement dans les syst√®mes.

## üî¨ Physique et Mod√®le A√©rodynamique

La physique de la simulation est un aspect critique.

-   **R√©f√©rence Makani** : Le mod√®le physique est fortement inspir√© du projet open-source **Makani** de Google. Le code source se trouve dans `external/makani-master/`. Avant de modifier la physique (`AeroSystem.ts`, `ConstraintSystem.ts`), consultez ce code pour comprendre les algorithmes de calcul des forces (portance/tra√Æn√©e) et des contraintes.
-   **Syst√®mes cl√©s** :
    *   `WindSystem.ts` : Calcule le vent apparent selon la formule `Vent_apparent = Vent_ambiant - Vitesse_kite + Turbulence`. Le vent est d√©fini dans le plan horizontal XZ (Y = vertical). Synchronisation automatique avec `InputComponent` pour les param√®tres UI (vitesse, direction, turbulence).
    *   `AeroSystem.ts` : Calcule les forces a√©rodynamiques (portance, tra√Æn√©e) en utilisant les donn√©es du `WindSystem`.
    *   `ConstraintSystem.ts` : G√®re la physique des lignes (tension, amortissement).
    *   `PhysicsSystem.ts` : Int√®gre les forces pour mettre √† jour la position et la vitesse (int√©grateur d'Euler).

### Syst√®me de coordonn√©es pour le vent
-   Direction 0¬∞ = axe +X (Est)
-   Direction 90¬∞ = axe +Z (Sud)
-   Direction 180¬∞ = axe -X (Ouest)
-   Direction 270¬∞ = axe -Z (Nord)
-   Y = axe vertical (pas de composante horizontale du vent dans Y)

## üöÄ Flux de travail du d√©veloppeur

Utilisez les commandes npm d√©finies dans `package.json` pour les t√¢ches courantes.

### ‚õî R√àGLE STRICTE : NE JAMAIS EX√âCUTER `npm run dev`

**Ne JAMAIS lancer `npm run dev` automatiquement.** C'est absolument interdit.

**Pourquoi :**
- Le serveur de d√©veloppement est g√©r√© manuellement par l'utilisateur
- Lancer automatiquement le serveur peut cr√©er des conflits de ports
- Le rechargement √† chaud (HMR) peut perturber le d√©bogage en cours
- L'utilisateur doit avoir le contr√¥le total du cycle de vie du serveur
- Les agents IA ne doivent pas interf√©rer avec les processus en arri√®re-plan

**√Ä faire √† la place :**
- ‚úÖ Informer l'utilisateur qu'il doit lancer `npm run dev` lui-m√™me
- ‚úÖ Indiquer l'URL attendue : `http://localhost:3001` (ou 3002 si port occup√©)
- ‚úÖ Expliquer que le rechargement √† chaud d√©tectera automatiquement les changements

**R√©f√©rence serveur** :
-   **D√©marrage** : `npm run dev` (MANUEL UNIQUEMENT)
    *   Lance le serveur de d√©veloppement Vite sur `http://localhost:3001` avec rechargement √† chaud.

### Autres commandes disponibles

-   **Qualit√© du code** :
    *   `npm run lint` : Ex√©cute ESLint pour l'analyse statique.
    *   `npm run lint:fix` : Corrige automatiquement les probl√®mes de style.
    *   `npm run type-check` : V√©rifie les types TypeScript.
-   **Build** : `npm run build`
    *   Cr√©e une version de production optimis√©e dans le r√©pertoire `dist/`.

j'aimerais que tu lise tout le projet en details pour bien comprendre le fonctionnement et objectif global du projet. mais ne te laisse pas influencer par de potentiel erreurs dans le code ou commentaire, la vision global et l'objectif prime


## üé® Rendu 3D avec Three.js

-   Le rendu est g√©r√© par `RenderSystem.ts` et `GeometryRenderSystem.ts`.
-   Les `MeshComponent` et `GeometryComponent` lient une entit√© √† sa repr√©sentation visuelle dans la sc√®ne Three.js.
-   Pour modifier l'apparence d'un objet, mettez √† jour le mat√©riau (`Material`) ou la g√©om√©trie (`BufferGeometry`) associ√©s dans ces composants.

## üìù Gestion de la documentation

### ‚õî R√àGLE STRICTE : PAS DE FICHIERS MARKDOWN

**Ne JAMAIS cr√©er de fichiers Markdown (.md)** pour la documentation, m√™me temporairement. C'est absolument interdit.

**Pourquoi :**
- Les fichiers .md polluent le repository et cr√©ent du debt technique
- Ils ne sont pas maintenus et deviennent rapidement obsol√®tes
- Ils ne sont pas li√©s au code, donc impossible √† refactoriser avec le code
- Ils cr√©ent du bruit dans git history
- Les rapports/analyses doivent rester en conversation ou dans les commits

**Alternative :**
- Documentation int√©gr√©e directement dans le code via commentaires **JSDoc/TSDoc**
- Explications ajout√©es √† ce fichier `copilot-instructions.md`
- Analyses complexes document√©es dans les messages de commit avec `git commit -m "long message"`
- Pour les explications d√©taill√©es, utiliser les commentaires multi-lignes (`/** ... */`) dans le code

**Exemples interdits :**
- ‚ùå CONTROL_MECHANISM_ANALYSIS.md
- ‚ùå DEBUG_CHECKLIST.md
- ‚ùå SESSION_SUMMARY.md
- ‚ùå README_DEBUGGING.md
- ‚ùå LOGGING_GUIDE.md

**Exemples accept√©s :**
- ‚úÖ Commentaires JSDoc dans `src/ecs/systems/ConstraintSystem.ts`
- ‚úÖ Sections ajout√©es √† ce fichier `copilot-instructions.md`
- ‚úÖ Messages de commit d√©taill√©s (50+ lignes si n√©cessaire)
- ‚úÖ Console logs temporaires pendant debug (puis supprim√©s)

## üß† M√©thodologie de r√©solution de probl√®mes

-   **Utiliser la r√©flexion structur√©e** : Avant d'effectuer des modifications importantes ou de d√©boguer un probl√®me complexe, utilisez l'outil de r√©flexion s√©quentielle (`mcp_sequentialthi_sequentialthinking`) pour :
    *   D√©composer le probl√®me en √©tapes logiques
    *   Analyser les causes possibles
    *   √âvaluer les solutions alternatives
    *   V√©rifier la coh√©rence avec l'architecture ECS
    *   Pr√©voir les impacts sur les autres syst√®mes
-   **Quand utiliser la r√©flexion structur√©e** :
    *   Lors de l'investigation de bugs complexes
    *   Avant d'ajouter un nouveau syst√®me ou composant
    *   Lors de modifications affectant l'ordre d'ex√©cution des syst√®mes
    *   Pour comprendre les interactions entre syst√®mes
    *   Lors de probl√®mes de performance ou de rendu
-   **Objectif** : Garantir que chaque d√©cision technique respecte les principes ECS et maintient la coh√©rence du simulateur.

## üß≤ Simulation des cordes (ConstraintSystem.ts)

Le syst√®me de contrainte impl√©mente deux modes pour simuler les lignes de cerf-volant :

### Mode PBD (Position-Based Dynamics) - Am√©lior√©
Le mode PBD est une approche robuste bas√©e sur les contraintes de distance. Impl√©mentation actuelle (feat/improve-pbd-stability) :

**Param√®tres configurables :**
- `PBD_STIFFNESS = 0.8` : Fraction de correction appliqu√©e par it√©ration (0.0-1.0)
  - 1.0 = correction compl√®te (tr√®s rigide)
  - 0.5 = correction progressive (√©lastique)
- `PBD_DAMPING = 0.2` : Coefficient d'amortissement (0.1-0.3)
  - Dissipe l'√©nergie bas√©e sur la vitesse relative
  - R√©duit les oscillations non-physiques
- `PBD_ITERATIONS = 3` : Nombre d'it√©rations par frame
  - Chaque it√©ration am√©liore la convergence
  - PhysX recommande 120-300 Hz (2-4 it√©rations √† 60 fps)
- `BAUMGARTE_COEF = 0.1` : Stabilization coefficient
  - Compense les erreurs num√©riques accumul√©es
  - Pr√©vient la divergence

**Algorithme (par it√©ration) :**
1. Calculer l'√©longation: `delta = distance - restLength`
2. Si slack (pas en tension): retourner sans appliquer de forces
3. Calculer forces:
   - Force ressort: `F_spring = k √ó elongation`
   - Force amortissement: `F_damp = -c √ó v_radial`
   - Baumgarte: `F_baum = Œ≤ √ó elongation`
4. Appliquer la force totale `F_total = max(0, F_spring + F_damp + F_baum)`
5. G√©n√©rer le torque: `œÑ = r √ó F` (pour l'orientation du kite)
6. Projection de position si encore en d√©passement

**Avantages du PBD :**
- Stable m√™me avec grands timesteeps
- Support natif des slack lines (cordes molles)
- Contr√¥le fin de la rigidit√© via param√®tres
- G√©n√©ration correcte de torques pour la rotation

En suivant ces instructions, vous serez en mesure de contribuer efficacement au projet tout en respectant son architecture fondamentale.
