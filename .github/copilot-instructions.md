# Guide pour les agents IA - Simulateur de cerf-volant V8

Ce document fournit des instructions pour interagir avec la base de code du simulateur de cerf-volant. Le respect de ces directives est essentiel pour maintenir la qualit√© et la coh√©rence du code.

## üèóÔ∏è Architecture : Entity-Component-System (ECS) Pure

Le projet utilise une architecture **ECS pure**. Il est crucial de comprendre et de respecter cette s√©paration stricte :

1.  **Components (`src/ecs/components/`)** :
    *   Ce sont des conteneurs de **donn√©es pures** uniquement (par exemple, `PhysicsComponent`, `TransformComponent`).
    *   **R√®gle :** Ne jamais y ajouter de m√©thodes ou de logique. Ils doivent √™tre s√©rialisables (POJO - Plain Old JavaScript Objects).

2.  **Systems (`src/ecs/systems/`)** :
    *   Ils contiennent **toute la logique** du simulateur.
    *   Chaque syst√®me op√®re sur un ensemble d'entit√©s qui poss√®dent des composants sp√©cifiques. Par exemple, le `PhysicsSystem` met √† jour les entit√©s ayant un `PhysicsComponent` et un `TransformComponent`.
    *   **R√®gle :** L'ordre d'ex√©cution des syst√®mes est d√©fini dans `src/ecs/SimulationApp.ts`. Cet ordre est critique. Lors de l'ajout d'un nouveau syst√®me, ins√©rez-le au bon endroit dans le pipeline de la boucle de simulation (`initializeSystems` et `update`).

3.  **Entities (`src/ecs/entities/`)** :
    *   Les entit√©s sont de simples identifiants. Elles sont assembl√©es √† l'aide de "factories" (usines) dans ce r√©pertoire.
    *   **R√®gle :** Pour cr√©er un nouvel objet dans la simulation (par exemple, un obstacle), cr√©ez une nouvelle usine (par exemple, `ObstacleFactory.ts`) qui attache les composants n√©cessaires. N'instanciez pas les entit√©s directement dans les syst√®mes.

## üî¨ Physique et Mod√®le A√©rodynamique

La physique de la simulation est un aspect critique.

-   **R√©f√©rence Makani** : Le mod√®le physique est fortement inspir√© du projet open-source **Makani** de Google. Le code source se trouve dans `external/makani-master/`. Avant de modifier la physique (`AeroSystem.ts`, `ConstraintSystem.ts`), consultez ce code pour comprendre les algorithmes de calcul des forces (portance/tra√Æn√©e) et des contraintes.
-   **Syst√®mes cl√©s** :
    *   `WindSystem.ts` : Calcule le vent apparent selon la formule `Vent_apparent = Vent_ambiant - Vitesse_kite + Turbulence`. Le vent est d√©fini dans le plan horizontal XZ (Y = vertical). Synchronisation automatique avec `InputComponent` pour les param√®tres UI (vitesse, direction, turbulence).
    *   `AeroSystem.ts` : Calcule les forces a√©rodynamiques (portance, tra√Æn√©e) en utilisant les donn√©es du `WindSystem`.
    *   `ConstraintSystem.ts` : G√®re la physique des lignes (tension, amortissement).
    *   `PhysicsSystem.ts` : Int√®gre les forces pour mettre √† jour la position et la vitesse (int√©grateur d'Euler).

### Syst√®me de coordonn√©es pour le vent
-   Direction 0¬∞ = axe +X (Est)
-   Direction 90¬∞ = axe +Z (Sud)
-   Direction 180¬∞ = axe -X (Ouest)
-   Direction 270¬∞ = axe -Z (Nord)
-   Y = axe vertical (pas de composante horizontale du vent dans Y)

## üöÄ Flux de travail du d√©veloppeur

Utilisez les commandes npm d√©finies dans `package.json` pour les t√¢ches courantes.

### ‚õî R√àGLE STRICTE : NE JAMAIS EX√âCUTER `npm run dev`

**Ne JAMAIS lancer `npm run dev` automatiquement.** C'est absolument interdit.

**Pourquoi :**
- Le serveur de d√©veloppement est g√©r√© manuellement par l'utilisateur
- Lancer automatiquement le serveur peut cr√©er des conflits de ports
- Le rechargement √† chaud (HMR) peut perturber le d√©bogage en cours
- L'utilisateur doit avoir le contr√¥le total du cycle de vie du serveur
- Les agents IA ne doivent pas interf√©rer avec les processus en arri√®re-plan

**√Ä faire √† la place :**
- ‚úÖ Informer l'utilisateur qu'il doit lancer `npm run dev` lui-m√™me
- ‚úÖ Indiquer l'URL attendue : `http://localhost:3001` (ou 3002 si port occup√©)
- ‚úÖ Expliquer que le rechargement √† chaud d√©tectera automatiquement les changements

**R√©f√©rence serveur** :
-   **D√©marrage** : `npm run dev` (MANUEL UNIQUEMENT)
    *   Lance le serveur de d√©veloppement Vite sur `http://localhost:3001` avec rechargement √† chaud.

### Autres commandes disponibles

-   **Qualit√© du code** :
    *   `npm run lint` : Ex√©cute ESLint pour l'analyse statique.
    *   `npm run lint:fix` : Corrige automatiquement les probl√®mes de style.
    *   `npm run type-check` : V√©rifie les types TypeScript.
-   **Build** : `npm run build`
    *   Cr√©e une version de production optimis√©e dans le r√©pertoire `dist/`.

## üé® Rendu 3D avec Three.js

-   Le rendu est g√©r√© par `RenderSystem.ts` et `GeometryRenderSystem.ts`.
-   Les `MeshComponent` et `GeometryComponent` lient une entit√© √† sa repr√©sentation visuelle dans la sc√®ne Three.js.
-   Pour modifier l'apparence d'un objet, mettez √† jour le mat√©riau (`Material`) ou la g√©om√©trie (`BufferGeometry`) associ√©s dans ces composants.

## üìù Gestion de la documentation

### ‚õî R√àGLE STRICTE : PAS DE FICHIERS MARKDOWN

**Ne JAMAIS cr√©er de fichiers Markdown (.md)** pour la documentation, m√™me temporairement. C'est absolument interdit.

**Pourquoi :**
- Les fichiers .md polluent le repository et cr√©ent du debt technique
- Ils ne sont pas maintenus et deviennent rapidement obsol√®tes
- Ils ne sont pas li√©s au code, donc impossible √† refactoriser avec le code
- Ils cr√©ent du bruit dans git history
- Les rapports/analyses doivent rester en conversation ou dans les commits

**Alternative :**
- Documentation int√©gr√©e directement dans le code via commentaires **JSDoc/TSDoc**
- Explications ajout√©es √† ce fichier `copilot-instructions.md`
- Analyses complexes document√©es dans les messages de commit avec `git commit -m "long message"`
- Pour les explications d√©taill√©es, utiliser les commentaires multi-lignes (`/** ... */`) dans le code

**Exemples interdits :**
- ‚ùå CONTROL_MECHANISM_ANALYSIS.md
- ‚ùå DEBUG_CHECKLIST.md
- ‚ùå SESSION_SUMMARY.md
- ‚ùå README_DEBUGGING.md
- ‚ùå LOGGING_GUIDE.md

**Exemples accept√©s :**
- ‚úÖ Commentaires JSDoc dans `src/ecs/systems/ConstraintSystem.ts`
- ‚úÖ Sections ajout√©es √† ce fichier `copilot-instructions.md`
- ‚úÖ Messages de commit d√©taill√©s (50+ lignes si n√©cessaire)
- ‚úÖ Console logs temporaires pendant debug (puis supprim√©s)

## üß† M√©thodologie de r√©solution de probl√®mes

-   **Utiliser la r√©flexion structur√©e** : Avant d'effectuer des modifications importantes ou de d√©boguer un probl√®me complexe, utilisez l'outil de r√©flexion s√©quentielle (`mcp_sequentialthi_sequentialthinking`) pour :
    *   D√©composer le probl√®me en √©tapes logiques
    *   Analyser les causes possibles
    *   √âvaluer les solutions alternatives
    *   V√©rifier la coh√©rence avec l'architecture ECS
    *   Pr√©voir les impacts sur les autres syst√®mes
-   **Quand utiliser la r√©flexion structur√©e** :
    *   Lors de l'investigation de bugs complexes
    *   Avant d'ajouter un nouveau syst√®me ou composant
    *   Lors de modifications affectant l'ordre d'ex√©cution des syst√®mes
    *   Pour comprendre les interactions entre syst√®mes
    *   Lors de probl√®mes de performance ou de rendu
-   **Objectif** : Garantir que chaque d√©cision technique respecte les principes ECS et maintient la coh√©rence du simulateur.

En suivant ces instructions, vous serez en mesure de contribuer efficacement au projet tout en respectant son architecture fondamentale.
