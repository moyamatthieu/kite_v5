CONSOLIDATION DES SOURCES - Thu Oct  9 12:40:14 UTC 2025
==================================

=== base/BaseFactory.ts ===

/**
 * BaseFactory.ts - Factory abstraite pour tous les objets 3D
 * 
 * Pattern Factory Method avec support des param√®tres configurables
 */

import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export interface FactoryParams {
  [key: string]: any;
}

export interface ObjectMetadata {
  category: string;
  name: string;
  description: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'complex';
}

/**
 * Factory abstraite pour la cr√©ation d'objets 3D
 */
export abstract class BaseFactory<T extends StructuredObject & ICreatable> {
  protected abstract metadata: ObjectMetadata;

  /**
   * Cr√©er un objet avec des param√®tres optionnels
   */
  abstract createObject(params?: FactoryParams): T | Promise<T>;

  /**
   * Obtenir les m√©tadonn√©es de l'objet
   */
  getMetadata(): ObjectMetadata {
    return { ...this.metadata };
  }

  /**
   * Obtenir la cat√©gorie de l'objet
   */
  getCategory(): string {
    return this.metadata.category;
  }

  /**
   * Obtenir le nom de l'objet
   */
  getName(): string {
    return this.metadata.name;
  }

  /**
   * Valider les param√®tres avant cr√©ation
   */
  protected validateParams(params?: FactoryParams): void {
    // Validation de base - √† surcharger dans les classes d√©riv√©es
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value === null || value === undefined) {
          throw new Error(`Param√®tre '${key}' ne peut pas √™tre null ou undefined`);
        }
      });
    }
  }

  /**
   * Param√®tres par d√©faut - √† surcharger dans les classes d√©riv√©es
   */
  protected getDefaultParams(): FactoryParams {
    return {};
  }

  /**
   * Fusionner les param√®tres par d√©faut avec les param√®tres fournis
   */
  protected mergeParams(params?: FactoryParams): FactoryParams {
    return {
      ...this.getDefaultParams(),
      ...params
    };
  }
}


=== core/Node3D.ts ===


/**
 * Node3D.ts - Couche d'abstraction Godot-compatible pour la simulation Kite
 *
 * R√¥le :
 *   - Encapsule THREE.Group avec une API similaire √† Godot
 *   - Fournit des propri√©t√©s et m√©thodes compatibles avec le moteur Godot
 *   - Sert de base √† StructuredObject et √† tous les objets 3D du projet
 *
 * D√©pendances principales :
 *   - Three.js : Pour la gestion des groupes et transformations 3D
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) h√©rite de Node3D
 *   - Tous les objets 3D du projet h√©ritent indirectement de Node3D
 *
 * Utilisation typique :
 *   - Sert de base √† la hi√©rarchie d'objets 3D
 *   - Permet la compatibilit√© avec Godot pour la portabilit√©
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

/**
 * Transform3D compatible Godot
 */
export interface Transform3D {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    scale: THREE.Vector3;
}

/**
 * Signal basique pour la communication entre nodes
 */
export interface Signal {
    name: string;
    callbacks: Array<{ target: Node3D; method: string }>;
}

/**
 * Node3D - √âquivalent du Node3D de Godot
 * H√©rite de THREE.Group pour la compatibilit√©
 */
export class Node3D extends THREE.Group {
    // üéÆ Propri√©t√©s Godot-like
    public transform: Transform3D;
    public signals: Map<string, Signal> = new Map();
    
    // üè∑Ô∏è M√©tadonn√©es
    public readonly nodeId: string;
    public nodeType: string = 'Node3D';
    
    // üîß √âtat interne
    protected isReady: boolean = false;
    
    constructor(name: string = 'Node3D') {
        super();
        this.name = name;
        this.nodeId = this.generateNodeId();
        
        // Transform3D unifi√©
        this.transform = {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale
        };
        
        // Auto-initialisation
        this.callReady();
    }
    
    /**
     * G√©n√®re un ID unique pour le node (compatible Godot)
     */
    private generateNodeId(): string {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 5);
        return `node_${timestamp}_${random}`;
    }
    
    // === üéÆ M√©thodes Cycle de Vie Godot ===
    
    /**
     * _ready() - Appel√© une seule fois quand le node est ajout√© √† la sc√®ne
     */
    protected _ready(): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _process() - Appel√© √† chaque frame
     */
    protected _process(delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * _physics_process() - Appel√© √† chaque frame physique
     */
    protected _physics_process(delta: number): void {
        // √Ä overrider dans les classes d√©riv√©es
    }
    
    /**
     * Appel automatique de _ready()
     */
    private callReady(): void {
        if (!this.isReady) {
            this.isReady = true;
            this._ready();
        }
    }
    
    // === üîó Gestion des Signaux ===
    
    /**
     * D√©finit un signal (√©quivalent signal en GDScript)
     */
    public define_signal(name: string): void {
        if (!this.signals.has(name)) {
            this.signals.set(name, {
                name,
                callbacks: []
            });
        }
    }
    
    /**
     * √âmet un signal
     */
    public emit_signal(name: string, ...args: any[]): void {
        const signal = this.signals.get(name);
        if (signal) {
            signal.callbacks.forEach(callback => {
                const method = (callback.target as any)[callback.method];
                if (typeof method === 'function') {
                    method.call(callback.target, ...args);
                }
            });
        }
    }
    
    /**
     * Connecte un signal √† une m√©thode
     */
    public connect(signal: string, target: Node3D, method: string): void {
        if (!this.signals.has(signal)) {
            this.define_signal(signal);
        }
        
        const signalObj = this.signals.get(signal)!;
        signalObj.callbacks.push({ target, method });
    }
    
    // === üå≥ Gestion de l'Arbre de Nodes ===
    
    /**
     * Ajoute un enfant (compatible Godot)
     */
    public add_child(child: Node3D): void {
        this.add(child);
        child.callReady();
    }
    
    /**
     * Retire un enfant
     */
    public remove_child(child: Node3D): void {
        this.remove(child);
    }
    
    /**
     * Trouve un enfant par nom
     */
    public get_node(path: string): Node3D | null {
        return this.getObjectByName(path) as Node3D || null;
    }
    
    /**
     * Trouve tous les enfants d'un type donn√©
     */
    public get_children_of_type<T extends Node3D>(type: new (...args: any[]) => T): T[] {
        const result: T[] = [];
        this.traverse((obj) => {
            if (obj instanceof type) {
                result.push(obj);
            }
        });
        return result;
    }
    
    // === üîÑ Mise √† Jour du Cycle de Vie ===
    
    /**
     * Met √† jour le node et tous ses enfants
     */
    public update(delta: number): void {
        if (this.isReady) {
            this._process(delta);
            this._physics_process(delta);
            
            // Mettre √† jour les enfants Node3D
            this.children.forEach(child => {
                if (child instanceof Node3D) {
                    child.update(delta);
                }
            });
        }
    }
    
    // === üè∑Ô∏è M√©tadonn√©es et Debug ===
    
    /**
     * Retourne une description du node
     */
    public get_description(): string {
        return `${this.nodeType}:${this.name} (${this.nodeId})`;
    }
    
    /**
     * Affiche l'arbre des nodes (debug)
     */
    public print_tree(indent: number = 0): void {
        const spaces = '  '.repeat(indent);
        console.log(`${spaces}${this.get_description()}`);
        
        this.children.forEach(child => {
            if (child instanceof Node3D) {
                child.print_tree(indent + 1);
            }
        });
    }
    
    // === üéØ Compatibilit√© Three.js ===
    
    /**
     * Acc√®s direct au transform Three.js
     */
    public get three_transform() {
        return {
            position: this.position,
            rotation: this.rotation,
            scale: this.scale,
            matrix: this.matrix,
            matrixWorld: this.matrixWorld
        };
    }
}


=== core/Primitive.ts ===


/**
 * Primitive.ts - G√©n√©rateurs de primitives Three.js pour la simulation Kite
 *
 * R√¥le :
 *   - Fournit des utilitaires pour cr√©er les formes de base (cube, sph√®re, cylindre, etc.)
 *   - Permet de g√©n√©rer des mat√©riaux coh√©rents pour les objets 3D
 *   - Sert √† la construction des objets structur√©s (cerf-volant, barre, etc.)
 *
 * D√©pendances principales :
 *   - Three.js : Pour la g√©om√©trie et les mat√©riaux
 *   - Types : MaterialConfig pour la configuration des mat√©riaux
 *
 * Relation avec les fichiers adjacents :
 *   - StructuredObject.ts (dossier core) utilise Primitive pour cr√©er les √©l√©ments 3D
 *   - Tous les objets 3D du projet peuvent utiliser Primitive pour g√©n√©rer leurs formes
 *
 * Utilisation typique :
 *   - Appel√© par les factories et objets structur√©s pour g√©n√©rer la g√©om√©trie
 *   - Sert √† la cr√©ation rapide et coh√©rente des primitives
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 */

import * as THREE from 'three';

import { MaterialConfig } from '../types/index';

/**
 * Classe statique pour g√©n√©rer les primitives de base
 */
export class Primitive {
  /**
   * Cr√©er un mat√©riau standardis√©
   */
  private static createMaterial(config: string | MaterialConfig): THREE.MeshStandardMaterial {
    if (typeof config === 'string') {
      return new THREE.MeshStandardMaterial({ color: config });
    }

    return new THREE.MeshStandardMaterial({
      color: config.color,
      transparent: config.transparent || false,
      opacity: config.opacity || 1,
      metalness: config.metalness || 0,
      roughness: config.roughness || 0.5,
      side: config.side || THREE.FrontSide
    });
  }

  /**
   * Cr√©er une bo√Æte (cube ou parall√©l√©pip√®de)
   */
  static box(
    width: number,
    height: number,
    depth: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BoxGeometry(width, height, depth);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une sph√®re
   */
  static sphere(
    radius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.SphereGeometry(radius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un cylindre
   */
  static cylinder(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un c√¥ne
   */
  static cone(
    radius: number,
    height: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.ConeGeometry(radius, height, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un plan (surface plate)
   */
  static plane(
    width: number,
    height: number,
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.PlaneGeometry(width, height);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er un tore (anneau)
   */
  static torus(
    radius: number,
    tubeRadius: number,
    material: string | MaterialConfig,
    segments: number = 16
  ): THREE.Mesh {
    const geometry = new THREE.TorusGeometry(radius, tubeRadius, segments, segments);
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une surface √† partir de points (triangulation simple)
   */
  static surface(
    points: THREE.Vector3[],
    material: string | MaterialConfig
  ): THREE.Mesh {
    const geometry = new THREE.BufferGeometry();
    const vertices: number[] = [];

    // Ajouter les points
    points.forEach(point => {
      vertices.push(point.x, point.y, point.z);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

    // Triangulation am√©lior√©e pour les quads (faces du cube)
    const indices: number[] = [];
    if (points.length === 3) {
      // Triangle simple
      indices.push(0, 1, 2);
    }

    if (points.length === 4) {
      // Quad - utiliser une triangulation qui pr√©serve la manifold
      // Pour un cube, on utilise toujours la m√™me diagonale (0,2)
      // Cela garantit que l'ar√™te diagonale n'est pas partag√©e avec d'autres faces
      indices.push(0, 1, 2);  // Premier triangle
      indices.push(0, 2, 3);  // Deuxi√®me triangle
    }

    if (points.length > 4) {
      // Fan triangulation pour plus de points
      for (let i = 1; i < points.length - 1; i++) {
        indices.push(0, i, i + 1);
      }
    }

    geometry.setIndex(indices);

    // Calculer les normales de mani√®re coh√©rente
    geometry.computeVertexNormals();

    // S'assurer que les normales pointent vers l'ext√©rieur pour un cube
    // En inversant si n√©cessaire
    const mat = this.createMaterial(material);
    return new THREE.Mesh(geometry, mat);
  }

  /**
   * Cr√©er une fl√®che de debug (ArrowHelper)
   *
   * @param direction - Direction normalis√©e de la fl√®che
   * @param origin - Point d'origine de la fl√®che
   * @param length - Longueur de la fl√®che
   * @param color - Couleur (hex) de la fl√®che
   * @param headLength - Longueur de la t√™te de fl√®che (optionnel)
   * @param headWidth - Largeur de la t√™te de fl√®che (optionnel)
   * @returns THREE.ArrowHelper configur√©
   */
  static arrow(
    direction: THREE.Vector3,
    origin: THREE.Vector3,
    length: number,
    color: number,
    headLength?: number,
    headWidth?: number
  ): THREE.ArrowHelper {
    return new THREE.ArrowHelper(
      direction,
      origin,
      length,
      color,
      headLength,
      headWidth
    );
  }
}

=== core/StructuredObject.ts ===


/**
 * StructuredObject.ts - Classe de base unifi√©e pour tous les objets 3D structur√©s du projet Kite
 *
 * R√¥le :
 *   - Fournit une architecture orient√©e objet avec points anatomiques nomm√©s
 *   - Sert de classe m√®re pour tous les objets 3D complexes (cerf-volant, barre, etc.)
 *   - Compatible Godot via Node3D
 *
 * D√©pendances principales :
 *   - Node3D.ts : Couche d'abstraction Godot-compatible
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : Position3D, NamedPoint, SurfaceOptions, MaterialConfig
 *   - Three.js : Pour la g√©om√©trie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Node3D.ts (dossier core) est la classe m√®re directe
 *   - Primitive.ts fournit les utilitaires de cr√©ation
 *   - Tous les objets 3D du projet h√©ritent de StructuredObject
 *
 * Utilisation typique :
 *   - Sert de base √† la cr√©ation de tous les objets 3D structur√©s
 *   - Permet la gestion des points, labels et debug
 *
 * Voir aussi :
 *   - src/core/Node3D.ts
 *   - src/core/Primitive.ts
 */

import * as THREE from 'three';

import { Position3D, NamedPoint, SurfaceOptions, MaterialConfig } from '../types/index';

import { Primitive } from './Primitive';
import { Node3D } from './Node3D';

/**
 * Classe abstraite de base pour tous les objets 3D structur√©s
 * üéÆ H√©rite de Node3D pour la compatibilit√© Godot
 */
export abstract class StructuredObject extends Node3D {
  /**
   * Points anatomiques nomm√©s de l'objet
   */
  protected points: Map<string, THREE.Vector3> = new Map();
  
  /**
   * Points avec marqueurs visuels (debug)
   */
  protected namedPoints: NamedPoint[] = [];
  
  /**
   * Affichage des labels en mode debug
   */
  public showDebugPoints: boolean = false;
  
  /**
   * Affichage des labels de texte
   */
  public showLabels: boolean = false;

  constructor(name: string, showDebugPoints: boolean = false) {
    super(name);
    this.nodeType = 'StructuredObject';
    this.showDebugPoints = showDebugPoints;
    // L'initialisation sera appel√©e par la classe enfant apr√®s configuration
  }

  /**
   * Initialisation automatique de l'objet
   */
  protected initialize(): void {
    // Vider le groupe au cas o√π
    this.clear();
    
    // Construire l'objet dans l'ordre
    this.definePoints();
    this.buildStructure();
    this.buildSurfaces();
    
    // Afficher les points de debug si demand√©
    if (this.showDebugPoints) {
      this.createDebugMarkers();
    }
  }

  /**
   * Initialisation publique √† appeler par les classes enfants
   */
  public init(): void {
    this.initialize();
  }

  /**
   * D√©finit tous les points anatomiques de l'objet
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract definePoints(): void;

  /**
   * Construit la structure rigide de l'objet (frame, squelette)
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildStructure(): void;

  /**
   * Construit les surfaces et d√©tails visuels
   * √Ä impl√©menter dans chaque classe d√©riv√©e
   */
  protected abstract buildSurfaces(): void;

  /**
   * D√©finit un point nomm√© dans l'espace
   */
  protected setPoint(name: string, position: Position3D): void {
    const vector = new THREE.Vector3(position[0], position[1], position[2]);
    this.points.set(name, vector);
    
    // Ajouter aux points nomm√©s pour le debug
    this.namedPoints.push({
      name,
      position: vector.clone(),
      visible: this.showDebugPoints
    });
  }

  /**
   * R√©cup√®re un point par son nom
   */
  public getPoint(name: string): THREE.Vector3 | undefined {
    return this.points.get(name);
  }

  /**
   * Cr√©e un cylindre entre deux points nomm√©s
   */
  protected addCylinderBetweenPoints(
    point1Name: string,
    point2Name: string,
    radius: number,
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    const p1 = this.getPoint(point1Name);
    const p2 = this.getPoint(point2Name);
    
    if (!p1 || !p2) {
      console.warn(`Points ${point1Name} ou ${point2Name} non trouv√©s`);
      return null;
    }

    // Calculer la distance et l'orientation
    const distance = p1.distanceTo(p2);
    const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
    
    // Cr√©er le cylindre
    const cylinder = Primitive.cylinder(radius, distance, material);
    
    // Orienter le cylindre
    const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
    const quaternion = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction
    );
    cylinder.quaternion.copy(quaternion);
    cylinder.position.copy(midpoint);
    
    // Ajouter au groupe
    this.add(cylinder);
    return cylinder;
  }

  /**
   * Cr√©e une surface entre des points nomm√©s
   */
  protected addSurfaceBetweenPoints(
    pointNames: string[],
    material: string | MaterialConfig
  ): THREE.Mesh | null {
    if (pointNames.length < 3) {
      console.warn('Il faut au moins 3 points pour cr√©er une surface');
      return null;
    }

    const points: THREE.Vector3[] = [];
    
    // R√©cup√©rer tous les points
    for (const name of pointNames) {
      const point = this.getPoint(name);
      if (!point) {
        console.warn(`Point ${name} non trouv√©`);
        return null;
      }
      points.push(point);
    }

    // Cr√©er la surface
    const surface = Primitive.surface(points, material);
    this.add(surface);
    return surface;
  }

  /**
   * Ajoute une primitive √† une position donn√©e
   */
  protected addPrimitiveAt(
    primitive: THREE.Mesh,
    position: Position3D
  ): void {
    primitive.position.set(position[0], position[1], position[2]);
    this.add(primitive);
  }

  /**
   * Ajoute une primitive √† la position d'un point nomm√©
   */
  protected addPrimitiveAtPoint(
    primitive: THREE.Mesh,
    pointName: string
  ): boolean {
    const point = this.getPoint(pointName);
    if (!point) {
      console.warn(`Point ${pointName} non trouv√©`);
      return false;
    }
    
    primitive.position.copy(point);
    this.add(primitive);
    return true;
  }

  /**
   * Cr√©e des marqueurs visuels pour tous les points (debug)
   */
  protected createDebugMarkers(): void {
    this.points.forEach((position, name) => {
      // Petite sph√®re jaune pour marquer le point
      const marker = Primitive.sphere(0.02, '#ffff00');
      marker.position.copy(position);
      this.add(marker);
      
      // Ajouter label texte si activ√©
      if (this.showLabels) {
        const label = this.createTextLabel(name);
        label.position.copy(position);
        label.position.y += 0.05; // D√©caler le label au-dessus du point
        this.add(label);
      }
    });
  }
  
  /**
   * Cr√©e un label de texte pour un point
   */
  private createTextLabel(text: string): THREE.Sprite {
    // Cr√©er un canvas pour le texte
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    canvas.width = 256;
    canvas.height = 64;
    
    // Style du texte
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.font = 'Bold 24px Arial';
    context.fillStyle = 'black';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);
    
    // Cr√©er une texture depuis le canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Cr√©er un sprite avec la texture
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Ajuster la taille du sprite
    sprite.scale.set(0.3, 0.075, 1);
    
    return sprite;
  }

  /**
   * Active/d√©sactive l'affichage des marqueurs de debug
   */
  public setShowDebugPoints(show: boolean): void {
    this.showDebugPoints = show;
    // Reconstruire l'objet pour appliquer le changement
    this.initialize();
  }
  
  /**
   * Active/d√©sactive l'affichage des labels de texte
   */
  public setShowLabels(show: boolean): void {
    this.showLabels = show;
    // Si les points de debug ne sont pas activ√©s et qu'on veut les labels, activer les deux
    if (show && !this.showDebugPoints) {
      this.showDebugPoints = true;
    }
    // Reconstruire l'objet pour appliquer le changement
    this.initialize();
  }

  /**
   * Retourne tous les noms de points d√©finis
   */
  public getPointNames(): string[] {
    return Array.from(this.points.keys());
  }

  /**
   * Retourne le nombre de points d√©finis
   */
  public getPointCount(): number {
    return this.points.size;
  }

  /**
   * Retourne les informations sur un point
   */
  public getPointInfo(name: string): NamedPoint | undefined {
    const point = this.getPoint(name);
    if (!point) return undefined;
    
    return {
      name,
      position: point.clone(),
      visible: this.showDebugPoints
    };
  }
}

=== factories/BridleFactory.ts ===

/**
 * BridleFactory.ts - Factory pour cr√©er les instances Line repr√©sentant les brides
 *
 * R√¥le :
 *   - Cr√©e les 6 brides (3 gauches + 3 droites) comme instances de Line
 *   - Fournit une configuration physique sp√©cifique aux brides (Dyneema courtes et rigides)
 *   - Centralise la cr√©ation pour garantir coh√©rence et validation
 *
 * Architecture :
 *   - R√©utilise la classe Line (m√™me que lignes principales)
 *   - Config diff√©rente : plus rigides, plus courtes, moins √©lastiques
 *   - Pattern Factory comme LineFactory
 *
 * Relation avec les autres modules :
 *   - Utilise Line (src/objects/mechanical/Line.ts)
 *   - Utilis√© par BridleSystem
 *   - Config bas√©e sur BridleLengths (BridleTypes.ts)
 *
 * Voir aussi :
 *   - src/factories/LineFactory.ts (pattern similaire)
 *   - src/objects/mechanical/Line.ts
 *   - src/simulation/types/BridleTypes.ts
 */

import { Line, LineConfig, LineAttachments } from "@objects/mechanical/Line";

import { BridleLengths, BridleAttachment, BridleSide, BridlePosition } from "../simulation/types/BridleTypes";

/**
 * Factory pour cr√©er les brides du cerf-volant
 *
 * Les brides sont des lignes courtes et rigides en Dyneema qui relient
 * les points anatomiques du kite (NEZ, INTER, CENTRE) aux points de contr√¥le (CTRL).
 */
export class BridleFactory {
  /**
   * Configuration physique standard pour les brides
   *
   * Les brides sont plus rigides et moins √©lastiques que les lignes principales :
   * - Plus courtes (0.5-0.7m vs 15m)
   * - Plus rigides (5000 N/m vs 2200 N/m)
   * - Moins d'amortissement (quasi-rigides)
   * - Tr√®s l√©g√®res
   */
  private static readonly BRIDLE_CONFIG: Omit<LineConfig, 'length'> = {
    stiffness: 5000,           // N/m - Tr√®s rigides (Dyneema courte)
    preTension: 10,            // N - Pr√©-tension faible
    maxTension: 300,           // N - R√©sistance avant rupture
    dampingCoeff: 0.02,        // Sans dimension - Peu d'amortissement
    linearMassDensity: 0.0003, // kg/m - Tr√®s l√©g√®res
  };

  /**
   * Mapping des positions vers les points anatomiques
   */
  private static readonly POINT_MAPPING = {
    left: {
      nez: { start: "NEZ", end: "CTRL_GAUCHE" },
      inter: { start: "INTER_GAUCHE", end: "CTRL_GAUCHE" },
      centre: { start: "CENTRE", end: "CTRL_GAUCHE" },
    },
    right: {
      nez: { start: "NEZ", end: "CTRL_DROIT" },
      inter: { start: "INTER_DROIT", end: "CTRL_DROIT" },
      centre: { start: "CENTRE", end: "CTRL_DROIT" },
    },
  } as const;

  /**
   * Cr√©e une bride individuelle
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @param length - Longueur en m√®tres
   * @returns Instance Line configur√©e
   */
  static createBridle(
    side: BridleSide,
    position: BridlePosition,
    length: number
  ): Line {
    const points = this.POINT_MAPPING[side][position];
    const id = `bridle_${side}_${position}`;

    const config: LineConfig = {
      ...this.BRIDLE_CONFIG,
      length,
    };

    const attachments: LineAttachments = {
      kitePoint: points.start,
      barPoint: points.end,
    };

    return new Line(config, attachments, id);
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© gauche
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createLeftBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('left', 'nez', lengths.nez),
      this.createBridle('left', 'inter', lengths.inter),
      this.createBridle('left', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e les 3 brides du c√¥t√© droit
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 3 instances Line [nez, inter, centre]
   */
  static createRightBridles(lengths: BridleLengths): [Line, Line, Line] {
    return [
      this.createBridle('right', 'nez', lengths.nez),
      this.createBridle('right', 'inter', lengths.inter),
      this.createBridle('right', 'centre', lengths.centre),
    ];
  }

  /**
   * Cr√©e toutes les 6 brides (gauches + droites)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Objet contenant les brides gauches et droites
   */
  static createAllBridles(lengths: BridleLengths): {
    left: [Line, Line, Line];
    right: [Line, Line, Line];
  } {
    return {
      left: this.createLeftBridles(lengths),
      right: this.createRightBridles(lengths),
    };
  }

  /**
   * Cr√©e les m√©tadonn√©es d'attache pour toutes les brides
   * (utilis√© pour documentation/debug)
   *
   * @param lengths - Longueurs physiques des brides
   * @returns Tableau de 6 BridleAttachment
   */
  static createBridleAttachments(lengths: BridleLengths): BridleAttachment[] {
    const attachments: BridleAttachment[] = [];

    // Brides gauches
    Object.entries(this.POINT_MAPPING.left).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_left_${position}`,
      });
    });

    // Brides droites
    Object.entries(this.POINT_MAPPING.right).forEach(([position, points]) => {
      attachments.push({
        startPoint: points.start,
        endPoint: points.end,
        length: lengths[position as BridlePosition],
        id: `bridle_right_${position}`,
      });
    });

    return attachments;
  }

  /**
   * Valide les longueurs de brides
   *
   * @param lengths - Longueurs √† valider
   * @throws Error si longueurs invalides
   */
  static validateBridleLengths(lengths: BridleLengths): void {
    const { nez, inter, centre } = lengths;

    // V√©rifier valeurs positives
    if (nez <= 0 || inter <= 0 || centre <= 0) {
      throw new Error(
        `Longueurs de brides doivent √™tre positives: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier plage raisonnable (0.2m √† 1.5m)
    const min = 0.2;
    const max = 1.5;
    if (nez < min || nez > max || inter < min || inter > max || centre < min || centre > max) {
      throw new Error(
        `Longueurs de brides hors plage [${min}, ${max}]m: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }

    // V√©rifier coh√©rence g√©om√©trique (bride nez g√©n√©ralement plus longue)
    if (nez < inter * 0.8 || nez < centre * 0.8) {
      console.warn(
        `‚ö†Ô∏è Bride NEZ plus courte que INTER/CENTRE peut causer instabilit√©: nez=${nez}, inter=${inter}, centre=${centre}`
      );
    }
  }

  /**
   * Obtient la configuration physique utilis√©e pour les brides
   * (utile pour debug/documentation)
   */
  static getBridleConfig(): Omit<LineConfig, 'length'> {
    return { ...this.BRIDLE_CONFIG };
  }
}


=== factories/FrameFactory.ts ===

/**
 * FrameFactory.ts - Factory pour cr√©er des structures filaires (frames)
 * 
 * Pattern actuel KISS : Points ‚Üí Cylindres entre points
 * Compatible avec buildStructure() de StructuredObject
 */

import { BaseFactory, FactoryParams } from '../base/BaseFactory';
import { StructuredObject } from '../core/StructuredObject';
import { ICreatable } from '../types/index';

export interface FrameParams extends FactoryParams {
  diameter?: number;     // Diam√®tre des tubes
  material?: string;     // Couleur/mat√©riau
  points?: Array<[string, number[]]>;  // Points nomm√©s
  connections?: Array<[string, string]>; // Connexions entre points
}

/**
 * Factory pour cr√©er des structures filaires
 * 
 * TODO: Questions pour √©volution future
 * - [ ] Supporter diff√©rents profils (carr√©, rond, I-beam) ? uniquemet rond
 * - [ ] Ajouter des jonctions/connecteurs aux intersections ?  non 
 * - [ ] Calculer automatiquement les connexions optimales ? non
 * - [ ] Supporter des courbes (splines) entre points ? non
 * - [ ] Ajouter contraintes m√©caniques (r√©sistance, poids) ? plus tard
  */
export class FrameFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: 'structure',
    name: 'Frame',
    description: 'Structure filaire param√©trique',
    tags: ['frame', 'structure', 'squelette'],
    complexity: 'simple' as const
  };

  protected getDefaultParams(): FrameParams {
    return {
      diameter: 0.01,
      material: '#333333',
      points: [],
      connections: []
    };
  }

  createObject(params?: FrameParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as FrameParams;
    
    class FrameObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Frame", false);
      }
      
      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }
      
      protected buildStructure(): void {
        // Cr√©er les cylindres entre les points connect√©s
        if (mergedParams.connections) {
          mergedParams.connections.forEach(([point1, point2]) => {
            this.addCylinderBetweenPoints(
              point1, 
              point2, 
              mergedParams.diameter || 0.01,
              mergedParams.material || '#333333'
            );
          });
        }
      }
      
      protected buildSurfaces(): void {
        // Pas de surfaces pour un frame
      }
      
      // Impl√©mentation ICreatable
      create(): this { return this; }
      getName(): string { return 'Frame'; }
      getDescription(): string { return 'Structure filaire'; }
      getPrimitiveCount(): number { return (mergedParams.connections || []).length; }
    }
    
    const frame = new FrameObject();
    frame.init();
    return frame;
  }
}


=== factories/LineFactory.ts ===

/**
 * LineFactory.ts - Factory pour cr√©er des lignes de cerf-volant (OOP pattern)
 *
 * R√¥le :
 *   - Cr√©er des objets Line selon le pattern Factory du projet
 *   - Valider les param√®tres avant cr√©ation
 *   - Fournir des presets pour configurations typiques
 *
 * Responsabilit√© :
 *   - Instanciation coh√©rente des objets Line
 *   - Application des valeurs par d√©faut
 *   - Validation des param√®tres physiques
 *
 * Pattern :
 *   - Ne suit PAS BaseFactory<StructuredObject> car Line n'est pas un objet 3D
 *   - Factory simple avec m√©thodes statiques pour configurations communes
 *   - S√©paration claire : Line (m√©tier) vs LineVisual (3D)
 *
 * Relation avec les autres modules :
 *   - Cr√©e des objets Line
 *   - Utilis√© par LineSystem pour instancier les lignes
 *   - Ind√©pendant de Three.js (pure TypeScript)
 *
 * Philosophie :
 *   - "Make invalid states unrepresentable" : Validation stricte
 *   - Presets pour cas d'usage communs
 *   - Immutabilit√© : Les lignes cr√©√©es sont immutables (config readonly)
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts
 *   - src/base/BaseFactory.ts (pattern de r√©f√©rence)
 */

import { Line, LineConfig, LineAttachments } from '@objects/mechanical/Line';

import { CONFIG } from '@/simulation/config/SimulationConfig';

/**
 * Param√®tres pour cr√©er une ligne via factory
 */
export interface LineFactoryParams {
  /** Longueur au repos (m) - D√©faut: CONFIG.lines.defaultLength */
  length?: number;

  /** Point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;

  /** Rigidit√© personnalis√©e (N/m) - D√©faut: CONFIG.lines.stiffness */
  stiffness?: number;

  /** Pr√©-tension personnalis√©e (N) - D√©faut: CONFIG.lines.preTension */
  preTension?: number;

  /** Tension max personnalis√©e (N) - D√©faut: CONFIG.lines.maxTension */
  maxTension?: number;

  /** Damping personnalis√© - D√©faut: CONFIG.lines.dampingCoeff */
  dampingCoeff?: number;

  /** Masse lin√©ique personnalis√©e (kg/m) - D√©faut: CONFIG.lines.linearMassDensity */
  linearMassDensity?: number;

  /** Identifiant personnalis√© (optionnel) */
  id?: string;
}

/**
 * Erreur de validation lors de la cr√©ation d'une ligne
 */
export class LineValidationError extends Error {
  constructor(message: string, public field: string) {
    super(`LineFactory validation error [${field}]: ${message}`);
    this.name = 'LineValidationError';
  }
}

/**
 * Factory pour cr√©er des lignes de cerf-volant
 *
 * @example
 * ```typescript
 * // Ligne standard avec param√®tres par d√©faut
 * const leftLine = LineFactory.createLine({
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Ligne personnalis√©e
 * const customLine = LineFactory.createLine({
 *   length: 20,
 *   stiffness: 1800,
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 *
 * // Preset d√©butant
 * const beginnerLine = LineFactory.createBeginnerLine("CTRL_GAUCHE", "HANDLE_LEFT");
 * ```
 */
export class LineFactory {
  /**
   * Cr√©e une ligne avec param√®tres personnalis√©s
   *
   * @param params - Param√®tres de configuration
   * @returns Instance de Line configur√©e
   * @throws LineValidationError si param√®tres invalides
   */
  static createLine(params: LineFactoryParams): Line {
    // Valider les param√®tres
    this.validateParams(params);

    // Configuration avec valeurs par d√©faut depuis SimulationConfig
    const config: LineConfig = {
      length: params.length ?? CONFIG.lines.defaultLength,
      stiffness: params.stiffness ?? CONFIG.lines.stiffness,
      preTension: params.preTension ?? CONFIG.lines.preTension,
      maxTension: params.maxTension ?? CONFIG.lines.maxTension,
      dampingCoeff: params.dampingCoeff ?? CONFIG.lines.dampingCoeff,
      linearMassDensity: params.linearMassDensity ?? CONFIG.lines.linearMassDensity
    };

    // Points d'attache
    const attachments: LineAttachments = {
      kitePoint: params.kitePoint,
      barPoint: params.barPoint
    };

    // Cr√©er et retourner la ligne
    return new Line(config, attachments, params.id);
  }

  /**
   * Cr√©e une paire de lignes gauche/droite standard
   *
   * @param length - Longueur commune (m)
   * @returns Tuple [ligne gauche, ligne droite]
   */
  static createLinePair(length?: number): [Line, Line] {
    const leftLine = this.createLine({
      length,
      kitePoint: "CTRL_GAUCHE",
      barPoint: "HANDLE_LEFT",
      id: "line_left"
    });

    const rightLine = this.createLine({
      length,
      kitePoint: "CTRL_DROIT",
      barPoint: "HANDLE_RIGHT",
      id: "line_right"
    });

    return [leftLine, rightLine];
  }

  /**
   * Preset : Ligne pour d√©butant
   * - Plus courte (12m)
   * - Moins rigide (1800 N/m)
   * - Pr√©-tension plus faible (50N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour d√©butant
   */
  static createBeginnerLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 12,
      stiffness: 1800,
      preTension: 50,
      maxTension: 600,
      dampingCoeff: 0.08, // Plus de damping = plus stable
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne pour expert
   * - Plus longue (20m)
   * - Rigidit√© standard (2200 N/m)
   * - Haute tension max (1000N)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne configur√©e pour expert
   */
  static createExpertLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 20,
      stiffness: 2200,
      preTension: 100,
      maxTension: 1000,
      dampingCoeff: 0.03, // Moins de damping = plus r√©actif
      kitePoint,
      barPoint
    });
  }

  /**
   * Preset : Ligne de s√©curit√© (ultra-r√©sistante)
   * - Tension max tr√®s √©lev√©e (1500N)
   * - Rigidit√© renforc√©e (3000 N/m)
   *
   * @param kitePoint - Point d'attache kite
   * @param barPoint - Point d'attache barre
   * @returns Ligne de s√©curit√©
   */
  static createSafetyLine(kitePoint: string, barPoint: string): Line {
    return this.createLine({
      length: 15,
      stiffness: 3000,
      preTension: 150,
      maxTension: 1500,
      dampingCoeff: 0.05,
      linearMassDensity: 0.001, // Plus lourde
      kitePoint,
      barPoint
    });
  }

  /**
   * Cr√©e une ligne depuis JSON (d√©s√©rialisation)
   *
   * @param json - Donn√©es JSON (depuis Line.toJSON())
   * @returns Instance de Line recr√©√©e
   */
  static fromJSON(json: any): Line {
    return Line.fromJSON(json);
  }

  /**
   * Valide les param√®tres avant cr√©ation
   *
   * @param params - Param√®tres √† valider
   * @throws LineValidationError si invalide
   */
  private static validateParams(params: LineFactoryParams): void {
    // Points d'attache obligatoires
    if (!params.kitePoint || params.kitePoint.trim() === '') {
      throw new LineValidationError('Kite attachment point is required', 'kitePoint');
    }

    if (!params.barPoint || params.barPoint.trim() === '') {
      throw new LineValidationError('Bar attachment point is required', 'barPoint');
    }

    // Longueur positive
    if (params.length !== undefined && params.length <= 0) {
      throw new LineValidationError('Length must be positive', 'length');
    }

    // Rigidit√© positive
    if (params.stiffness !== undefined && params.stiffness <= 0) {
      throw new LineValidationError('Stiffness must be positive', 'stiffness');
    }

    // Pr√©-tension non-n√©gative
    if (params.preTension !== undefined && params.preTension < 0) {
      throw new LineValidationError('PreTension cannot be negative', 'preTension');
    }

    // Tension max > pr√©-tension
    if (params.maxTension !== undefined && params.preTension !== undefined) {
      if (params.maxTension <= params.preTension) {
        throw new LineValidationError(
          'MaxTension must be greater than preTension',
          'maxTension'
        );
      }
    }

    // Damping dans [0, 1]
    if (params.dampingCoeff !== undefined) {
      if (params.dampingCoeff < 0 || params.dampingCoeff > 1) {
        throw new LineValidationError(
          'DampingCoeff must be between 0 and 1',
          'dampingCoeff'
        );
      }
    }

    // Masse lin√©ique positive
    if (params.linearMassDensity !== undefined && params.linearMassDensity <= 0) {
      throw new LineValidationError(
        'LinearMassDensity must be positive',
        'linearMassDensity'
      );
    }
  }

  /**
   * Obtient les valeurs par d√©faut utilis√©es par la factory
   *
   * @returns Configuration par d√©faut
   */
  static getDefaultConfig(): LineConfig {
    return {
      length: CONFIG.lines.defaultLength,
      stiffness: CONFIG.lines.stiffness,
      preTension: CONFIG.lines.preTension,
      maxTension: CONFIG.lines.maxTension,
      dampingCoeff: CONFIG.lines.dampingCoeff,
      linearMassDensity: CONFIG.lines.linearMassDensity
    };
  }

  /**
   * V√©rifie si deux lignes ont la m√™me configuration physique
   *
   * @param line1 - Premi√®re ligne
   * @param line2 - Deuxi√®me ligne
   * @returns true si configurations identiques
   */
  static areConfigsEqual(line1: Line, line2: Line): boolean {
    const c1 = line1.config;
    const c2 = line2.config;

    return (
      c1.length === c2.length &&
      c1.stiffness === c2.stiffness &&
      c1.preTension === c2.preTension &&
      c1.maxTension === c2.maxTension &&
      c1.dampingCoeff === c2.dampingCoeff &&
      c1.linearMassDensity === c2.linearMassDensity
    );
  }
}


=== factories/PointFactory.ts ===

/**
 * PointFactory.ts - Encapsule la logique de calcul des points anatomiques
 *
 * Responsabilit√© : Calculer les positions des points d'un cerf-volant delta
 */

import * as THREE from 'three';

/**
 * Longueurs physiques des brides (en m√®tres)
 */
export interface BridleLengths {
  nez: number;      // Longueur bride NEZ -> CTRL (avant)
  inter: number;    // Longueur bride INTER -> CTRL (lat√©ral)
  centre: number;   // Longueur bride CENTRE -> CTRL (arri√®re)
}

export interface KiteParams {
  width: number;   // Envergure
  height: number;  // Hauteur
  depth: number;   // Profondeur whiskers
  bridleLengths?: BridleLengths;  // Longueurs physiques des brides
}

/**
 * Factory simple qui encapsule la logique de calcul des points
 */
export class PointFactory {
  /**
   * Longueurs de brides par d√©faut (en m√®tres)
   * LONGUEURS IDENTIQUES : L'√©quilibre g√©om√©trique vient de la structure, pas des brides
   */
  private static readonly DEFAULT_BRIDLE_LENGTHS: BridleLengths = {
    nez: 0.65,     // 65cm - identique pour toutes les brides
    inter: 0.65,   // 65cm - identique pour toutes les brides
    centre: 0.65,  // 65cm - identique pour toutes les brides
  };

  /**
   * Calcule la position du point de contr√¥le (CTRL) par trilat√©ration 3D analytique
   * R√©sout l'intersection de 3 sph√®res centr√©es en NEZ, INTER, CENTRE
   * avec rayons = longueurs de brides respectives
   */
  private static calculateControlPoint(
    nez: [number, number, number],
    inter: [number, number, number],
    centre: [number, number, number],
    bridleLengths: BridleLengths,
    side: 'left' | 'right'
  ): [number, number, number] {
    // Convertir en Vector3
    const p1 = new THREE.Vector3(...nez);      // Point 1 : NEZ
    const p2 = new THREE.Vector3(...inter);    // Point 2 : INTER
    const p3 = new THREE.Vector3(...centre);   // Point 3 : CENTRE

    const r1 = bridleLengths.nez;     // Rayon sph√®re 1
    const r2 = bridleLengths.inter;   // Rayon sph√®re 2
    const r3 = bridleLengths.centre;  // Rayon sph√®re 3

    // Trilat√©ration 3D analytique
    // √âtape 1 : Cr√©er un rep√®re local avec p1 √† l'origine
    const ex = new THREE.Vector3().subVectors(p2, p1).normalize(); // axe X : direction p1->p2
    const d = p2.distanceTo(p1); // distance entre p1 et p2

    // √âtape 2 : Calculer composante Y du rep√®re
    const p3_p1 = new THREE.Vector3().subVectors(p3, p1);
    const i = ex.dot(p3_p1); // projection de p3-p1 sur ex
    const ey_temp = new THREE.Vector3().copy(p3_p1).addScaledVector(ex, -i);
    const ey = ey_temp.normalize(); // axe Y : perpendiculaire √† ex dans le plan

    // √âtape 3 : Axe Z (perpendiculaire au plan p1-p2-p3)
    const ez = new THREE.Vector3().crossVectors(ex, ey);

    // IMPORTANT : Pour garantir la sym√©trie, ez doit toujours pointer vers l'arri√®re (+Z global)
    // Si ez.z < 0, on inverse la direction
    if (ez.z < 0) {
      ez.negate();
    }

    // √âtape 4 : Coordonn√©es de p3 dans le rep√®re local
    const j = ey.dot(p3_p1);

    // √âtape 5 : R√©solution du syst√®me dans le rep√®re local
    // x = (r1¬≤ - r2¬≤ + d¬≤) / (2d)
    const x = (r1 * r1 - r2 * r2 + d * d) / (2 * d);

    // y = (r1¬≤ - r3¬≤ + i¬≤ + j¬≤) / (2j) - (i/j) * x
    const y = (r1 * r1 - r3 * r3 + i * i + j * j) / (2 * j) - (i / j) * x;

    // z¬≤ = r1¬≤ - x¬≤ - y¬≤
    const zSquared = r1 * r1 - x * x - y * y;

    // Si z¬≤ < 0, les sph√®res ne se croisent pas (configuration impossible)
    let z: number;
    if (zSquared < 0) {
      console.warn(`‚ö†Ô∏è Configuration de brides impossible (z¬≤=${zSquared.toFixed(3)}), approximation`);
      z = 0; // Solution d√©g√©n√©r√©e : CTRL dans le plan des 3 points
    } else {
      // Deux solutions possibles (devant/derri√®re le plan)
      // On prend z > 0 (vers l'arri√®re du kite, direction +Z)
      // Pour garantir la SYM√âTRIE, les deux c√¥t√©s doivent avoir le m√™me Z
      z = Math.sqrt(zSquared);
    }

    // √âtape 6 : Convertir les coordonn√©es locales en coordonn√©es globales
    const result = new THREE.Vector3();
    result.copy(p1); // Partir de p1
    result.addScaledVector(ex, x); // Ajouter x * ex
    result.addScaledVector(ey, y); // Ajouter y * ey
    result.addScaledVector(ez, z); // Ajouter z * ez

    return [result.x, result.y, result.z];
  }

  /**
   * Calcule toutes les positions des points anatomiques d'un cerf-volant delta
   */
  static calculateDeltaKitePoints(params: KiteParams): Map<string, [number, number, number]> {
    const { width, height, depth, bridleLengths = PointFactory.DEFAULT_BRIDLE_LENGTHS } = params;

    // Logique m√©tier extraite de Kite.ts
    const centreY = height / 4;
    const ratio = (height - centreY) / height;
    const interGaucheX = ratio * (-width / 2);
    const interDroitX = ratio * (width / 2);
    const fixRatio = 2 / 3;

    // Points d'ancrage fixes des brides
    const nezPos: [number, number, number] = [0, height, 0];
    const centrePos: [number, number, number] = [0, height / 4, 0];
    const interGauchePos: [number, number, number] = [interGaucheX, centreY, 0];
    const interDroitPos: [number, number, number] = [interDroitX, centreY, 0];

    // Calculer la position du point de contr√¥le DROIT par trilat√©ration.
    // Le point GAUCHE sera d√©duit par sym√©trie pour garantir une g√©om√©trie parfaite.
    const ctrlDroit = PointFactory.calculateControlPoint(
      nezPos,
      interDroitPos, // Utilise le point d'ancrage droit
      centrePos,
      bridleLengths,
      'right'
    );

    // Le point de contr√¥le GAUCHE est le miroir du point droit par rapport √† l'axe YZ.
    // On prend la position du point droit et on inverse simplement sa coordonn√©e X.
    const ctrlGauche: [number, number, number] = [-ctrlDroit[0], ctrlDroit[1], ctrlDroit[2]];

    // Retourner la Map exactement comme dans le code original
    return new Map<string, [number, number, number]>([
      // Points structurels principaux
      ["SPINE_BAS", [0, 0, 0]],
      ["CENTRE", centrePos],
      ["NEZ", nezPos],

      // Points des bords d'attaque
      ["BORD_GAUCHE", [-width / 2, 0, 0]],
      ["BORD_DROIT", [width / 2, 0, 0]],

      // Points d'intersection pour le spreader
      ["INTER_GAUCHE", interGauchePos],
      ["INTER_DROIT", interDroitPos],

      // Points de fixation whiskers
      ["FIX_GAUCHE", [fixRatio * interGaucheX, centreY, 0]],
      ["FIX_DROIT", [fixRatio * interDroitX, centreY, 0]],

      // Points des whiskers
      ["WHISKER_GAUCHE", [-width / 4, 0.1, -depth]],
      ["WHISKER_DROIT", [width / 4, 0.1, -depth]],

      // Points de contr√¥le (bridage) - CALCUL√âS depuis longueurs physiques
      ["CTRL_GAUCHE", ctrlGauche],
      ["CTRL_DROIT", ctrlDroit],

      // Points d'ancrage des brides
      ["BRIDE_GAUCHE_A", nezPos],
      ["BRIDE_GAUCHE_B", interGauchePos],
      ["BRIDE_GAUCHE_C", centrePos],
      ["BRIDE_DROITE_A", nezPos],
      ["BRIDE_DROITE_B", interDroitPos],
      ["BRIDE_DROITE_C", centrePos],
    ]);
  }
}

=== factories/SurfaceFactory.ts ===

/**
 * SurfaceFactory.ts - Factory pour cr√©er des surfaces et toiles
 *
 * Pattern actuel KISS : Points ‚Üí Triangles pour surfaces
 * Compatible avec buildSurfaces() de StructuredObject
 */

import * as THREE from "three";

import { BaseFactory, FactoryParams } from "../base/BaseFactory";
import { StructuredObject } from "../core/StructuredObject";
import { ICreatable } from "../types/index";

export interface SurfaceParams extends FactoryParams {
  points?: Array<[string, number[]]>; // Points nomm√©s pour la surface
  panels?: Array<string[]>; // Groupes de 3-4 points formant des panneaux
  material?: {
    color?: string;
    opacity?: number;
    transparent?: boolean;
    doubleSided?: boolean; // true = visible des deux c√¥t√©s (d√©faut), false = une face
    side?: THREE.Side;
  };
  tension?: number; // Tension de la toile (future feature)
}

/**
 * Factory pour cr√©er des surfaces tendues
 *
 * TODO: Questions pour √©volution future
 * - [ ] Impl√©menter subdivision de surfaces pour plus de d√©tail ? non
 * - [ ] Ajouter simulation de tension/d√©formation ? non
 * - [ ] Supporter surfaces courbes (NURBS simplifi√©es) ? non
 * - [ ] Calculer automatiquement la triangulation optimale ? non
 * - [ ] Ajouter textures proc√©durales (tissage, ripstop) ? non
 * - [ ] G√©rer les plis et d√©formations ? non
 *
 */
export class SurfaceFactory extends BaseFactory<StructuredObject & ICreatable> {
  protected metadata = {
    category: "surface",
    name: "Surface",
    description: "Surface tendue param√©trique",
    tags: ["surface", "toile", "membrane"],
    complexity: "simple" as const,
  };

  protected getDefaultParams(): SurfaceParams {
    return {
      points: [],
      panels: [],
      material: {
        color: "#ff0000",
        opacity: 0.9,
        transparent: true,
        doubleSided: true, // Par d√©faut, visible des deux c√¥t√©s
      },
      tension: 1.0,
    };
  }

  createObject(params?: SurfaceParams): StructuredObject & ICreatable {
    const mergedParams = this.mergeParams(params) as SurfaceParams;

    class SurfaceObject extends StructuredObject implements ICreatable {
      constructor() {
        super("Surface", false);
      }

      protected definePoints(): void {
        // Ajouter les points fournis
        if (mergedParams.points) {
          mergedParams.points.forEach(([name, position]) => {
            this.setPoint(name, position as [number, number, number]);
          });
        }
      }

      protected buildStructure(): void {
        // Pas de structure pour une surface pure
      }

      protected buildSurfaces(): void {
        // Cr√©er les panneaux de surface
        if (mergedParams.panels) {
          mergedParams.panels.forEach((panel) => {
            // Convertir doubleSided en THREE.Side
            const mat = mergedParams.material || {};
            const side =
              mat.doubleSided !== false ? THREE.DoubleSide : THREE.FrontSide;

            // Chaque panneau est un triangle (3 points) ou quad (4 points)
            this.addSurfaceBetweenPoints(panel, {
              color: mat.color || "#ff0000",
              opacity: mat.opacity !== undefined ? mat.opacity : 0.9,
              transparent: mat.transparent !== false,
              side: mat.side || side,
            });
          });
        }
      }

      // Impl√©mentation ICreatable
      create(): this {
        return this;
      }
      getName(): string {
        return "Surface";
      }
      getDescription(): string {
        return "Surface tendue";
      }
      getPrimitiveCount(): number {
        return (mergedParams.panels || []).length;
      }
    }

    const surface = new SurfaceObject();
    surface.init();
    return surface;
  }
}


=== main.ts ===

import { Simulation } from "./simulation";

// Initialisation de la simulation
console.log("üöÄ D√©marrage de la simulation ...");

try {
  const app = new Simulation();
  console.log("‚úÖ Simulation initialis√©e avec succ√®s");

  // Gestion du nettoyage lors de la fermeture de la page
  window.addEventListener("beforeunload", () => {
    if (app && typeof app.cleanup === "function") {
      app.cleanup();
    }
  });
} catch (error) {
  console.error("‚ùå Erreur lors de l'initialisation de la simulation:", error);
}


=== objects/mechanical/Line.ts ===

/**
 * Line.ts - Entit√© m√©tier repr√©sentant une ligne de cerf-volant
 *
 * R√¥le :
 *   - Encapsule les propri√©t√©s physiques d'une ligne (Dyneema/Spectra)
 *   - Repr√©sente une ligne individuelle du syst√®me de pilotage
 *   - Pure data object, pas de logique de calcul
 *
 * Responsabilit√© :
 *   - Stocker les param√®tres physiques (longueur, rigidit√©, tension)
 *   - G√©rer les points d'attache (nom des points anatomiques)
 *   - Fournir un √©tat coh√©rent pour les calculs physiques
 *
 * Relation avec les autres modules :
 *   - Utilis√© par LinePhysics pour les calculs de force
 *   - Cr√©√© par LineFactory
 *   - Consomm√© par LineSystem (orchestration)
 *
 * Philosophie :
 *   - "Tell, don't ask" : La ligne expose son √©tat, ne fait pas de calculs
 *   - Immutabilit√© partielle : Les param√®tres physiques sont readonly
 *   - Single Responsibility : Repr√©sentation m√©tier uniquement
 *
 * Voir aussi :
 *   - src/simulation/physics/LinePhysics.ts (calculs)
 *   - src/factories/LineFactory.ts (cr√©ation)
 *   - src/objects/mechanical/LineVisual.ts (rendu)
 */

import * as THREE from "three";

/**
 * Configuration physique d'une ligne de cerf-volant
 */
export interface LineConfig {
  /** Longueur au repos (m√®tres) */
  length: number;

  /** Rigidit√© axiale EA/L (N/m) - Typique Dyneema : 2200 N/m pour 15m */
  stiffness: number;

  /** Pr√©-tension minimale (N) - Toujours pr√©sente, m√™me ligne molle */
  preTension: number;

  /** Tension maximale avant rupture (N) */
  maxTension: number;

  /** Coefficient d'amortissement interne (sans dimension, 0-1) */
  dampingCoeff: number;

  /** Masse lin√©ique (kg/m) - Pour calcul cat√©naire */
  linearMassDensity: number;
}

/**
 * Points d'attache d'une ligne
 */
export interface LineAttachments {
  /** Nom du point d'attache sur le kite (ex: "CTRL_GAUCHE") */
  kitePoint: string;

  /** Nom du point d'attache sur la barre (ex: "HANDLE_LEFT") */
  barPoint: string;
}

/**
 * Entit√© repr√©sentant une ligne de cerf-volant
 *
 * @example
 * ```typescript
 * const leftLine = new Line({
 *   length: 15,
 *   stiffness: 2200,
 *   preTension: 75,
 *   maxTension: 800,
 *   dampingCoeff: 0.05,
 *   linearMassDensity: 0.0005
 * }, {
 *   kitePoint: "CTRL_GAUCHE",
 *   barPoint: "HANDLE_LEFT"
 * });
 * ```
 */
export class Line {
  /** Identifiant unique de la ligne */
  public readonly id: string;

  /** Configuration physique (immuable) */
  public readonly config: Readonly<LineConfig>;

  /** Points d'attache (immuables) */
  public readonly attachments: Readonly<LineAttachments>;

  /** √âtat actuel de la ligne */
  private currentLength: number;
  private currentTension: number;

  /** Timestamp derni√®re mise √† jour */
  private lastUpdateTime: number;

  constructor(
    config: LineConfig,
    attachments: LineAttachments,
    id?: string
  ) {
    this.id = id || `line_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.config = Object.freeze({ ...config });
    this.attachments = Object.freeze({ ...attachments });

    // √âtat initial
    this.currentLength = config.length;
    this.currentTension = config.preTension;
    this.lastUpdateTime = 0;
  }

  /**
   * Met √† jour l'√©tat actuel de la ligne
   * (Appel√© par LinePhysics apr√®s calcul)
   */
  updateState(length: number, tension: number, timestamp: number): void {
    this.currentLength = length;
    this.currentTension = tension;
    this.lastUpdateTime = timestamp;
  }

  /**
   * Obtient la longueur actuelle (√©tir√©e)
   */
  getCurrentLength(): number {
    return this.currentLength;
  }

  /**
   * Obtient la tension actuelle
   */
  getCurrentTension(): number {
    return this.currentTension;
  }

  /**
   * Calcule l'extension actuelle (Œîx = L_current - L_rest)
   */
  getExtension(): number {
    return Math.max(0, this.currentLength - this.config.length);
  }

  /**
   * V√©rifie si la ligne est tendue
   */
  isTaut(): boolean {
    return this.currentLength > this.config.length;
  }

  /**
   * V√©rifie si la ligne est proche de la rupture
   */
  isNearBreaking(threshold: number = 0.9): boolean {
    return this.currentTension >= this.config.maxTension * threshold;
  }

  /**
   * Obtient le timestamp de derni√®re mise √† jour
   */
  getLastUpdateTime(): number {
    return this.lastUpdateTime;
  }

  /**
   * Clone cette ligne avec une nouvelle configuration
   */
  clone(newConfig?: Partial<LineConfig>): Line {
    return new Line(
      { ...this.config, ...newConfig },
      { ...this.attachments }
    );
  }

  /**
   * Repr√©sentation textuelle pour debug
   */
  toString(): string {
    return `Line[${this.id}](${this.attachments.kitePoint} ‚Üí ${this.attachments.barPoint}) ` +
           `L=${this.currentLength.toFixed(3)}m T=${this.currentTension.toFixed(1)}N`;
  }

  /**
   * Export JSON pour s√©rialisation
   */
  toJSON(): object {
    return {
      id: this.id,
      config: this.config,
      attachments: this.attachments,
      state: {
        currentLength: this.currentLength,
        currentTension: this.currentTension,
        lastUpdateTime: this.lastUpdateTime
      }
    };
  }

  /**
   * Cr√©e une ligne depuis JSON
   */
  static fromJSON(data: any): Line {
    const line = new Line(data.config, data.attachments, data.id);
    if (data.state) {
      line.updateState(
        data.state.currentLength,
        data.state.currentTension,
        data.state.lastUpdateTime
      );
    }
    return line;
  }
}


=== objects/organic/Kite.ts ===


/**
 * Kite.ts - Mod√®le 3D du cerf-volant delta pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la structure, les points anatomiques et les surfaces du cerf-volant
 *   - Utilise les factories pour g√©n√©rer la g√©om√©trie, la structure et la toile
 *   - Sert de base √† tous les calculs physiques et au rendu
 *
 * D√©pendances principales :
 *   - StructuredObject.ts : Classe de base pour tous les objets 3D structur√©s
 *   - FrameFactory.ts, SurfaceFactory.ts, PointFactory.ts : Factories pour la cr√©ation des √©l√©ments du kite
 *   - Primitive.ts : Utilitaires pour les formes de base
 *   - Types : ICreatable pour l'interface de cr√©ation
 *   - Three.js : Pour la g√©om√©trie et le rendu
 *
 * Relation avec les fichiers adjacents :
 *   - Les factories (FrameFactory, SurfaceFactory, PointFactory) sont utilis√©es pour g√©n√©rer la structure et la toile
 *   - StructuredObject.ts (dossier core) est la classe m√®re
 *
 * Utilisation typique :
 *   - Instanci√© par le moteur physique et le rendu pour manipuler le kite
 *   - Sert de source unique pour les points et la g√©om√©trie du kite
 *
 * Voir aussi :
 *   - src/core/StructuredObject.ts
 *   - src/factories/FrameFactory.ts
 *   - src/factories/SurfaceFactory.ts
 *   - src/factories/PointFactory.ts
 */

import * as THREE from "three";

import { StructuredObject } from "../../core/StructuredObject";
import { ICreatable } from "../../types/index";
import { Primitive } from "../../core/Primitive";
import { FrameFactory } from "../../factories/FrameFactory";
import { SurfaceFactory } from "../../factories/SurfaceFactory";
import { PointFactory, BridleLengths } from "../../factories/PointFactory";
import { CONFIG } from "../../simulation/config/SimulationConfig";

export class Kite extends StructuredObject implements ICreatable {
  private frameFactory: FrameFactory;
  private surfaceFactory: SurfaceFactory;
  // Map centrale des points - Single Source of Truth
  private pointsMap: Map<string, [number, number, number]> = new Map();
  private bridleLines: THREE.Group | null = null;
  private bridleLengthFactor: number = 1.0; // Facteur de longueur virtuelle des brides principales

  // Longueurs physiques des brides (en m√®tres)
  // LONGUEURS IDENTIQUES : L'√©quilibre vient de la g√©om√©trie, pas des brides
  // Principe: Kite suspendu par CTRL_GAUCHE et CTRL_DROIT sera horizontal
  // si le centre de masse se trouve entre ces deux points (axe X)
  private bridleLengths: BridleLengths = {
    nez: 0.65,     // 65cm - longueur standard
    inter: 0.65,   // 65cm - longueur standard
    centre: 0.65,  // 65cm - longueur standard
  };

  // Param√®tres du cerf-volant
  private params = {
    width: 1.65, // Envergure
    height: 0.65, // Hauteur
    depth: 0.20, // Profondeur whiskers
    frameDiameter: 0.01,
    frameColor: "#2a2a2a",
    sailColor: "#ff3333",
    sailOpacity: 0.9,
  };

  constructor(customParams = {}) {
    super("Cerf-volant Delta", false);
    this.params = { ...this.params, ...customParams };
    this.frameFactory = new FrameFactory();
    this.surfaceFactory = new SurfaceFactory();
    this.init();
  }

  /**
   * D√©finit tous les points anatomiques du cerf-volant
   * Utilise PointFactory pour encapsuler la logique de calcul
   */
  protected definePoints(): void {
    const { width, height, depth } = this.params;

    // Utiliser PointFactory pour calculer les positions avec bridleLengths physiques
    this.pointsMap = PointFactory.calculateDeltaKitePoints({
      width,
      height,
      depth,
      bridleLengths: this.bridleLengths
    });

    // Enregistrer dans StructuredObject pour compatibilit√© avec le syst√®me existant
    this.pointsMap.forEach((position, name) => {
      this.setPoint(name, position);
    });
  }

  /**
   * Construit la structure rigide avec FrameFactory
   */
  protected buildStructure(): void {
    const { frameDiameter, frameColor } = this.params;

    // Cr√©er le frame principal avec la Map de points partag√©e
    const mainFrameParams = {
      diameter: frameDiameter,
      material: frameColor,
      points: Array.from(this.pointsMap.entries()), // Passer LA Map de r√©f√©rence
      connections: [
        // √âpine centrale
        ["NEZ", "SPINE_BAS"] as [string, string],
        // Bords d'attaque
        ["NEZ", "BORD_GAUCHE"] as [string, string],
        ["NEZ", "BORD_DROIT"] as [string, string],
        // Spreader
        ["INTER_GAUCHE", "INTER_DROIT"] as [string, string],
      ],
    };

    const mainFrame = this.frameFactory.createObject(mainFrameParams);
    this.add(mainFrame);

    // Cr√©er les whiskers avec un frame s√©par√© (plus fin)
    const whiskerFrameParams = {
      diameter: frameDiameter / 2,
      material: "#444444",
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      connections: [
        ["WHISKER_GAUCHE", "FIX_GAUCHE"] as [string, string],
        ["WHISKER_DROIT", "FIX_DROIT"] as [string, string],
      ],
    };

    const whiskerFrame = this.frameFactory.createObject(whiskerFrameParams);
    this.add(whiskerFrame);

    // Cr√©er le syst√®me de bridage avec des lignes souples
    this.createBridleLines();
  }

  /**
   * Cr√©e les lignes de bridage souples (visuelles uniquement)
   * Ces lignes repr√©sentent des cordes sans √©lasticit√© ni effet ressort
   */
  private createBridleLines(): void {
    // Supprimer les anciennes lignes si elles existent
    if (this.bridleLines) {
      this.remove(this.bridleLines);
    }

    this.bridleLines = new THREE.Group();
    this.bridleLines.name = "BridleLines";

    // Configuration des brides
    const bridleConnections = [
      // Bridage gauche (3 lignes partant de CTRL_GAUCHE)
      ["CTRL_GAUCHE", "NEZ"],
      ["CTRL_GAUCHE", "INTER_GAUCHE"],
      ["CTRL_GAUCHE", "CENTRE"],
      // Bridage droit (3 lignes partant de CTRL_DROIT)
      ["CTRL_DROIT", "NEZ"],
      ["CTRL_DROIT", "INTER_DROIT"],
      ["CTRL_DROIT", "CENTRE"],
    ];

    // Mat√©riau pour les lignes de bridage
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: 1,
      opacity: 0.8,
      transparent: true,
    });

    // Cr√©er chaque ligne de bridage
    bridleConnections.forEach(([startName, endName]) => {
      const startPos = this.pointsMap.get(startName);
      const endPos = this.pointsMap.get(endName);

      if (startPos && endPos) {
        // Cr√©er une ligne droite simple (sans effet cat√©naire pour les brides internes)
        const geometry = new THREE.BufferGeometry();
        const points = [
          new THREE.Vector3(...startPos),
          new THREE.Vector3(...endPos),
        ];
        geometry.setFromPoints(points);

        const line = new THREE.Line(geometry, lineMaterial);
        line.name = `Bridle_${startName}_${endName}`;

        // Stocker la longueur de repos de la bride
        const restLength = new THREE.Vector3(...startPos).distanceTo(
          new THREE.Vector3(...endPos)
        );
        line.userData.restLength = restLength;
        line.userData.startPoint = startName;
        line.userData.endPoint = endName;

        this.bridleLines!.add(line);
      }
    });

    this.add(this.bridleLines!);
  }

  /**
   * Met √† jour les lignes de bridage pour suivre les points
   * √Ä appeler si les points bougent dynamiquement
   */
  public updateBridleLines(): void {
    if (!this.bridleLines) return;

    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const startName = line.userData.startPoint;
        const endName = line.userData.endPoint;
        const startPos = this.pointsMap.get(startName);
        const endPos = this.pointsMap.get(endName);

        if (startPos && endPos) {
          const geometry = line.geometry as THREE.BufferGeometry;
          const points = [
            new THREE.Vector3(...startPos),
            new THREE.Vector3(...endPos),
          ];
          geometry.setFromPoints(points);
          geometry.attributes.position.needsUpdate = true;
        }
      }
    });
  }

  /**
   * Met √† jour la visualisation des brides selon leurs tensions
   * Couleurs : vert (molle) ‚Üí jaune (moyenne) ‚Üí rouge (tendue)
   *
   * @param tensions - Tensions des 6 brides en Newtons
   */
  public updateBridleVisualization(tensions: {
    leftNez: number;
    leftInter: number;
    leftCentre: number;
    rightNez: number;
    rightInter: number;
    rightCentre: number;
  }): void {
    if (!this.bridleLines) return;

    // Mapping nom ligne ‚Üí tension
    const tensionMap = new Map<string, number>([
      ["Bridle_CTRL_GAUCHE_NEZ", tensions.leftNez],
      ["Bridle_CTRL_GAUCHE_INTER_GAUCHE", tensions.leftInter],
      ["Bridle_CTRL_GAUCHE_CENTRE", tensions.leftCentre],
      ["Bridle_CTRL_DROIT_NEZ", tensions.rightNez],
      ["Bridle_CTRL_DROIT_INTER_DROIT", tensions.rightInter],
      ["Bridle_CTRL_DROIT_CENTRE", tensions.rightCentre],
    ]);

    // Mettre √† jour couleur de chaque bride
    this.bridleLines.children.forEach((line) => {
      if (line instanceof THREE.Line) {
        const tension = tensionMap.get(line.name) ?? 0;
        const material = line.material as THREE.LineBasicMaterial;

        // Seuils de tension (N) - centralis√©s dans CONFIG
        const lowThreshold = CONFIG.debug.bridleTensionLow;
        const highThreshold = CONFIG.debug.bridleTensionHigh;

        if (tension < lowThreshold) {
          // Vert : bride molle
          material.color.setHex(0x00ff00);
          material.opacity = 0.5;
        } else if (tension < highThreshold) {
          // Jaune : tension moyenne
          // Interpolation vert ‚Üí jaune
          const t = (tension - lowThreshold) / (highThreshold - lowThreshold);
          const r = Math.floor(t * 255);
          const g = 255;
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.6 + t * 0.2; // 0.6 ‚Üí 0.8
        } else {
          // Rouge : bride tendue
          // Interpolation jaune ‚Üí rouge
          const t = Math.min((tension - highThreshold) / 100, 1);
          const r = 255;
          const g = Math.floor((1 - t) * 255);
          const b = 0;
          material.color.setRGB(r / 255, g / 255, b / 255);
          material.opacity = 0.8 + t * 0.2; // 0.8 ‚Üí 1.0
        }
      }
    });
  }

  /**
   * Construit les surfaces avec SurfaceFactory
   */
  protected buildSurfaces(): void {
    const { sailColor, sailOpacity } = this.params;

    // Cr√©er la toile avec 4 panneaux triangulaires
    const sailParams = {
      points: Array.from(this.pointsMap.entries()), // M√™me Map de r√©f√©rence
      panels: [
        // Toile gauche
        ["NEZ", "BORD_GAUCHE", "WHISKER_GAUCHE"],
        ["NEZ", "WHISKER_GAUCHE", "SPINE_BAS"],
        // Toile droite
        ["NEZ", "BORD_DROIT", "WHISKER_DROIT"],
        ["NEZ", "WHISKER_DROIT", "SPINE_BAS"],
      ],
      material: {
        color: sailColor,
        transparent: true,
        opacity: sailOpacity,
        doubleSided: true, // Visible des deux c√¥t√©s
      },
    };

    const sail = this.surfaceFactory.createObject(sailParams);
    this.add(sail);

    // Ajouter des marqueurs visuels aux points cl√©s
    this.addVisualMarkers();
  }

  /**
   * M√©thode helper pour obtenir la Map de points
   * Peut √™tre utilis√©e si d'autres objets ont besoin des points
   */
  public getPointsMap(): Map<string, [number, number, number]> {
    return new Map(this.pointsMap); // Retourner une copie pour √©viter les modifications externes
  }

  /**
   * Ajuste le facteur de longueur virtuelle des brides principales (NEZ vers CTRL_*)
   * @param factor - Facteur de longueur (0.5 = 50% plus court, 1.0 = normal, 1.5 = 50% plus long)
   */
  public adjustBridleLength(factor: number): void {
    // Limiter la valeur entre 0.5 et 1.5
    this.bridleLengthFactor = Math.max(0.5, Math.min(1.5, factor));
    console.log(
      `üìè Facteur de longueur des brides principales: ${this.bridleLengthFactor}`
    );
  }

  /**
   * Retourne la longueur de repos virtuelle pour les brides principales
   * Utilis√© par la physique pour calculer les tensions
   * @param bridleName - 'left' ou 'right'
   * @returns La longueur de repos modifi√©e ou undefined si pas une bride principale
   */
  public getBridleRestLength(bridleName: "left" | "right"): number | undefined {
    const nez = this.getPoint("NEZ");
    const ctrl = this.getPoint(
      bridleName === "left" ? "CTRL_GAUCHE" : "CTRL_DROIT"
    );

    if (!nez || !ctrl) return undefined;

    // Calculer la distance g√©om√©trique r√©elle
    const realDistance = nez.distanceTo(ctrl);

    // Appliquer le facteur de longueur virtuelle
    // factor < 1 = bride plus courte = plus de tension
    // factor > 1 = bride plus longue = moins de tension
    return realDistance * this.bridleLengthFactor;
  }

  /**
   * Retourne le facteur de longueur actuel des brides
   */
  public getBridleLengthFactor(): number {
    return this.bridleLengthFactor;
  }

  /**
   * Ajuste les longueurs physiques des brides (en m√®tres)
   * @param lengths - Longueurs des 3 brides { nez, inter, centre }
   */
  public setBridleLengths(lengths: Partial<BridleLengths>): void {
    // Mettre √† jour les longueurs (merge avec les valeurs existantes)
    this.bridleLengths = {
      ...this.bridleLengths,
      ...lengths
    };

    console.log(`ü™Å Longueurs brides: NEZ=${this.bridleLengths.nez.toFixed(2)}m, INTER=${this.bridleLengths.inter.toFixed(2)}m, CENTRE=${this.bridleLengths.centre.toFixed(2)}m`);

    // Supprimer tous les enfants pour nettoyer l'ancienne g√©om√©trie
    this.clearChildren();

    // Recalculer les points avec les nouvelles longueurs
    this.definePoints();

    // Reconstruire le kite avec les nouveaux points
    this.buildStructure();
    this.buildSurfaces();
    this.createBridleLines();

    // Recr√©er les marqueurs visuels aux nouvelles positions
    this.addVisualMarkers();
  }

  /**
   * Supprime tous les enfants du kite (g√©om√©trie, marqueurs, etc.)
   */
  private clearChildren(): void {
    // Supprimer tous les enfants Three.js
    while (this.children.length > 0) {
      this.remove(this.children[0]);
    }
  }

  /**
   * Retourne les longueurs actuelles des brides
   */
  public getBridleLengths(): BridleLengths {
    return { ...this.bridleLengths };
  }

  /**
   * Ajoute des marqueurs visuels aux points importants
   */
  private addVisualMarkers(): void {
    // Nez (point rouge)
    const nez = this.getPoint("NEZ");
    if (nez) {
      const marker = Primitive.sphere(0.025, "#ff0000");
      this.addPrimitiveAt(marker, [nez.x, nez.y, nez.z]);
    }

    // Points de contr√¥le
    const ctrlG = this.getPoint("CTRL_GAUCHE");
    if (ctrlG) {
      const marker = Primitive.sphere(0.025, "#dc143c");
      this.addPrimitiveAt(marker, [ctrlG.x, ctrlG.y, ctrlG.z]);
    }

    const ctrlD = this.getPoint("CTRL_DROIT");
    if (ctrlD) {
      const marker = Primitive.sphere(0.025, "#b22222");
      this.addPrimitiveAt(marker, [ctrlD.x, ctrlD.y, ctrlD.z]);
    }
  }

  // Impl√©mentation de l'interface ICreatable
  create(): this {
    return this;
  }

  getName(): string {
    return "Cerf-volant Delta v2";
  }

  getDescription(): string {
    return "Cerf-volant delta construit avec les factories CAO";
  }

  getPrimitiveCount(): number {
    return 25; // Frame + surfaces + marqueurs
  }
}

/**
 * AVANTAGES de cette approche avec factories:
 *
 * 1. **Modularit√©** : Points, frames et surfaces sont g√©r√©s par des factories d√©di√©es
 * 2. **R√©utilisabilit√©** : Les factories peuvent √™tre utilis√©es pour d'autres objets
 * 3. **Param√©trage** : Facile de modifier les param√®tres de chaque composant
 * 4. **Composition** : On peut combiner diff√©rentes factories
 * 5. **√âvolutivit√©** : Facile d'ajouter de nouvelles fonctionnalit√©s aux factories
 *
 * UTILISATION DE POINTFACTORY:
 * - Tous les points sont d√©finis dans une Map centralis√©e
 * - PointFactory cr√©e un objet points r√©utilisable
 * - Pas de sym√©trie automatique : chaque point est d√©fini explicitement
 * - Permet une gestion coh√©rente et valid√©e des points anatomiques
 *
 * WORKFLOW CAO:
 * 1. PointFactory ‚Üí D√©finir tous les points anatomiques
 * 2. FrameFactory ‚Üí Construire la structure rigide
 * 3. SurfaceFactory ‚Üí Ajouter les surfaces/toiles
 * 4. Assembly ‚Üí Combiner le tout (futur)
 */


=== simulation.ts ===

/**
 * Point d'entr√©e de compatibilit√©
 *
 * Ce fichier maintient la compatibilit√© avec l'ancien import
 * tout en redirigeant vers la nouvelle structure modulaire
 */

export { Simulation } from './simulation/SimulationApp';

=== simulation/SimulationApp.ts ===

/**
 * SimulationApp.ts - Application principale de simulation
 *
 * Point d'entr√©e refactoris√© qui assemble tous les composants modulaires
 */

import * as THREE from "three";

import { Kite } from "../objects/organic/Kite";

import { RenderManager } from "./rendering/RenderManager";
import { DebugRenderer } from "./rendering/DebugRenderer";
import { PhysicsEngine } from "./physics/PhysicsEngine";
import { InputHandler } from "./controllers/InputHandler";
import { UIManager } from "./ui/UIManager";
import { CONFIG } from "./config/SimulationConfig";
import { KiteGeometry } from "./config/KiteGeometry";

export class Simulation {
  private renderManager: RenderManager;
  private debugRenderer: DebugRenderer;
  private physicsEngine!: PhysicsEngine;
  private inputHandler: InputHandler;
  private uiManager!: UIManager;
  private kite!: Kite;
  private controlBar!: THREE.Group;
  private clock: THREE.Clock;
  private isPlaying: boolean = true;
  private leftLine: THREE.Line | null = null;
  private rightLine: THREE.Line | null = null;
  private frameCount: number = 0;

  constructor() {
    console.log("üöÄ D√©marrage de la Simulation V8 - Version modulaire");

    try {
      const container = document.getElementById("app");
      if (!container) {
        throw new Error("Container #app non trouv√©");
      }

      this.renderManager = new RenderManager(container);
      this.debugRenderer = new DebugRenderer(this.renderManager);
      this.inputHandler = new InputHandler();
      this.clock = new THREE.Clock();

      // üîß Initialiser le niveau de subdivision du maillage
      KiteGeometry.setMeshSubdivisionLevel(CONFIG.kite.defaultMeshSubdivisionLevel);

      this.setupControlBar();
      this.setupKite();
      this.physicsEngine = new PhysicsEngine(
        this.kite,
        this.controlBar.position
      );
      this.setupUI();
      this.createControlLines();
      this.animate();
    } catch (error) {
      console.error(
        "‚ùå Erreur lors de l'initialisation de la Simulation:",
        error
      );
      throw error;
    }
  }

  private setupKite(): void {
    this.kite = new Kite();
    const pilot = this.controlBar.position.clone();
    // Position initiale : 95% de la longueur de ligne pour avoir lignes l√©g√®rement tendues
    const initialDistance = CONFIG.lines.defaultLength * CONFIG.initialization.initialDistanceFactor;

    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);

    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);
    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();

    console.log(
      `üìç Position initiale du kite: ${this.kite.position.toArray()}`
    );
    this.renderManager.addObject(this.kite);
  }

  private setupControlBar(): void {
    this.controlBar = new THREE.Group();
    this.controlBar.position.copy(CONFIG.controlBar.position);

    const barGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.barRadius,
      CONFIG.controlBar.width
    );
    const barMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      metalness: 0.7,
      roughness: 0.3,
    });
    const bar = new THREE.Mesh(barGeometry, barMaterial);
    bar.rotation.z = CONFIG.controlBar.barRotation;
    this.controlBar.add(bar);

    const handleGeometry = new THREE.CylinderGeometry(
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleRadius,
      CONFIG.controlBar.handleLength
    );
    const handleMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      roughness: 0.6,
    });

    const halfWidth = CONFIG.controlBar.width / 2;
    const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    leftHandle.position.set(-halfWidth, 0, 0);
    this.controlBar.add(leftHandle);

    const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    rightHandle.position.set(halfWidth, 0, 0);
    this.controlBar.add(rightHandle);

    const pilotGeometry = new THREE.BoxGeometry(
      CONFIG.pilot.width,
      CONFIG.pilot.height,
      CONFIG.pilot.depth
    );
    const pilotMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a4a4a,
      roughness: 0.8,
    });
    const pilot = new THREE.Mesh(pilotGeometry, pilotMaterial);
    pilot.position.set(0, CONFIG.pilot.offsetY, CONFIG.pilot.offsetZ);
    pilot.castShadow = true;

    this.renderManager.addObject(this.controlBar);
    this.renderManager.addObject(pilot);
  }

  /**
   * Calcule la distance horizontale via Pythagore
   * √âvite la duplication de code (utilis√© dans setupKite et resetSimulation)
   */
  private calculateHorizontalDistance(hypotenuse: number, vertical: number): number {
    const minHorizontal = 0.1; // m - Distance horizontale minimale pour √©viter kite au-dessus du pilote
    return Math.max(
      minHorizontal,
      Math.sqrt(Math.max(0, hypotenuse * hypotenuse - vertical * vertical))
    );
  }

  private createControlLines(): void {
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x333333,
      linewidth: CONFIG.visualization.lineWidth,
    });

    const leftGeometry = new THREE.BufferGeometry();
    const rightGeometry = new THREE.BufferGeometry();

    this.leftLine = new THREE.Line(leftGeometry, lineMaterial);
    this.rightLine = new THREE.Line(rightGeometry, lineMaterial);

    this.renderManager.addObject(this.leftLine);
    this.renderManager.addObject(this.rightLine);
  }

  private updateControlLines(): void {
    if (!this.leftLine || !this.rightLine) return;

    const ctrlLeft = this.kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = this.kite.getPoint("CTRL_DROIT");

    if (!ctrlLeft || !ctrlRight) return;

    const kiteLeftWorld = ctrlLeft.clone();
    const kiteRightWorld = ctrlRight.clone();
    this.kite.localToWorld(kiteLeftWorld);
    this.kite.localToWorld(kiteRightWorld);

    const handles = this.physicsEngine
      .getControlBarManager()
      .getHandlePositions(this.kite.position);

    const leftPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.left, kiteLeftWorld);
    const rightPoints = this.physicsEngine
      .getLineSystem()
      .calculateCatenary(handles.right, kiteRightWorld);

    this.leftLine.geometry.setFromPoints(leftPoints);
    this.rightLine.geometry.setFromPoints(rightPoints);

    this.physicsEngine
      .getControlBarManager()
      .updateVisual(this.controlBar, this.kite);
  }

  private setupUI(): void {
    this.uiManager = new UIManager(
      this.physicsEngine,
      this.debugRenderer,
      () => this.resetSimulation(),
      () => this.togglePlayPause()
    );
  }

  private resetSimulation(): void {
    const currentLineLength =
      this.physicsEngine.getLineSystem().lineLength ||
      CONFIG.lines.defaultLength;
    const initialDistance = currentLineLength * CONFIG.initialization.initialDistanceFactor;

    const pilot = this.controlBar.position.clone();
    const kiteY = CONFIG.initialization.initialKiteY;
    const dy = kiteY - pilot.y;
    const horizontal = this.calculateHorizontalDistance(initialDistance, dy);
    this.kite.position.set(pilot.x, kiteY, pilot.z - horizontal);

    this.kite.rotation.set(0, 0, 0);
    this.kite.quaternion.identity();
    this.controlBar.quaternion.identity();

    this.physicsEngine = new PhysicsEngine(this.kite, this.controlBar.position);
    this.physicsEngine.setLineLength(currentLineLength);

    this.updateControlLines();
    console.log(`üîÑ Simulation r√©initialis√©e`);
  }

  private togglePlayPause(): void {
    this.isPlaying = !this.isPlaying;
    this.uiManager.updatePlayButton(this.isPlaying);
  }

  private animate = (): void => {
    requestAnimationFrame(this.animate);

    this.frameCount++;

    if (this.isPlaying) {
      try {
        const deltaTime = this.clock.getDelta();
        this.inputHandler.update(deltaTime);
        const targetRotation = this.inputHandler.getTargetBarRotation();

        this.physicsEngine.update(deltaTime, targetRotation, false);
        this.updateControlLines();
        this.debugRenderer.updateDebugArrows(this.kite, this.physicsEngine);
      } catch (error) {
        console.error("‚ùå Erreur dans la boucle d'animation:", error);
        this.isPlaying = false;
      }
    }

    this.renderManager.render();
  };

  public cleanup(): void {
    console.log("üßπ Nettoyage de la Simulation...");
    this.isPlaying = false;

    this.debugRenderer.clearDebugArrows();

    if (this.leftLine) {
      this.renderManager.removeObject(this.leftLine);
      this.leftLine = null;
    }
    if (this.rightLine) {
      this.renderManager.removeObject(this.rightLine);
      this.rightLine = null;
    }

    if (this.kite) {
      this.renderManager.removeObject(this.kite);
    }

    if (this.controlBar) {
      this.renderManager.removeObject(this.controlBar);
    }

    console.log("‚úÖ Simulation nettoy√©e");
  }
}

=== simulation/config/KiteGeometry.ts ===

/**
 * KiteGeometry.ts - D√©finition de la g√©om√©trie du cerf-volant pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la forme, les points anatomiques et les surfaces du cerf-volant
 *   - Sert de plan de construction pour tous les calculs physiques et graphiques
 *   - Utilis√© pour le calcul des forces, la cr√©ation du mod√®le 3D et la configuration
 *
 * D√©pendances principales :
 *   - Three.js : Utilis√© pour les coordonn√©es et la g√©om√©trie
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise KiteGeometry pour la surface et les points
 *   - Tous les modules physiques et graphiques utilisent KiteGeometry pour les calculs
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de rendu et de configuration
 *   - Sert √† positionner les points et surfaces du kite
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

/**
 * G√©om√©trie du cerf-volant
 *
 * La forme du cerf-volant - comme un plan de construction
 * On d√©finit o√π sont tous les points importants du cerf-volant
 */
export class KiteGeometry {
  // Les points cl√©s du cerf-volant (comme les coins d'une maison)
  // Coordonn√©es en m√®tres : [gauche/droite, haut/bas, avant/arri√®re]
  static readonly POINTS = {
    NEZ: new THREE.Vector3(0, 0.65, 0), // Le bout pointu en haut
    SPINE_BAS: new THREE.Vector3(0, 0, 0), // Le centre en bas
    BORD_GAUCHE: new THREE.Vector3(-0.825, 0, 0), // L'extr√©mit√© de l'aile gauche
    BORD_DROIT: new THREE.Vector3(0.825, 0, 0), // L'extr√©mit√© de l'aile droite
    WHISKER_GAUCHE: new THREE.Vector3(-0.4125, 0.1, -0.15), // Stabilisateur gauche (l√©g√®rement en arri√®re)
    WHISKER_DROIT: new THREE.Vector3(0.4125, 0.1, -0.15), // Stabilisateur droit (l√©g√®rement en arri√®re)
    CTRL_GAUCHE: new THREE.Vector3(-0.15, 0.3, -0.2), // O√π s'attache la ligne gauche
    CTRL_DROIT: new THREE.Vector3(0.15, 0.3, -0.2), // O√π s'attache la ligne droite
  };

  /**
   * Calcule l'aire d'un triangle 3D √† partir de ses 3 sommets
   * Utilise la formule : Aire = 0.5 √ó ||AB √ó AC||
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle
   * @param v3 Troisi√®me sommet du triangle
   * @returns L'aire du triangle en m¬≤
   */
  private static calculateTriangleArea(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): number {
    // Cr√©er deux vecteurs repr√©sentant deux c√¥t√©s du triangle
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    
    // Le produit vectoriel donne un vecteur perpendiculaire
    // dont la longueur = aire du parall√©logramme form√© par edge1 et edge2
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    
    // L'aire du triangle = la moiti√© de l'aire du parall√©logramme
    return cross.length() / 2;
  }

  /**
   * Calcule le centro√Øde (centre g√©om√©trique) d'un triangle
   * Le centro√Øde est situ√© √† l'intersection des m√©dianes du triangle
   * 
   * @param v1 Premier sommet du triangle
   * @param v2 Deuxi√®me sommet du triangle  
   * @param v3 Troisi√®me sommet du triangle
   * @returns Le point centro√Øde du triangle
   */
  static calculateTriangleCentroid(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3
  ): THREE.Vector3 {
    return v1.clone()
      .add(v2)
      .add(v3)
      .divideScalar(3);
  }

  // Le cerf-volant est fait de 4 triangles de tissu
  // Chaque triangle a 3 coins (vertices) et une surface en m√®tres carr√©s
  //
  // ORDRE DES VERTICES (r√®gle main droite) :
  // Les normales doivent pointer vers l'ARRI√àRE (Z positif) pour recevoir le vent
  // qui vient de l'arri√®re (direction -Z).
  // Order : sens horaire vu de l'arri√®re = normale vers l'arri√®re
  //
  // NOTE : Les aires sont calcul√©es automatiquement √† partir de la g√©om√©trie r√©elle
  // pour garantir la coh√©rence physique
  //
  // NOTE : Les masses sont calcul√©es apr√®s, voir SURFACES_WITH_MASS ci-dessous
  static readonly SURFACES = [
    {
      // Surface haute gauche (normale doit pointer vers arri√®re)
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.BORD_GAUCHE,
        KiteGeometry.POINTS.WHISKER_GAUCHE
      ),
    },
    {
      // Surface basse gauche
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_GAUCHE,
        KiteGeometry.POINTS.SPINE_BAS
      ),
    },
    {
      // Surface haute droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.WHISKER_DROIT,
        KiteGeometry.POINTS.BORD_DROIT
      ),
    },
    {
      // Surface basse droite
      vertices: [
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT,
      ],
      area: KiteGeometry.calculateTriangleArea(
        KiteGeometry.POINTS.NEZ,
        KiteGeometry.POINTS.SPINE_BAS,
        KiteGeometry.POINTS.WHISKER_DROIT
      ),
    },
  ];

  /**
   * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
   * @param v1, v2, v3 : sommets du triangle
   * @returns Tableau de 4 sous-triangles {vertices, area}
   */
  private static subdivideTriangle(v1: THREE.Vector3, v2: THREE.Vector3, v3: THREE.Vector3) {
    // Calcul des milieux
    const m12 = v1.clone().add(v2).multiplyScalar(0.5);
    const m23 = v2.clone().add(v3).multiplyScalar(0.5);
    const m31 = v3.clone().add(v1).multiplyScalar(0.5);

    // 4 sous-triangles
    const tris = [
      { vertices: [v1, m12, m31] },
      { vertices: [v2, m23, m12] },
      { vertices: [v3, m31, m23] },
      { vertices: [m12, m23, m31] },
    ];
    // Ajoute l'aire √† chaque sous-triangle
    return tris.map(t => ({
      vertices: t.vertices,
      area: KiteGeometry.calculateTriangleArea(t.vertices[0], t.vertices[1], t.vertices[2])
    }));
  }

  /**
   * Subdivise r√©cursivement un triangle selon un niveau donn√©
   * @param v1, v2, v3 : sommets du triangle
   * @param level : niveau de subdivision (0 = pas de subdivision)
   * @returns Tableau de tous les sous-triangles
   */
  private static subdivideTriangleRecursive(
    v1: THREE.Vector3,
    v2: THREE.Vector3,
    v3: THREE.Vector3,
    level: number
  ): { vertices: THREE.Vector3[]; area: number }[] {
    if (level <= 0) {
      // Pas de subdivision : retourner le triangle original
      return [{
        vertices: [v1, v2, v3],
        area: KiteGeometry.calculateTriangleArea(v1, v2, v3)
      }];
    }

    // Subdiviser en 4 sous-triangles
    const subTriangles = KiteGeometry.subdivideTriangle(v1, v2, v3);

    // Appliquer r√©cursivement la subdivision √† chaque sous-triangle
    const result: { vertices: THREE.Vector3[]; area: number }[] = [];
    for (const subTri of subTriangles) {
      const [sv1, sv2, sv3] = subTri.vertices;
      result.push(...KiteGeometry.subdivideTriangleRecursive(sv1, sv2, sv3, level - 1));
    }

    return result;
  }

  /**
   * Subdivision du maillage pour am√©liorer la pr√©cision a√©rodynamique.
   *
   * POURQUOI LA SUBDIVISION :
   * - Un triangle unique ne peut avoir qu'une seule normale ‚Üí angle d'attaque uniforme
   * - Avec subdivision, chaque sous-triangle peut avoir un angle d'attaque local diff√©rent
   * - Permet de capturer les variations spatiales du vent et de la courbure virtuelle
   * - Am√©liore le r√©alisme des couples a√©rodynamiques distribu√©s
   *
   * CO√õT PERFORMANCE :
   * - Niveau 0 : 4 triangles (rapide, peu pr√©cis)
   * - Niveau 1 : 16 triangles (bon compromis)
   * - Niveau 2 : 64 triangles (pr√©cis, co√ªt mod√©r√©) ‚Üê recommand√©
   * - Niveau 3 : 256 triangles (tr√®s pr√©cis, co√ªteux)
   * - Niveau 4+ : 1024+ triangles (impact performance significatif)
   */

  /**
   * Niveau de subdivision actuel du maillage
   * Par d√©faut niveau 1 (16 triangles), peut √™tre chang√© via setMeshSubdivisionLevel()
   */
  private static meshSubdivisionLevel: number = 1; // Niveau par d√©faut, sera initialis√© depuis CONFIG dans SimulationApp

  /**
   * Cache typ√© des surfaces subdivis√©es
   */
  private static _subdividedSurfaces: { vertices: THREE.Vector3[]; area: number }[] | null = null;

  /**
   * Constantes pour la subdivision
   */
  private static readonly MAX_SUBDIVISION_LEVEL = 3; // Limite raisonnable pour √©viter surcharge

  /**
   * Calcule le nombre de triangles par surface originale pour un niveau donn√©
   * Formule : 4^niveau (car chaque subdivision d√©coupe en 4)
   *
   * @param level - Niveau de subdivision (0, 1, 2, 3...)
   * @returns Nombre de sous-triangles par surface originale
   *
   * @example
   * TRIANGLES_PER_SURFACE_AT_LEVEL(0) ‚Üí 1 triangle
   * TRIANGLES_PER_SURFACE_AT_LEVEL(1) ‚Üí 4 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(2) ‚Üí 16 triangles
   * TRIANGLES_PER_SURFACE_AT_LEVEL(3) ‚Üí 64 triangles
   */
  static TRIANGLES_PER_SURFACE_AT_LEVEL(level: number): number {
    return Math.pow(4, level);
  }

  /**
   * Modifie le niveau de subdivision du maillage
   *
   * @param level - Niveau de subdivision (0=4 triangles, 1=16, 2=64, 3=256)
   *
   * IMPORTANT : Des niveaux √©lev√©s (>3) peuvent causer des probl√®mes de performance.
   * Le niveau est automatiquement limit√© √† MAX_SUBDIVISION_LEVEL (3).
   */
  static setMeshSubdivisionLevel(level: number): void {
    // Clamper entre 0 et MAX
    const clampedLevel = Math.max(0, Math.min(level, KiteGeometry.MAX_SUBDIVISION_LEVEL));

    // Warning si niveau trop √©lev√©
    if (level > KiteGeometry.MAX_SUBDIVISION_LEVEL) {
      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(level);
      console.warn(
        `‚ö†Ô∏è Niveau de subdivision ${level} trop √©lev√© (${totalTriangles} triangles).\n` +
        `Limit√© √† ${KiteGeometry.MAX_SUBDIVISION_LEVEL} pour √©viter surcharge performance.\n` +
        `Si vous avez vraiment besoin de plus, augmentez MAX_SUBDIVISION_LEVEL.`
      );
    }

    if (clampedLevel !== KiteGeometry.meshSubdivisionLevel) {
      KiteGeometry.meshSubdivisionLevel = clampedLevel;
      // Invalider le cache des surfaces subdivis√©es
      KiteGeometry._subdividedSurfaces = null;

      const totalTriangles = KiteGeometry.SURFACES.length * KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(clampedLevel);
      console.log(`üîß Maillage subdivis√© : niveau ${clampedLevel} ‚Üí ${totalTriangles} triangles au total`);
    }
  }

  /**
   * Retourne le niveau de subdivision actuel du maillage
   */
  static getMeshSubdivisionLevel(): number {
    return KiteGeometry.meshSubdivisionLevel;
  }

  /**
   * Maillage fin : tous les sous-triangles du kite selon le niveau de subdivision configur√©
   *
   * CACHE : Les surfaces sont calcul√©es une seule fois puis mises en cache.
   * Le cache est invalid√© automatiquement quand le niveau change.
   *
   * @returns Tableau de tous les sous-triangles avec leurs vertices et aires
   */
  static get SUBDIVIDED_SURFACES(): { vertices: THREE.Vector3[]; area: number }[] {
    if (!KiteGeometry._subdividedSurfaces) {
      KiteGeometry._subdividedSurfaces = KiteGeometry.SURFACES.flatMap(surface =>
        KiteGeometry.subdivideTriangleRecursive(
          surface.vertices[0],
          surface.vertices[1],
          surface.vertices[2],
          KiteGeometry.meshSubdivisionLevel
        )
      );
    }
    return KiteGeometry._subdividedSurfaces;
  }

  // Calcul automatique de la surface totale
  static readonly TOTAL_AREA = KiteGeometry.SURFACES.reduce(
    (sum, surface) => sum + surface.area,
    0
  );  // ============================================================================
  // CALCUL AUTOMATIQUE DE LA MASSE DU CERF-VOLANT
  // ============================================================================

  /**
   * Sp√©cifications des mat√©riaux utilis√©s pour calculer la masse
   * Bas√© sur des composants r√©els de kites sport/stunt
   *
   * CORRECTION: Grammages augment√©s pour atteindre masse r√©aliste de 0.3-0.4 kg
   * (Pr√©c√©dente masse calcul√©e de ~0.153 kg √©tait √ó2.5 trop l√©g√®re)
   */
  private static readonly MATERIAL_SPECS = {
    // Tubes de carbone (masse lin√©ique en g/m)
    carbon: {
      spine: 10,        // 5mm diam√®tre renforc√© (corrig√© de 10)
      leadingEdge: 10,  // 5mm diam√®tre standard (corrig√© de 10)
      strut: 4,         // 4mm diam√®tre l√©ger (corrig√© de 2)
    },
    // Tissu (grammage en g/m¬≤)
    fabric: {
      ripstop: 40,     // Ripstop nylon standard (corrig√© de 40)
    },
    // Accessoires (masse en grammes)
    accessories: {
      connectorsLeadingEdge: 1,  // Connecteurs pour les bords d'attaque
      connectorCenterT: 1,       // Connecteur central en T
      connectorsStruts: 1,       // Connecteurs pour les struts
      bridleSystem: 1,          // Syst√®me de brides complet
      reinforcements: 1,        // Renforts et coutures
    },
  };

  /**
   * Calcule la longueur totale de tous les tubes de la frame
   * @returns Objet contenant les longueurs par type de tube et le total
   */
  private static calculateFrameLengths(): {
    spine: number;
    leadingEdges: number;
    struts: number;
    total: number;
  } {
    const spine = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.SPINE_BAS
    );

    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_GAUCHE
    );
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(
      KiteGeometry.POINTS.BORD_DROIT
    );
    const leadingEdges = leadingEdgeLeft + leadingEdgeRight;

    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_GAUCHE
    );
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(
      KiteGeometry.POINTS.WHISKER_DROIT
    );
    const struts = strutLeft + strutRight + spreader;

    return {
      spine,
      leadingEdges,
      struts,
      total: spine + leadingEdges + struts,
    };
  }

  /**
   * Calcule la masse de la structure (frame) en carbone
   * @returns Masse en kilogrammes
   */
  private static calculateFrameMass(): number {
    const lengths = KiteGeometry.calculateFrameLengths();
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;

    const spineMass = lengths.spine * specs.spine;
    const leadingEdgesMass = lengths.leadingEdges * specs.leadingEdge;
    const strutsMass = lengths.struts * specs.strut;

    // Somme en grammes, conversion en kg
    return (spineMass + leadingEdgesMass + strutsMass) / 1000;
  }

  /**
   * Calcule la masse du tissu (voile)
   * @returns Masse en kilogrammes
   */
  private static calculateFabricMass(): number {
    const grammage = KiteGeometry.MATERIAL_SPECS.fabric.ripstop;
    // Surface en m¬≤ √ó grammage en g/m¬≤ ‚Üí conversion en kg
    return (KiteGeometry.TOTAL_AREA * grammage) / 1000;
  }

  /**
   * Calcule la masse totale des accessoires
   * @returns Masse en kilogrammes
   */
  private static calculateAccessoriesMass(): number {
    const acc = KiteGeometry.MATERIAL_SPECS.accessories;
    const total =
      acc.connectorsLeadingEdge +
      acc.connectorCenterT +
      acc.connectorsStruts +
      acc.bridleSystem +
      acc.reinforcements;

    // Conversion g ‚Üí kg
    return total / 1000;
  }

  /**
   * Calcule la masse totale du cerf-volant (frame + tissu + accessoires)
   * Calcul√©e automatiquement depuis la g√©om√©trie et les sp√©cifications mat√©riaux
   * @returns Masse en kilogrammes
   */
  static calculateTotalMass(): number {
    return (
      KiteGeometry.calculateFrameMass() +
      KiteGeometry.calculateFabricMass() +
      KiteGeometry.calculateAccessoriesMass()
    );
  }

  /**
   * Masse totale du cerf-volant calcul√©e automatiquement
   * Bas√©e sur la g√©om√©trie r√©elle et les mat√©riaux standards
   */
  static readonly TOTAL_MASS = KiteGeometry.calculateTotalMass();

  /**
   * üî¥ BUG FIX #2 : Distribution masse frame selon g√©om√©trie R√âELLE
   * 
   * Topologie du kite (4 surfaces triangulaires) :
   *   Surface 0 (haute gauche)  : NEZ ‚Üí BORD_GAUCHE ‚Üí WHISKER_GAUCHE
   *   Surface 1 (basse gauche)  : NEZ ‚Üí WHISKER_GAUCHE ‚Üí SPINE_BAS
   *   Surface 2 (haute droite)  : NEZ ‚Üí BORD_DROIT ‚Üí WHISKER_DROIT
   *   Surface 3 (basse droite)  : NEZ ‚Üí WHISKER_DROIT ‚Üí SPINE_BAS
   * 
   * Attribution des segments de frame aux surfaces :
   *   - Spine (NEZ ‚Üí SPINE_BAS) : partag√©e 50/50 entre hautes et basses
   *   - Leading edge gauche (NEZ ‚Üí BORD_GAUCHE) : 100% surface 0
   *   - Leading edge droit (NEZ ‚Üí BORD_DROIT) : 100% surface 2
   *   - Strut gauche (BORD_GAUCHE ‚Üí WHISKER_GAUCHE) : partag√© surface 0/1
   *   - Strut droit (BORD_DROIT ‚Üí WHISKER_DROIT) : partag√© surface 2/3
   *   - Spreader (WHISKER_GAUCHE ‚Üí WHISKER_DROIT) : partag√© entre toutes
   * 
   * @returns Tableau de 4 masses (kg) pour chaque surface
   */
  private static calculateFrameMassDistribution(): number[] {
    const specs = KiteGeometry.MATERIAL_SPECS.carbon;
    
    // Masses lin√©iques (kg/m)
    const spineUnitMass = specs.spine / 1000;        // g/m ‚Üí kg/m
    const leadingEdgeUnitMass = specs.leadingEdge / 1000;
    const strutUnitMass = specs.strut / 1000;
    
    // Longueurs individuelles des segments
    const spineLength = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.SPINE_BAS);
    const leadingEdgeLeft = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_GAUCHE);
    const leadingEdgeRight = KiteGeometry.POINTS.NEZ.distanceTo(KiteGeometry.POINTS.BORD_DROIT);
    const strutLeft = KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_GAUCHE);
    const strutRight = KiteGeometry.POINTS.BORD_DROIT.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    const spreader = KiteGeometry.POINTS.WHISKER_GAUCHE.distanceTo(KiteGeometry.POINTS.WHISKER_DROIT);
    /**
     * Subdivise un triangle en 4 sous-triangles (subdivision barycentrique simple)
     * @param v1, v2, v3 : sommets du triangle
     * @returns Tableau de 4 sous-triangles {vertices, area}
     */

    // Masses individuelles des segments
    const spineMass = spineLength * spineUnitMass;
    const leadingEdgeLeftMass = leadingEdgeLeft * leadingEdgeUnitMass;
    const leadingEdgeRightMass = leadingEdgeRight * leadingEdgeUnitMass;
    const strutLeftMass = strutLeft * strutUnitMass;
    const strutRightMass = strutRight * strutUnitMass;
    const spreaderMass = spreader * strutUnitMass;
    
    // Attribution g√©om√©trique r√©aliste aux surfaces
    const frameMasses = [
      // Surface 0 (haute gauche) : spine + leading edge gauche + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeLeftMass +         // 100% leading edge gauche
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 1 (basse gauche) : spine + strut gauche + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutLeftMass * 0.5) +       // 50% strut gauche (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin gauche)

      // Surface 2 (haute droite) : spine + leading edge droit + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      leadingEdgeRightMass +        // 100% leading edge droit
      (strutRightMass * 0.5) +      // 50% strut droit (partie haute)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)

      // Surface 3 (basse droite) : spine + strut droit + spreader
      (spineMass * 0.25) +          // 25% spine (partag√©e entre 4 surfaces)
      (strutRightMass * 0.5) +      // 50% strut droit (partie basse)
      (spreaderMass * 0.25),        // 25% spreader (coin droit)
    ];
    
    return frameMasses;
  }

  /**
   * Distribution de la masse sur les surfaces
   * Chaque surface porte une fraction de la masse totale
   * 
   * Mod√®le physique CORRIG√â :
   * - Masse de tissu (fabric) : Distribu√©e proportionnellement √† l'aire
   * - Masse de frame : Distribu√©e selon g√©om√©trie r√©elle (üî¥ BUG FIX #2)
   * - Masse d'accessoires : Distribu√©e uniform√©ment sur les 4 surfaces
   * 
   * @returns Masse de chaque surface en kg
   */
  static calculateSurfaceMasses(): number[] {
    const fabricMass = KiteGeometry.calculateFabricMass();
    const frameMasses = KiteGeometry.calculateFrameMassDistribution();  // üî¥ BUG FIX #2
    const accessoriesMass = KiteGeometry.calculateAccessoriesMass();
    
    // Accessoires r√©partis uniform√©ment (connecteurs dispers√©s sur tout le kite)
    const uniformAccessories = accessoriesMass / KiteGeometry.SURFACES.length;
    
    // La masse de tissu est r√©partie proportionnellement √† l'aire
    return KiteGeometry.SURFACES.map((surface, index) => {
      const fabricMassRatio = surface.area / KiteGeometry.TOTAL_AREA;
      const surfaceFabricMass = fabricMass * fabricMassRatio;
      
      return surfaceFabricMass + frameMasses[index] + uniformAccessories;
    });
  }

  /**
   * Masses pr√©calcul√©es pour chaque surface (en kg)
   * Index correspond √† l'index dans SURFACES
   */
  static readonly SURFACE_MASSES = KiteGeometry.calculateSurfaceMasses();

  /**
   * Surfaces enrichies avec leur masse individuelle
   * Utilis√©es par AerodynamicsCalculator pour appliquer la gravit√© distribu√©e
   */
  static readonly SURFACES_WITH_MASS = KiteGeometry.SURFACES.map((surface, index) => ({
    ...surface,
    mass: KiteGeometry.SURFACE_MASSES[index],
  }));

  /**
   * Calcule le moment d'inertie approximatif du cerf-volant
   * Utilise la formule simplifi√©e : I ‚âà m √ó r¬≤
   * o√π r est le rayon de giration moyen
   * @returns Moment d'inertie en kg¬∑m¬≤
   */
  static calculateInertia(): number {
    // Constantes pour calcul d'inertie (√©viter d√©pendance circulaire avec CONFIG)
    const GYRATION_DIVISOR = Math.sqrt(2); // wingspan / ‚àö2 pour forme delta (triangle isoc√®le)

    // Rayon de giration correct pour forme delta wing
    // Formule r√©aliste : r = wingspan / ‚àö2 (au lieu de /4)
    // R√©f√©rence : g√©om√©trie d'un triangle isoc√®le
    const wingspan =
      KiteGeometry.POINTS.BORD_GAUCHE.distanceTo(
        KiteGeometry.POINTS.BORD_DROIT
      );
    const radiusOfGyration = wingspan / GYRATION_DIVISOR;  // ‚âà 1.167 m au lieu de 0.4125 m

    const physicalInertia = KiteGeometry.TOTAL_MASS * radiusOfGyration * radiusOfGyration;

    // üîß FIX INERTIE: Factor 0.1 pour r√©activit√© imm√©diate au vent
    // Le kite doit √™tre "emport√©" par le vent, pas r√©sister par inertie
    // Factor 0.1 ram√®ne √† ~0.042 kg¬∑m¬≤ (tr√®s r√©actif, comme un tissu l√©ger)
    const REACTIVE_INERTIA_FACTOR = 0.1;
    return physicalInertia * REACTIVE_INERTIA_FACTOR;
  }

  /**
   * Moment d'inertie calcul√© automatiquement
   */
  static readonly INERTIA = KiteGeometry.calculateInertia();
}


=== simulation/config/PhysicsConstants.ts ===

/**
 * PhysicsConstants.ts - Constantes physiques globales pour la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les limites physiques, tol√©rances et facteurs de s√©curit√© du monde virtuel
 *   - Sert √† garantir la stabilit√© et la coh√©rence de la simulation
 *   - Utilis√© pour √©viter les comportements irr√©alistes ou dangereux
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par tous les modules physiques et de configuration
 *
 * Relation avec les fichiers adjacents :
 *   - SimulationConfig.ts : Utilise PhysicsConstants pour fixer les limites
 *   - Tous les modules du projet importent PhysicsConstants pour les v√©rifications
 *
 * Utilisation typique :
 *   - Import√© dans les modules de physique, de contr√¥le et de rendu
 *   - Sert √† valider les valeurs et √† limiter les extr√™mes
 *
 * Voir aussi :
 *   - src/simulation/config/SimulationConfig.ts
 */
export class PhysicsConstants {
  // Tol√©rances num√©riques
  static readonly EPSILON = 1e-4; // Sans unit√© - Seuil pour "presque z√©ro" (comparaisons flottants)
  static readonly EPSILON_FINE = 1e-6; // Sans unit√© - Seuil fin pour calculs pr√©cis (LinePhysics)

  // Contr√¥les et contraintes
  static readonly CONTROL_DEADZONE = 0.01; // rad - Zone morte pour input barre de contr√¥le
  static readonly LINE_CONSTRAINT_TOLERANCE = 0.0005; // m - Tol√©rance contraintes lignes (0.5mm)
  static readonly LINE_TENSION_FACTOR = 0.99; // Sans unit√© - Facteur tension lignes (99% = l√©g√®rement tendues)

  // Sol et friction
  static readonly GROUND_FRICTION = 0.95; // Sans unit√© - Facteur friction sol (5% perte vitesse)

  // Rendu cat√©naire
  static readonly CATENARY_SEGMENTS = 10; // Sans unit√© - Nombre segments pour courbe cat√©naire

  // Limites de s√©curit√© physique (√©viter explosions num√©riques)
  static readonly MAX_FORCE = 1000; // N - Force maximale (√©quivalent ~100kg)
  static readonly MAX_VELOCITY = 30; // m/s - Vitesse maximale kite (108 km/h)
  static readonly MAX_ANGULAR_VELOCITY = 15; // rad/s - Limite √©lev√©e pour permettre convergence naturelle
  static readonly MAX_ACCELERATION = 100; // m/s¬≤ - Acc√©l√©ration maximale (~10G)
  static readonly MAX_ANGULAR_ACCELERATION = 5; // rad/s¬≤ - Acc√©l√©ration angulaire r√©aliste
}

=== simulation/config/SimulationConfig.ts ===

/**
 * SimulationConfig.ts - Configuration         // C  // Facteurs d'√©chelle a√©rodynamiques √©quilibr√©s
  liftScale: 1.2, // Facteur de portance
  dragScale: 1.2, // Facteur de tra√Æn√©e (√©quilibr√© avec portance)ficients d'amortissement (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 0.2, // Amortissement lin√©aire mod√©r√©
  angularDragFactor: 1.0, // Amortissement angulaire √©quilibr√© pour stabilisation naturelleamping coefficients (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 1.5, // üîß R√âALISTE: Friction a√©rodynamique mod√©r√©e pour stabilisation naturelle
    // Angular damping : UN SEUL m√©canisme (angular drag proportionnel √† œâ)
  angularDragFactor: 5.0, // üîß STABILIT√â CRITIQUE: Tr√®s fort amortissement pour √©viter rotation excessive
  },le de la simulation K  wind: {
    defaultSpeed: 25, // km/h - Vitesse r√©aliste pour cerf-volant sport (15-30 km/h typique)
    defaultDirection: 0, // degr√©s
    defaultTurbulence: 5, // % - Turbulence r√©aliste pour conditions normales
    turbulenceScale: 0.05,*
 * R√¥le :
 *   - D√©finit tous les param√®tres physiques, a√©rodynamiques, g√©om√©triques et environnementaux
 *   - Sert de source unique de v√©rit√© pour les r√©glages du monde virtuel
 *   - Permet d'ajuster le comportement du kite, du vent, des lignes, etc.
 *
 * D√©pendances principales :
 *   - KiteGeometry.ts : Utilis√© pour la surface et les points du kite
 *   - Utilis√© par tous les modules physiques et de rendu
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsConstants.ts : D√©finit les limites et tol√©rances physiques
 *   - KiteGeometry.ts : D√©finit la g√©om√©trie du kite
 *   - Tous les modules du projet importent SimulationConfig pour acc√©der aux param√®tres
 *
 * Utilisation typique :
 *   - Import√© dans tous les modules pour acc√©der aux r√©glages
 *   - Sert √† personnaliser la simulation (test, debug, tuning)
 *
 * Voir aussi :
 *   - src/simulation/config/PhysicsConstants.ts
 *   - src/simulation/config/KiteGeometry.ts
 */
import * as THREE from "three";

import { KiteGeometry } from "./KiteGeometry";

/**
 * Configuration √©pur√©e de la simulation
 *
 * Les r√©glages de notre monde virtuel - comme les r√®gles d'un jeu
 * Vous pouvez changer ces valeurs pour voir comment le cerf-volant r√©agit
 */
export const CONFIG = {
  physics: {
    gravity: 9.81, // La gravit√© terrestre (fait tomber les objets)
    airDensity: 1.225, // Densit√© de l'air (l'air √©pais pousse plus fort)
    deltaTimeMax: 0.016, // Mise √† jour max 60 fois par seconde (pour rester fluide)
    // Damping coefficients (en 1/s) - appliqu√©s avec formule exponentielle
  linearDampingCoeff: 1, // üîß FIX INERTIE: Drastiquement r√©duit pour r√©activit√© imm√©diate
    // üî¥ SOLUTION #2 : Amortissement angulaire r√©duit pour √©quilibre naturel
  angularDragFactor: 1.5, // ÔøΩ √âQUILIBRE: R√©duit de 5.0 ‚Üí 1.0 pour permettre stabilisation naturelle
  },
  aero: {
  // üî¥ SOLUTION #2 : Forces a√©rodynamiques √©quilibr√©es
  liftScale: 1.2, // ÔøΩ √âQUILIBR√â: R√©duit de 1.5 ‚Üí 1.2 
  dragScale: 1.2, // ÔøΩ √âQUILIBR√â: Maintenu √† 1.2 (coh√©rent avec lift)
  },
  kite: {
    // Masse et inertie calcul√©es AUTOMATIQUEMENT depuis la g√©om√©trie
    // Bas√©es sur:
    // - Frame carbone (spine 5mm, leading edges 5mm, struts 4mm)
    // - Tissu ripstop nylon 120 g/m¬≤ (corrig√© pour atteindre masse r√©aliste)
    // - Accessoires (connecteurs, bridage, renforts)
    // Voir KiteGeometry.calculateTotalMass() pour les d√©tails
    mass: KiteGeometry.TOTAL_MASS, // kg - Calcul√©e automatiquement (~0.31 kg apr√®s correction)
    area: KiteGeometry.TOTAL_AREA, // m¬≤ - Surface totale (calcul√©e automatiquement)
    inertia: KiteGeometry.INERTIA, // kg¬∑m¬≤ - Moment d'inertie (I ‚âà m¬∑r¬≤, calcul√© automatiquement)
    minHeight: 0, // m - Altitude minimale (plus haut pour √©viter le sol)
    // üîß MAILLAGE FIN PARAM√âTRABLE (d√©faut = niveau 1 = 16 triangles)
    defaultMeshSubdivisionLevel: 1, // Niveau par d√©faut (0=4, 1=16, 2=64, 3=256 triangles)
  },
  lines: {
    defaultLength: 15, // m - Longueur par d√©faut
    stiffness: 1200, // N/m - Rigidit√© r√©duite pour plus de souplesse (2200 √©tait trop rigide)
    preTension: 75, // N - Tension minimale toujours pr√©sente
    maxTension: 800, // N - Tension max avant rupture (~80% charge nominale)
    dampingCoeff: 0.05, // Coefficient d'amortissement interne (0-1)
    linearMassDensity: 0.0005, // kg/m - Masse lin√©ique pour calcul cat√©naire
  },
  wind: {
    defaultSpeed: 20, // km/h - Vitesse id√©ale pour cerf-volant
    defaultDirection: 0, // degr√©s
    defaultTurbulence: 0.001, // % - Turbulence r√©aliste (0.001 ‚Üí 10)
    turbulenceScale: 0.05,
    turbulenceFreqBase: 0.05,
    turbulenceFreqY: 0.3,
    turbulenceFreqZ: 0.3,
    turbulenceIntensityXZ: 0.2,
    turbulenceIntensityY: 0.2,
  },
  rendering: {
    shadowMapSize: 2048,
    antialias: true,
    fogStart: 100,
    fogEnd: 1000,
  },
  debugVectors: true, // Active ou d√©sactive l'affichage des vecteurs de debug
  controlBar: {
    width: 0.6, // m - Largeur de la barre
    position: new THREE.Vector3(0, 1.2, 8), // Position initiale
    barRadius: 0.02, // m - Rayon du cylindre de la barre
    barRotation: Math.PI / 2, // rad - Rotation pour orientation horizontale
    handleRadius: 0.03, // m - Rayon des poign√©es
    handleLength: 0.15, // m - Longueur des poign√©es
  },
  pilot: {
    width: 0.4, // m - Largeur du corps du pilote
    height: 1.6, // m - Hauteur du corps du pilote
    depth: 0.3, // m - Profondeur du corps du pilote
    offsetY: 0.8, // m - D√©calage vertical par rapport √† la barre
    offsetZ: 8.5, // m - Distance derri√®re la barre
  },
  initialization: {
    initialKiteY: 7.0, // m - Altitude initiale du kite
    initialDistanceFactor: 0.98, // Sans unit√© - Facteur de distance initiale (98% de longueur ligne ‚Üí lignes l√©g√®rement tendues au d√©part)
  },
  visualization: {
    lineWidth: 2, // pixels - Largeur des lignes de contr√¥le
  },
  debug: {
    // Seuils de tension des brides pour couleurs visuelles
    bridleTensionLow: 1, // N - Seuil tension molle (vert)
    bridleTensionHigh: 100, // N - Seuil tension √©lev√©e (rouge)
    // Seuils pour vecteurs debug
    minVectorLength: 0.01, // m - Longueur minimale pour afficher un vecteur
    minVelocityDisplay: 0.1, // m/s - Vitesse minimale pour afficher vecteur vitesse
  },
  input: {
    rotationSpeed: 0.5, // rad/s - Vitesse de rotation de la barre (input utilisateur)
    returnSpeed: 3.0, // rad/s - Vitesse de retour au centre de la barre
    maxRotation: Math.PI / 3, // rad - Rotation maximale de la barre (¬∞)
  },
  kiteInertia: {
    gyrationDivisor: Math.sqrt(2), // Sans unit√© - Diviseur pour rayon de giration (wingspan / ‚àö2)
    inertiaFactor: 1, // Sans unit√© - Facteur ajustement inertie (compromis stabilit√©/r√©activit√©)
  },
};

=== simulation/controllers/ControlBarManager.ts ===

/**
 * ControlBarManager.ts - Gestionnaire de la barre de contr√¥le pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re la position et l'orientation de la barre de contr√¥le du cerf-volant
 *   - Calcule les positions des poign√©es et la rotation de la barre
 *   - Sert d'interface entre le pilote et le syst√®me de lignes
 *
 * D√©pendances principales :
 *   - Kite.ts : Mod√®le 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres et limites physiques
 *   - Types : HandlePositions pour typer les poign√©es
 *   - Three.js : Pour la g√©om√©trie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par KiteController et PhysicsEngine pour manipuler la barre et les lignes
 *   - Interagit avec LineSystem pour la gestion des tensions
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, appel√© √† chaque frame pour mettre √† jour la position des poign√©es
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/simulation/physics/LineSystem.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { HandlePositions } from "../types";

/**
 * Gestionnaire de la barre de contr√¥le
 *
 * G√®re la position et l'orientation de la barre de contr√¥le du cerf-volant
 */
export class ControlBarManager {
  private position: THREE.Vector3;
  private rotation: number = 0;

  constructor(position: THREE.Vector3 = CONFIG.controlBar.position) {
    this.position = position.clone();
  }

  /**
   * Calcule le quaternion de rotation de la barre
   */
  private computeRotationQuaternion(
    toKiteVector: THREE.Vector3
  ): THREE.Quaternion {
    const barDirection = new THREE.Vector3(1, 0, 0);
    const rotationAxis = new THREE.Vector3()
      .crossVectors(barDirection, toKiteVector)
      .normalize();

    if (rotationAxis.length() < PhysicsConstants.CONTROL_DEADZONE) {
      rotationAxis.set(0, 1, 0);
    }

    return new THREE.Quaternion().setFromAxisAngle(rotationAxis, this.rotation);
  }

  /**
   * Obtient les positions des poign√©es (m√©thode unique centralis√©e)
   */
  getHandlePositions(kitePosition: THREE.Vector3): HandlePositions {
    const toKiteVector = kitePosition.clone().sub(this.position).normalize();
    const rotationQuaternion = this.computeRotationQuaternion(toKiteVector);

    const halfWidth = CONFIG.controlBar.width / 2;
    const handleLeftLocal = new THREE.Vector3(-halfWidth, 0, 0);
    const handleRightLocal = new THREE.Vector3(halfWidth, 0, 0);

    handleLeftLocal.applyQuaternion(rotationQuaternion);
    handleRightLocal.applyQuaternion(rotationQuaternion);

    return {
      left: handleLeftLocal.clone().add(this.position),
      right: handleRightLocal.clone().add(this.position),
    };
  }

  /**
   * Met √† jour la rotation de la barre
   */
  setRotation(rotation: number): void {
    this.rotation = rotation;
  }

  getRotation(): number {
    return this.rotation;
  }

  getPosition(): THREE.Vector3 {
    return this.position.clone();
  }

  /**
   * Met √† jour l'objet 3D visuel de la barre
   */
  updateVisual(bar: THREE.Group, kite: Kite): void {
    if (!bar) return;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const centerKite = kiteLeftWorld
        .clone()
        .add(kiteRightWorld)
        .multiplyScalar(0.5);
      const toKiteVector = centerKite.clone().sub(this.position).normalize();

      bar.quaternion.copy(this.computeRotationQuaternion(toKiteVector));
    }
  }
}

=== simulation/controllers/InputHandler.ts ===

/**
 * InputHandler.ts - Gestionnaire des entr√©es utilisateur pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re les contr√¥les clavier pour piloter le cerf-volant
 *   - Traduit les actions utilisateur en rotation de la barre de contr√¥le
 *   - Sert d'interface entre l'utilisateur et le syst√®me de contr√¥le
 *
 * D√©pendances principales :
 *   - PhysicsConstants.ts : Param√®tres et limites pour la gestion des entr√©es
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par ControlBarManager et PhysicsEngine pour appliquer les commandes utilisateur
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, √©coute les √©v√©nements clavier pour piloter le kite
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/simulation/controllers/ControlBarManager.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 */
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire des entr√©es utilisateur
 *
 * G√®re les contr√¥les clavier pour piloter le cerf-volant
 */
export class InputHandler {
  private currentRotation: number = 0;
  private keysPressed = new Set<string>();
  private rotationSpeed: number = CONFIG.input.rotationSpeed;
  private returnSpeed: number = CONFIG.input.returnSpeed;
  private maxRotation: number = CONFIG.input.maxRotation;

  constructor() {
    this.setupKeyboardControls();
  }

  private setupKeyboardControls(): void {
    window.addEventListener("keydown", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.add(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });

    window.addEventListener("keyup", (event) => {
      const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
      this.keysPressed.delete(key);

      if (
        key === "ArrowLeft" ||
        key === "ArrowRight" ||
        key === "q" ||
        key === "a" ||
        key === "d"
      ) {
        event.preventDefault();
      }
    });
  }

  update(deltaTime: number): void {
    const left =
      this.keysPressed.has("ArrowLeft") ||
      this.keysPressed.has("q") ||
      this.keysPressed.has("a");
    const right =
      this.keysPressed.has("ArrowRight") || this.keysPressed.has("d");
    const dir = (left ? 1 : 0) + (right ? -1 : 0);

    if (dir !== 0) {
      this.currentRotation += dir * this.rotationSpeed * deltaTime;
    } else {
      if (Math.abs(this.currentRotation) > PhysicsConstants.EPSILON) {
        const sign = Math.sign(this.currentRotation);
        this.currentRotation -= sign * this.returnSpeed * deltaTime;
        if (Math.sign(this.currentRotation) !== sign) {
          this.currentRotation = 0;
        }
      } else {
        this.currentRotation = 0;
      }
    }

    this.currentRotation = Math.max(
      -this.maxRotation,
      Math.min(this.maxRotation, this.currentRotation)
    );
  }

  getTargetBarRotation(): number {
    return this.currentRotation;
  }
}

=== simulation/controllers/KiteController.ts ===

/**
 * KiteController.ts - Contr√¥leur du cerf-volant pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re l'√©tat physique et le mouvement du cerf-volant
 *   - Applique les forces, met √† jour la position, la vitesse et l'orientation
 *   - D√©tecte les situations extr√™mes (acc√©l√©ration, vitesse, rotation)
 *
 * D√©pendances principales :
 *   - Kite.ts : Mod√®le 3D du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres et limites physiques
 *   - ConstraintSolver.ts : Applique les contraintes de ligne
 *   - Types : KiteState, HandlePositions pour typer l'√©tat
 *   - Three.js : Pour la g√©om√©trie et le calcul
 *
 * Relation avec les fichiers adjacents :
 *   - Utilis√© par PhysicsEngine pour manipuler le kite
 *   - Interagit avec ControlBarManager pour la gestion des lignes
 *
 * Utilisation typique :
 *   - Instanci√© par PhysicsEngine, appel√© √† chaque frame pour mettre √† jour l'√©tat du kite
 *   - Sert √† la visualisation et au contr√¥le du kite
 *
 * Voir aussi :
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/controllers/ControlBarManager.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, HandlePositions } from "../types";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { ConstraintSolver } from "../physics/ConstraintSolver";

/**
 * Contr√¥leur du cerf-volant
 *
 * G√®re l'√©tat physique et le mouvement du cerf-volant
 */
export class KiteController {
  private kite: Kite;
  private state: KiteState;
  private previousPosition: THREE.Vector3;
  // √âtats pour les warnings
  private hasExcessiveAccel: boolean = false;
  private hasExcessiveVelocity: boolean = false;
  private hasExcessiveAngular: boolean = false;
  private lastAccelMagnitude: number = 0;
  private lastVelocityMagnitude: number = 0;

  // Lissage temporel des forces
  private smoothedForce: THREE.Vector3;
  private smoothedTorque: THREE.Vector3;
  private forceSmoothingRate: number = KiteController.DEFAULT_FORCE_SMOOTHING_RATE; // üîß PHASE 1: Quasi-d√©sactiv√© pour restaurer r√©activit√©

  // Constantes pour √©viter les facteurs magiques
  private static readonly DEFAULT_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MIN_FORCE_SMOOTHING_RATE = 0.1;
  private static readonly MAX_FORCE_SMOOTHING_RATE = 20.0;

  constructor(kite: Kite) {
    this.kite = kite;
    this.state = {
      position: kite.position.clone(),
      velocity: new THREE.Vector3(),
      angularVelocity: new THREE.Vector3(),
      orientation: kite.quaternion.clone(),
    };
    this.previousPosition = kite.position.clone();
    this.kite.userData.lineLength = CONFIG.lines.defaultLength;

    // Initialiser les forces liss√©es avec gravit√© initiale (√©vite chute au d√©marrage)
    const initialGravity = new THREE.Vector3(0, -CONFIG.kite.mass * CONFIG.physics.gravity, 0);
    this.smoothedForce = initialGravity.clone();
    this.smoothedTorque = new THREE.Vector3();
  }

  /**
   * Met √† jour la position et l'orientation du cerf-volant
   */
  update(
    forces: THREE.Vector3,
    torque: THREE.Vector3,
    handles: HandlePositions,
    deltaTime: number
  ): void {
    // Valider les forces brutes
    const validForces = this.validateForces(forces);
    const validTorque = this.validateTorque(torque);

    // Lissage exponentiel des forces (ind√©pendant du framerate)
    // smoothingFactor = 1 - e^(-rate √ó dt)
    const smoothingFactor = 1 - Math.exp(-this.forceSmoothingRate * deltaTime);
    this.smoothedForce.lerp(validForces, smoothingFactor);
    this.smoothedTorque.lerp(validTorque, smoothingFactor);

    // Utiliser les forces liss√©es pour la physique
    const newPosition = this.integratePhysics(this.smoothedForce, deltaTime);

    // R√©solution it√©rative des contraintes PBD pour convergence stable
    // Les contraintes lignes ‚Üî brides s'influencent mutuellement
    // Une seule passe n'est pas suffisante - il faut it√©rer jusqu'√† convergence
    const MAX_CONSTRAINT_ITERATIONS = 2;  // üîß PHASE 3: R√©duit (3 ‚Üí 2) pour moins de sur-contrainte
    
    for (let iter = 0; iter < MAX_CONSTRAINT_ITERATIONS; iter++) {
      // Appliquer les contraintes de lignes (Position-Based Dynamics)
      // Le solveur peut modifier newPosition ainsi que state.velocity / state.angularVelocity
      try {
        ConstraintSolver.enforceLineConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          handles
        );
      } catch (err) {
        // Ne pas laisser une exception du solveur casser la boucle principale
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceLineConstraints (iter ${iter}):`, err);
      }

      // Appliquer les contraintes des brides (Position-Based Dynamics)
      // Les brides sont des contraintes INTERNES qui lient les points du kite entre eux
      try {
        ConstraintSolver.enforceBridleConstraints(
          this.kite,
          newPosition,
          { velocity: this.state.velocity, angularVelocity: this.state.angularVelocity },
          this.kite.getBridleLengths()
        );
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur dans ConstraintSolver.enforceBridleConstraints (iter ${iter}):`, err);
      }
    }

    // G√©rer la collision avec le sol - corrige newPosition et vitesse si n√©cessaire
    try {
      ConstraintSolver.handleGroundCollision(this.kite, newPosition, this.state.velocity);
    } catch (err) {
      console.error("‚ö†Ô∏è Erreur dans ConstraintSolver.handleGroundCollision:", err);
    }

    // Valider la position finale
    this.validatePosition(newPosition);

    // Appliquer la position et l'orientation
    this.kite.position.copy(newPosition);
    this.updateOrientation(this.smoothedTorque, deltaTime); // Utiliser le torque liss√©
    this.previousPosition.copy(newPosition);
  }
  /**
   * Valide les forces appliqu√©es au cerf-volant
   */
  private validateForces(forces: THREE.Vector3): THREE.Vector3 {
    if (
      !forces ||
      forces.length() > PhysicsConstants.MAX_FORCE ||
      isNaN(forces.length())
    ) {
      console.error(
        `‚ö†Ô∏è Forces invalides: ${forces ? forces.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return forces;
  }

  /**
   * Valide le couple
   */
  private validateTorque(torque: THREE.Vector3): THREE.Vector3 {
    if (!torque || isNaN(torque.length())) {
      console.error(
        `‚ö†Ô∏è Couple invalide: ${torque ? torque.toArray() : "undefined"}`
      );
      return new THREE.Vector3();
    }
    return torque;
  }

  /**
   * Int√®gre les forces pour calculer la nouvelle position (m√©thode d'Euler)
   * Impl√©mente la 2√®me loi de Newton : F = ma ‚Üí a = F/m
   */
  private integratePhysics(
    forces: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    // Newton : acc√©l√©ration = Force / masse
    // IMPORTANT: clone() pour ne pas modifier le vecteur forces en place!
    const acceleration = forces.clone().divideScalar(CONFIG.kite.mass);
    this.lastAccelMagnitude = acceleration.length();

    // S√©curit√© : limiter pour √©viter l'explosion num√©rique
    this.hasExcessiveAccel = acceleration.length() > PhysicsConstants.MAX_ACCELERATION;
    if (this.hasExcessiveAccel) {
      acceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ACCELERATION);
    }

    // Int√©gration d'Euler : v(t+dt) = v(t) + a¬∑dt
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier acceleration!
    this.state.velocity.add(acceleration.clone().multiplyScalar(deltaTime));

    // Amortissement exponentiel : v(t) = v‚ÇÄ √ó e^(-c√ódt)
    // Formule physiquement correcte, ind√©pendante du framerate
    const linearDampingFactor = Math.exp(-CONFIG.physics.linearDampingCoeff * deltaTime);
    this.state.velocity.multiplyScalar(linearDampingFactor);
    this.lastVelocityMagnitude = this.state.velocity.length();

    // Garde-fou vitesse max (r√©alisme physique)
    this.hasExcessiveVelocity = this.state.velocity.length() > PhysicsConstants.MAX_VELOCITY;
    if (this.hasExcessiveVelocity) {
      this.state.velocity
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_VELOCITY);
    }

    // Position : x(t+dt) = x(t) + v¬∑dt
    return this.kite.position
      .clone()
      .add(this.state.velocity.clone().multiplyScalar(deltaTime));
  }

  /**
   * Valide la position finale
   */
  private validatePosition(newPosition: THREE.Vector3): void {
    if (isNaN(newPosition.x) || isNaN(newPosition.y) || isNaN(newPosition.z)) {
      console.error(`‚ö†Ô∏è Position NaN d√©tect√©e! Reset √† la position pr√©c√©dente`);
      newPosition.copy(this.previousPosition);
      this.state.velocity.set(0, 0, 0);
    }
  }

  /**
   * Met √† jour l'orientation du cerf-volant - Dynamique du corps rigide
   */
  private updateOrientation(torque: THREE.Vector3, deltaTime: number): void {
    // Couple d'amortissement (r√©sistance a√©rodynamique √† la rotation)
    // œÑ_drag = -I √ó k_drag √ó œâ  (unit√©s correctes: kg¬∑m¬≤ √ó 1/s √ó rad/s = N¬∑m)
    const dampTorque = this.state.angularVelocity
      .clone()
      .multiplyScalar(-CONFIG.kite.inertia * CONFIG.physics.angularDragFactor);
    const effectiveTorque = torque.clone().add(dampTorque);

    // Dynamique rotationnelle : Œ± = T / I
    // IMPORTANT: clone() pour ne pas modifier effectiveTorque en place!
    const angularAcceleration = effectiveTorque.clone().divideScalar(
      CONFIG.kite.inertia
    );

    // Limiter l'acc√©l√©ration angulaire
    if (
      angularAcceleration.length() > PhysicsConstants.MAX_ANGULAR_ACCELERATION
    ) {
      angularAcceleration
        .normalize()
        .multiplyScalar(PhysicsConstants.MAX_ANGULAR_ACCELERATION);
    }

    // Mise √† jour de la vitesse angulaire
    // IMPORTANT: clone() avant multiplyScalar pour ne pas modifier angularAcceleration!
    this.state.angularVelocity.add(
      angularAcceleration.clone().multiplyScalar(deltaTime)
    );

    // Note: Amortissement d√©j√† appliqu√© via dampTorque ci-dessus
    // Pas de damping exponentiel suppl√©mentaire pour √©viter sur-amortissement

    // üîß D√âSACTIVATION TEMPORAIRE : Limiter la vitesse angulaire
    // Cause des positions impossibles car emp√™che la convergence naturelle
    // this.hasExcessiveAngular = this.state.angularVelocity.length() > PhysicsConstants.MAX_ANGULAR_VELOCITY;
    // if (this.hasExcessiveAngular) {
    //   this.state.angularVelocity
    //     .normalize()
    //     .multiplyScalar(PhysicsConstants.MAX_ANGULAR_VELOCITY);
    // }
    this.hasExcessiveAngular = false; // Toujours faux pour l'instant

    // Appliquer la rotation
    if (this.state.angularVelocity.length() > PhysicsConstants.EPSILON) {
      const deltaRotation = new THREE.Quaternion();
      const axis = this.state.angularVelocity.clone().normalize();
      const angle = this.state.angularVelocity.length() * deltaTime;
      deltaRotation.setFromAxisAngle(axis, angle);

      this.kite.quaternion.multiply(deltaRotation);
      this.kite.quaternion.normalize();
    }
  }

  getState(): KiteState {
    return { ...this.state };
  }

  getKite(): Kite {
    return this.kite;
  }

  setLineLength(length: number): void {
    this.kite.userData.lineLength = length;
  }

  /**
   * Retourne les √©tats de warning pour l'affichage
   */
  getWarnings(): {
    accel: boolean;
    velocity: boolean;
    angular: boolean;
    accelValue: number;
    velocityValue: number;
  } {
    return {
      accel: this.hasExcessiveAccel,
      velocity: this.hasExcessiveVelocity,
      angular: this.hasExcessiveAngular,
      accelValue: this.lastAccelMagnitude,
      velocityValue: this.lastVelocityMagnitude,
    };
  }

  /**
   * D√©finit le taux de lissage des forces physiques
   * @param rate - Taux en 1/s (valeurs typiques: 1-10, plus √©lev√© = lissage plus rapide)
   */
  setForceSmoothing(rate: number): void {
    this.forceSmoothingRate = Math.max(
      KiteController.MIN_FORCE_SMOOTHING_RATE,
      Math.min(KiteController.MAX_FORCE_SMOOTHING_RATE, rate)
    );
  }

  /**
   * Retourne le taux de lissage actuel des forces (en 1/s)
   */
  getForceSmoothing(): number {
    return this.forceSmoothingRate;
  }
}

=== simulation/index.ts ===

/**
 * Point d'entr√©e principal de la simulation modulaire
 */

// Export de la classe principale
export { Simulation } from './SimulationApp';

// Re-export de tous les modules pour faciliter l'importation
export * from './config/PhysicsConstants';
export * from './config/KiteGeometry';
export * from './config/SimulationConfig';

export * from './types';

export * from './physics/WindSimulator';
export * from './physics/AerodynamicsCalculator';
export * from './physics/LineSystem';
export * from './physics/PhysicsEngine';

export * from './controllers/ControlBarManager';
export * from './controllers/KiteController';
export * from './controllers/InputHandler';

export * from './rendering/RenderManager';
export * from './rendering/DebugRenderer';

export * from './ui/UIManager';

export * from './physics/ConstraintSolver';

=== simulation/physics/AerodynamicsCalculator.ts ===

/**
 * AerodynamicsCalculator.ts - Calculateur de forces a√©rodynamiques distribu√©es
 *
 * Calcule les forces a√©rodynamiques (portance, tra√Æn√©e) et gravitationnelles 
 * distribu√©es sur chaque surface du kite selon les principes de la m√©canique des fluides.
 *
 * Mod√®le physique :
 *   - Portance : CL = sin(Œ±)√ócos(Œ±) (plaqu      gravity: gravityForce,  // Gravit√© distribu√©e par surface plane)
 *   - Tra√Æn√©e : CD = sin¬≤(Œ±) (plaque plane)
 *   - Gravit√© distribu√©e par masse surfacique
 *   - Couples √©mergents de la distribution spatiale des forces
 *
 * @see PhysicsEngine.ts - Utilise les forces calcul√©es
 * @see KiteGeometry.ts - D√©finit les surfaces et masses
 */
import * as THREE from "three";

import { KiteGeometry } from "../config/KiteGeometry";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { SurfaceForce } from "../types/PhysicsTypes";

/**
 * Calculateur de forces a√©rodynamiques
 *
 * Calcule comment le vent pousse sur le cerf-volant selon sa forme et orientation
 */
export class AerodynamicsCalculator {
  // Constantes de calculs a√©rodynamiques
  private static readonly HALF_AIR_DENSITY = 0.5 * CONFIG.physics.airDensity;
  private static readonly MIN_WIND_SPEED = 0.01; // m/s - seuil minimal pour calculs a√©ro

  /**
   * Calcule le couple (moment) d'une force appliqu√©e √† un point
   * M√©thode utilitaire pour √©viter la r√©p√©tition de new THREE.Vector3().crossVectors()
   */
  private static calculateTorque(lever: THREE.Vector3, force: THREE.Vector3): THREE.Vector3 {
    return new THREE.Vector3().crossVectors(lever, force);
  }

  /**
   * Calcule la normale d'un triangle dans l'espace monde
   * M√©thode utilitaire pour √©viter la duplication de code
   *
   * @param surface - Surface triangulaire avec vertices
   * @param kiteOrientation - Quaternion d'orientation du kite (optionnel)
   * @returns Vecteur normal unitaire dans l'espace monde
   */
  private static calculateSurfaceNormal(
    surface: { vertices: THREE.Vector3[] },
    kiteOrientation?: THREE.Quaternion
  ): THREE.Vector3 {
    // Calcul des ar√™tes du triangle
    const edge1 = surface.vertices[1].clone().sub(surface.vertices[0]);
    const edge2 = surface.vertices[2].clone().sub(surface.vertices[0]);
    
    // Normale locale (produit vectoriel normalis√©)
    const normal = new THREE.Vector3()
      .crossVectors(edge1, edge2)
      .normalize();
    
    // Transformation dans l'espace monde si orientation fournie
    return kiteOrientation ? normal.applyQuaternion(kiteOrientation) : normal;
  }

  /**
   * Calcule comment le vent pousse sur le cerf-volant
   *
   * COMMENT √áA MARCHE :
   * 1. On regarde chaque triangle du cerf-volant
   * 2. On calcule sous quel angle le vent frappe ce triangle
   * 3. Plus le vent frappe de face, plus la force est grande
   * 4. On additionne toutes les forces pour avoir la force totale
   *
   * POURQUOI C'EST IMPORTANT :
   * Si un c√¥t√© du kite re√ßoit plus de vent, il sera pouss√© plus fort
   * Cette diff√©rence fait tourner le kite naturellement !
   */
  static calculateForces(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion,
    kitePosition?: THREE.Vector3,
    kiteVelocity?: THREE.Vector3,
    angularVelocity?: THREE.Vector3
  ): {
    lift: THREE.Vector3;
    drag: THREE.Vector3;
    gravity: THREE.Vector3;  // Gravit√© distribu√©e par surface
    torque: THREE.Vector3;
    leftForce?: THREE.Vector3;
    rightForce?: THREE.Vector3;
    surfaceForces: SurfaceForce[];
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < 0.1) {
      return {
        lift: new THREE.Vector3(),
        drag: new THREE.Vector3(),
        gravity: new THREE.Vector3(),  // Pas de gravit√© si vent nul
        torque: new THREE.Vector3(),
        surfaceForces: [],
      };
    }

    const windDir = apparentWind.clone().normalize();
    const dynamicPressure = AerodynamicsCalculator.HALF_AIR_DENSITY * windSpeed * windSpeed;

    // Forces s√©par√©es pour gauche et droite
    const leftForce = new THREE.Vector3();
    const rightForce = new THREE.Vector3();
    const totalForce = new THREE.Vector3();
    const totalTorque = new THREE.Vector3();
    
    // Accumulation des forces par type (formules plaque plane : CL = sin(Œ±)√ócos(Œ±), CD = sin¬≤(Œ±))
    const totalLift = new THREE.Vector3();      // Portance totale
    const totalDrag = new THREE.Vector3();      // Tra√Æn√©e totale
    const gravityForce = new THREE.Vector3();   // Gravit√© distribu√©e par surface/frame
    
    // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent
    const aeroTorque = new THREE.Vector3();
    const gravityTorque = new THREE.Vector3();
    
    // Collection des forces par surface pour le debug
    const surfaceForces: SurfaceForce[] = [];

    // On examine chaque triangle du cerf-volant un par un
    // C'est comme v√©rifier comment le vent frappe chaque panneau d'un parasol
    KiteGeometry.SUBDIVIDED_SURFACES.forEach((surface, surfaceIndex) => {
      // üî¥ MAILLAGE FIN : Distribuer la masse proportionnellement √† l'aire
      // Trouver quelle surface originale contient ce sous-triangle
      const trianglesPerSurface = KiteGeometry.TRIANGLES_PER_SURFACE_AT_LEVEL(
        KiteGeometry.getMeshSubdivisionLevel()
      );
      const originalSurfaceIndex = Math.floor(surfaceIndex / trianglesPerSurface);
      const originalSurfaceMass = KiteGeometry.SURFACE_MASSES[originalSurfaceIndex];

      // Distribuer la masse proportionnellement √† l'aire relative
      const totalAreaForOriginal = KiteGeometry.SURFACES[originalSurfaceIndex].area;
      const massRatio = surface.area / totalAreaForOriginal;
      const surfaceMass = originalSurfaceMass * massRatio;
      // üî¥ D√âSACTIVATION TEMPORAIRE du vent apparent local pour debug
      // Le calcul local peut r√©duire trop fortement le vent per√ßu en rotation
      
      // Utiliser le vent apparent GLOBAL pour toutes les surfaces
      const localApparentWind = apparentWind.clone();
      const localWindSpeed = localApparentWind.length();
      
      if (localWindSpeed < 0.1) {
        return; // Pas de vent sur cette surface
      }
      
      const localWindDir = localApparentWind.clone().normalize();
      const localDynamicPressure = 0.5 * CONFIG.physics.airDensity * localWindSpeed * localWindSpeed;
      
      // Pour comprendre comment le vent frappe ce triangle,
      // on doit savoir dans quelle direction il "regarde"
      // (comme l'orientation d'un panneau solaire)
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      // Calcul de l'angle d'incidence pour une plaque plane (cerf-volant)
      // Œ± = angle entre la direction du vent et la surface
      const windDotNormal = localWindDir.dot(normaleMonde);
      const cosTheta = Math.abs(windDotNormal); // cos(Œ∏) o√π Œ∏ = angle vent-normale

      // Pour une plaque : sin(Œ±) = cos(Œ∏) et cos(Œ±) = sin(Œ∏)
      const sinAlpha = cosTheta;
      const cosAlpha = Math.sqrt(1 - sinAlpha * sinAlpha); // sin¬≤+cos¬≤=1

      // Si le vent glisse sur le c√¥t√© (angle = 0), pas de force
      if (sinAlpha <= PhysicsConstants.EPSILON) {
        return;
      }

      // üî¥ BUG FIX #4 : COEFFICIENTS PLAQUE PLANE CORRECTS (Hoerner)
      // Formules physiques pour plaque plane inclin√©e √† angle Œ± :
      //   C_L = sin(Œ±) √ó cos(Œ±)  ‚Üí Coefficient de portance
      //   C_D = sin¬≤(Œ±)           ‚Üí Coefficient de tra√Æn√©e
      // Ces coefficients sont valid√©s exp√©rimentalement !
      
      const CL = sinAlpha * cosAlpha;  // Coefficient lift
      const CD = sinAlpha * sinAlpha;   // Coefficient drag (= CN)
      
      // üîç DEBUG premi√®re surface (angle et coefficients) - DISABLED for performance
      // if (surfaceIndex === 0) {
      //   const alphaDeg = Math.asin(sinAlpha) * 180 / Math.PI;

      // }
      
      // Direction : normale √† la surface, orient√©e face au vent
      const windFacingNormal = windDotNormal >= 0 ? normaleMonde.clone() : normaleMonde.clone().negate();
      
      // DIRECTION LIFT : Perpendiculaire au vent, dans le plan (vent, normale)
      // M√©thode : liftDir = normalize(windFacingNormal - (windFacingNormal¬∑windDir)√ówindDir)
      const liftDir = windFacingNormal.clone()
        .sub(localWindDir.clone().multiplyScalar(windFacingNormal.dot(localWindDir)))
        .normalize();
      
      // V√©rifier validit√© (√©viter division par z√©ro si vent // normale)
      if (liftDir.lengthSq() < PhysicsConstants.EPSILON) {
        liftDir.copy(windFacingNormal);  // Fallback : utiliser normale
      }
      
      // DIRECTION DRAG : Parall√®le au vent
      const dragDir = localWindDir.clone();
      
      // FORCES A√âRODYNAMIQUES (AVANT scaling) avec pression dynamique LOCALE
      const liftMagnitude = localDynamicPressure * surface.area * CL;
      const dragMagnitude = localDynamicPressure * surface.area * CD;
      
      const liftForce = liftDir.clone().multiplyScalar(liftMagnitude);
      const dragForce = dragDir.clone().multiplyScalar(dragMagnitude);
      
      // Force a√©rodynamique totale = lift + drag (vectoriel)
      const aeroForce = liftForce.clone().add(dragForce);
      
      // GRAVIT√â DISTRIBU√âE (√©mergente, pas script√©e !)
      // Chaque surface porte une fraction de la masse totale
      // La gravit√© est appliqu√©e au centre g√©om√©trique de chaque surface
      // ‚Üí Couple gravitationnel √©merge naturellement de r √ó F_gravity
      const gravity = new THREE.Vector3(0, -surfaceMass * CONFIG.physics.gravity, 0);
      
      // Accumulation des forces par type
      totalLift.add(liftForce);
      totalDrag.add(dragForce);
      gravityForce.add(gravity);
      
      // Force totale sur cette surface = a√©ro + gravit√©
      const totalSurfaceForce = aeroForce.clone().add(gravity);
      
      // Pour le debug : conserver lift/drag locaux
      const lift = liftForce.clone();
      const drag = dragForce.clone();

      // 6. Centre de pression = centre g√©om√©trique du triangle
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // üîç DEBUG TOUTES les surfaces : g√©om√©trie + forces - DISABLED for performance


      // On note si cette force est sur le c√¥t√© gauche ou droit
      // C'est important car si un c√¥t√© a plus de force,
      // le kite va tourner (comme un bateau avec une seule rame)
      const isLeft = centre.x < 0; // N√©gatif = gauche, Positif = droite

      if (isLeft) {
        leftForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      } else {
        rightForce.add(totalSurfaceForce); // Force totale (a√©ro + gravit√©)
      }

      totalForce.add(totalSurfaceForce);

      // Friction (n√©gligeable pour l'air, nulle)
      const friction = new THREE.Vector3();

      // R√©sultante = force a√©ro totale (lift + drag vectoriel)
      const resultant = aeroForce.clone();

      surfaceForces.push({
        surfaceIndex,
        lift,
        drag,
        friction,
        resultant,
        center: centre.clone(), // Coordonn√©es locales du kite
        normal: normaleMonde.clone(),
        area: surface.area,
      });

      // Le couple, c'est ce qui fait tourner le kite
      // Imaginez une porte : si vous poussez pr√®s des gonds, elle tourne peu
      // Si vous poussez loin des gonds, elle tourne beaucoup
      // Ici, plus la force est loin du centre, plus elle fait tourner
      //
      // S√©paration couples a√©ro et gravit√© pour scaling coh√©rent :
      // - Couple a√©ro : sera scal√© proportionnellement aux forces (liftScale/dragScale)
      // - Couple gravit√© : physique pure, pas de scaling
      const centreWorldForTorque = centre.clone().applyQuaternion(kiteOrientation);
      
      // Couples calcul√©s via m√©thode utilitaire
      aeroTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, aeroForce));
      gravityTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, gravity));
      totalTorque.add(AerodynamicsCalculator.calculateTorque(centreWorldForTorque, totalSurfaceForce));


    });

    // PHYSIQUE √âMERGENTE : Le couple vient de la diff√©rence G/D
    // Si leftForce > rightForce ‚Üí rotation vers la droite
    // Si rightForce > leftForce ‚Üí rotation vers la gauche
    // AUCUN facteur artificiel n√©cessaire!

    // üî¥ BUG FIX #4 : PAS DE D√âCOMPOSITION GLOBALE !
    // Les lift/drag ont d√©j√† √©t√© calcul√©s CORRECTEMENT par surface avec CL/CD
    // Il suffit d'appliquer les scaling factors directement
    const lift = totalLift.multiplyScalar(CONFIG.aero.liftScale);
    const drag = totalDrag.multiplyScalar(CONFIG.aero.dragScale);

    // üîç DEBUG : Afficher forces calcul√©es - DISABLED for performance
    // Uncomment for debugging:


    // üîç DEBUG CRITIQUE : Asym√©trie gauche/droite - DISABLED for performance
    // const leftMag = leftForce.length();
    // const rightMag = rightForce.length();
    // const asymmetry = leftMag - rightMag;
    // const asymmetryPercent = rightMag > 0 ? (asymmetry / rightMag * 100) : 0;
    // const leftArr = leftForce.toArray();
    // const rightArr = rightForce.toArray();
    // const diffArr = leftForce.clone().sub(rightForce).toArray();


    // CORRECTION CRITIQUE : Scaling coh√©rent du couple a√©rodynamique
    // Le couple DOIT √™tre scal√© proportionnellement aux forces a√©ro pour coh√©rence physique
    // Si les forces sont doubl√©es (scale=2), le couple doit l'√™tre aussi
    // MAIS la gravit√© reste inchang√©e (physique pure)
    const averageAeroScale = (CONFIG.aero.liftScale + CONFIG.aero.dragScale) / 2;
    const scaledAeroTorque = aeroTorque.multiplyScalar(averageAeroScale);
    
    // Couple total = couple a√©ro scal√© + couple gravit√© (non scal√©)
    const finalTorque = scaledAeroTorque.clone().add(gravityTorque);

    return {
      lift,
      drag,
      gravity: gravityForce,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e par surface
      torque: finalTorque,  // Couple coh√©rent avec forces scal√©es
      leftForce, // Exposer les forces pour analyse
      rightForce, // Permet de voir l'asym√©trie √©mergente
      surfaceForces, // Forces individuelles par surface pour debug
    };
  }

  /**
   * Calcule des m√©triques pour le debug
   */
  static computeMetrics(
    apparentWind: THREE.Vector3,
    kiteOrientation: THREE.Quaternion
  ): {
    apparentSpeed: number;
    liftMag: number;
    dragMag: number;
    lOverD: number;
    aoaDeg: number;
  } {
    const windSpeed = apparentWind.length();
    if (windSpeed < PhysicsConstants.EPSILON) {
      return { apparentSpeed: 0, liftMag: 0, dragMag: 0, lOverD: 0, aoaDeg: 0 };
    }

    const { lift } = this.calculateForces(apparentWind, kiteOrientation);
    const liftMag = lift.length();
    const dragMag = 0; // Tra√Æn√©e int√©gr√©e dans les forces totales
    const lOverD = 0; // Ratio non applicable pour un cerf-volant

    // Calcul approximatif de l'angle d'attaque
    const windDir = apparentWind.clone().normalize();
    const weightedNormal = new THREE.Vector3();

    KiteGeometry.SURFACES.forEach((surface) => {
      const normaleMonde = AerodynamicsCalculator.calculateSurfaceNormal(surface, kiteOrientation);

      const facing = windDir.dot(normaleMonde);
      const cosIncidence = Math.max(0, Math.abs(facing));

      const normalDir =
        facing >= 0 ? normaleMonde : normaleMonde.clone().negate();
      weightedNormal.add(normalDir.multiplyScalar(surface.area * cosIncidence));
    });

    let aoaDeg = 0;
    if (
      weightedNormal.lengthSq() >
      PhysicsConstants.EPSILON * PhysicsConstants.EPSILON
    ) {
      const eff = weightedNormal.normalize();
      const dot = Math.max(-1, Math.min(1, eff.dot(windDir)));
      const phiDeg = (Math.acos(dot) * 180) / Math.PI;
      aoaDeg = Math.max(0, 90 - phiDeg);
    }

    return { apparentSpeed: windSpeed, liftMag, dragMag, lOverD, aoaDeg };
  }
}

=== simulation/physics/BridleSystem.ts ===

/**
 * BridleSystem.ts - Orchestrateur du syst√®me de bridage du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les 6 brides (3 gauches + 3 droites)
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les brides sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT les points d'attache (distance max)
 *   - Elles ne TIRENT PAS les points les uns vers les autres
 *   - Le ConstraintSolver.enforceBridleConstraints() g√®re la contrainte g√©om√©trique
 *
 * Architecture :
 *   - Similar √† LineSystem mais pour les brides internes au kite
 *   - R√©utilise LinePhysics pour les calculs de tension
 *   - Les 6 brides sont des instances Line ind√©pendantes
 *
 * Relation avec les autres modules :
 *   - Utilise BridleFactory pour cr√©er les brides
 *   - Utilise LinePhysics pour calculer tensions
 *   - Utilis√© par PhysicsEngine
 *   - Les contraintes sont appliqu√©es dans ConstraintSolver
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts (pattern similaire)
 *   - src/factories/BridleFactory.ts
 *   - src/simulation/physics/ConstraintSolver.ts
 */

import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { BridleFactory } from "@factories/BridleFactory";

import { BridleLengths, BridleTensions } from "../types/BridleTypes";

import { LinePhysics } from "./LinePhysics";

/**
 * Syst√®me de gestion des brides
 *
 * G√®re les 6 brides qui relient les points anatomiques du kite
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */
export class BridleSystem {
  // Brides gauches (3)
  private leftNez: Line;
  private leftInter: Line;
  private leftCentre: Line;

  // Brides droites (3)
  private rightNez: Line;
  private rightInter: Line;
  private rightCentre: Line;

  // Service de calcul physique (r√©utilis√©)
  private physics: LinePhysics;

  // Positions pr√©c√©dentes pour calcul v√©locit√©
  private previousPositions: Map<string, THREE.Vector3> = new Map();

  constructor(bridleLengths: BridleLengths) {
    // Valider les longueurs
    BridleFactory.validateBridleLengths(bridleLengths);

    // Cr√©er les 6 brides via factory
    const { left, right } = BridleFactory.createAllBridles(bridleLengths);

    // Assigner brides gauches
    [this.leftNez, this.leftInter, this.leftCentre] = left;

    // Assigner brides droites
    [this.rightNez, this.rightInter, this.rightCentre] = right;

    // Service de calcul physique
    this.physics = new LinePhysics();
  }

  /**
   * Calcule les tensions de toutes les brides
   *
   * Note : Ces tensions sont calcul√©es pour affichage/debug uniquement.
   * Les brides sont des contraintes g√©om√©triques g√©r√©es par ConstraintSolver,
   * elles n'appliquent PAS de forces au kite.
   *
   * @param kite - Instance du cerf-volant
   * @returns Tensions des 6 brides (Newtons)
   */
  calculateBridleTensions(kite: Kite): BridleTensions {
    const deltaTime = 1 / 60; // Approximation pour calcul v√©locit√©

    // Calculer tension bride gauche NEZ
    const leftNezTension = this.calculateSingleBridleTension(
      kite,
      this.leftNez,
      "NEZ",
      "CTRL_GAUCHE",
      deltaTime
    );

    // Calculer tension bride gauche INTER
    const leftInterTension = this.calculateSingleBridleTension(
      kite,
      this.leftInter,
      "INTER_GAUCHE",
      "CTRL_GAUCHE",
      deltaTime
    );

    // Calculer tension bride gauche CENTRE
    const leftCentreTension = this.calculateSingleBridleTension(
      kite,
      this.leftCentre,
      "CENTRE",
      "CTRL_GAUCHE",
      deltaTime
    );

    // Calculer tension bride droite NEZ
    const rightNezTension = this.calculateSingleBridleTension(
      kite,
      this.rightNez,
      "NEZ",
      "CTRL_DROIT",
      deltaTime
    );

    // Calculer tension bride droite INTER
    const rightInterTension = this.calculateSingleBridleTension(
      kite,
      this.rightInter,
      "INTER_DROIT",
      "CTRL_DROIT",
      deltaTime
    );

    // Calculer tension bride droite CENTRE
    const rightCentreTension = this.calculateSingleBridleTension(
      kite,
      this.rightCentre,
      "CENTRE",
      "CTRL_DROIT",
      deltaTime
    );

    return {
      leftNez: leftNezTension,
      leftInter: leftInterTension,
      leftCentre: leftCentreTension,
      rightNez: rightNezTension,
      rightInter: rightInterTension,
      rightCentre: rightCentreTension,
    };
  }

  /**
   * Calcule la tension d'une bride individuelle
   *
   * @param kite - Instance du cerf-volant
   * @param bridle - Instance Line de la bride
   * @param startPointName - Nom du point de d√©part (ex: "NEZ")
   * @param endPointName - Nom du point d'arriv√©e (ex: "CTRL_GAUCHE")
   * @param deltaTime - Pas de temps pour calcul v√©locit√©
   * @returns Tension en Newtons
   */
  private calculateSingleBridleTension(
    kite: Kite,
    bridle: Line,
    startPointName: string,
    endPointName: string,
    deltaTime: number
  ): number {
    // R√©cup√©rer positions locales
    const startLocal = kite.getPoint(startPointName);
    const endLocal = kite.getPoint(endPointName);

    if (!startLocal || !endLocal) {
      console.warn(`‚ö†Ô∏è Points bride introuvables: ${startPointName} ou ${endPointName}`);
      return 0;
    }

    // Convertir en coordonn√©es monde
    const startWorld = startLocal
      .clone()
      .applyQuaternion(kite.quaternion)
      .add(kite.position);

    const endWorld = endLocal
      .clone()
      .applyQuaternion(kite.quaternion)
      .add(kite.position);

    // Calculer v√©locit√© relative
    const velocity = this.calculateVelocity(
      startWorld,
      endWorld,
      startPointName,
      endPointName,
      deltaTime
    );

    // Calculer tension via LinePhysics
    const result = this.physics.calculateTensionForce(
      bridle,
      startWorld,
      endWorld,
      velocity
    );

    // Mettre √† jour l'√©tat de la bride
    bridle.updateState(result.currentLength, result.tension, performance.now());

    return result.tension;
  }

  /**
   * Calcule la v√©locit√© relative entre deux points
   *
   * @param currentStart - Position actuelle point d√©part (monde)
   * @param currentEnd - Position actuelle point arriv√©e (monde)
   * @param startKey - Cl√© unique point d√©part
   * @param endKey - Cl√© unique point arriv√©e
   * @param deltaTime - Pas de temps
   * @returns Vecteur v√©locit√© relative
   */
  private calculateVelocity(
    currentStart: THREE.Vector3,
    currentEnd: THREE.Vector3,
    startKey: string,
    endKey: string,
    deltaTime: number
  ): THREE.Vector3 {
    const key = `${startKey}_${endKey}`;
    const prevStart = this.previousPositions.get(`${key}_start`);
    const prevEnd = this.previousPositions.get(`${key}_end`);

    let velocity = new THREE.Vector3();

    if (prevStart && prevEnd) {
      // V√©locit√© point d√©part
      const velStart = currentStart.clone().sub(prevStart).divideScalar(deltaTime);
      // V√©locit√© point arriv√©e
      const velEnd = currentEnd.clone().sub(prevEnd).divideScalar(deltaTime);
      // V√©locit√© relative
      velocity = velStart.sub(velEnd);
    }

    // M√©moriser positions actuelles
    this.previousPositions.set(`${key}_start`, currentStart.clone());
    this.previousPositions.set(`${key}_end`, currentEnd.clone());

    return velocity;
  }

  /**
   * Met √† jour les longueurs des brides
   *
   * @param newLengths - Nouvelles longueurs (partial update)
   * @deprecated Utilisez PhysicsEngine.setBridleLength() √† la place
   */
  setBridleLengths(newLengths: Partial<BridleLengths>): void {
    // Note: Les instances Line sont immuables. Pour changer les longueurs,
    // il faut recr√©er BridleSystem avec les nouvelles longueurs.
    // Cette m√©thode est d√©pr√©ci√©e - utilisez PhysicsEngine.setBridleLength()
    console.warn("‚ö†Ô∏è BridleSystem.setBridleLengths() est d√©pr√©ci√©. Utilisez PhysicsEngine.setBridleLength() √† la place");
    console.log("   Nouvelles longueurs demand√©es:", newLengths);
  }

  /**
   * Obtient les longueurs actuelles des brides
   *
   * @returns BridleLengths actuelles
   */
  getBridleLengths(): BridleLengths {
    return {
      nez: this.leftNez.config.length,
      inter: this.leftInter.config.length,
      centre: this.leftCentre.config.length,
    };
  }

  /**
   * Obtient toutes les instances Line des brides
   * (utile pour ConstraintSolver)
   *
   * @returns Objet contenant les 6 brides
   */
  getAllBridles(): {
    left: { nez: Line; inter: Line; centre: Line };
    right: { nez: Line; inter: Line; centre: Line };
  } {
    return {
      left: {
        nez: this.leftNez,
        inter: this.leftInter,
        centre: this.leftCentre,
      },
      right: {
        nez: this.rightNez,
        inter: this.rightInter,
        centre: this.rightCentre,
      },
    };
  }

  /**
   * V√©rifie si une bride est tendue
   *
   * @param side - C√¥t√© (left/right)
   * @param position - Position (nez/inter/centre)
   * @returns true si tendue
   */
  isBridleTaut(side: 'left' | 'right', position: 'nez' | 'inter' | 'centre'): boolean {
    const bridleMap = {
      left: { nez: this.leftNez, inter: this.leftInter, centre: this.leftCentre },
      right: { nez: this.rightNez, inter: this.rightInter, centre: this.rightCentre },
    };

    return bridleMap[side][position].isTaut();
  }

  /**
   * Obtient des statistiques sur l'√©tat des brides
   * (utile pour debug/monitoring)
   */
  getStats(): {
    tautCount: number;
    avgTension: number;
    maxTension: number;
    minTension: number;
  } {
    const bridles = [
      this.leftNez,
      this.leftInter,
      this.leftCentre,
      this.rightNez,
      this.rightInter,
      this.rightCentre,
    ];

    const tautCount = bridles.filter(b => b.isTaut()).length;
    const tensions = bridles.map(b => b.getCurrentTension());
    const avgTension = tensions.reduce((sum, t) => sum + t, 0) / tensions.length;
    const maxTension = Math.max(...tensions);
    const minTension = Math.min(...tensions);

    return { tautCount, avgTension, maxTension, minTension };
  }
}


=== simulation/physics/ConstraintSolver.ts ===

/**
 * ConstraintSolver.ts - Solveur de contraintes pour les lignes du cerf-volant
 *
 * R√¥le :
 *   - Applique les contraintes de distance sur les lignes via l'algorithme Position-Based Dynamics (PBD)
 *   - Garantit la stabilit√© g√©om√©trique du kite et le respect des longueurs de ligne
 *   - Permet la rotation naturelle et le d√©crochage du kite
 *
 * D√©pendances principales :
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et points du cerf-volant
 *   - PhysicsConstants.ts : Constantes physiques pour la tol√©rance et la gestion des contraintes
 *   - SimulationConfig.ts : Param√®tres de configuration
 *   - Types : Utilise HandlePositions pour typer les poign√©es
 *
 * Relation avec les fichiers adjacents :
 *   - LineSystem.ts : Utilise ConstraintSolver pour appliquer les contraintes sur les lignes
 *   - PhysicsEngine.ts : Orchestration de l'appel au solveur
 *
 * Utilisation typique :
 *   - Appel√© par LineSystem ou PhysicsEngine pour maintenir la contrainte de distance
 *
 * Voir aussi :
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { HandlePositions } from "../types";
import { BridleLengths } from "../types/BridleTypes";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Solveur de contraintes pour les lignes
 *
 * Impl√©mente l'algorithme Position-Based Dynamics (PBD) pour maintenir
 * les contraintes de distance des lignes
 */
export class ConstraintSolver {
  /**
   * Applique les contraintes des lignes - Solver PBD (Position-Based Dynamics)
   * Algorithme sophistiqu√© qui respecte la contrainte de distance tout en
   * permettant la rotation naturelle du kite
   */
  static enforceLineConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    handles: HandlePositions
  ): void {
    // PRINCIPE DE LA PYRAMIDE DE CONTRAINTE :
    // Le cerf-volant est constamment pouss√© par le vent contre la sph√®re de contrainte
    // Les lignes + brides forment une pyramide qui maintient une g√©om√©trie stable
    // Le kite "glisse" sur la surface de la sph√®re d√©finie par la longueur des lignes
    // C'est quand il sort de cette sph√®re qu'il "d√©croche"

    const lineLength =
      kite.userData.lineLength || CONFIG.lines.defaultLength;
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;

    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) return;

    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // R√©solution PBD pour chaque ligne
    const solveLine = (ctrlLocal: THREE.Vector3, handle: THREE.Vector3) => {
      const q = kite.quaternion;
      const cpWorld = ctrlLocal
        .clone()
        .applyQuaternion(q)
        .add(predictedPosition);
      const diff = cpWorld.clone().sub(handle);
      const dist = diff.length();

      if (dist <= lineLength - tol) return; // Ligne molle

      const n = diff.clone().normalize();
      const C = dist - lineLength;

      const r = cpWorld.clone().sub(predictedPosition);
      const alpha = new THREE.Vector3().crossVectors(r, n);
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);
      const denom = invMass + alpha.lengthSq() * invInertia;
      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections
      const dPos = n.clone().multiplyScalar(-invMass * lambda);
      predictedPosition.add(dPos);

      const dTheta = alpha.clone().multiplyScalar(-invInertia * lambda);
      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse
      const q2 = kite.quaternion;
      const cpWorld2 = ctrlLocal
        .clone()
        .applyQuaternion(q2)
        .add(predictedPosition);
      const n2 = cpWorld2.clone().sub(handle).normalize();
      const r2 = cpWorld2.clone().sub(predictedPosition);
      const pointVel = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, r2));
      const radialSpeed = pointVel.dot(n2);

      if (radialSpeed > 0) {
        const rxn = new THREE.Vector3().crossVectors(r2, n2);
        const eff = invMass + rxn.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        state.velocity.add(n2.clone().multiplyScalar(J * invMass));
        const angImpulse = new THREE.Vector3().crossVectors(
          r2,
          n2.clone().multiplyScalar(J)
        );
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // Deux passes pour mieux satisfaire les contraintes
    for (let i = 0; i < 2; i++) {
      solveLine(ctrlLeft, handles.left);
      solveLine(ctrlRight, handles.right);
    }
  }

  /**
   * Applique les contraintes des brides - Solver PBD (Position-Based Dynamics)
   * 
   * Les brides sont des contraintes INTERNES au kite qui relient :
   * - NEZ ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * - INTER_GAUCHE ‚Üí CTRL_GAUCHE
   * - INTER_DROIT ‚Üí CTRL_DROIT
   * - CENTRE ‚Üí CTRL_GAUCHE / CTRL_DROIT
   * 
   * Contrairement aux lignes principales (kite ‚Üî pilote), les brides lient
   * des points du M√äME objet (le kite). Elles d√©finissent la forme et rigidit√©
   * interne du cerf-volant.
   */
  static enforceBridleConstraints(
    kite: Kite,
    predictedPosition: THREE.Vector3,
    state: { velocity: THREE.Vector3; angularVelocity: THREE.Vector3 },
    bridleLengths: BridleLengths
  ): void {
    const tol = PhysicsConstants.LINE_CONSTRAINT_TOLERANCE;
    const mass = CONFIG.kite.mass;
    const inertia = CONFIG.kite.inertia;

    // D√©finition des 6 brides (3 par c√¥t√©)
    const bridles = [
      // Brides gauches
      { start: "NEZ", end: "CTRL_GAUCHE", length: bridleLengths.nez },
      { start: "INTER_GAUCHE", end: "CTRL_GAUCHE", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_GAUCHE", length: bridleLengths.centre },
      // Brides droites
      { start: "NEZ", end: "CTRL_DROIT", length: bridleLengths.nez },
      { start: "INTER_DROIT", end: "CTRL_DROIT", length: bridleLengths.inter },
      { start: "CENTRE", end: "CTRL_DROIT", length: bridleLengths.centre },
    ];

    // R√©solution PBD pour chaque bride
    const solveBridle = (
      startName: string,
      endName: string,
      bridleLength: number
    ) => {
      const startLocal = kite.getPoint(startName);
      const endLocal = kite.getPoint(endName);

      if (!startLocal || !endLocal) {
        console.warn(`‚ö†Ô∏è Points bride introuvables: ${startName} ou ${endName}`);
        return;
      }

      const q = kite.quaternion;

      // Convertir points locaux en coordonn√©es monde
      const startWorld = startLocal
        .clone()
        .applyQuaternion(q)
        .add(predictedPosition);

      const endWorld = endLocal
        .clone()
        .applyQuaternion(q)
        .add(predictedPosition);

      // Calculer distance actuelle
      const diff = endWorld.clone().sub(startWorld);
      const dist = diff.length();

      // Si bride molle, pas de contrainte
      if (dist <= bridleLength - tol) return;

      // Direction de contrainte (normalis√©e)
      const n = diff.clone().normalize();

      // Violation de contrainte C = distance - longueur_bride
      const C = dist - bridleLength;

      // Calcul des bras de levier pour rotation
      const rStart = startWorld.clone().sub(predictedPosition);
      const rEnd = endWorld.clone().sub(predictedPosition);

      // Moments angulaires
      const alphaStart = new THREE.Vector3().crossVectors(rStart, n);
      const alphaEnd = new THREE.Vector3().crossVectors(rEnd, n.clone().negate());

      // Inverse masses
      const invMass = 1 / mass;
      const invInertia = 1 / Math.max(inertia, PhysicsConstants.EPSILON);

      // D√©nominateur pour lambda (inclut rotation)
      // Les deux points appartiennent au m√™me corps rigide, donc contribution double
      const denom =
        2 * invMass +
        alphaStart.lengthSq() * invInertia +
        alphaEnd.lengthSq() * invInertia;

      const lambda = C / Math.max(denom, PhysicsConstants.EPSILON);

      // Corrections de position
      // Point start : pouss√© dans direction -n
      const dPosStart = n.clone().multiplyScalar(-invMass * lambda);
      // Point end : pouss√© dans direction +n
      const dPosEnd = n.clone().multiplyScalar(invMass * lambda);

      // Correction nette de position (moyenne)
      const dPos = dPosStart.clone().add(dPosEnd).multiplyScalar(0.5);
      predictedPosition.add(dPos);

      // Correction de rotation (moyenne des deux contributions)
      const dThetaStart = alphaStart.clone().multiplyScalar(-invInertia * lambda);
      const dThetaEnd = alphaEnd.clone().multiplyScalar(-invInertia * lambda);
      const dTheta = dThetaStart.clone().add(dThetaEnd).multiplyScalar(0.5);

      const angle = dTheta.length();
      if (angle > PhysicsConstants.EPSILON) {
        const axis = dTheta.normalize();
        const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        kite.quaternion.premultiply(dq).normalize();
      }

      // Correction de vitesse (dampening)
      const q2 = kite.quaternion;
      const startWorld2 = startLocal
        .clone()
        .applyQuaternion(q2)
        .add(predictedPosition);
      const endWorld2 = endLocal
        .clone()
        .applyQuaternion(q2)
        .add(predictedPosition);

      const n2 = endWorld2.clone().sub(startWorld2).normalize();
      const rStart2 = startWorld2.clone().sub(predictedPosition);
      const rEnd2 = endWorld2.clone().sub(predictedPosition);

      // Vitesses des points
      const velStart = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rStart2));
      const velEnd = state.velocity
        .clone()
        .add(new THREE.Vector3().crossVectors(state.angularVelocity, rEnd2));

      // Vitesse relative le long de la bride
      const relVel = velEnd.clone().sub(velStart);
      const radialSpeed = relVel.dot(n2);

      // Si les points s'√©loignent, appliquer correction de vitesse
      if (radialSpeed > 0) {
        const rxnStart = new THREE.Vector3().crossVectors(rStart2, n2);
        const rxnEnd = new THREE.Vector3().crossVectors(rEnd2, n2.clone().negate());
        const eff =
          2 * invMass + rxnStart.lengthSq() * invInertia + rxnEnd.lengthSq() * invInertia;
        const J = -radialSpeed / Math.max(eff, PhysicsConstants.EPSILON);

        // Correction vitesse lin√©aire
        state.velocity.add(n2.clone().multiplyScalar(J * invMass));

        // Correction vitesse angulaire (moyenne des deux contributions)
        const angImpulseStart = new THREE.Vector3().crossVectors(
          rStart2,
          n2.clone().multiplyScalar(J)
        );
        const angImpulseEnd = new THREE.Vector3().crossVectors(
          rEnd2,
          n2.clone().multiplyScalar(-J)
        );
        const angImpulse = angImpulseStart.clone().add(angImpulseEnd).multiplyScalar(0.5);
        state.angularVelocity.add(angImpulse.multiplyScalar(invInertia));
      }
    };

    // R√©soudre toutes les brides (1 passe suffit g√©n√©ralement)
    // Les brides sont courtes et rigides, convergence rapide
    bridles.forEach(({ start, end, length }) => {
      solveBridle(start, end, length);
    });
  }

  /**
   * G√®re la collision avec le sol
   */
  static handleGroundCollision(
    kite: Kite,
    newPosition: THREE.Vector3,
    velocity: THREE.Vector3
  ): void {
    const groundY = CONFIG.kite.minHeight;
    const pointsMap = kite.getPointsMap?.() as
      | Map<string, [number, number, number]>
      | undefined;

    if (pointsMap && pointsMap.size > 0) {
      let minY = Infinity;
      const q = kite.quaternion;

      pointsMap.forEach(([px, py, pz]) => {
        const world = new THREE.Vector3(px, py, pz)
          .applyQuaternion(q)
          .add(newPosition);
        if (world.y < minY) minY = world.y;
      });

      if (minY < groundY) {
        const lift = groundY - minY;
        newPosition.y += lift;

        if (velocity.y < 0) velocity.y = 0;
        velocity.x *= PhysicsConstants.GROUND_FRICTION;
        velocity.z *= PhysicsConstants.GROUND_FRICTION;
      }
      return;
    }

    // Fallback simple
    if (newPosition.y < groundY) {
      newPosition.y = groundY;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x *= PhysicsConstants.GROUND_FRICTION;
      velocity.z *= PhysicsConstants.GROUND_FRICTION;
    }
  }
}

=== simulation/physics/LinePhysics.ts ===

/**
 * LinePhysics.ts - Service de calculs physiques pour les lignes de cerf-volant
 *
 * R√¥le :
 *   - Calculer les forces de tension dans une ligne (mod√®le Dyneema r√©aliste)
 *   - Appliquer pr√©-tension, √©lasticit√© lin√©aire et damping
 *   - Calculer l'affaissement cat√©naire pour le rendu
 *
 * Responsabilit√© :
 *   - Physique pure : F = F‚ÇÄ + k√óŒîx - c√óv_radial
 *   - Pas de gestion d'√©tat (stateless)
 *   - Pas de d√©pendance Three.js (calculs vectoriels purs)
 *
 * Mod√®le Physique :
 *   - Lignes haute performance (Dyneema/Spectra)
 *   - √âlasticit√© ~2-3%, rigidit√© EA/L ‚âà 2200 N/m pour 15m
 *   - Toujours pr√©-tendues (50-100N minimum)
 *   - Damping interne (dissipation d'√©nergie)
 *
 * Relation avec les autres modules :
 *   - Op√®re sur des objets Line
 *   - Appel√© par LineSystem pour calculer forces
 *   - Pas de d√©pendance sur la sc√®ne 3D
 *
 * Philosophie :
 *   - Pure function : Entr√©es ‚Üí Sorties, pas d'effet de bord
 *   - Testable unitairement (pas de mock Three.js requis)
 *   - Single Responsibility : Calculs physiques uniquement
 *
 * Voir aussi :
 *   - src/objects/mechanical/Line.ts (entit√© m√©tier)
 *   - docs/LINE_PHYSICS_AUDIT_2025-10-01.md (r√©f√©rences physiques)
 */

import { Vector3 } from 'three';
import { Line } from '@objects/mechanical/Line';
import { PhysicsConstants } from '../config/PhysicsConstants';

/**
 * R√©sultat d'un calcul de force de tension
 */
export interface TensionResult {
  /** Force vectorielle √† appliquer (N) */
  force: Vector3;

  /** Magnitude de la tension (N) */
  tension: number;

  /** Extension actuelle (m) */
  extension: number;

  /** Longueur actuelle (m) */
  currentLength: number;

  /** Ligne tendue ou molle */
  isTaut: boolean;
}

/**
 * Service de calculs physiques pour lignes de cerf-volant
 *
 * @example
 * ```typescript
 * const physics = new LinePhysics();
 * const result = physics.calculateTensionForce(
 *   line,
 *   new Vector3(0, 10, 0),  // Position kite
 *   new Vector3(0, 0, 0),   // Position poign√©e
 *   new Vector3(0, -1, 0)   // Vitesse relative
 * );
 * console.log(`Tension: ${result.tension}N`);
 * ```
 */
export class LinePhysics {
  /** Constante gravitationnelle (m/s¬≤) */
  private static readonly GRAVITY = 9.81;

  /** Epsilon fin pour calculs de pr√©cision (r√©utilise PhysicsConstants) */
  private static readonly EPSILON = PhysicsConstants.EPSILON_FINE;

  /**
   * Calcule la force de tension dans une ligne
   *
   * Mod√®le : F = F‚ÇÄ + k√óŒîx - c√óv_radial
   * - F‚ÇÄ : Pr√©-tension minimale (toujours pr√©sente)
   * - k√óŒîx : Composante √©lastique (si ligne tendue)
   * - c√óv_radial : Damping (dissipation d'√©nergie)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position point d'attache d√©part (kite ou barre)
   * @param endPos - Position point d'attache arriv√©e (barre ou kite)
   * @param relativeVelocity - Vitesse relative entre les deux points (pour damping)
   * @returns R√©sultat du calcul (force, tension, extension)
   */
  calculateTensionForce(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    relativeVelocity: Vector3 = new Vector3()
  ): TensionResult {
    // Vecteur ligne et direction
    const lineVector = new Vector3().subVectors(endPos, startPos);
    const currentLength = lineVector.length();

    // √âviter division par z√©ro
    if (currentLength < LinePhysics.EPSILON) {
      return {
        force: new Vector3(),
        tension: 0,
        extension: 0,
        currentLength: 0,
        isTaut: false
      };
    }

    const lineDir = lineVector.clone().normalize();
    const restLength = line.config.length;

    // 1. Composante √©lastique : F_elastic = F‚ÇÄ + k√óŒîx
    let elasticTension: number;
    let extension: number;
    let isTaut: boolean;

    if (currentLength > restLength) {
      // Ligne tendue : ajouter force √©lastique √† la pr√©-tension
      extension = currentLength - restLength;
      elasticTension = line.config.preTension + line.config.stiffness * extension;
      isTaut = true;
    } else {
      // Ligne molle : maintenir pr√©-tension minimale
      extension = 0;
      elasticTension = line.config.preTension;
      isTaut = false;
    }

    // 2. Composante de damping : F_damp = -c √ó v_along_line
    const velocityAlongLine = relativeVelocity.dot(lineDir);
    const dampingTension = -line.config.dampingCoeff * velocityAlongLine;

    // 3. Tension totale (limit√©e par maxTension)
    const totalTension = Math.min(
      Math.max(elasticTension + dampingTension, 0), // Jamais n√©gative
      line.config.maxTension
    );

    // 4. Force vectorielle
    const force = lineDir.clone().multiplyScalar(totalTension);

    return {
      force,
      tension: totalTension,
      extension,
      currentLength,
      isTaut
    };
  }

  /**
   * Calcule l'affaissement cat√©naire r√©el pour une ligne horizontale
   *
   * Formule simplifi√©e : sag = (œÅ √ó g √ó L¬≤) / (8 √ó T)
   * o√π :
   * - œÅ : masse lin√©ique (kg/m)
   * - g : gravit√© (9.81 m/s¬≤)
   * - L : longueur ligne (m)
   * - T : tension (N)
   *
   * @param line - Ligne √† analyser
   * @param tension - Tension actuelle (N)
   * @returns Affaissement vertical au centre (m)
   *
   * @example
   * ```typescript
   * const sag = physics.calculateCatenarySag(line, 100);
   * console.log(`Sag: ${sag * 1000}mm`); // ~1.4mm pour Dyneema 15m @ 100N
   * ```
   */
  calculateCatenarySag(line: Line, tension: number): number {
    if (tension < LinePhysics.EPSILON) {
      return 0; // Pas de tension = pas d'affaissement d√©fini
    }

    const rho = line.config.linearMassDensity;
    const L = line.config.length;

    // Formule cat√©naire simplifi√©e (ligne horizontale)
    const sag = (rho * LinePhysics.GRAVITY * L * L) / (8 * tension);

    return Math.max(0, sag); // Toujours positif
  }

  /**
   * Calcule les points d'une vraie cat√©naire pour le rendu
   *
   * √âquation compl√®te : y(x) = a √ó cosh(x/a) - a
   * o√π a = T / (œÅ √ó g)
   *
   * @param line - Ligne √† analyser
   * @param startPos - Position d√©part
   * @param endPos - Position arriv√©e
   * @param tension - Tension actuelle (N)
   * @param segments - Nombre de segments pour la courbe
   * @returns Tableau de points 3D formant la cat√©naire
   *
   * @remarks
   * Pour lignes tr√®s tendues (T > 100N), la cat√©naire est quasi-lin√©aire
   * Pour lignes molles (T < 50N), l'affaissement devient visible
   */
  calculateCatenaryPoints(
    line: Line,
    startPos: Vector3,
    endPos: Vector3,
    tension: number,
    segments: number = 10
  ): Vector3[] {
    const directDistance = startPos.distanceTo(endPos);

    // Si ligne tendue ou tr√®s courte, approximation lin√©aire suffit
    if (directDistance >= line.config.length * 0.98 || tension > 100) {
      return [startPos.clone(), endPos.clone()];
    }

    // Param√®tre de la cat√©naire : a = T / (œÅ √ó g)
    const rho = line.config.linearMassDensity;
    const a = tension / (rho * LinePhysics.GRAVITY);

    // Calcul sag maximal
    const sag = this.calculateCatenarySag(line, tension);

    const points: Vector3[] = [];

    for (let i = 0; i <= segments; i++) {
      const t = i / segments;

      // Position lin√©aire interpol√©e
      const point = new Vector3().lerpVectors(startPos, endPos, t);

      // Ajout de l'affaissement en Y (forme parabolique simplifi√©e)
      // Pour un vrai cosh, il faudrait transformer en coordonn√©es locales
      point.y -= sag * 4 * t * (1 - t); // Maximum au centre (t=0.5)

      points.push(point);
    }

    return points;
  }

  /**
   * Calcule l'√©nergie √©lastique stock√©e dans une ligne
   *
   * E = ¬Ω √ó k √ó Œîx¬≤
   *
   * @param line - Ligne √† analyser
   * @returns √ânergie en Joules
   */
  calculateElasticEnergy(line: Line): number {
    const extension = line.getExtension();
    return 0.5 * line.config.stiffness * extension * extension;
  }

  /**
   * Estime la fr√©quence propre d'oscillation de la ligne
   *
   * f ‚âà (1/2œÄ) √ó ‚àö(k/m_effective)
   *
   * @param line - Ligne √† analyser
   * @param attachedMass - Masse attach√©e au bout (kg)
   * @returns Fr√©quence en Hz
   */
  calculateNaturalFrequency(line: Line, attachedMass: number): number {
    if (attachedMass < LinePhysics.EPSILON) {
      return 0;
    }

    // Masse effective de la ligne (1/3 de la masse totale)
    const lineMass = line.config.linearMassDensity * line.config.length;
    const effectiveMass = attachedMass + lineMass / 3;

    const omega = Math.sqrt(line.config.stiffness / effectiveMass);
    const frequency = omega / (2 * Math.PI);

    return frequency;
  }

  /**
   * V√©rifie si la ligne est dans un √©tat physique valide
   *
   * @param line - Ligne √† valider
   * @returns true si valide, false sinon
   */
  validateLine(line: Line): boolean {
    const config = line.config;

    return (
      config.length > 0 &&
      config.stiffness > 0 &&
      config.preTension >= 0 &&
      config.maxTension > config.preTension &&
      config.dampingCoeff >= 0 &&
      config.dampingCoeff <= 1 &&
      config.linearMassDensity > 0
    );
  }
}


=== simulation/physics/LineSystem.ts ===

/**
 * LineSystem.ts - Orchestrateur du syst√®me de lignes du cerf-volant
 *
 * R√¥le :
 *   - Coordonne les lignes gauche/droite du syst√®me de pilotage
 *   - Calcule les tensions pour affichage/debug (pas de forces appliqu√©es)
 *   - Les contraintes de distance sont g√©r√©es par ConstraintSolver
 *
 * IMPORTANT : Les lignes sont des CONTRAINTES, pas des ressorts !
 *   - Elles RETIENNENT le kite (distance max)
 *   - Elles ne TIRENT PAS le kite vers le pilote
 *   - Le ConstraintSolver.enforceLineConstraints() g√®re la contrainte g√©om√©trique
 */
import * as THREE from "three";
import { Kite } from "@objects/organic/Kite";
import { Line } from "@objects/mechanical/Line";
import { LineFactory } from "@factories/LineFactory";

import { ControlBarManager } from "../controllers/ControlBarManager";
import { PhysicsConstants } from "../config/PhysicsConstants";

import { LinePhysics } from "./LinePhysics";

export class LineSystem {
  private leftLine: Line;
  private rightLine: Line;
  private physics: LinePhysics;
  private previousLeftKitePos: THREE.Vector3 | null = null;
  private previousRightKitePos: THREE.Vector3 | null = null;
  private previousLeftBarPos: THREE.Vector3 | null = null;
  private previousRightBarPos: THREE.Vector3 | null = null;

  constructor(lineLength?: number) {
    const [left, right] = LineFactory.createLinePair(lineLength);
    this.leftLine = left;
    this.rightLine = right;
    this.physics = new LinePhysics();
  }

  calculateLineTensions(
    kite: Kite,
    controlRotation: number,
    pilotPosition: THREE.Vector3
  ): {
    leftForce: THREE.Vector3;
    rightForce: THREE.Vector3;
    torque: THREE.Vector3;
  } {
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");
    if (!ctrlLeft || !ctrlRight) {
      return {
        leftForce: new THREE.Vector3(),
        rightForce: new THREE.Vector3(),
        torque: new THREE.Vector3(),
      };
    }

    const leftWorld = ctrlLeft.clone().applyQuaternion(kite.quaternion).add(kite.position);
    const rightWorld = ctrlRight.clone().applyQuaternion(kite.quaternion).add(kite.position);

    const tempControlBar = new ControlBarManager(pilotPosition);
    tempControlBar.setRotation(controlRotation);
    const handles = tempControlBar.getHandlePositions(kite.position);

    const leftVelocity = this.calculateVelocity(leftWorld, handles.left, this.previousLeftKitePos, this.previousLeftBarPos, 1 / 60);
    const rightVelocity = this.calculateVelocity(rightWorld, handles.right, this.previousRightKitePos, this.previousRightBarPos, 1 / 60);

    // Calculer tensions pour info/debug uniquement (pas de force appliqu√©e)
    const leftResult = this.physics.calculateTensionForce(this.leftLine, leftWorld, handles.left, leftVelocity);
    const rightResult = this.physics.calculateTensionForce(this.rightLine, rightWorld, handles.right, rightVelocity);

    // Mettre √† jour l'√©tat des lignes (pour affichage)
    this.leftLine.updateState(leftResult.currentLength, leftResult.tension, performance.now());
    this.rightLine.updateState(rightResult.currentLength, rightResult.tension, performance.now());

    // M√©moriser positions pour prochain frame
    this.previousLeftKitePos = leftWorld.clone();
    this.previousRightKitePos = rightWorld.clone();
    this.previousLeftBarPos = handles.left.clone();
    this.previousRightBarPos = handles.right.clone();

    // ‚ö†Ô∏è IMPORTANT : PAS DE FORCES NI DE COUPLE APPLIQU√âS
    // Les lignes sont des contraintes g√©om√©triques (ConstraintSolver)
    // Le kite est retenu √† distance max, pas tir√© vers le pilote
    return {
      leftForce: new THREE.Vector3(), // Force nulle
      rightForce: new THREE.Vector3(), // Force nulle
      torque: new THREE.Vector3(), // Couple nul
    };
  }

  private calculateVelocity(
    currentKite: THREE.Vector3,
    currentBar: THREE.Vector3,
    previousKite: THREE.Vector3 | null,
    previousBar: THREE.Vector3 | null,
    deltaTime: number
  ): THREE.Vector3 {
    if (!previousKite || !previousBar || deltaTime <= 0) {
      return new THREE.Vector3();
    }
    const kiteVelocity = new THREE.Vector3().subVectors(currentKite, previousKite).divideScalar(deltaTime);
    const barVelocity = new THREE.Vector3().subVectors(currentBar, previousBar).divideScalar(deltaTime);
    return new THREE.Vector3().subVectors(kiteVelocity, barVelocity);
  }

  private calculateTorque(
    ctrlLeft: THREE.Vector3,
    ctrlRight: THREE.Vector3,
    kiteQuaternion: THREE.Quaternion,
    leftForce: THREE.Vector3,
    rightForce: THREE.Vector3
  ): THREE.Vector3 {
    const totalTorque = new THREE.Vector3();
    if (leftForce.length() > PhysicsConstants.EPSILON) {
      const leftLever = ctrlLeft.clone().applyQuaternion(kiteQuaternion);
      const leftTorque = new THREE.Vector3().crossVectors(leftLever, leftForce);
      totalTorque.add(leftTorque);
    }
    if (rightForce.length() > PhysicsConstants.EPSILON) {
      const rightLever = ctrlRight.clone().applyQuaternion(kiteQuaternion);
      const rightTorque = new THREE.Vector3().crossVectors(rightLever, rightForce);
      totalTorque.add(rightTorque);
    }
    return totalTorque;
  }

  calculateCatenary(start: THREE.Vector3, end: THREE.Vector3, segments: number = PhysicsConstants.CATENARY_SEGMENTS): THREE.Vector3[] {
    const tension = this.leftLine.getCurrentTension();
    return this.physics.calculateCatenaryPoints(this.leftLine, start, end, tension, segments);
  }

  setLineLength(length: number): void {
    const [left, right] = LineFactory.createLinePair(length);
    this.leftLine = left;
    this.rightLine = right;
    this.previousLeftKitePos = null;
    this.previousRightKitePos = null;
    this.previousLeftBarPos = null;
    this.previousRightBarPos = null;
  }

  get lineLength(): number {
    return this.leftLine.config.length;
  }

  set lineLength(length: number) {
    this.setLineLength(length);
  }

  /**
   * Retourne les tensions actuelles des lignes gauche et droite
   * @returns Objet contenant les tensions en Newtons
   */
  getTensions(): { left: number; right: number } {
    return {
      left: this.leftLine.getCurrentTension(),
      right: this.rightLine.getCurrentTension()
    };
  }
}


=== simulation/physics/PhysicsEngine.ts ===

/**
 * PhysicsEngine.ts - Moteur physique principal de la simulation Kite
 *
 * R√¥le :
 *   - Orchestration de tou    // C      gravity,  // Gravit√© distribu√©e par surfacelcul des forces a√©rodynamiques et gravitationnelles distribu√©es calculs physiques du cerf-volant (vent, lignes, forces, contr√¥les)
 *   - Point d'entr√©e pour la boucle de simulation physique (appel√© √† chaque frame)
 *   - Centralise l'acc√®s aux sous-modules physiques
 *
 * D√©pendances principales :
 *   - WindSimulator.ts : Simulation du vent et turbulences
 *   - LineSystem.ts : Calcul des tensions et contraintes des lignes
 *   - AerodynamicsCalculator.ts : Calcul des forces a√©rodynamiques
 *   - KiteController.ts : Gestion de l'√©tat physique du cerf-volant
 *   - ControlBarManager.ts : Gestion de la barre de contr√¥le du pilote
 *   - SimulationConfig.ts : Param√®tres globaux de la simulation
 *   - Kite.ts : Mod√®le 3D et points anatomiques du cerf-volant
 *
 * Relation avec les fichiers adjacents :
 *   - Tous les fichiers du dossier 'physics' sont des sous-modules utilis√©s par PhysicsEngine
 *   - Les modules 'controllers' et 'objects' sont utilis√©s pour manipuler le kite et la barre
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage, appel√© √† chaque frame pour mettre √† jour la physique
 *   - Sert d'API centrale pour acc√©der √† l'√©tat physique du kite
 *
 * Voir aussi :
 *   - src/simulation/physics/WindSimulator.ts
 *   - src/simulation/physics/LineSystem.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/simulation/controllers/KiteController.ts
 *   - src/objects/organic/Kite.ts
 */
import * as THREE from "three";

import { Kite } from "../../objects/organic/Kite";
import { KiteController } from "../controllers/KiteController";
import { ControlBarManager } from "../controllers/ControlBarManager";
import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

import { WindSimulator } from "./WindSimulator";
import { LineSystem } from "./LineSystem";
import { BridleSystem } from "./BridleSystem";
import { AerodynamicsCalculator } from "./AerodynamicsCalculator";

/**
 * Moteur physique principal
 *
 * Orchestre toutes les simulations physiques du cerf-volant
 */
export class PhysicsEngine {
  private windSimulator: WindSimulator;
  private lineSystem: LineSystem;
  private bridleSystem: BridleSystem;
  private kiteController: KiteController;
  private controlBarManager: ControlBarManager;
  private lastLogTime: number = 0;
  private readonly LOG_INTERVAL: number = 1000; // Log toutes les 1000ms (1 seconde)
  private startTime: number = Date.now(); // Temps de d√©marrage pour elapsed time
  private frameCount: number = 0; // Compteur de frames

  constructor(kite: Kite, controlBarPosition: THREE.Vector3) {
    this.windSimulator = new WindSimulator();
    this.lineSystem = new LineSystem();
    this.bridleSystem = new BridleSystem(kite.getBridleLengths());
    this.kiteController = new KiteController(kite);
    this.controlBarManager = new ControlBarManager(controlBarPosition);
  }

  /**
   * LE C≈íUR DE LA SIMULATION - Appel√©e 60 fois par seconde
   *
   * C'est ici que tout se passe ! Cette fonction orchestre toute la physique.
   *
   * VOICI CE QUI SE PASSE √Ä CHAQUE INSTANT :
   * 1. On regarde comment la barre est tourn√©e
   * 2. On calcule o√π sont les mains du pilote
   * 3. On calcule le vent que ressent le kite
   * 4. On calcule toutes les forces :
   *    - Le vent qui pousse
   *    - Les lignes qui tirent
   *    - La gravit√© qui attire vers le bas
   * 5. On fait bouger le kite selon ces forces
   *
   * C'est comme une boucle infinie qui simule la r√©alit√© !
   */
  update(
    deltaTime: number,
    targetBarRotation: number,
    isPaused: boolean = false
  ): void {
    // Si en pause, ne rien faire
    if (isPaused) return;

    // Limiter le pas de temps pour √©viter l'instabilit√© num√©rique
    deltaTime = Math.min(deltaTime, CONFIG.physics.deltaTimeMax);

    // Appliquer directement la rotation de la barre (pas de lissage, d√©j√† g√©r√© par InputHandler)
    this.controlBarManager.setRotation(targetBarRotation);

    // R√©cup√©rer l'√©tat actuel du syst√®me
    const kite = this.kiteController.getKite();
    const handles = this.controlBarManager.getHandlePositions(kite.position);

    // Vent apparent = vent r√©el - vitesse du kite (principe de relativit√©)
    const kiteState = this.kiteController.getState();

    // üîç DEBUG: V√©rifier la vitesse du kite pour comprendre le vent apparent faible - DISABLED for performance


    const apparentWind = this.windSimulator.getApparentWind(
      kiteState.velocity,
      deltaTime
    );


    // ÔøΩ PHYSIQUE √âMERGENTE : Forces a√©ro + gravit√© distribu√©e calcul√©es par surface
    // - Chaque surface porte une fraction de la masse (fabric + frame + accessoires)
    // - Gravit√© appliqu√©e au centre g√©om√©trique de chaque surface
    // - Le couple gravitationnel √©merge naturellement de r √ó F_gravity
    // - Le couple total √©merge de la diff√©rence gauche/droite naturelle
    const {
      lift,
      drag,
      gravity,  // ÔøΩ RESTAUR√â : Gravit√© distribu√©e (plus r√©aliste physiquement)
      torque: totalTorque,  // Inclut d√©j√† couple a√©ro + couple gravitationnel !
    } = AerodynamicsCalculator.calculateForces(
      apparentWind, 
      kite.quaternion,
      kite.position,
      kiteState.velocity,
      kiteState.angularVelocity
    );

    // CALCUL DES TENSIONS (pour affichage/debug uniquement)
    // Les lignes ne TIRENT PAS le kite - elles le RETIENNENT √† distance max
    // La contrainte g√©om√©trique est appliqu√©e par ConstraintSolver dans KiteController
    const pilotPosition = this.controlBarManager.getPosition();
    this.lineSystem.calculateLineTensions(kite, this.controlBarManager.getRotation(), pilotPosition);

    // CALCUL DES TENSIONS DES BRIDES (pour affichage/debug uniquement)
    // Les brides sont des contraintes INTERNES au kite
    // Les contraintes g√©om√©triques sont appliqu√©es par ConstraintSolver.enforceBridleConstraints()
    const bridleTensions = this.bridleSystem.calculateBridleTensions(kite);

    // Incr√©menter le compteur de frames
    this.frameCount++;

    // üìä LOG COMPLET toutes les secondes
    const currentTime = Date.now();
    if (currentTime - this.lastLogTime >= this.LOG_INTERVAL) {
      this.lastLogTime = currentTime;

      // Calculs suppl√©mentaires pour le log
      const elapsedTime = (currentTime - this.startTime) / 1000; // en secondes
      const euler = new THREE.Euler().setFromQuaternion(kite.quaternion, 'XYZ');
      const pitch = euler.x * (180 / Math.PI); // Convertir en degr√©s
      const roll = euler.z * (180 / Math.PI);
      const yaw = euler.y * (180 / Math.PI);

      // Tensions des lignes
      const lineTensions = this.lineSystem.getTensions();

      // Acc√©l√©ration (approximation : F/m)
      const totalForceCalc = new THREE.Vector3().add(lift).add(drag).add(gravity);
      const acceleration = totalForceCalc.clone().divideScalar(CONFIG.kite.mass);

      // Ratio portance/tra√Æn√©e
      const liftMag = lift.length();
      const dragMag = drag.length();
      const ldRatio = dragMag > 0.01 ? liftMag / dragMag : 0;

      console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      console.log(`‚ïë üìä √âTAT COMPLET DU KITE - Frame #${this.frameCount.toString().padStart(6, '0')}                              ‚ïë`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë ‚è±Ô∏è  Temps: ${elapsedTime.toFixed(3)}s | Œît: ${(deltaTime * 1000).toFixed(2)}ms | FPS: ${(1/deltaTime).toFixed(1)}    ‚ïë`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë üìç POSITION & ORIENTATION                                                 ‚ïë`);
      console.log(`‚ïë    Position: (${kite.position.x.toFixed(2)}, ${kite.position.y.toFixed(2)}, ${kite.position.z.toFixed(2)}) m`);
      console.log(`‚ïë    Distance pilote: ${kite.position.length().toFixed(2)} m`);
      console.log(`‚ïë    Angles: Pitch ${pitch.toFixed(1)}¬∞ | Roll ${roll.toFixed(1)}¬∞ | Yaw ${yaw.toFixed(1)}¬∞`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë üöÄ CIN√âMATIQUE                                                            ‚ïë`);
      console.log(`‚ïë    Vitesse: (${kiteState.velocity.x.toFixed(2)}, ${kiteState.velocity.y.toFixed(2)}, ${kiteState.velocity.z.toFixed(2)}) m/s | Mag: ${kiteState.velocity.length().toFixed(2)} m/s`);
      console.log(`‚ïë    Acc√©l√©ration: (${acceleration.x.toFixed(2)}, ${acceleration.y.toFixed(2)}, ${acceleration.z.toFixed(2)}) m/s¬≤ | Mag: ${acceleration.length().toFixed(2)} m/s¬≤`);
      console.log(`‚ïë    Vit. angulaire: (${kiteState.angularVelocity.x.toFixed(2)}, ${kiteState.angularVelocity.y.toFixed(2)}, ${kiteState.angularVelocity.z.toFixed(2)}) rad/s | Mag: ${kiteState.angularVelocity.length().toFixed(2)} rad/s`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë üí® A√âRODYNAMIQUE                                                          ‚ïë`);
      console.log(`‚ïë    Vent apparent: (${apparentWind.x.toFixed(2)}, ${apparentWind.y.toFixed(2)}, ${apparentWind.z.toFixed(2)}) m/s | Mag: ${apparentWind.length().toFixed(2)} m/s`);
      console.log(`‚ïë    Portance: (${lift.x.toFixed(2)}, ${lift.y.toFixed(2)}, ${lift.z.toFixed(2)}) N | Mag: ${liftMag.toFixed(2)} N`);
      console.log(`‚ïë    Tra√Æn√©e: (${drag.x.toFixed(2)}, ${drag.y.toFixed(2)}, ${drag.z.toFixed(2)}) N | Mag: ${dragMag.toFixed(2)} N`);
      console.log(`‚ïë    Ratio L/D: ${ldRatio.toFixed(2)}`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë ‚öñÔ∏è  FORCES & COUPLES                                                       ‚ïë`);
      console.log(`‚ïë    Gravit√©: (${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}, ${gravity.z.toFixed(2)}) N | Mag: ${gravity.length().toFixed(2)} N`);
      console.log(`‚ïë    Force totale: (${totalForceCalc.x.toFixed(2)}, ${totalForceCalc.y.toFixed(2)}, ${totalForceCalc.z.toFixed(2)}) N | Mag: ${totalForceCalc.length().toFixed(2)} N`);
      console.log(`‚ïë    Couple total: (${totalTorque.x.toFixed(2)}, ${totalTorque.y.toFixed(2)}, ${totalTorque.z.toFixed(2)}) N‚ãÖm | Mag: ${totalTorque.length().toFixed(2)} N‚ãÖm`);
      console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
      console.log(`‚ïë ü™¢ TENSIONS                                                                ‚ïë`);
      console.log(`‚ïë    Ligne gauche: ${lineTensions.left.toFixed(2)} N | Ligne droite: ${lineTensions.right.toFixed(2)} N`);
      console.log(`‚ïë    Asym√©trie: ${(lineTensions.left - lineTensions.right).toFixed(2)} N (${((lineTensions.left - lineTensions.right) / Math.max(lineTensions.left, lineTensions.right) * 100).toFixed(1)}%)`);
      console.log(`‚ïë    Brides: NEZ L/R: ${bridleTensions.leftNez.toFixed(1)}/${bridleTensions.rightNez.toFixed(1)} N`);
      console.log(`‚ïë            INTER L/R: ${bridleTensions.leftInter.toFixed(1)}/${bridleTensions.rightInter.toFixed(1)} N`);
      console.log(`‚ïë            CENTRE L/R: ${bridleTensions.leftCentre.toFixed(1)}/${bridleTensions.rightCentre.toFixed(1)} N`);
      console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
    }

    // Mettre √† jour la visualisation des brides selon leurs tensions
    kite.updateBridleVisualization(bridleTensions);

    // Somme vectorielle des forces (2√®me loi de Newton : F = ma)
    const totalForce = new THREE.Vector3()
      .add(lift)     // Portance a√©rodynamique (perpendiculaire au vent)
      .add(drag)     // Tra√Æn√©e a√©rodynamique (parall√®le au vent)
      .add(gravity); // Gravit√© distribu√©e (d√©j√† calcul√©e par surface)
      // PAS de forces de lignes - elles sont des contraintes g√©om√©triques

    // Couple total = moment a√©rodynamique + moment gravitationnel (√©mergent)
    // Les lignes n'appliquent PAS de couple - elles contraignent la position
    // L'orientation √©merge de l'√©quilibre des forces distribu√©es + contraintes

    // Int√©gration physique : F=ma et T=IŒ± pour calculer nouvelle position/orientation
    this.kiteController.update(totalForce, totalTorque, handles, deltaTime);
  }

  setBridleFactor(_factor: number): void {
    // Fonctionnalit√© d√©sactiv√©e dans V8 - physique √©mergente pure
  }

  /**
   * Ajuste une longueur de bride physique (en m√®tres)
   * @param bridleName - 'nez', 'inter' ou 'centre'
   * @param length - longueur en m√®tres
   */
  setBridleLength(bridleName: 'nez' | 'inter' | 'centre', length: number): void {
    this.kiteController.getKite().setBridleLengths({ [bridleName]: length });
  }

  setWindParams(params: Partial<WindParams>): void {
    this.windSimulator.setParams(params);
  }

  setLineLength(length: number): void {
    this.lineSystem.setLineLength(length);
    this.kiteController.setLineLength(length);
  }

  getKiteController(): KiteController {
    return this.kiteController;
  }

  getWindSimulator(): WindSimulator {
    return this.windSimulator;
  }

  getLineSystem(): LineSystem {
    return this.lineSystem;
  }

  getControlBarManager(): ControlBarManager {
    return this.controlBarManager;
  }

  /**
   * Retourne les longueurs actuelles des brides du kite
   */
  getBridleLengths() {
    return this.kiteController.getKite().getBridleLengths();
  }

  /**
   * D√©finit le taux de lissage des forces (en 1/s)
   */
  setForceSmoothing(rate: number): void {
    this.kiteController.setForceSmoothing(rate);
  }

  /**
   * Retourne le taux de lissage des forces actuel
   */
  getForceSmoothing(): number {
    return this.kiteController.getForceSmoothing();
  }
}

=== simulation/physics/WindSimulator.ts ===

/**
 * WindSimulator.ts - Simulateur de vent et turbulences pour la simulation Kite
 *
 * R√¥le :
 *   - G√©n√®re le vent et ses variations (direction, vitesse, turbulence)
 *   - Fournit le vent apparent ressenti par le cerf-volant
 *   - Sert de source d'environnement pour la physique et le rendu
 *
 * D√©pendances principales :
 *   - SimulationConfig.ts : Param√®tres de vent et turbulence
 *   - Types/WindTypes.ts : Typage des param√®tres de vent
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsEngine.ts : Utilise WindSimulator pour obtenir le vent √† chaque frame
 *   - Les autres modules du dossier 'physics' utilisent le vent pour calculer les forces
 *
 * Utilisation typique :
 *   - Instanci√© par PhysicsEngine, appel√© pour obtenir le vent local ou global
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";

import { WindParams } from "../types";
import { CONFIG } from "../config/SimulationConfig";

/**
 * Simulateur de vent et turbulences
 *
 * G√®re le vent et ses variations pour cr√©er des conditions r√©alistes
 */
export class WindSimulator {
  private params: WindParams;
  private time: number = 0; // Compteur de temps pour faire varier les turbulences
  private windSpeedMs: number = 0;
  private windRad: number = 0;

  constructor() {
    // On d√©marre avec les r√©glages par d√©faut du vent
    this.params = {
      speed: CONFIG.wind.defaultSpeed,
      direction: CONFIG.wind.defaultDirection,
      turbulence: CONFIG.wind.defaultTurbulence,
    };
    this.updateWindInternals();
  }

  private updateWindInternals(): void {
    this.windSpeedMs = this.params.speed / 3.6;
    this.windRad = (this.params.direction * Math.PI) / 180;
  }

  /**
   * Calcule les turbulences du vent
   * M√©thode extraite pour √©viter la duplication de code
   */
  private calculateTurbulence(baseWindVector: THREE.Vector3): THREE.Vector3 {
    if (this.params.turbulence <= 0) {
      return baseWindVector.clone();
    }

    const turbIntensity =
      (this.params.turbulence / 100) * CONFIG.wind.turbulenceScale;
    const freq = CONFIG.wind.turbulenceFreqBase;

    const turbulenceVector = baseWindVector.clone();

    // Utiliser des sinus pour cr√©er des variations douces et naturelles
    turbulenceVector.x +=
      Math.sin(this.time * freq) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;
    turbulenceVector.y +=
      Math.sin(this.time * freq * CONFIG.wind.turbulenceFreqY) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityY;
    turbulenceVector.z +=
      Math.cos(this.time * freq * CONFIG.wind.turbulenceFreqZ) *
      this.windSpeedMs *
      turbIntensity *
      CONFIG.wind.turbulenceIntensityXZ;

    return turbulenceVector;
  }

  /**
   * Calcule le vent que "ressent" le cerf-volant
   * C'est comme quand vous mettez la main par la fen√™tre d'une voiture :
   * - Si la voiture roule vite, vous sentez plus de vent
   * - Si vous allez contre le vent, il est plus fort
   * - Si vous allez avec le vent, il est plus faible
   */
  getApparentWind(
    kiteVelocity: THREE.Vector3,
    deltaTime: number
  ): THREE.Vector3 {
    this.time += deltaTime;

    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    const windVector = this.calculateTurbulence(baseWindVector);

    // Le vent apparent = vent r√©el - vitesse du kite
    // Si le kite va vite vers l'avant, il "cr√©e" du vent de face
    const apparent = windVector.clone().sub(kiteVelocity);

    // üîç DEBUG: V√©rifier le calcul du vent apparent - DISABLED for performance
    // console.log(`üîç WIND CALC: Real wind (${windVector.x.toFixed(2)}, ${windVector.y.toFixed(2)}, ${windVector.z.toFixed(2)}) = ${windVector.length().toFixed(2)} m/s | Kite vel (${kiteVelocity.x.toFixed(2)}, ${kiteVelocity.y.toFixed(2)}, ${kiteVelocity.z.toFixed(2)}) = ${kiteVelocity.length().toFixed(2)} m/s | Apparent (${apparent.x.toFixed(2)}, ${apparent.y.toFixed(2)}, ${apparent.z.toFixed(2)}) = ${apparent.length().toFixed(2)} m/s`);

    return apparent;
  }

  /**
   * Obtient le vecteur de vent √† une position donn√©e
   */
  getWindAt(_position: THREE.Vector3): THREE.Vector3 {
    const baseWindVector = new THREE.Vector3(
      Math.sin(this.windRad) * this.windSpeedMs,
      0,
      -Math.cos(this.windRad) * this.windSpeedMs
    );

    return this.calculateTurbulence(baseWindVector);
  }

  setParams(params: Partial<WindParams>): void {
    Object.assign(this.params, params);
    this.updateWindInternals();
  }

  getParams(): WindParams {
    return { ...this.params };
  }
}

=== simulation/rendering/DebugRenderer.ts ===

/**
 * DebugRenderer.ts - Gestionnaire du rendu de debug pour la simulation Kite
 *
 * R√¥le :
 *   - Affiche visuellement les forces physiques (portance, tra√Æn√©e, friction, r√©sultante) et la vitesse du cerf-volant
 *   - Met √† jour le panneau d'informations de debug (HTML)
 *   - Permet d'activer/d√©sactiver le mode debug et de g√©rer l'affichage des vecteurs
 *
 * D√©pendances principales :
 *   - RenderManager.ts : Ajoute/retire les objets de debug √† la sc√®ne Three.js
 *   - PhysicsEngine.ts : R√©cup√®re l'√©tat physique du cerf-volant et les forces calcul√©es
 *   - AerodynamicsCalculator.ts : Calcule les forces a√©rodynamiques sur chaque surface du kite
 *   - Kite.ts : Acc√®s √† la g√©om√©trie et aux points anatomiques du cerf-volant
 *   - PhysicsConstants.ts, SimulationConfig.ts : Param√®tres physiques et configuration
 *   - Types : Utilise SurfaceForce, KiteState pour typer les donn√©es physiques
 *
 * Relation avec les fichiers adjacents :
 *   - RenderManager.ts : Fichier adjacent direct, g√®re la sc√®ne 3D et l'environnement visuel. DebugRenderer utilise RenderManager pour afficher les fl√®ches de debug.
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec RenderManager.
 *
 * Utilisation typique :
 *   - Instanci√© dans la boucle de simulation pour afficher les vecteurs de forces et la vitesse du kite
 *   - Interagit avec le DOM pour afficher les infos de debug
 *
 * Voir aussi :
 *   - src/simulation/physics/PhysicsEngine.ts
 *   - src/simulation/physics/AerodynamicsCalculator.ts
 *   - src/objects/organic/Kite.ts
 *   - src/simulation/rendering/RenderManager.ts
 */
import * as THREE from "three";
import { Primitive } from "@core/Primitive";

import { Kite } from "../../objects/organic/Kite";
import { KiteState, SurfaceForce } from "../types";
import { PhysicsEngine } from "../physics/PhysicsEngine";
import { AerodynamicsCalculator } from "../physics/AerodynamicsCalculator";
import { PhysicsConstants } from "../config/PhysicsConstants";
import { CONFIG } from "../config/SimulationConfig";
import { KiteGeometry } from "../config/KiteGeometry";

import { RenderManager } from "./RenderManager";

/**
 * Palette de couleurs am√©lior√©e pour les vecteurs de debug
 */
const DEBUG_COLORS = {
  // Vecteurs de mouvement
  velocity: 0x00ff00,        // Vert vif - Vitesse du kite
  apparentWind: 0x00ffff,    // Cyan - Vent apparent

  // Forces globales
  globalLift: 0x4169e1,      // Bleu royal - Portance globale
  globalResultant: 0xffffff, // Blanc - R√©sultante globale

  // Forces par surface
  surfaceLift: 0x00bfff,     // Bleu ciel profond - Portance locale
  surfaceDrag: 0xff4444,     // Rouge vif - Tra√Æn√©e
  surfaceFriction: 0xaaaaaa, // Gris moyen - Friction
  surfaceResultant: 0xffdd00,// Jaune vif - R√©sultante locale
  
  // Masse distribu√©e
  surfaceMass: 0xff00ff,     // Magenta - Force gravitationnelle par surface
};

/**
 * Tailles des vecteurs pour meilleure lisibilit√©
 */
const VECTOR_SCALES = {
  velocity: 0.6,
  apparentWind: 0.5,
  globalLift: 0.25,
  globalResultant: 0.35,
  surfaceLift: 0.35,
  surfaceDrag: 0.35,
  surfaceFriction: 0.25,
  surfaceResultant: 0.45,
  surfaceMass: 3.0,  // Amplifier pour visibilit√© (gravit√© ~0.8N par surface)
};

/**
 * Configuration des t√™tes de fl√®ches pour un rendu plus fin et pr√©cis
 */
const ARROW_HEAD_CONFIG = {
  // Grandes fl√®ches (vitesse, vent apparent, r√©sultantes)
  large: {
    headLength: 0.15,  // Longueur de la t√™te de fl√®che
    headWidth: 0.12,   // Largeur de la t√™te de fl√®che
  },
  // Fl√®ches moyennes (forces globales)
  medium: {
    headLength: 0.12,
    headWidth: 0.09,
  },
  // Petites fl√®ches (forces par surface)
  small: {
    headLength: 0.10,
    headWidth: 0.07,
  },
  // Tr√®s petites fl√®ches (friction)
  tiny: {
    headLength: 0.08,
    headWidth: 0.06,
  },
};

/**
 * Gestionnaire du rendu de debug
 *
 * Affiche les forces, vitesses et informations de debug
 */
/**
 * Configuration des vecteurs visibles
 */
interface VectorVisibility {
  velocity: boolean;
  apparentWind: boolean;
  globalForces: boolean;
  surfaceForces: boolean;
  surfaceMass: boolean;  // Afficher forces gravitationnelles distribu√©es
}

export class DebugRenderer {
  private renderManager: RenderManager;
  private debugArrows: THREE.ArrowHelper[] = [];
  private debugMode: boolean;
  private vectorVisibility: VectorVisibility = {
    velocity: true,
    apparentWind: true,
    globalForces: true,
    surfaceForces: true,
    surfaceMass: false,  // D√©sactiv√© par d√©faut (peut surcharger l'affichage)
  };

  constructor(renderManager: RenderManager) {
    this.renderManager = renderManager;
    this.debugMode = CONFIG.debugVectors === true;
    this.setupDebugControls();
  }

  isDebugMode(): boolean {
    return this.debugMode;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;

    const debugBtn = document.getElementById("debug-physics");
    const debugPanel = document.getElementById("debug-panel");

    if (debugBtn) {
      debugBtn.textContent = this.debugMode ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugMode);
    }

    if (debugPanel) {
      debugPanel.style.display = this.debugMode ? "block" : "none";
    }

    document.body.classList.toggle("debug-mode", this.debugMode);

    if (!this.debugMode) {
      this.clearDebugArrows();
    }
  }

  toggleDebugMode(): void {
    this.setDebugMode(!this.debugMode);
  }

  /**
   * Configure le panneau de contr√¥le des vecteurs de debug
   */
  private setupDebugControls(): void {
    // Trouver ou cr√©er le conteneur de contr√¥les
    let controlsContainer = document.getElementById("debug-vector-controls");

    if (!controlsContainer) {
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        controlsContainer = document.createElement("div");
        controlsContainer.id = "debug-vector-controls";
        controlsContainer.style.cssText = `
          margin-top: 15px;
          padding-top: 15px;
          border-top: 1px solid rgba(255,255,255,0.2);
        `;

        controlsContainer.innerHTML = `
          <strong style="display: block; margin-bottom: 10px;">üé® Vecteurs visibles:</strong>
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-velocity" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ff00;">‚óè</span> Vitesse kite
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-apparent-wind" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #00ffff;">‚óè</span> Vent apparent
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-global-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #4169e1;">‚óè</span> Forces globales
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-forces" checked style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ffdd00;">‚óè</span> Forces surfaces
            </label>
            <label style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="toggle-surface-mass" style="margin-right: 8px; cursor: pointer;">
              <span style="color: #ff00ff;">‚óè</span> Masse distribu√©e
            </label>
          </div>
        `;

        debugPanel.appendChild(controlsContainer);

        // Ajouter les event listeners
        document.getElementById("toggle-velocity")?.addEventListener("change", (e) => {
          this.vectorVisibility.velocity = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-apparent-wind")?.addEventListener("change", (e) => {
          this.vectorVisibility.apparentWind = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-global-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.globalForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-forces")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceForces = (e.target as HTMLInputElement).checked;
        });

        document.getElementById("toggle-surface-mass")?.addEventListener("change", (e) => {
          this.vectorVisibility.surfaceMass = (e.target as HTMLInputElement).checked;
        });
      }
    }
  }

  clearDebugArrows(): void {
    this.debugArrows.forEach((arrow) => {
      this.renderManager.removeObject(arrow);
    });
    this.debugArrows = [];
  }

  updateDebugArrows(kite: Kite, physicsEngine: PhysicsEngine): void {
    if (!this.debugMode) return;

    this.clearDebugArrows();

    const kiteState = physicsEngine.getKiteController().getState();
    const kitePosition = kite.position.clone();

    // Calculer le centre g√©om√©trique entre NEZ et SPINE_BAS
    const centerLocal = new THREE.Vector3(0, 0.325, 0);
    const centerWorld = kite.localToWorld(centerLocal.clone());

    // Vecteur de vitesse du kite (vert vif)
    if (this.vectorVisibility.velocity && kiteState.velocity.length() > CONFIG.debug.minVelocityDisplay) {
      const velocityArrow = Primitive.arrow(
        kiteState.velocity.clone().normalize(),
        centerWorld,
        kiteState.velocity.length() * VECTOR_SCALES.velocity,
        DEBUG_COLORS.velocity,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(velocityArrow);
      this.debugArrows.push(velocityArrow);
    }

    const windSim = physicsEngine.getWindSimulator();
    const wind = windSim.getWindAt(kitePosition);
    const relativeWind = wind.clone().sub(kiteState.velocity);

    // Vecteur de vent apparent (cyan)
    if (this.vectorVisibility.apparentWind && relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const apparentWindArrow = Primitive.arrow(
        relativeWind.clone().normalize(),
        centerWorld,
        relativeWind.length() * VECTOR_SCALES.apparentWind,
        DEBUG_COLORS.apparentWind,
        ARROW_HEAD_CONFIG.large.headLength,
        ARROW_HEAD_CONFIG.large.headWidth
      );
      this.renderManager.addObject(apparentWindArrow);
      this.debugArrows.push(apparentWindArrow);
    }

    if (relativeWind.length() > CONFIG.debug.minVelocityDisplay) {
      const { lift, drag, surfaceForces } = AerodynamicsCalculator.calculateForces(
        relativeWind,
        kite.quaternion
      );

      // Forces globales (si activ√©)
      if (this.vectorVisibility.globalForces) {
        // Portance globale (bleu royal)
        if (lift.length() > CONFIG.debug.minVectorLength) {
          const liftArrow = Primitive.arrow(
            lift.clone().normalize(),
            centerWorld,
            Math.sqrt(lift.length()) * VECTOR_SCALES.globalLift,
            DEBUG_COLORS.globalLift,
            ARROW_HEAD_CONFIG.medium.headLength,
            ARROW_HEAD_CONFIG.medium.headWidth
          );
          this.renderManager.addObject(liftArrow);
          this.debugArrows.push(liftArrow);
        }

        // R√©sultante globale (blanc) - somme de toutes les surfaces
        const globalResultant = surfaceForces.reduce((sum, sf) => sum.add(sf.resultant.clone()), new THREE.Vector3());
        if (globalResultant.length() > CONFIG.debug.minVectorLength) {
          const resultantArrow = Primitive.arrow(
            globalResultant.clone().normalize(),
            centerWorld,
            Math.sqrt(globalResultant.length()) * VECTOR_SCALES.globalResultant,
            DEBUG_COLORS.globalResultant,
            ARROW_HEAD_CONFIG.large.headLength,
            ARROW_HEAD_CONFIG.large.headWidth
          );
          this.renderManager.addObject(resultantArrow);
          this.debugArrows.push(resultantArrow);
        }
      }

      // Afficher les forces par surface (si activ√©)
      if (this.vectorVisibility.surfaceForces) {
        this.displaySurfaceForces(surfaceForces, kite);
      }

      // Afficher les vecteurs de masse distribu√©e (si activ√©)
      if (this.vectorVisibility.surfaceMass) {
        this.displaySurfaceMass(kite);
      }

      this.updateDebugDisplay(kiteState, kitePosition, { lift, drag }, physicsEngine);
    }
  }

  private updateDebugDisplay(
    kiteState: KiteState,
    kitePosition: THREE.Vector3,
    forces: { lift: THREE.Vector3; drag: THREE.Vector3 },
    physicsEngine: PhysicsEngine
  ): void {
    const debugInfo = document.getElementById("debug-info");
    if (!debugInfo || !this.debugMode) return;

    const { lift, drag } = forces;

    // Calcul des tensions des lignes
    const lineLength = physicsEngine.getLineSystem().lineLength;
    const handles = physicsEngine
      .getControlBarManager()
      .getHandlePositions(kitePosition);

    const kite = physicsEngine.getKiteController().getKite();
    const ctrlLeft = kite.getPoint("CTRL_GAUCHE");
    const ctrlRight = kite.getPoint("CTRL_DROIT");

    let tensionInfo = "N/A";
    if (ctrlLeft && ctrlRight) {
      const kiteLeftWorld = ctrlLeft.clone();
      const kiteRightWorld = ctrlRight.clone();
      kite.localToWorld(kiteLeftWorld);
      kite.localToWorld(kiteRightWorld);

      const distL = kiteLeftWorld.distanceTo(handles.left);
      const distR = kiteRightWorld.distanceTo(handles.right);
      const tautL = distL >= lineLength - PhysicsConstants.CONTROL_DEADZONE;
      const tautR = distR >= lineLength - PhysicsConstants.CONTROL_DEADZONE;

      tensionInfo = `L:${tautL ? "TENDU" : "REL√ÇCH√â"}(${distL.toFixed(2)}m) R:${
        tautR ? "TENDU" : "REL√ÇCH√â"
      }(${distR.toFixed(2)}m)`;
    }

    // Informations du vent
    const windParams = physicsEngine.getWindSimulator().getParams();

    // Assemblage des informations de debug
    const totalForce = Math.sqrt(lift.lengthSq() + drag.lengthSq());

    debugInfo.innerHTML = `
            <strong>ü™Å Position Cerf-volant:</strong><br>
            X: ${kitePosition.x.toFixed(2)}m, Y: ${kitePosition.y.toFixed(
      2
    )}m, Z: ${kitePosition.z.toFixed(2)}m<br><br>

            <strong>üí® Vent:</strong><br>
            Vitesse: ${windParams.speed.toFixed(1)} km/h<br>
            Direction: ${windParams.direction.toFixed(0)}¬∞<br>
            Turbulence: ${windParams.turbulence.toFixed(1)}%<br><br>

            <strong>‚ö° Forces A√©rodynamiques:</strong><br>
            Portance: ${lift.length().toFixed(3)} N<br>
            Tra√Æn√©e: ${drag.length().toFixed(3)} N<br>
            Force Totale: ${totalForce.toFixed(3)} N<br><br>

            <strong>üîó Tensions Lignes:</strong><br>
            ${tensionInfo}<br><br>

            <strong>üèÉ Vitesse Cerf-volant:</strong><br>
            ${kiteState.velocity.length().toFixed(2)} m/s<br><br>

            <strong>‚öôÔ∏è Performance:</strong><br>
            Statut: <span style="color: #00ff88;">STABLE</span>
        `;
  }

  /**
   * Affiche une fl√®che de force pour chaque surface du kite
   */
  private displaySurfaceForces(surfaceForces: SurfaceForce[], kite: Kite): void {
    const colorPalette = [
      0xff6b6b, // Rouge - Surface 0 (haute gauche)
      0x51cf66, // Vert - Surface 1 (basse gauche) 
      0x667eea, // Bleu - Surface 2 (haute droite)
      0xff9f43, // Orange - Surface 3 (basse droite)
    ];

    surfaceForces.forEach((surfaceForce) => {
      const { lift, drag, friction, resultant, center, surfaceIndex } = surfaceForce;
      const centerWorld = center.clone();
      kite.localToWorld(centerWorld);

      // Portance locale (bleu ciel profond)
      if (lift.length() > CONFIG.debug.minVectorLength) {
        const liftArrow = Primitive.arrow(
          lift.clone().normalize(),
          centerWorld,
          Math.sqrt(lift.length()) * VECTOR_SCALES.surfaceLift,
          DEBUG_COLORS.surfaceLift,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(liftArrow);
        this.debugArrows.push(liftArrow);
      }

      // Tra√Æn√©e (rouge vif)
      if (drag.length() > CONFIG.debug.minVectorLength) {
        const dragArrow = Primitive.arrow(
          drag.clone().normalize(),
          centerWorld,
          Math.sqrt(drag.length()) * VECTOR_SCALES.surfaceDrag,
          DEBUG_COLORS.surfaceDrag,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(dragArrow);
        this.debugArrows.push(dragArrow);
      }

      // Friction (gris moyen)
      if (friction && friction.length() > CONFIG.debug.minVectorLength) {
        const frictionArrow = Primitive.arrow(
          friction.clone().normalize(),
          centerWorld,
          Math.sqrt(friction.length()) * VECTOR_SCALES.surfaceFriction,
          DEBUG_COLORS.surfaceFriction,
          ARROW_HEAD_CONFIG.tiny.headLength,
          ARROW_HEAD_CONFIG.tiny.headWidth
        );
        this.renderManager.addObject(frictionArrow);
        this.debugArrows.push(frictionArrow);
      }

      // R√©sultante locale (jaune vif)
      if (resultant.length() > CONFIG.debug.minVectorLength) {
        const resultantArrow = Primitive.arrow(
          resultant.clone().normalize(),
          centerWorld,
          Math.sqrt(resultant.length()) * VECTOR_SCALES.surfaceResultant,
          DEBUG_COLORS.surfaceResultant,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(resultantArrow);
        this.debugArrows.push(resultantArrow);
      }
    });
  }

  /**
   * Affiche les vecteurs de force gravitationnelle pour chaque surface
   * Visualise la masse distribu√©e (physique √©mergente)
   */
  private displaySurfaceMass(kite: Kite): void {
    // Pour chaque surface avec sa masse
    KiteGeometry.SURFACES_WITH_MASS.forEach((surface: any, surfaceIndex: number) => {
      // Centre g√©om√©trique de la surface (coordonn√©es locales)
      const centre = KiteGeometry.calculateTriangleCentroid(
        surface.vertices[0],
        surface.vertices[1], 
        surface.vertices[2]
      );

      // Transformer en coordonn√©es monde
      const centerWorld = kite.localToWorld(centre.clone());

      // Force gravitationnelle = m √ó g (vers le bas)
      const gravityForce = new THREE.Vector3(0, -surface.mass * CONFIG.physics.gravity, 0);
      const forceMagnitude = gravityForce.length();

      // Afficher fl√®che magenta pointant vers le bas
      if (forceMagnitude > CONFIG.debug.minVectorLength) {
        const gravityArrow = Primitive.arrow(
          gravityForce.clone().normalize(),
          centerWorld,
          forceMagnitude * VECTOR_SCALES.surfaceMass,
          DEBUG_COLORS.surfaceMass,
          ARROW_HEAD_CONFIG.small.headLength,
          ARROW_HEAD_CONFIG.small.headWidth
        );
        this.renderManager.addObject(gravityArrow);
        this.debugArrows.push(gravityArrow);

        // Optionnel : Ajouter une sph√®re pour montrer la masse
        // Taille proportionnelle √† la masse
        const sphereRadius = surface.mass * 0.2; // 0.2m pour 1kg
        const massIndicator = new THREE.Mesh(
          new THREE.SphereGeometry(sphereRadius, 8, 8),
          new THREE.MeshBasicMaterial({
            color: DEBUG_COLORS.surfaceMass,
            transparent: true,
            opacity: 0.3,
            wireframe: true
          })
        );
        massIndicator.position.copy(centerWorld);
        this.renderManager.addObject(massIndicator);
        this.debugArrows.push(massIndicator as any); // Pour cleanup
      }
    });
  }
}



=== simulation/rendering/RenderManager.ts ===

/**
 * RenderManager.ts - Gestionnaire du rendu 3D pour la simulation Kite
 *
 * R√¥le :
 *   - G√®re la sc√®ne Three.js, la cam√©ra, le rendu et l'environnement visuel (ciel, sol, nuages, lumi√®res)
 *   - Ajoute et retire dynamiquement des objets 3D (cerf-volant, fl√®ches de debug, etc.)
 *   - Fournit l'API pour le rendu et la gestion de la sc√®ne
 *
 * D√©pendances principales :
 *   - Three.js : Moteur de rendu 3D
 *   - SimulationConfig.ts : Param√®tres de configuration du rendu (fog, ombres, etc.)
 *
 * Relation avec les fichiers adjacents :
 *   - DebugRenderer.ts : Fichier adjacent direct, utilise RenderManager pour afficher les vecteurs de debug (fl√®ches de forces, vitesse, etc.)
 *   - Les autres fichiers du dossier 'rendering' sont absents, la relation est donc principalement avec DebugRenderer.
 *
 * Utilisation typique :
 *   - Instanci√© au d√©marrage de la simulation pour initialiser la sc√®ne et le rendu
 *   - Utilis√© par DebugRenderer pour ajouter/retirer des objets de debug
 *
 * Voir aussi :
 *   - src/simulation/rendering/DebugRenderer.ts
 *   - src/simulation/config/SimulationConfig.ts
 */
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

import { CONFIG } from "../config/SimulationConfig";

/**
 * Gestionnaire du rendu 3D
 *
 * G√®re la sc√®ne 3D, la cam√©ra, le rendu et l'environnement visuel
 */
export class RenderManager {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.Fog(
      0x87ceeb,
      CONFIG.rendering.fogStart,
      CONFIG.rendering.fogEnd
    );

    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(3, 5, 12);
    this.camera.lookAt(0, 3, -5);

    this.renderer = new THREE.WebGLRenderer({
      antialias: CONFIG.rendering.antialias,
      alpha: true,
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
    this.controls.maxDistance = 50;
    this.controls.minDistance = 2;

    this.setupEnvironment();
    window.addEventListener("resize", () => this.onResize());
  }

  private setupEnvironment(): void {
    // Cr√©ation d'un beau ciel d√©grad√©
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel profond
        bottomColor: { value: new THREE.Color(0x87ceeb) }, // Bleu ciel plus clair
        offset: { value: 400 },
        exponent: { value: 0.6 },
      },
      side: THREE.BackSide,
    });

    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);

    // Ajout de quelques nuages pour plus de r√©alisme
    this.addClouds();

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 50, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    sunLight.shadow.mapSize.width = CONFIG.rendering.shadowMapSize;
    sunLight.shadow.mapSize.height = CONFIG.rendering.shadowMapSize;
    this.scene.add(sunLight);

    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    this.scene.add(ground);

    const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
    this.scene.add(gridHelper);
  }

  private addClouds(): void {
    // Cr√©ation de quelques nuages simples et r√©alistes
    const cloudGroup = new THREE.Group();

    // Mat√©riau pour les nuages - blanc semi-transparent
    const cloudMaterial = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7,
    });

    // Cr√©ation de plusieurs nuages √† diff√©rentes positions
    for (let i = 0; i < 8; i++) {
      const cloud = new THREE.Group();

      // Chaque nuage est compos√© de plusieurs sph√®res pour un aspect naturel
      for (let j = 0; j < 5; j++) {
        const cloudPart = new THREE.Mesh(
          new THREE.SphereGeometry(Math.random() * 4 + 2, 6, 4),
          cloudMaterial
        );

        cloudPart.position.x = Math.random() * 10 - 5;
        cloudPart.position.y = Math.random() * 2 - 1;
        cloudPart.position.z = Math.random() * 10 - 5;
        cloudPart.scale.setScalar(Math.random() * 0.5 + 0.5);

        cloud.add(cloudPart);
      }

      // Position des nuages dans le ciel
      cloud.position.set(
        (Math.random() - 0.5) * 200, // X: -100 √† 100
        Math.random() * 30 + 20, // Y: 20 √† 50 (hauteur dans le ciel)
        (Math.random() - 0.5) * 200 // Z: -100 √† 100
      );

      cloudGroup.add(cloud);
    }

    this.scene.add(cloudGroup);
  }

  addObject(object: THREE.Object3D): void {
    this.scene.add(object);
  }

  removeObject(object: THREE.Object3D): void {
    this.scene.remove(object);
  }

  render(): void {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  private onResize(): void {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  getScene(): THREE.Scene {
    return this.scene;
  }
}

=== simulation/types/BridleTypes.ts ===

/**
 * BridleTypes.ts - Types et interfaces pour le syst√®me de bridage
 *
 * D√©finit les structures de donn√©es pour les brides du cerf-volant.
 * Les brides relient des points anatomiques du kite (NEZ, INTER, CENTRE)
 * aux points de contr√¥le (CTRL_GAUCHE, CTRL_DROIT).
 */

/**
 * Longueurs physiques des 3 types de brides
 * (identique pour gauche et droite)
 */
export interface BridleLengths {
  /** Longueur bride NEZ ‚Üí CTRL (m√®tres) */
  nez: number;

  /** Longueur bride INTER ‚Üí CTRL (m√®tres) */
  inter: number;

  /** Longueur bride CENTRE ‚Üí CTRL (m√®tres) */
  centre: number;
}

/**
 * Tensions actuelles des 6 brides
 * (3 gauches + 3 droites)
 */
export interface BridleTensions {
  /** Tension bride NEZ gauche (Newtons) */
  leftNez: number;

  /** Tension bride INTER gauche (Newtons) */
  leftInter: number;

  /** Tension bride CENTRE gauche (Newtons) */
  leftCentre: number;

  /** Tension bride NEZ droite (Newtons) */
  rightNez: number;

  /** Tension bride INTER droite (Newtons) */
  rightInter: number;

  /** Tension bride CENTRE droite (Newtons) */
  rightCentre: number;
}

/**
 * D√©finition d'une attache de bride
 * (relie deux points anatomiques du kite)
 */
export interface BridleAttachment {
  /** Nom du point de d√©part (ex: "NEZ", "INTER_GAUCHE") */
  startPoint: string;

  /** Nom du point d'arriv√©e (ex: "CTRL_GAUCHE", "CTRL_DROIT") */
  endPoint: string;

  /** Longueur au repos (m√®tres) */
  length: number;

  /** Identifiant unique (ex: "bridle_left_nez") */
  id: string;
}

/**
 * Type des c√¥t√©s du bridage
 */
export type BridleSide = 'left' | 'right';

/**
 * Type des positions de bride
 */
export type BridlePosition = 'nez' | 'inter' | 'centre';

/**
 * Configuration compl√®te d'une bride (utilis√© par BridleFactory)
 */
export interface BridleConfig {
  /** C√¥t√© de la bride */
  side: BridleSide;

  /** Position de la bride */
  position: BridlePosition;

  /** Longueur (m√®tres) */
  length: number;

  /** Identifiant unique */
  id: string;
}


=== simulation/types/PhysicsTypes.ts ===

/**
 * PhysicsTypes.ts - Types et interfaces pour la physique de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit les structures de donn√©es pour l'√©tat du cerf-volant, les forces, les poign√©es, etc.
 *   - Sert √† typer les √©changes entre les modules physiques et de rendu
 *
 * D√©pendances principales :
 *   - Three.js : Pour les vecteurs et quaternions
 *
 * Relation avec les fichiers adjacents :
 *   - WindTypes.ts : D√©finit les types pour le vent
 *   - Tous les modules physiques et de rendu importent PhysicsTypes pour typer les donn√©es
 *
 * Utilisation typique :
 *   - Utilis√© dans PhysicsEngine, AerodynamicsCalculator, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es physiques
 *
 * Voir aussi :
 *   - src/simulation/types/WindTypes.ts
 */
import * as THREE from "three";

/**
 * Types et interfaces pour la physique de la simulation
 */

export interface KiteState {
  position: THREE.Vector3;
  velocity: THREE.Vector3;
  angularVelocity: THREE.Vector3;
  orientation: THREE.Quaternion;
}

export interface HandlePositions {
  left: THREE.Vector3;
  right: THREE.Vector3;
}

/**
 * Force appliqu√©e sur une surface sp√©cifique du kite
 */
export interface SurfaceForce {
  /** Indice de la surface dans KiteGeometry.SURFACES */
  surfaceIndex: number;
  /** Portance sur cette surface (en Newton) */
  lift: THREE.Vector3;
  /** Tra√Æn√©e sur cette surface (en Newton) */
  drag: THREE.Vector3;
  /** Friction sur cette surface (optionnel, en Newton) */
  friction?: THREE.Vector3;
  /** Force totale (r√©sultante) sur cette surface (en Newton) */
  resultant: THREE.Vector3;
  /** Centre g√©om√©trique de la surface (en coordonn√©es monde) */
  center: THREE.Vector3;
  /** Normale de la surface (en coordonn√©es monde) */
  normal: THREE.Vector3;
  /** Surface en m¬≤ */
  area: number;
}

=== simulation/types/WindTypes.ts ===


/**
 * WindTypes.ts - Types pour le syst√®me de vent de la simulation Kite
 *
 * R√¥le :
 *   - D√©finit la structure des param√®tres de vent (vitesse, direction, turbulence)
 *   - Sert √† typer les √©changes entre le simulateur de vent et les autres modules
 *
 * D√©pendances principales :
 *   - Aucun import direct, mais utilis√© par WindSimulator et PhysicsEngine
 *
 * Relation avec les fichiers adjacents :
 *   - PhysicsTypes.ts : D√©finit les types pour la physique
 *   - Tous les modules physiques et de rendu importent WindTypes pour typer le vent
 *
 * Utilisation typique :
 *   - Utilis√© dans WindSimulator, PhysicsEngine, DebugRenderer, etc.
 *   - Sert √† garantir la coh√©rence des √©changes de donn√©es de vent
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 */

export interface WindParams {
  speed: number; // km/h
  direction: number; // degr√©s
  turbulence: number; // pourcentage
}

=== simulation/types/index.ts ===


/**
 * index.ts - Export centralis√© de tous les types de la simulation Kite
 *
 * R√¥le :
 *   - Centralise l'export des types physiques et de vent
 *   - Permet d'importer tous les types depuis un seul point
 *
 * D√©pendances principales :
 *   - PhysicsTypes.ts : Types pour la physique
 *   - WindTypes.ts : Types pour le vent
 *
 * Relation avec les fichiers adjacents :
 *   - Sert de point d'entr√©e pour tous les imports de types dans le projet
 *
 * Utilisation typique :
 *   - Import√© dans les modules physiques, de rendu, de configuration, etc.
 *   - Facilite la maintenance et la coh√©rence des types
 *
 * Voir aussi :
 *   - src/simulation/types/PhysicsTypes.ts
 *   - src/simulation/types/WindTypes.ts
 */

export * from './PhysicsTypes';
export * from './WindTypes';

=== simulation/ui/UIManager.ts ===

import { PhysicsEngine } from "../physics/PhysicsEngine";
import { CONFIG } from "../config/SimulationConfig";
import { DebugRenderer } from "../rendering/DebugRenderer";
import { KiteGeometry } from "../config/KiteGeometry";

/**
 * Gestionnaire de l'interface utilisateur
 *
 * G√®re les contr√¥les et interactions utilisateur
 */
export class UIManager {
  private physicsEngine: PhysicsEngine;
  private debugRenderer: DebugRenderer;
  private resetCallback: () => void;
  private togglePlayCallback: () => void;

  constructor(
    physicsEngine: PhysicsEngine,
    debugRenderer: DebugRenderer,
    resetCallback: () => void,
    togglePlayCallback: () => void
  ) {
    this.physicsEngine = physicsEngine;
    this.debugRenderer = debugRenderer;
    this.resetCallback = resetCallback;
    this.togglePlayCallback = togglePlayCallback;
    this.setupControls();
  }

  private setupControls(): void {
    const resetBtn = document.getElementById("reset-sim");
    if (resetBtn) {
      resetBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.resetCallback();
      });
    }

    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.togglePlayCallback();
      });
    }

    const debugBtn = document.getElementById("debug-physics");
    if (debugBtn) {
      // Initialiser l'√©tat du bouton
      debugBtn.textContent = this.debugRenderer.isDebugMode() ? "üîç Debug ON" : "üîç Debug OFF";
      debugBtn.classList.toggle("active", this.debugRenderer.isDebugMode());

      debugBtn.addEventListener("click", (e) => {
        e.preventDefault();
        this.debugRenderer.toggleDebugMode();
      });
    }

    // Activer la classe debug-mode sur le body si debugMode est true
    if (this.debugRenderer.isDebugMode()) {
      document.body.classList.add("debug-mode");
      // Afficher le panneau de debug si le mode debug est activ√©
      const debugPanel = document.getElementById("debug-panel");
      if (debugPanel) {
        debugPanel.style.display = "block";
      }
    }

    this.setupWindControls();
  }

  private setupWindControls(): void {
    // Configuration des contr√¥les de vent
    const speedSlider = document.getElementById(
      "wind-speed"
    ) as HTMLInputElement;
    const speedValue = document.getElementById("wind-speed-value");
    if (speedSlider && speedValue) {
      speedSlider.value = CONFIG.wind.defaultSpeed.toString();
      speedValue.textContent = `${CONFIG.wind.defaultSpeed} km/h`;

      speedSlider.oninput = () => {
        const speed = parseFloat(speedSlider.value);
        this.physicsEngine.setWindParams({ speed });
        speedValue.textContent = `${speed} km/h`;
      };
    }

    const dirSlider = document.getElementById(
      "wind-direction"
    ) as HTMLInputElement;
    const dirValue = document.getElementById("wind-direction-value");
    if (dirSlider && dirValue) {
      dirSlider.value = CONFIG.wind.defaultDirection.toString();
      dirValue.textContent = `${CONFIG.wind.defaultDirection}¬∞`;

      dirSlider.oninput = () => {
        const direction = parseFloat(dirSlider.value);
        this.physicsEngine.setWindParams({ direction });
        dirValue.textContent = `${direction}¬∞`;
      };
    }

    const turbSlider = document.getElementById(
      "wind-turbulence"
    ) as HTMLInputElement;
    const turbValue = document.getElementById("wind-turbulence-value");
    if (turbSlider && turbValue) {
      turbSlider.value = CONFIG.wind.defaultTurbulence.toString();
      turbValue.textContent = `${CONFIG.wind.defaultTurbulence}%`;

      turbSlider.oninput = () => {
        const turbulence = parseFloat(turbSlider.value);
        this.physicsEngine.setWindParams({ turbulence });
        turbValue.textContent = `${turbulence}%`;
      };
    }

    const lengthSlider = document.getElementById(
      "line-length"
    ) as HTMLInputElement;
    const lengthValue = document.getElementById("line-length-value");
    if (lengthSlider && lengthValue) {
      lengthSlider.value = CONFIG.lines.defaultLength.toString();
      lengthValue.textContent = `${CONFIG.lines.defaultLength}m`;

      lengthSlider.oninput = () => {
        const length = parseFloat(lengthSlider.value);
        this.physicsEngine.setLineLength(length);
        lengthValue.textContent = `${length}m`;
      };
    }

    // Contr√¥les des brides (3 sliders ind√©pendants)
    // R√©cup√©rer les valeurs actuelles depuis le Kite
    const currentBridleLengths = this.physicsEngine.getBridleLengths();
    
    const bridleNezSlider = document.getElementById("bridle-nez") as HTMLInputElement;
    const bridleNezValue = document.getElementById("bridle-nez-value");
    if (bridleNezSlider && bridleNezValue) {
      bridleNezSlider.value = currentBridleLengths.nez.toString();
      bridleNezValue.textContent = `${currentBridleLengths.nez.toFixed(2)}m`;

      bridleNezSlider.oninput = () => {
        const length = parseFloat(bridleNezSlider.value);
        this.physicsEngine.setBridleLength('nez', length);
        bridleNezValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleInterSlider = document.getElementById("bridle-inter") as HTMLInputElement;
    const bridleInterValue = document.getElementById("bridle-inter-value");
    if (bridleInterSlider && bridleInterValue) {
      bridleInterSlider.value = currentBridleLengths.inter.toString();
      bridleInterValue.textContent = `${currentBridleLengths.inter.toFixed(2)}m`;

      bridleInterSlider.oninput = () => {
        const length = parseFloat(bridleInterSlider.value);
        this.physicsEngine.setBridleLength('inter', length);
        bridleInterValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    const bridleCentreSlider = document.getElementById("bridle-centre") as HTMLInputElement;
    const bridleCentreValue = document.getElementById("bridle-centre-value");
    if (bridleCentreSlider && bridleCentreValue) {
      bridleCentreSlider.value = currentBridleLengths.centre.toString();
      bridleCentreValue.textContent = `${currentBridleLengths.centre.toFixed(2)}m`;

      bridleCentreSlider.oninput = () => {
        const length = parseFloat(bridleCentreSlider.value);
        this.physicsEngine.setBridleLength('centre', length);
        bridleCentreValue.textContent = `${length.toFixed(2)}m`;
      };
    }

    // Contr√¥les de damping physique
    const linearDampingSlider = document.getElementById(
      "linear-damping"
    ) as HTMLInputElement;
    const linearDampingValue = document.getElementById("linear-damping-value");
    if (linearDampingSlider && linearDampingValue) {
      linearDampingSlider.value = CONFIG.physics.linearDampingCoeff.toString();
      linearDampingValue.textContent = CONFIG.physics.linearDampingCoeff.toFixed(2);

      linearDampingSlider.oninput = () => {
        const damping = parseFloat(linearDampingSlider.value);
        CONFIG.physics.linearDampingCoeff = damping;
        linearDampingValue.textContent = damping.toFixed(2);
      };
    }

    const angularDampingSlider = document.getElementById(
      "angular-damping"
    ) as HTMLInputElement;
    const angularDampingValue = document.getElementById("angular-damping-value");
    if (angularDampingSlider && angularDampingValue) {
      angularDampingSlider.value = CONFIG.physics.angularDragFactor.toString();
      angularDampingValue.textContent = CONFIG.physics.angularDragFactor.toFixed(2);

      angularDampingSlider.oninput = () => {
        const dragFactor = parseFloat(angularDampingSlider.value);
        CONFIG.physics.angularDragFactor = dragFactor;
        angularDampingValue.textContent = dragFactor.toFixed(2);
      };
    }

    // üîß Contr√¥le du niveau de subdivision du maillage
    const meshLevelSlider = document.getElementById(
      "mesh-subdivision-level"
    ) as HTMLInputElement;
    const meshLevelValue = document.getElementById("mesh-subdivision-level-value");
    if (meshLevelSlider && meshLevelValue) {
      meshLevelSlider.value = CONFIG.kite.defaultMeshSubdivisionLevel.toString();
      meshLevelValue.textContent = `${CONFIG.kite.defaultMeshSubdivisionLevel} (${Math.pow(4, CONFIG.kite.defaultMeshSubdivisionLevel + 1)} triangles)`;

      meshLevelSlider.oninput = () => {
        const level = parseInt(meshLevelSlider.value);
        CONFIG.kite.defaultMeshSubdivisionLevel = level;
        KiteGeometry.setMeshSubdivisionLevel(level);
        const triangleCount = Math.pow(4, level + 1);
        meshLevelValue.textContent = `${level} (${triangleCount} triangles)`;
        console.log(`üîß Maillage chang√© : niveau ${level} = ${triangleCount} triangles`);
      };
    }

    // Contr√¥les a√©rodynamiques
    const liftScaleSlider = document.getElementById(
      "lift-scale"
    ) as HTMLInputElement;
    const liftScaleValue = document.getElementById("lift-scale-value");
    if (liftScaleSlider && liftScaleValue) {
      liftScaleSlider.value = CONFIG.aero.liftScale.toString();
      liftScaleValue.textContent = CONFIG.aero.liftScale.toFixed(2);

      liftScaleSlider.oninput = () => {
        const scale = parseFloat(liftScaleSlider.value);
        CONFIG.aero.liftScale = scale;
        liftScaleValue.textContent = scale.toFixed(2);
      };
    }

    const dragScaleSlider = document.getElementById(
      "drag-scale"
    ) as HTMLInputElement;
    const dragScaleValue = document.getElementById("drag-scale-value");
    if (dragScaleSlider && dragScaleValue) {
      dragScaleSlider.value = CONFIG.aero.dragScale.toString();
      dragScaleValue.textContent = CONFIG.aero.dragScale.toFixed(2);

      dragScaleSlider.oninput = () => {
        const scale = parseFloat(dragScaleSlider.value);
        CONFIG.aero.dragScale = scale;
        dragScaleValue.textContent = scale.toFixed(2);
      };
    }

    // Contr√¥le du lissage des forces physiques
    const forceSmoothingSlider = document.getElementById(
      "force-smoothing"
    ) as HTMLInputElement;
    const forceSmoothingValue = document.getElementById("force-smoothing-value");
    if (forceSmoothingSlider && forceSmoothingValue) {
      forceSmoothingSlider.value = this.physicsEngine.getForceSmoothing().toString();
      forceSmoothingValue.textContent = this.physicsEngine.getForceSmoothing().toFixed(2);

      forceSmoothingSlider.oninput = () => {
        const smoothing = parseFloat(forceSmoothingSlider.value);
        this.physicsEngine.setForceSmoothing(smoothing);
        forceSmoothingValue.textContent = smoothing.toFixed(2);
      };
    }
  }

  updatePlayButton(isPlaying: boolean): void {
    const playBtn = document.getElementById("play-pause");
    if (playBtn) {
      playBtn.textContent = isPlaying ? "‚è∏Ô∏è Pause" : "‚ñ∂Ô∏è Lancer";
    }
  }
}

=== types/index.ts ===

/**
 * Types centralis√©s pour le syst√®me de visualisation 3D
 * Interface unique et coh√©rente pour tous les objets
 */

import * as THREE from 'three';

/**
 * Position 3D simple [x, y, z]
 */
export type Position3D = [number, number, number];

/**
 * Interface principale que TOUS les objets doivent impl√©menter
 * üéÆ v3.0: Compatible avec l'architecture StructuredObject + Node3D
 */
export interface ICreatable {
  /**
   * Retourne l'objet lui-m√™me (StructuredObject h√©rite de Node3D)
   * Pattern fluent pour la nouvelle architecture
   */
  create(): this;

  /**
   * Nom affich√© dans l'interface utilisateur
   */
  getName(): string;

  /**
   * Description courte de l'objet
   */
  getDescription(): string;

  /**
   * Nombre de primitives utilis√©es (pour statistiques)
   */
  getPrimitiveCount(): number;
}

/**
 * Options pour cr√©er des surfaces
 */
export interface SurfaceOptions {
  color?: string;
  transparent?: boolean;
  opacity?: number;
  doubleSide?: boolean;
  wireframe?: boolean;
}

/**
 * Configuration pour les mat√©riaux
 */
export interface MaterialConfig {
  color: string;
  transparent?: boolean;
  opacity?: number;
  metalness?: number;
  roughness?: number;
  side?: THREE.Side;
}

/**
 * Interface pour un point nomm√© dans l'espace 3D
 */
export interface NamedPoint {
  name: string;
  position: THREE.Vector3;
  visible?: boolean;
}

/**
 * M√©tadonn√©es optionnelles pour les objets
 */
export interface ObjectMetadata {
  category?: string;
  complexity?: 'simple' | 'medium' | 'complex';
  tags?: string[];
  author?: string;
  version?: string;
}

